if (AjxPackage.define("Ajax")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only
if (AjxPackage.define("ajax.core.AjxCore")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * 
 * @private
 */
AjxCore = function() {}

AjxCore._objectIds = [null];

/**
 * @deprecated
 * 
 * The association is now made by DwtControl using the element's ID, so a separate
 * unique ID is not needed.
 */
AjxCore.assignId = 
function(anObject) {
	var myId = AjxCore._objectIds.length;
	AjxCore._objectIds[myId]= anObject;
	return myId;
};

/**
 * @deprecated
 */
AjxCore.unassignId = 
function(anId) {
	AjxCore._objectIds[anId]= null;
};

/**
 * @deprecated
 */
AjxCore.objectWithId = 
function(anId) {
	return AjxCore._objectIds[anId];
};

/**
 * Adds a listener to an element, for the given event name.
 */
AjxCore.addListener = 
function(eventSource, eventName, action) {
	eventSource = AjxCore._getEventSource(eventSource);
	var listenerStruct = AjxCore._getListenerStruct(eventSource, eventName, true);
	listenerStruct.list[listenerStruct.list.length] = action;
};

/**
 * sets a one time event handler for the given eventName.
 */
AjxCore.setEventHandler = 
function(eventSource, eventName, action) {
	eventSource = AjxCore._getEventSource(eventSource);
	var listenerStruct = AjxCore._getListenerStruct(eventSource, eventName, true);
	listenerStruct.single = action;
};

/**
 * removes a listener for a given event
 */
AjxCore.removeListener = 
function(eventSource, eventName, action) {
	eventSource = AjxCore._getEventSource(eventSource);
	var listenerStruct = AjxCore._getListenerStruct(eventSource, eventName);

	if (listenerStruct) {
		var listenerList = listenerStruct.list;
		var len = listenerList.length;
		for (var i = 0; i < len; i++) {
			if (listenerList[i] == action) {
				listenerList[i] = null;
			}
		}
	}
};

/**
 * Removes all listeners for a given eventName, and source
 */
AjxCore.removeAllListeners = 
function(eventSource, eventName) {
	eventSource = AjxCore._getEventSource(eventSource);
	var listenerStruct = AjxCore._getListenerStruct(eventSource, eventName);

	if (listenerStruct) {
		var listenerList = listenerStruct.list;
		var len = listenerList.length;
		for (var i = 0; i < len; i++) {
			listenerList[i] = null;
		}
	}
	AjxCore.unassignId(listenerStruct.id);
};

/**
 * notifies listeners of the event. This only needs to be called if
 * the event is not a standard DOM event. Those types of event callbacks
 * will be triggered by their event handlers
 */
AjxCore.notifyListeners = 
function(eventSource, eventName, arg1) {
	eventSource = AjxCore._getEventSource(eventSource);
	var listenerStruct = AjxCore._getListenerStruct(eventSource, eventName);
	if (listenerStruct) {
		eventSource[eventName](arg1);
	}
};

AjxCore._getEventSource = 
function(eventSource) {
	if (typeof(eventSource) == 'string') {
		eventSource = document.getElementById(eventSource);
	}
	return eventSource;
};

AjxCore.getListenerStruct = 
function (eventSource, eventName) {
	return AjxCore._getListenerStruct(eventSource, eventName);
};

/**
 * gets the existing struct for the eventSource, or creates a new one.
 */
AjxCore._getListenerStruct = 
function(eventSource, eventName, create) {
	var listenerStruct = null;
	if (eventSource[eventName]) {
		var id = eventSource[eventName]._lsListenerStructId;
		listenerStruct = AjxCore.objectWithId(id);
	} else if (create) {
		listenerStruct = AjxCore._setupListener(eventSource, eventName);
	}

	return listenerStruct;
};
    
/**
 * Creates a listener struct
 */
AjxCore._setupListener = 
function(eventSource, eventName, id) {
	var listenerStruct = new Object();
	listenerStruct.list = new Array();
	listenerStruct.single = null;
	var id = listenerStruct.id = AjxCore.assignId(listenerStruct);
	var handler = AjxCore._createListenerClosure(id);
	eventSource[eventName] = handler;
	eventSource[eventName]._lsListenerStructId = id;

	return listenerStruct;
};

AjxCore._createListenerClosure = 
function(id) {
	var closure = function(arg1) {
		var listenerStruct = AjxCore.objectWithId(id);
		var listenerList = listenerStruct.list;
		var len = listenerList.length;
		for (var i = 0; i < len; i++) {
			var callback = listenerList[i];
			if (callback) {
				if (typeof(callback) == 'string') {
					eval(callback);
				} else {
					// handle AjxListener callbacks as well as simple functions
					if (callback.handleEvent) {
						callback.handleEvent(arg1, this);
					} else {
						callback(arg1, this);
					}
				}
			}
		}
        if (listenerStruct.single) {
			var callback = listenerStruct.single;
			if (typeof(callback) == 'string') {
				eval(callback);
			} else {
				return callback.handleEvent
					? callback.handleEvent(arg1, this)
					: callback(arg1, this);
			}
		}
	}
	return closure;
};

/**
 * Convenience method for adding onload listeners
 */
AjxCore.addOnloadListener = 
function(action) {
	if (window.onload && (!window.onload._lsListenerStructId)) {
		var priorListener = window.onload;
		window.onload = null;
		AjxCore.addListener(window, "onload", priorListener);
	}

	AjxCore.addListener(window, "onload", action);
};

/**
 * Convenience method for adding onunload listeners
 */    
AjxCore.addOnunloadListener = 
function(action) {
	if (window.onunload && (!window.onunload._lsListenerStructId)) {
		var priorListener = window.onunload;
		window.onunload = null;
		AjxCore.addListener(window, "onunload", priorListener);
	}

	AjxCore.addListener(window, "onunload", action);
};
}
if (AjxPackage.define("ajax.util.AjxUtil")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * AjxUtil - static class with some utility methods. This is where to
 * put things when no other class wants them.
 *
 * 12/3/2004 At this point, it only needs AjxEnv to be loaded.
 * 
 * @private
 */
AjxUtil = function() {
};

AjxUtil.FLOAT_RE = /^[+\-]?((\d+(\.\d*)?)|((\d*\.)?\d+))([eE][+\-]?\d+)?$/;
AjxUtil.NOTFLOAT_RE = /[^\d\.]/;
AjxUtil.NOTINT_RE = /[^0-9]+/;
AjxUtil.LIFETIME_FIELD = /^([0-9])+([dhms]|ms)?$/;
AjxUtil.INT_RE = /^\-?(0|[1-9]\d*)$/;

AjxUtil.isSpecified 		= function(aThing) { return ((aThing !== void 0) && (aThing !== null)); };
AjxUtil.isUndefined 		= function(aThing) { return (aThing === void 0); };
AjxUtil.isNull 				= function(aThing) { return (aThing === null); };
AjxUtil.isBoolean 			= function(aThing) { return (typeof(aThing) === 'boolean'); };
AjxUtil.isString 			= function(aThing) { return (typeof(aThing) === 'string'); };
AjxUtil.isNumber 			= function(aThing) { return (typeof(aThing) === 'number'); };
AjxUtil.isObject 			= function(aThing) { return ((typeof(aThing) === 'object') && (aThing !== null)); };
AjxUtil.isArray 			= function(aThing) { return AjxUtil.isInstance(aThing, Array); };
AjxUtil.isArrayLike			= function(aThing) { return typeof aThing !== 'string' && typeof aThing.length === 'number'; };
AjxUtil.isFunction 			= function(aThing) { return (typeof(aThing) === 'function'); };
AjxUtil.isDate 				= function(aThing) { return AjxUtil.isInstance(aThing, Date); };
AjxUtil.isLifeTime 			= function(aThing) { return AjxUtil.LIFETIME_FIELD.test(aThing); };
AjxUtil.isNumeric 			= function(aThing) { return (!isNaN(parseFloat(aThing)) && AjxUtil.FLOAT_RE.test(aThing) && !AjxUtil.NOTFLOAT_RE.test(aThing)); };
AjxUtil.isInt				= function(aThing) { return AjxUtil.INT_RE.test(aThing); };
AjxUtil.isPositiveInt		= function(aThing) { return AjxUtil.isInt(aThing) && parseInt(aThing, 10) > 0; }; //note - assume 0 is not positive
AjxUtil.isLong = AjxUtil.isInt;
AjxUtil.isNonNegativeLong	= function(aThing) { return AjxUtil.isLong(aThing) && parseInt(aThing, 10) >= 0; };
AjxUtil.isEmpty				= function(aThing) { return ( AjxUtil.isNull(aThing) || AjxUtil.isUndefined(aThing) || (aThing === "") || (AjxUtil.isArray(aThing) && (aThing.length==0))); };
// REVISIT: Should do more precise checking. However, there are names in
//			common use that do not follow the RFC patterns (e.g. domain
//			names that start with digits).
AjxUtil.IPv4_ADDRESS_RE = /^\d{1,3}(\.\d{1,3}){3}(\.\d{1,3}\.\d{1,3})?$/;
AjxUtil.IPv4_ADDRESS_WITH_PORT_RE = /^\d{1,3}(\.\d{1,3}){3}(\.\d{1,3}\.\d{1,3})?:\d{1,5}$/;
AjxUtil.IPv6_ADDRESS_RE = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|(?:%[-\w.~]+)?$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})(?:%[-\w.~]+)?$/i;
AjxUtil.IPv6_ADDRESS_WITH_PORT_RE = new RegExp(AjxUtil.IPv6_ADDRESS_RE.source.replace('^', '^\\[').replace('$', '\\]:\\d{1,5}$'), 'i');
AjxUtil.SUBNET_RE = /^\d{1,3}(\.\d{1,3}){3}(\.\d{1,3}\.\d{1,3})?\/\d{1,2}$/;
AjxUtil.DOMAIN_NAME_SHORT_RE = /^[A-Za-z0-9\-]{2,}$/;
AjxUtil.DOMAIN_NAME_FULL_RE = /^[A-Za-z0-9\-]{1,}(\.[A-Za-z0-9\-]{2,}){1,}$/;
AjxUtil.HOST_NAME_RE = /^[A-Za-z0-9\-]{2,}(\.[A-Za-z0-9\-]{1,})*(\.[A-Za-z0-9\-]{2,})*$/;
AjxUtil.HOST_NAME_WITH_PORT_RE = /^[A-Za-z0-9\-]{2,}(\.[A-Za-z0-9\-]{2,})*:([0-9])+$/;
AjxUtil.EMAIL_SHORT_RE = /^[^@\s]+$/;
AjxUtil.EMAIL_FULL_RE = /^[^@\s]+@[A-Za-z0-9\-]{2,}(\.[A-Za-z0-9\-]{2,})+$/;
AjxUtil.FULL_URL_RE = /^[A-Za-z0-9]{2,}:\/\/[A-Za-z0-9\-]+(\.[A-Za-z0-9\-]+)*(:([0-9])+)?(\/[\w\.\|\^\*\[\]\{\}\(\)\-<>~,'#_;@:!%]+)*(\/)?(\?[\w\.\|\^\*\+\[\]\{\}\(\)\-<>~,'#_;@:!%&=]*)?$/;
AjxUtil.IP_FULL_URL_RE = /^[A-Za-z0-9]{2,}:\/\/\d{1,3}(\.\d{1,3}){3}(\.\d{1,3}\.\d{1,3})?(:([0-9])+)?(\/[\w\.\|\^\*\[\]\{\}\(\)\-<>~,'#_;@:!%]+)*(\/)?(\?[\w\.\|\^\*\+\[\]\{\}\(\)\-<>~,'#_;@:!%&=]*)?$/;
AjxUtil.SHORT_URL_RE = /^[A-Za-z0-9]{2,}:\/\/[A-Za-z0-9\-]+(\.[A-Za-z0-9\-]+)*(:([0-9])+)?$/;
AjxUtil.IP_SHORT_URL_RE = /^[A-Za-z0-9]{2,}:\/\/\d{1,3}(\.\d{1,3}){3}(\.\d{1,3}\.\d{1,3})?(:([0-9])+)?$/;

AjxUtil.isHostName 			= function(s) { return AjxUtil.HOST_NAME_RE.test(s); };
AjxUtil.isDomainName = 
function(s, shortMatch) {
	return shortMatch 
		? AjxUtil.DOMAIN_NAME_SHORT_RE.test(s) 
		: AjxUtil.DOMAIN_NAME_FULL_RE.test(s);
};

AjxUtil.isEmailAddress = 
function(s, nameOnly) {
	return nameOnly 
		? AjxUtil.EMAIL_SHORT_RE.test(s) 
		: AjxUtil.EMAIL_FULL_RE.test(s);
};

AjxUtil.isValidEmailNonReg = 
function(s) {
	return ((s.indexOf ("@") > 0) && (s.lastIndexOf ("@") == s.indexOf ("@")) && (s.indexOf (".@") < 0));
};

/**
 * Return true if the given object is a plain hash.
 *
 * @param aThing	The object for testing.
 */
AjxUtil.isHash =
function(aThing) {
	// Note: can't just look at prototype since that fails cross-window.
	// See http://stackoverflow.com/questions/10741618/how-to-check-if-argument-is-an-object-and-not-an-array, esp the part with isPlainObject()
	var str = aThing && aThing.toString ? aThing.toString() : Object.prototype.toString.call(aThing);
	return AjxUtil.isObject(aThing) && str === '[object Object]';
};

AjxUtil.SIZE_GIGABYTES = "GB";
AjxUtil.SIZE_MEGABYTES = "MB";
AjxUtil.SIZE_KILOBYTES = "KB";
AjxUtil.SIZE_BYTES = "B";

/**
 * Formats a size (in bytes) to the largest whole unit. For example,
 * AjxUtil.formatSize(302132199) returns "288 MB".
 *
 * @param size      The size (in bytes) to be formatted.
 * @param round     True to round to nearest integer. Default is true.
 * @param fractions Number of fractional digits to display, if not rounding.
 *                  Trailing zeros after the decimal point are trimmed.
 */
AjxUtil.formatSize = 
function(size, round, fractions) {
	if (round == null) round = true;
	if (fractions == null) fractions = 20; // max allowed for toFixed is 20

	var formattedUnits = AjxMsg.sizeBytes;
	var units = AjxMsg.SIZE_BYTES;
	if (size >= 1073741824) {
		formattedUnits = AjxMsg.sizeGigaBytes;
		units = AjxUtil.SIZE_GIGABYTES;
	}
	else if (size >= 1048576) {
		formattedUnits = AjxMsg.sizeMegaBytes;
		units = AjxUtil.SIZE_MEGABYTES;
	}
	else if (size > 1023) {
		formattedUnits = AjxMsg.sizeKiloBytes;
		units = AjxUtil.SIZE_KILOBYTES;
	}


	var formattedSize = AjxUtil.formatSizeForUnits(size, units, round, fractions);
	return AjxMessageFormat.format(AjxMsg.formatSizeAndUnits, [formattedSize, formattedUnits]);
};

/**
 * Formats a size (in bytes) to a specific unit. Since the unit size is
 * known, the unit is not shown in the returned string. For example,
 * AjxUtil.formatSizeForUnit(302132199, AjxUtil.SIZE_MEGABYTES, false, 2) 
 * returns "288.13".
 *
 * @param size      The size (in bytes) to be formatted.
 * @param units     The unit of measure.
 * @param round     True to round to nearest integer. Default is true.
 * @param fractions Number of fractional digits to display, if not rounding.
 *                  Trailing zeros after the decimal point are trimmed.
 */
AjxUtil.formatSizeForUnits = 
function(size, units, round, fractions) {
	if (units == null) units = AjxUtil.SIZE_BYTES;
	if (round == null) round = true;
	if (fractions == null) fractions = 20; // max allowed for toFixed is 20

	switch (units) {
		case AjxUtil.SIZE_GIGABYTES: { size /= 1073741824; break; }
		case AjxUtil.SIZE_MEGABYTES: { size /= 1048576; break; }
		case AjxUtil.SIZE_KILOBYTES: { size /= 1024; break; }
	}
	var dot = I18nMsg.numberSeparatorDecimal !='' ? I18nMsg.numberSeparatorDecimal : '.';
	var pattern = I18nMsg.formatNumber.replace(/\..*$/, ""); // Strip off decimal, we'll be adding one anyway
	pattern = pattern.replace(/,/, "");       // Remove the ,
	if (!round && fractions) {
		pattern = pattern += dot;
		for (var i = 0; i < fractions; i++) {
			pattern += "#";
		}
	}
	return AjxNumberFormat.format(pattern, size);
};

/**
 * Performs the opposite of AjxUtil.formatSize in that this function takes a 
 * formatted size.
 *
 * @param units Unit constant: "GB", "MB", "KB", "B". Must be specified 
 *              unless the formatted size ends with the size marker, in
 *				which case the size marker in the formattedSize param
 *				overrides this parameter.
 */
AjxUtil.parseSize = 
function(formattedSize, units) {
	// NOTE: Take advantage of fact that parseFloat ignores bad chars
	//       after numbers
	if (typeof formattedSize != _STRING_) {
		formattedSize = formattedSize.toString() ;
	}
	var size = parseFloat(formattedSize.replace(/^\s*/,""));

	var marker = /[GMK]?B$/i;
	var result = marker.exec(formattedSize);
	if (result) {
		//alert("units: "+units+", result[0]: '"+result[0]+"'");
		units = result[0].toUpperCase();
	}
	
	switch (units) {
		case AjxUtil.SIZE_GIGABYTES: size *= 1073741824; break;
		case AjxUtil.SIZE_MEGABYTES: size *= 1048576; break; 
		case AjxUtil.SIZE_KILOBYTES: size *= 1024; break;
	}
	
	//alert("AjxUtil#parseSize: formattedSize="+formattedSize+", size="+size);
	return size;
};

AjxUtil.isInstance = 
function(aThing, aClass) { 
	return !!(aThing && aThing.constructor && (aThing.constructor === aClass)); 
};

AjxUtil.assert = 
function(aCondition, aMessage) {
	if (!aCondition && AjxUtil.onassert) AjxUtil.onassert(aMessage);
};

AjxUtil.onassert = 
function(aMessage) {
	// Create an exception object and set the message
	var myException = new Object();
	myException.message = aMessage;
	
	// Compile a stack trace
	var myStack = new Array();
	if (AjxEnv.isIE) {
		// On IE, the caller chain is on the arguments stack
		var myTrace = arguments.callee.caller;
		var i = 0; // stop at 20 since there might be somehow an infinite loop here. Maybe in case of a recursion. 
		while (myTrace && i++ < 20) {
		    myStack[myStack.length] = myTrace;
	    	myTrace = myTrace.caller;
		}
	} else {
		try {
			var myTrace = arguments.callee.caller;
			while (myTrace) {
				myStack[myStack.length] = myTrace;
				if (myStack.length > 2) break;
				myTrace = myTrace.caller;
		    }
		} catch (e) {
		}
	}
	myException.stack = myStack;
	
	// Alert with the message and a description of the stack
	var stackString = '';
	var MAX_LEN = 170;
	for (var i = 1; i < myStack.length; i++) {
		if (i > 1) stackString += '\n';
		if (i < 11) {
			var fs = myStack[i].toString();
			if (fs.length > MAX_LEN) {
				fs = fs.substr(0,MAX_LEN) + '...';
				fs = fs.replace(/\n/g, '');
			}
			stackString += i + ': ' + fs;
		} else {
			stackString += '(' + (myStack.length - 11) + ' frames follow)';
			break;
		}
	}
	alert('assertion:\n\n' + aMessage + '\n\n---- Call Stack ---\n' + stackString);
	
	// Now throw the exception
	throw myException;
};

// IE doesn't define Node type constants
AjxUtil.ELEMENT_NODE		= 1;
AjxUtil.TEXT_NODE			= 3;
AjxUtil.DOCUMENT_NODE		= 9;

AjxUtil.getInnerText = 
function(node) {
 	if (AjxEnv.isIE)
 		return node.innerText;

	function f(n) {
		if (n) {
			if (n.nodeType == 3 /* TEXT_NODE */)
				return n.data;
			if (n.nodeType == 1 /* ELEMENT_NODE */) {
				if (/^br$/i.test(n.tagName))
					return "\r\n";
				var str = "";
				for (var i = n.firstChild; i; i = i.nextSibling)
					str += f(i);
				return str;
			}
		}
		return "";
	};
	return f(node);
};

/**
 * This method returns a proxy for the specified object. This is useful when
 * you want to modify properties of an object and want to keep those values
 * separate from the values in the original object. You can then iterate
 * over the proxy's properties and use the <code>hasOwnProperty</code>
 * method to determine if the property is a new value in the proxy.
 * <p>
 * <strong>Note:</strong>
 * A reference to the original object is stored in the proxy as the "_object_" 
 * property.
 *
 * @param object [object] The object to proxy.
 * @param level  [number] The number of property levels deep to proxy.
 *						  Defaults to zero.
 */
AjxUtil.createProxy = 
function(object, level) {
	var proxy;
	var proxyCtor = function(){}; // bug #6517 (Safari doesnt like 'new Function')
	proxyCtor.prototype = object;
	if (object instanceof Array) {
		proxy  = new Array();
		var cnt  = object.length;
		for(var ix = 0; ix < cnt; ix++) {
			proxy[ix] = object[ix];
		}
	} else {
		proxy = new proxyCtor;
	}
	
	if (level) {
		for (var prop in object) {
			if (typeof object[prop] == "object" && object[prop] !== null)
				proxy[prop] = AjxUtil.createProxy(object[prop], level - 1);
		}
	}	
	
	proxy._object_ = object;
	return proxy;
};

AjxUtil.unProxy =
function(proxy) {
	var object = proxy && proxy._object_;
	if (object) {
		for (var prop in proxy) {
			if (proxy.hasOwnProperty(prop) && prop!="_object_") {
				object[prop] = proxy[prop];
			}
		}
		return object;
	}
	return null;
}

/**
* Returns a copy of a list with empty members removed.
*
* @param list	[array]		original list
*/
AjxUtil.collapseList =
function(list) {
	var newList = [];
	for (var i = 0; i < list.length; i++) {
		if (list[i]) {
			newList.push(list[i]);
		}
	}
	return newList;
};

AjxUtil.arrayAsHash =
function(array, valueOrFunc) {
	array = AjxUtil.toArray(array);
	var hash = {};
	var func = typeof valueOrFunc == "function" && valueOrFunc;
	var value = valueOrFunc || true; 
	for (var i = 0; i < array.length; i++) {
		var key = array[i];
		hash[key] = func ? func(key, hash, i, array) : value;
	}
	return hash;
};

AjxUtil.arrayAdd = function(array, member, index) {

    array = array || [];

	if (index == null || index < 0 || index >= array.length) {
		// index absent or is out of bounds - append object to the end
		array.push(member);
	} else {
		// otherwise, insert object
		array.splice(index, 0, member);
	}
};

AjxUtil.arrayRemove =
function(array, member) {
	if (array) {
		for (var i = 0; i < array.length; i++) {
			if (array[i] == member) {
				array.splice(i, 1);
				return true;
			}
		}
	}
	return false;
};

AjxUtil.indexOf =
function(array, object, strict) {
	if (array) {
		for (var i = 0; i < array.length; i++) {
			var item = array[i];
			if ((strict && item === object) || (!strict && item == object)) {
				return i;
			}
		}
	}
	return -1;
};

AjxUtil.arrayContains =
function(array, object, strict) {
	return AjxUtil.indexOf(array, object, strict) != -1;
};

AjxUtil.keys = function(object, acceptFunc) {
    var keys = [];
    for (var p in object) {
	    if (acceptFunc && !acceptFunc(p, object)) continue;
        keys.push(p);
    }
    return keys;
};
AjxUtil.values = function(object, acceptFunc) {
    var values = [];
    for (var p in object) {
	    if (acceptFunc && !acceptFunc(p, object)) continue;
        values.push(object[p]);
    }
    return values;
};

/**
 * Generate another hash mapping property values to their names. Each value
 * should be unique; otherwise the results are undefined.
 *
 * @param obj                   An object, treated as a hash.
 * @param func [function]       An optional function for filtering properties.
 */
AjxUtil.valueHash = function(obj, acceptFunc) {
    // don't rely on the value in the object itself
    var hasown = Object.prototype.hasOwnProperty.bind(obj);

    var r = {};
    for (var k in obj) {
        var v = obj[k];

        if (!hasown(k) || (acceptFunc && !acceptFunc(k, obj)))
            continue;
        r[v] = k;
    }
    return r;
};
AjxUtil.backMap = AjxUtil.valueHash;

/**
 * Call a function with the the items in the given object, which special logic
 * for handling of arrays.
 *
 * @param obj                   Array or other object
 * @param func [function]       Called with index or key and value.
 */
AjxUtil.foreach = function(obj, func) {

    if (!func || !obj) {
        return;
    }

    if (AjxUtil.isArrayLike(obj)) {
        var array = obj;

        for (var i = 0; i < array.length; i++) {
            func(array[i], i);
        }
    }
    else {
        // don't rely on the value in the object itself
        var hasown = Object.prototype.hasOwnProperty.bind(obj);

        for (var k in obj) {
            if (hasown(k)) {
                func(obj[k], k)
            }
        }
    }
};

AjxUtil.map = function(array, func) {

    if (!array) {
        return [];
    }

	var narray = new Array(array.length);
	for (var i = 0; i < array.length; i++) {
		narray[i] = func ? func(array[i], i) : array[i];
	}

	return narray;
};

AjxUtil.uniq = function(array) {

    if (!array) {
        return [];
    }

    var object = {};
	for (var i = 0; i < array.length; i++) {
		object[array[i]] = true;
	}

	return AjxUtil.keys(object);
};


/**
 * Remove duplicates from the given array,
 * <strong>in-place</strong>. Stable with regards to ordering.
 *
 * Please note that this method is O(n^2) if Array is backed by an
 * array/vector data structure.
 *
 * @param array [array]     array to process
 * @param keyfn [function]  used to extract a comparison key from each
 *                          list element, default is to compare
 *                          elements directly. if the comparison key
 *                          is 'undefined', the element is always
 *                          retained
 */
AjxUtil.dedup = function(array, keyfn) {

    if (!array) {
        return [];
    }

    if (!keyfn) {
		keyfn = function(v) { return v; };
    }

	var seen = {};

	for (var i = 0; i < array.length; i++) {
		var key = keyfn(array[i]);

		if (key !== undefined && seen[key]) {
			array.splice(i, 1);
			i -= 1;
		}

		seen[key] = true;
	}
};


AjxUtil.concat = function(array1 /* ..., arrayN */) {

	var array = [];
	for (var i = 0; i < arguments.length; i++) {
		array.push.apply(array, arguments[i]);
	}
	return array;
};

AjxUtil.union = function(array1 /* ..., arrayN */) {
	var array = [];
	return AjxUtil.uniq(array.concat.apply(array, arguments));
};

AjxUtil.intersection = function(array1 /* ..., arrayN */) {
	var array = AjxUtil.concat.apply(this, arguments);
	var object = AjxUtil.arrayAsHash(array, AjxUtil.__intersection_count);
	for (var p in object) {
		if (object[p] == 1) {
			delete object[p];
		}
	}
	return AjxUtil.keys(object);
};

AjxUtil.__intersection_count = function(key, hash, index, array) {
	return hash[key] != null ? hash[key] + 1 : 1;
};

AjxUtil.complement = function(array1, array2) {
	var object1 = AjxUtil.arrayAsHash(array1);
	var object2 = AjxUtil.arrayAsHash(array2);
	for (var p in object2) {
		if (p in object1) {
			delete object2[p];
		}
	}
	return AjxUtil.keys(object2);
};

/**
 * Returns an array with all the members of the given array for which the filtering function returns true.
 *
 * @param {Array}       array       source array
 * @param {Function}    func        filtering function
 * @param {Object}      context     scope for filtering function
 *
 * @returns {Array} array of members for which the filtering function returns true
 */
AjxUtil.filter = function(array, func, context) {

	var results = [];
	if (array == null) {
		return results;
	}

	var nativeFilter = Array.prototype.filter;
	if (nativeFilter && array.filter === nativeFilter) {
		return array.filter(func, context);
	}

	AjxUtil.foreach(array, function(value, index) {
		if (func.call(context, value, index)) {
			results.push(value);
		}
	});

	return results;
};

AjxUtil.getFirstElement = function(parent, ename, aname, avalue) {
    for (var child = parent.firstChild; child; child = child.nextSibling) {
        if (child.nodeType != AjxUtil.ELEMENT_NODE) continue;
        if (ename && child.nodeName != ename) continue;
        if (aname) {
            var attr = child.getAttributeNode(aname);
            if (attr.nodeName != aname) continue;
            if (avalue && attr.nodeValue != avalue) continue;
        }
        return child;
    }
    return null;
};

/**
 * @param params	[hash]		hash of params:
 *        relative	[boolean]*	if true, return a relative URL
 *        protocol	[string]*	protocol (trailing : is optional)
 *        host		[string]*	server hostname
 *        port		[int]*		server port
 *        path		[string]*	URL path
 *        qsReset	[boolean]*	if true, clear current query string
 *        qsArgs	[hash]*		set of query string names and values
 */
AjxUtil.formatUrl =
function(params) {
	params = params || {};
	var url = [];
	var i = 0;
	if (!params.relative) {
		var proto = params.protocol || location.protocol;
		if (proto.indexOf(":") == -1) {
			proto = proto + ":";
		}
		url[i++] = proto;
		url[i++] = "//";
		url[i++] = params.host || location.hostname;
		var port = Number(params.port || location.port);
		if (port &&
			((proto == ZmSetting.PROTO_HTTP && port != ZmSetting.HTTP_DEFAULT_PORT) ||
			 (proto == ZmSetting.PROTO_HTTPS && port != ZmSetting.HTTPS_DEFAULT_PORT))) {
			url[i++] =  ":";
			url[i++] = port;
		}
	}
	url[i++] = params.path || location.pathname;
	var qs = "";
	if (params.qsArgs) {
		qs = AjxStringUtil.queryStringSet(params.qsArgs, params.qsReset);
	} else {
		qs = params.qsReset ? "" : location.search;
	}
	url[i++] = qs;
	
	return url.join("");
};

AjxUtil.byNumber = function(a, b) {
	return Number(a) - Number(b);
};

/**
 * <strong>Note:</strong>
 * This function <em>must</em> be wrapped in a closure that passes
 * the property name as the first argument.
 *
 * @param {string}  prop    Property name.
 * @param {object}  a       Object A.
 * @param {object}  b       Object B.
 */
AjxUtil.byStringProp = function(prop, a, b) {
    return a[prop].localeCompare(b[prop]);
};

/**
 * returns the size of the given array, i.e. the number of elements in it, regardless of whether the array is associative or not.
 * so for example for array that is set simply by a = []; a[50] = "abc"; arraySize(a) == 1. For b = []; b["abc"] = "def"; arraySize(b) == 1 too.
 * Incredibly JavasCript does not have a built in simple way to get that.
 * @param arr
 */
AjxUtil.arraySize =
function(a) {
	var size = 0;
	for(var e in a) {
		if (a.hasOwnProperty(e)) {
			size ++;
		}
	}
	return size;
};

/**
 * mergesort+dedupe
**/
AjxUtil.mergeArrays =
function(arr1, arr2, orderfunc) {
	if(!orderfunc) {
		orderfunc = AjxUtil.__mergeArrays_orderfunc;
	}
 	var tmpArr1 = [];
 	var cnt1 = arr1.length;
 	for(var i = 0; i < cnt1; i++) {
 		tmpArr1.push(arr1[i]);
 	}

 	var tmpArr2 = [];
 	var cnt2 = arr2.length;
 	for(var i = 0; i < cnt2; i++) {
 		tmpArr2.push(arr2[i]);
 	} 	
	var resArr = [];
	while (tmpArr1.length>0 && tmpArr2.length>0) {
		if (orderfunc(tmpArr1[0],resArr[resArr.length-1])==0) {
			tmpArr1.shift();
			continue;
		}
		
		if (orderfunc(tmpArr2[0],resArr[resArr.length-1])==0) {
			tmpArr2.shift();
			continue;
		}		
			
		if (orderfunc(tmpArr1[0], tmpArr2[0])<0) {
			resArr.push(tmpArr1.shift());
		} else if (orderfunc(tmpArr1[0],tmpArr2[0])==0) {
			resArr.push(tmpArr1.shift());
			tmpArr2.shift();
		} else {
			resArr.push(tmpArr2.shift());
		}
	}
		
	while (tmpArr1.length>0) {
		if (orderfunc(tmpArr1[0],resArr[resArr.length-1])==0) {
			tmpArr1.shift();
			continue;
		}		
		resArr.push(tmpArr1.shift());
	}
		
	while (tmpArr2.length>0) {
		if (orderfunc(tmpArr2[0], resArr[resArr.length-1])==0) {
			tmpArr2.shift();
			continue;
		}			
		resArr.push(tmpArr2.shift());
	}
	return resArr;	
};

AjxUtil.__mergeArrays_orderfunc = function (val1,val2) {
    if(val1>val2)    return  1;
    if (val1 < val2) return -1;
    if(val1 == val2) return  0;
};

AjxUtil.arraySubtract = function (arr1, arr2, orderfunc) {
	if(!orderfunc) {
		orderfunc = function (val1,val2) {
			if(val1>val2)
				return 1;
			if (val1 < val2)
				return -1;
			if(val1 == val2)
				return 0;
		}
	}
 	var tmpArr1 = [];
 	var cnt1 = arr1.length;
 	for(var i = 0; i < cnt1; i++) {
 		tmpArr1.push(arr1[i]);
 	}

 	var tmpArr2 = [];
 	var cnt2 = arr2.length;
 	for(var i = 0; i < cnt2; i++) {
 		tmpArr2.push(arr2[i]);
 	} 	
 	tmpArr2.sort(orderfunc);
 	tmpArr1.sort(orderfunc);
	var resArr = [];
	while(tmpArr1.length > 0 && tmpArr2.length > 0) {
		if(orderfunc(tmpArr1[0],tmpArr2[0])==0) {
			tmpArr1.shift();
			tmpArr2.shift();
			continue;
		}
		
		if(orderfunc(tmpArr1[0],tmpArr2[0]) < 0) {
			resArr.push(tmpArr1.shift());
			continue;
		}
		
		if(orderfunc(tmpArr1[0],tmpArr2[0]) > 0) {
			tmpArr2.shift();
			continue;
		}
	}
	
	while(tmpArr1.length > 0) {
		resArr.push(tmpArr1.shift());
	}
	
	return resArr;
};

// Support deprecated, misspelled version
AjxUtil.arraySubstract = AjxUtil.arraySubtract;

/**
 * Returns the keys of the given hash as a sorted list.
 *
 * @param hash		[hash]
 */
AjxUtil.getHashKeys =
function(hash) {

	var list = [];
	for (var key in hash) {
		list.push(key);
	}
	list.sort();

	return list;
};

/**
 * Does a shallow comparison of two arrays.
 *
 * @param arr1	[array]
 * @param arr2	[array]
 */
AjxUtil.arrayCompare =
function(arr1, arr2) {
	if ((!arr1 || !arr2) && (arr1 != arr2)) {
		return false;
	}
	if (arr1.length != arr2.length) {
		return false;
	}
	for (var i = 0; i < arr1.length; i++) {
		if (arr1[i] != arr2[i]) {
			return false;
		}
	}
	return true;
};

/**
 * Does a shallow comparison of two hashes.
 *
 * @param hash1	[hash]
 * @param hash2	[hash]
 */
AjxUtil.hashCompare =
function(hash1, hash2) {

	var keys1 = AjxUtil.getHashKeys(hash1);
	var keys2 = AjxUtil.getHashKeys(hash2);
	if (!AjxUtil.arrayCompare(keys1, keys2)) {
		return false;
	}
	for (var i = 0, len = keys1.length; i < len; i++) {
		var key = keys1[i];
		if (hash1[key] != hash2[key]) {
			return false;
		}
	}
	return true;
};

/**
 * Returns a shallow copy of the given hash.
 *
 * @param {Object}  hash    source hash
 * @param {Array}   omit    Keys to skip (blacklist)
 * @param {Array}   keep 	Keys to keep (whitelist)
 */
AjxUtil.hashCopy = function(hash, omit, keep) {

    omit = omit && AjxUtil.arrayAsHash(omit);
    keep = keep && AjxUtil.arrayAsHash(keep);

	var copy = {};
	for (var key in hash) {
        if ((!omit || !omit[key]) && (!keep || keep[key])) {
    		copy[key] = hash[key];
        }
	}

	return copy;
};

/**
 * Updates one hash with values from another.
 *
 * @param {Object}  hash1		Hash to be updated
 * @param {Object}  hash2 		Hash to update from (values from hash2 will be copied to hash1)
 * @param {Boolean} overwrite 	Set to true if existing values in hash1 should be overwritten when keys match (defaults to false)
 * @param {Array}   omit 	    Keys to skip (blacklist)
 * @param {Array}   keep        Keys to keep (whitelist)
 */
AjxUtil.hashUpdate = function(hash1, hash2, overwrite, omit, keep) {

    omit = omit && AjxUtil.arrayAsHash(omit);
    keep = keep && AjxUtil.arrayAsHash(keep);

    for (var key in hash2) {
		if ((overwrite || !(key in hash1)) && (!omit || !omit[key]) && (!keep || keep[key])) {
			hash1[key] = hash2[key];
		}
	}
};

// array check that doesn't rely on instanceof, since type info
// can get lost in new window
AjxUtil.isArray1 =
function(arg) {
	return !!(arg && (arg.length != null) && arg.splice && arg.slice);
};

// converts the arg to an array if it isn't one
AjxUtil.toArray =
function(arg) {
	if (!arg) {
		return [];
	}
	else if (AjxUtil.isArray1(arg)) {
		return arg;
	}
	else if (AjxUtil.isArrayLike(arg)) {
		return Array.prototype.slice.call(arg);
	}
	else if (arg.isAjxVector) {
        return arg.getArray();
	}
	else {
		return [arg];
	}
};

/**
 * Returns a sub-property of an object. This is useful to avoid code like
 * the following:
 * <pre>
 * resp = resp && resp.BatchResponse;
 * resp = resp && resp.GetShareInfoResponse;
 * resp = resp && resp[0];
 * </pre>
 * <p>
 * The first argument to this function is the source object while the
 * remaining arguments are the property names of the path to follow.
 * This is done instead of as a path string (e.g. "foo/bar[0]") to
 * avoid unnecessary parsing.
 *
 * @param {object}          object  The source object.
 * @param {string|number}   ...     The property of the current context object.
 */
AjxUtil.get = function(object /* , propName1, ... */) {
    for (var i = 1; object && i < arguments.length; i++) {
        object = object[arguments[i]];
    }
    return object;
};


/**
 *  Convert non-ASCII characters to valid HTML UNICODE entities 
 * @param {string}
 * 
*/
AjxUtil.convertToEntities = function (source){
	var result = '';
	var length = 0;
    
    if (!source || !(length = source.length)) return source;
    
	for (var i = 0; i < length; i++) {
		var charCode = source.charCodeAt(i);
		// Encode non-ascii or double quotes
		if ((charCode > 127) || (charCode == 34)) {
			var temp = charCode.toString(10);
			while (temp.length < 4) {
				temp = '0' + temp;
			}
			result += '&#' + temp + ';';
		} else {
			result += source.charAt(i);
		}
	}
	return result;
};

/**
 *  Get the class attribute string from the given class.
 * @param {array} - An array of class names to be converted to a class attribute.
 * returns the attribute string with the class names or empty string if no class is passed.
	*
 */
AjxUtil.getClassAttr = function (classes){
	var attr = [];
	if (classes && classes.length > 0) {
		//remove duplicate css classes
		classes = AjxUtil.uniq(classes);
		return ["class='" , classes.join(" "), "'"].join("");
	}
	return "";
};

/**
 * converts datauri string to blob object used for uploading the image
 * @param {dataURI} - datauri string  data:image/png;base64,iVBORw0
 *
 */
AjxUtil.dataURItoBlob =
function (dataURI) {

    if (!(dataURI && typeof window.atob === "function" && typeof window.Blob === "function")) {
        return;
    }

    var dataURIArray = dataURI.split(",");
    if (dataURIArray.length === 2) {
        if (dataURIArray[0].indexOf('base64') === -1) {
            return;
        }
        // convert base64 to raw binary data held in a string
        // doesn't handle URLEncoded DataURIs
        try{
            var byteString = window.atob(dataURIArray[1]);
        }
        catch(e){
            return;
        }
        if (!byteString) {
            return;
        }
        // separate out the mime component
        var mimeString = dataURIArray[0].split(':');
        if (!mimeString[1]) {
            return;
        }
        mimeString = mimeString[1].split(';')[0];
        if (mimeString) {
            // write the bytes of the string to an ArrayBuffer
            var byteStringLength = byteString.length,
                ab = new ArrayBuffer(byteStringLength),
                ia = new Uint8Array(ab);
            for (var i = 0; i < byteStringLength; i++) {
                ia[i] = byteString.charCodeAt(i);
            }
            return new Blob([ab], {"type" : mimeString});
        }
    }

};

AjxUtil.reduce = function(array, callback, opt_initialValue) {
	/* left-over from IE8 support */
	return Array.prototype.reduce.call(array, callback, opt_initialValue);
};


/**
 * Returns a value for the brightness of the given color.
 *
 * @param   {string}    rgb     RGB value as #RRGGBB
 * @returns {number}    number between 0 and 255 (higher is brighter)
 */
AjxUtil.getBrightness = function(rgb) {

	var r, g, b;

	if (rgb && rgb.length === 7 && rgb.indexOf('#') === 0) {
		rgb = rgb.substr(1);
	}
	else {
		return null;
	}

	r = parseInt(rgb.substr(0, 2), 16);
	g = parseInt(rgb.substr(2, 2), 16);
	b = parseInt(rgb.substr(4, 2), 16);

	// http://alienryderflex.com/hsp.html
	return Math.sqrt(
		r * r * .299 +
			g * g * .587 +
			b * b * .114
	);
};

/**
 * Returns the better foreground color based on contrast with the given background color.
 *
 * @param   {string}    bgColor     RGB value as #RRGGBB
 * @returns {string}    'black' or 'white'
 */
AjxUtil.getForegroundColor = function(bgColor) {
	var brightness = AjxUtil.getBrightness(bgColor);
	return (brightness != null && brightness < 130) ? 'white' : 'black';
};

/**
 * Wrapper function to html encode data, this function handles normal string or array of strings
 * and returns encoded data in same format.
 *
 * @param   {string/array}    obj     array or string to html encode
 * @returns {string/array}    html encoded string or array
 */
AjxUtil.htmlEncode = function(obj) {
	if(AjxUtil.isArray(obj)) {
		obj = obj.map(function(item) {
			return AjxStringUtil.htmlEncode(item);
		});
	} else if (AjxUtil.isString(obj)) {
		obj = AjxStringUtil.htmlEncode(obj);
	}

	return obj;
};

/**
 * Wrapper function to html decode data, this function handles normal string or array of strings
 * and returns decoded data in same format.
 *
 * @param   {string/array}    obj     array or string to html decode
 * @returns {string/array}    html decoded string or array
 */
AjxUtil.htmlDecode = function(obj) {
	if(AjxUtil.isArray(obj)) {
		obj = obj.map(function(item) {
			return AjxStringUtil.htmlDecode(item);
		});
	} else if (AjxUtil.isString(obj)) {
		obj = AjxStringUtil.htmlDecode(obj);
	}

	return obj;
};
}
if (AjxPackage.define("ajax.core.AjxException")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * Creates an exception.
 * @constructor
 * @class
 * This is the base class for all exceptions in the Zimbra Ajax Toolkit.
 * 
 * @author Ross Dargahi
 * 
 * @param {string} 		[msg]		the human readable message
 * @param {constant} 	[code]	any error or fault code
 * @param {string} 		[method] 	the name of the method throwing the exception
 * @param {string} 		[detail]		any additional detail
 */
AjxException = function(msg, code, method, detail) {

	if (arguments.length == 0) { return; }
	
	/** 
	 * Human readable message, if applicable.
	 */
	this.msg = msg;
	
	/** 
	 * Error or fault code, if applicable.
	 */
	this.code = code;
	
	/**
	 * Name of the method throwing the exception, if applicable.
	 */
	this.method = method;
	
	/**
	 * Any additional detail.
	 */
	this.detail = detail;
};

/**
 * Returns a string representation of the object.
 * 
 * @return		{string}		a string representation of the object
 */
AjxException.prototype.toString = 
function() {
	return "AjxException";
};

/**
 * Dumps the exception.
 * 
 * @return {string}	the state of the exception
 */
AjxException.prototype.dump = 
function() {
	return "AjxException: msg=" + this.msg + " code=" + this.code + " method=" + this.method + " detail=" + this.detail;
};

/**
 * Invalid parent exception code.
 */
AjxException.INVALIDPARENT 			= "AjxException.INVALIDPARENT";

/**
 * Invalid operation exception code.
 */
AjxException.INVALID_OP 			= "AjxException.INVALID_OP";

/**
 * Internal error exception code.
 */
AjxException.INTERNAL_ERROR 		= "AjxException.INTERNAL_ERROR";

/**
 * Invalid parameter to method/operation exception code.
 */
AjxException.INVALID_PARAM 			= "AjxException.INVALID_PARAM";

/**
 * Unimplemented method called exception code.
 */
AjxException.UNIMPLEMENTED_METHOD 	= "AjxException.UNIMPLEMENTED_METHOD";

/**
 * Network error exception code.
 */
AjxException.NETWORK_ERROR 			= "AjxException.NETWORK_ERROR";

/**
 * Out or RPC cache exception code.
 */
AjxException.OUT_OF_RPC_CACHE		= "AjxException.OUT_OF_RPC_CACHE";

/**
 * Unsupported operation code.
 */
AjxException.UNSUPPORTED 			= "AjxException.UNSUPPORTED";

/**
 * Unknown error exception code.
 */
AjxException.UNKNOWN_ERROR 			= "AjxException.UNKNOWN_ERROR";

/**
 * Operation canceled exception code.
 */
AjxException.CANCELED				= "AjxException.CANCELED";

AjxException.defaultScriptErrorHandler =
function(ex) {
	alert(ex);
};

AjxException.setScriptErrorHandler =
function(func) {
	AjxException.scriptErrorHandler = func;
};

AjxException.reportScriptError =
function(ex) {
	if (AjxException.reportScriptErrors && AjxException.scriptErrorHandler && !(ex instanceof AjxException)) {
		AjxException.scriptErrorHandler(ex);
	}
	throw ex;
};

AjxException.reportScriptErrors = false;
AjxException.scriptErrorHandler = AjxException.defaultScriptErrorHandler;
}
if (AjxPackage.define("ajax.util.AjxCookie")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * 
 * @private
 */
AjxCookie = function() {
}

AjxCookie.prototype.toString = 
function() {
	return "AjxCookie";
}

AjxCookie.getCookie = 
function(doc, name) {
	var arg = name + "=";
	var alen = arg.length;
	var clen = doc.cookie.length;
	var cookie = doc.cookie;
	var i = 0;
	while (i < clen) {
		var j = i + alen;
		if (cookie.substring(i, j) == arg) {
			var endstr = cookie.indexOf (";", j);
			if (endstr == -1)
				endstr = cookie.length;
			return unescape(cookie.substring(j, endstr));
		}
		i = cookie.indexOf(" ", i) + 1;
		if (i == 0) 
			break; 
	}
  return null;
}

AjxCookie.setCookie = 
function(doc, name, value, expires, path, domain, secure) {
	doc.cookie = name + "=" + escape (value) +
		((expires) ? "; expires=" + expires.toGMTString() : "") +
		((path) ? "; path=" + path : "") +
		((domain) ? "; domain=" + domain : "") +
		((secure) ? "; secure" : "");
}

AjxCookie.deleteCookie = 
function (doc, name, path, domain) {
	doc.cookie = name + "=" +
	((path) ? "; path=" + path : "") +
	((domain) ? "; domain=" + domain : "") + "; expires=Fri, 31 Dec 1999 23:59:59 GMT";
}

AjxCookie.areCookiesEnabled = 
function (doc) {
	var name = "ZM_COOKIE_TEST";
	var value = "Zimbra";
	AjxCookie.setCookie(doc, name, value);
	var cookie = AjxCookie.getCookie(doc, name);
	AjxCookie.deleteCookie(doc, name);
	return cookie == value;
}

}
if (AjxPackage.define("ajax.soap.AjxSoapException")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * Creates a SOAP exception.
 * @class
 * 
 * 
 * @param {string} 		[msg]		the human readable message
 * @param {constant}		code		the exception code
 * @param {string} 		[method] 	the name of the method throwing the exception
 * @param {string} 		[detail]		any additional detail
 * 
 * @extends		AjxException
 * 
 * @private
 */
AjxSoapException = function(msg, code, method, detail) {
	AjxException.call(this, msg, code, method, detail);
}

AjxSoapException.prototype.toString = 
function() {
	return "AjxSoapException";
}

AjxSoapException.prototype = new AjxException;
AjxSoapException.prototype.constructor = AjxSoapException;

/**
 * Defines an "internal error" exception.
 */
AjxSoapException.INTERNAL_ERROR 	= "INTERNAL_ERROR";
/**
 * Defines an "invalid PDU" exception.
 */
AjxSoapException.INVALID_PDU 		= "INVALID_PDU";
/**
 * Defines an "element exists" exception.
 */
AjxSoapException.ELEMENT_EXISTS 	= "ELEMENT_EXISTS";
}
if (AjxPackage.define("ajax.soap.AjxSoapFault")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * Represents a SOAP Fault
 * @class
 * Public attributes:
 *
 * - faultCode: The SOAP fault code
 * - reason: Reason string
 * - errorCode: server error code
 * 
 * @private
 */
AjxSoapFault = function(faultEl) {
	if (arguments.length == 0) return;
	var prefix = faultEl.prefix;
	var codeStr = prefix + ":Code";
	var reasonStr = prefix + ":Reason";
	var detailStr = prefix + ":Detail"
	// We will assume a correctly formatted Fault element
	var len = faultEl.childNodes.length;
	for (var i = 0; i < len; i++) {
		var childNode = faultEl.childNodes[i];
		if (childNode.nodeName == codeStr) {
			var faultCode = childNode.firstChild.firstChild.nodeValue;
			if (faultCode == (prefix + ":VersionMismatch"))
				this.faultCode = AjxSoapFault.VERSION_MISMATCH;
			else if (faultCode == (prefix + ":MustUnderstand"))
				this.faultCode = AjxSoapFault.MUST_UNDERSTAND;
			else if (faultCode == (prefix + ":DataEncodingUnknown"))
				this.faultCode = AjxSoapFault.DATA_ENCODING_UNKNOWN;
			else if (faultCode == (prefix + ":Sender"))
				this.faultCode = AjxSoapFault.SENDER;
			else if (faultCode == (prefix + ":Receiver"))
				this.faultCode = AjxSoapFault.RECEIVER;
			else
				this.faultCode = AjxSoapFault.UNKNOWN;		
		} else if (childNode.nodeName == reasonStr) {
			this.reason = childNode.firstChild.firstChild.nodeValue;
		} else if (childNode.nodeName == detailStr) {
			this.errorCode = childNode.firstChild.firstChild.firstChild.nodeValue;
		}
	}
}

/**
 * Returns a string representation of this object.
 * 
 * @return	{string}	a string representation of this object
 */
AjxSoapFault.prototype.toString = 
function() {
	return "AjxSoapFault";
}

AjxSoapFault.SENDER = -1;
AjxSoapFault.RECEIVER = -2;
AjxSoapFault.VERSION_MISMATCH = -3;
AjxSoapFault.MUST_UNDERSTAND = -4;
AjxSoapFault.DATA_ENCODING_UNKNOWN = -5;
AjxSoapFault.UNKNOWN = -6;
}
if (AjxPackage.define("ajax.soap.AjxSoapDoc")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * Default constructor.
 * @class
 * Note: do not directly instantiate AjxSoapDoc. Use one of the <code>create</code> methods instead
 * 
 * @see		AjxSoapDoc.create
 */
AjxSoapDoc = function() {
	this._soapURI = AjxSoapDoc._SOAP_URI;
}

AjxSoapDoc.prototype.isAjxSoapDoc = true;
AjxSoapDoc.prototype.toString = function() { return "AjxSoapDoc"; };

AjxSoapDoc._SOAP_URI = "http://www.w3.org/2003/05/soap-envelope";
// AjxSoapDoc._SOAP_URI = "http://schemas.xmlsoap.org/soap/envelope/";
AjxSoapDoc._XMLNS_URI = "http://www.w3.org/2000/xmlns";

/**
 * Creates a SOAP document.
 * 
 * @param	{string}	method		the soap method
 * @param	{string}	namespace	the method namespace
 * @param	{string}	[namespaceId]	the namespace id
 * @param	{string}	[soapURI]	the SOAP uri
 * @return	{AjxSoapDoc}		the document
 */
AjxSoapDoc.create =
function(method, namespace, namespaceId, soapURI) {
	var sd = new AjxSoapDoc();
	sd._xmlDoc = AjxXmlDoc.create();
	var d = sd._xmlDoc.getDoc();

	if (!soapURI)
		soapURI = AjxSoapDoc._SOAP_URI;
	sd._soapURI = soapURI;

	var useNS = d.createElementNS && !AjxEnv.isSafari;
	var envEl = useNS ?  d.createElementNS(soapURI, "soap:Envelope") : d.createElement("soap:Envelope");
	if (!useNS) envEl.setAttribute("xmlns:soap", soapURI);

	d.appendChild(envEl);

	var bodyEl = useNS ? d.createElementNS(soapURI, "soap:Body") : d.createElement("soap:Body");
	envEl.appendChild(bodyEl);

	sd._methodEl = namespace && useNS ?  d.createElementNS(namespace, method) : d.createElement(method);
	if (namespace != null && !useNS) {
		if (namespaceId == null)
			sd._methodEl.setAttribute("xmlns", namespace);
		else
			sd._methodEl.setAttribute("xmlns:" + namespaceId, namespace);
	}
	bodyEl.appendChild(sd._methodEl);
	return sd;
};

/**
 * Creates from a DOM object.
 * 
 * @param	{Object}	doc		the DOM object
 * @return	{AjxSoapDoc}		the document
 */
AjxSoapDoc.createFromDom =
function(doc) {
	var sd = new AjxSoapDoc();
	sd._xmlDoc = AjxXmlDoc.createFromDom(doc);
	sd._methodEl = sd._check(sd._xmlDoc);
	return sd;
};

/**
 * Creates from an XML object.
 * 
 * @param	{Object}	xml		the XML object
 * @return	{AjxSoapDoc}		the document
 */
AjxSoapDoc.createFromXml =
function(xml) {
	var sd = new AjxSoapDoc();
	sd._xmlDoc = AjxXmlDoc.createFromXml(xml);
	sd._methodEl = sd._check(sd._xmlDoc);
	return sd;
};

AjxSoapDoc.element2FaultObj =
function(el) {
	// If the element is not a SOAP fault, then return null
	var faultEl = el.firstChild;
	// Safari is bad at handling namespaces
	if (!AjxEnv.isSafari) {
		if (faultEl != null && faultEl.namespaceURI != AjxSoapDoc._SOAP_URI || faultEl.nodeName != (el.prefix + ":Fault"))
		return null;
	} else {
		if (faultEl != null && faultEl.nodeName != (el.prefix + ":Fault"))
			return null;
	}
	return new AjxSoapFault(faultEl);
};

AjxSoapDoc.prototype.setMethodAttribute =
function(name, value) {
	this._methodEl.setAttribute(name, value);
};

/**
 * Creates arguments to pass within the envelope.  "value" can be a JS object
 * or a scalar (string, number, etc.).
 * <p>
 * When "value" is a JS object, set() will call itself recursively in order to
 * create a complex data structure.  Don't pass a "way-too-complicated" object
 * ("value" should only contain references to simple JS objects, or better put,
 * hashes--don't include a reference to the "window" object as it will kill
 * your browser).
 * <p>
 * Example:
 *
 * <pre>
 *    soapDoc.set("user_auth", {
 *       user_name : "foo",
 *       password  : "bar"
 *    });
 * </pre>
 * 
 * will create an XML like this under the method tag:
 *
 * <pre>
 *    &lt;user_auth>
 *      &lt;user_name>foo&lt;/user_name>
 *      &lt;password>bar&lt;/password>
 *    &lt;/user_auth>
 * </pre>
 * 
 * Of course, nesting other hashes is allowed and will work as expected.
 * <p>
 * NOTE: you can pass null for "name", in which case "value" is expected to be
 * an object whose properties will be created directly under the method el.
 * 
 * @param	{string}	name	the name
 * @param	{hash}	value		the attribute name/value pairs
 * @param	{string}	[parent]	the parent element to append to
 * @param	{string}	[namespace]	the namespace
 * @return	{Element}	the node element
 */
AjxSoapDoc.prototype.set =
function(name, value, parent, namespace) {
	var	doc = this.getDoc();

	var useNS = doc.createElementNS && !AjxEnv.isSafari;

	var	p = name
		? (namespace && useNS ? doc.createElementNS(namespace, name) : doc.createElement(name))
		: doc.createDocumentFragment();

    if ((namespace !== undefined) && (namespace !== null) && !useNS) {
        p.setAttribute("xmlns", namespace);
    }

	if (value != null) {
		if (typeof value == "object") {
			for (var i in value) {
                                var val = value[i];
                                if (i.charAt(0) == "!") {
                                        // attribute
                                        p.setAttribute(i.substr(1), val);
                                } else if (val instanceof Array) {
                                        // add multiple elements
                                        for (var j = 0; j < val.length; ++j)
                                                this.set(i, val[j], p);
                                } else {
				        this.set(i, val, p);
                                }
			}
		} else {
			p.appendChild(doc.createTextNode(value));
		}
	}
	if (!parent)
		parent = this._methodEl;
	return parent.appendChild(p);
};

/**
 * Gets the method.
 * 
 * @return	{string}	the method
 */
AjxSoapDoc.prototype.getMethod =
function() {
	return this._methodEl;
};

/**
 * Creates a header element.
 * 
 * @return	{Element}	the header element
 */
AjxSoapDoc.prototype.createHeaderElement =
function() {
	var d = this._xmlDoc.getDoc();
	var envEl = d.firstChild;
	var header = this.getHeader();
	if (header != null) {
		throw new AjxSoapException("SOAP header already exists", AjxSoapException.ELEMENT_EXISTS, "AjxSoapDoc.prototype.createHeaderElement");
	}
	var useNS = d.createElementNS && !AjxEnv.isSafari;
	header = useNS ? d.createElementNS(this._soapURI, "soap:Header") : d.createElement("soap:Header")
	envEl.insertBefore(header, envEl.firstChild);
	return header;
};

/**
 * Gets the header.
 * 
 * @return	{Element}	the header or <code>null</code> if not created
 */
AjxSoapDoc.prototype.getHeader =
function() {
	// fall back to getElementsByTagName in IE 8 and earlier
	var d = this._xmlDoc.getDoc();
	var nodeList = !d.getElementsByTagNameNS
		? (d.getElementsByTagName(d.firstChild.prefix + ":Header"))
		: (d.getElementsByTagNameNS(this._soapURI, "Header"));

	return nodeList ? nodeList[0] : null;
};

/**
 * Gets the body.
 * 
 * @return	{Element}	the body element
 */
AjxSoapDoc.prototype.getBody =
function() {
	// fall back to getElementsByTagName in IE 8 and earlier
	var d = this._xmlDoc.getDoc();
	var nodeList = !d.getElementsByTagNameNS
		? (d.getElementsByTagName(d.firstChild.prefix + ":Body"))
		: (d.getElementsByTagNameNS(this._soapURI, "Body"));

	return nodeList ? nodeList[0] : null;
};

AjxSoapDoc.prototype.getByTagName =
function(type) {
	if (type.indexOf(":") == -1)
		type = "soap:" + type;

	var a = this.getDoc().getElementsByTagName(type);

	if (a.length == 1)		return a[0];
	else if (a.length > 0)	return a;
	else					return null;
};

// gimme a header, no exceptions.
AjxSoapDoc.prototype.ensureHeader =
function() {
	return (this.getHeader() || this.createHeaderElement());
};

/**
 * Gets the document.
 * 
 * @return	{Document}	the document
 */
AjxSoapDoc.prototype.getDoc =
function() {
	return this._xmlDoc.getDoc();
};

/**
 * Adopts a node from another document to this document.
 * 
 * @param	{Element}	node		the node
 * @private
 */
AjxSoapDoc.prototype.adoptNode =
function(node) {
	// Older firefoxes throw not implemented error when you call adoptNode.
	if (AjxEnv.isFirefox3up || !AjxEnv.isFirefox) {
		try {
			var doc = this.getDoc();
			if (doc.adoptNode) {
				return doc.adoptNode(node, true);
			}
		} catch (ex) {
			// handle below by returning the input node.
		}
	}
	// call removeChild since Safari complains if you try to add an already
	// parented node to another document.
	return node.parentNode.removeChild(node);
};

/**
 * Gets the XML.
 * 
 * @return	{string}	the XML
 */
AjxSoapDoc.prototype.getXml = function() {
    return this._xmlDoc.getXml();
};

// Very simple checking of soap doc. Should be made more comprehensive
AjxSoapDoc.prototype._check =
function(xmlDoc) {
	var doc = xmlDoc.getDoc();
	if (doc.childNodes.length != 1)
		throw new AjxSoapException("Invalid SOAP PDU", AjxSoapException.INVALID_PDU, "AjxSoapDoc.createFromXml:1");

	// Check to make sure we have a soap envelope
	var el = doc.firstChild;

	// Safari is bad at handling namespaces
	if (!AjxEnv.isSafari) {
		if (el.namespaceURI != AjxSoapDoc._SOAP_URI ||
			el.nodeName != (el.prefix + ":Envelope") ||
			(el.childNodes.length < 1 || el.childNodes.length > 2))
		{
			DBG.println("<font color=red>XML PARSE ERROR on RESPONSE:</font>");
			DBG.printRaw(doc.xml);
			throw new AjxSoapException("Invalid SOAP PDU", AjxSoapException.INVALID_PDU, "AjxSoapDoc.createFromXml:2");
		}
	} else {
		if (el.nodeName != (el.prefix + ":Envelope"))
			throw new AjxSoapException("Invalid SOAP PDU", AjxSoapException.INVALID_PDU, "AjxSoapDoc.createFromXml:2");
	}
};
}
if (AjxPackage.define("ajax.net.AjxRpcRequest")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * @constructor
 * @class
 * This class encapsulates the XML HTTP request, hiding differences between
 * browsers. The internal request object depends on the browser. While it is 
 * possible to use this class directly, {@link AjxRpc} provides a managed interface
 * to this class 
 *
 * @author Ross Dargahi
 * @author Conrad Damon
 * 
 * @param {string} [id]		the ID to identify this object
 * 
 * @see AjxRpc
 * 
 */
AjxRpcRequest = function(id) {
	if (!AjxRpcRequest.__inited) {
		AjxRpcRequest.__init();
	}

	/**
	 * The id for this object.
	 */
	this.id = id;
	this.__httpReq = AjxRpcRequest.__msxmlVers
		? (new ActiveXObject(AjxRpcRequest.__msxmlVers))
		: (new XMLHttpRequest());
};

AjxRpcRequest.prototype.isAjxRpcRequest = true;
AjxRpcRequest.prototype.toString = function() { return "AjxRpcRequest"; };

AjxRpcRequest.TIMEDOUT		= -1000;		// Timed out exception
AjxRpcRequest.HTTP_GET		= "get";		//HTTP GET
AjxRpcRequest.HTTP_POST		= "post";		//HTTP POST
AjxRpcRequest.HTTP_PUT		= "put";		//HTTP PUT
AjxRpcRequest.HTTP_DELETE	= "delete";		//HTTP DELETE

AjxRpcRequest.__inited		= false;
AjxRpcRequest.__msxmlVers	= null;


/**
 * Sends this request to the target URL. If there is a callback, the request is
 * performed asynchronously.
 * 
 * @param {string} [requestStr] 	the HTTP request string/document
 * @param {string} serverUrl 	the request target 
 * @param {array} [requestHeaders] an array of HTTP request headers
 * @param {AjxCallback} callback 	the callback for asynchronous requests. This callback 
 * 		will be invoked when the requests completes. It will be passed the same
 * 		values as when this method is invoked synchronously (see the return values
 * 		below) with the exception that if the call times out (see timeout param 
 * 		below), then the object passed to the callback will be the same as in the 
 * 		error case with the exception that the status will be set to 
 * 		{@link AjxRpcRequest.TIMEDOUT}.
 * @param {Constant} [method] 		the HTTP method -- GET, POST, PUT, DELETE. if <code>true</code>, use get method for backward compatibility
 * @param {number} [timeout] 		the timeout (in milliseconds) after which the request is canceled
 * 
 * @return {object|hash}	if invoking in asynchronous mode, then it will return the id of the 
 * 		underlying {@link AjxRpcRequest} object. Else if invoked synchronously, if
 * 		there is no error (i.e. we get a HTTP result code of 200 from the server),
 * 		an object with the following attributes is returned
 * 		<ul>
 * 		<li>text - the string response text</li>
 * 		<li>xml - the string response xml</li>
 * 		<li>success - boolean set to true</li>
 * 		</ul>
 * 		If there is an eror, then the following will be returned
 * 		<ul>
 * 		<li>text - the string response text<li>
 * 		<li>xml - the string response xml </li>
 * 		<li>success - boolean set to <code>false</code></li>
 * 		<li>status - HTTP status</li>
 * 		</ul>
 * 
 * @throws	{AjxException.NETWORK_ERROR}	a network error occurs
 * @throws	{AjxException.UNKNOWN_ERROR}	an unknown error occurs
 * 
 * @see AjxRpc.invoke
 */
AjxRpcRequest.prototype.invoke =
function(requestStr, serverUrl, requestHeaders, callback, method, timeout) {


	var asyncMode = (callback != null);
	this.methodName = serverUrl || "";

	// An exception here will be caught by AjxRpc.invoke
	var httpMethod = AjxRpcRequest.HTTP_POST;
	if (method) {
		httpMethod = method === true ? AjxRpcRequest.HTTP_GET : method;
	}

	if (window.csrfToken &&
		(httpMethod === AjxRpcRequest.HTTP_POST ||
		httpMethod === AjxRpcRequest.HTTP_PUT ||
		httpMethod === AjxRpcRequest.HTTP_DELETE)) {

		requestHeaders = requestHeaders || {};
		requestHeaders["X-Zimbra-Csrf-Token"] = window.csrfToken;

	}

	this.__httpReq.open(httpMethod, serverUrl, asyncMode);

	if (asyncMode) {
		if (timeout) {
			var action = new AjxTimedAction(this, this.__handleTimeout, [callback]);
			callback._timedActionId = AjxTimedAction.scheduleAction(action, timeout);
		}
		var tempThis = this;
		this.__httpReq.onreadystatechange = function(ev) {
			if (window.AjxRpcRequest) {
				AjxRpcRequest.__handleResponse(tempThis, callback);
			}
		}
	} else {
		// IE appears to run handler even on sync requests, so we need to clear it
		this.__httpReq.onreadystatechange = function(ev) {};
	}

	if (requestHeaders) {
		for (var i in requestHeaders) {
            if (requestHeaders.hasOwnProperty(i)) {
                this.__httpReq.setRequestHeader(i, requestHeaders[i]);
            }
		}
	}

	AjxDebug.println(AjxDebug.RPC, AjxDebug._getTimeStamp() + " RPC send: " + this.id);
	this.__httpReq.send(requestStr);
	if (asyncMode) {
		return this.id;
	} else {
		if (this.__httpReq.status == 200 || this.__httpReq.status == 201) {
			return {text:this.__httpReq.responseText, xml:this.__httpReq.responseXML, success:true};
		} else {
			return {text:this.__httpReq.responseText, xml:this.__httpReq.responseXML, success:false, status:this.__httpReq.status};
		}
	}
};

/**
 * Cancels a pending request.
 * 
 */
AjxRpcRequest.prototype.cancel =
function() {
	AjxRpc.freeRpcCtxt(this);
    if (AjxEnv.isFirefox3_5up) {
		// bug 55911
        this.__httpReq.onreadystatechange = function(){};
    }
    this.__httpReq.abort();
};

/**
 * Handler that runs when an asynchronous request timesout.
 *
 * @param {AjxCallback} callback 	the callback to run after timeout
 * 
 * @private
 */
AjxRpcRequest.prototype.__handleTimeout =
function(callback) {
	this.cancel();
	callback.run( {text:null, xml:null, success:false, status:AjxRpcRequest.TIMEDOUT} );
};

/**
 * Handler that runs when an asynchronous response has been received. It runs a
 * callback to initiate the response handling.
 *
 * @param {AjxRpcRequest}	req		the request that generated the response
 * @param {AjxCallback}	callback	the callback to run after response is received
 * 
 * @private
 */
AjxRpcRequest.__handleResponse =
function(req, callback) {

	try {

	if (!req || !req.__httpReq) {

		req.cancel();

		// If IE receives a 500 error, the object reference can be lost
		DBG.println(AjxDebug.DBG1, "Async RPC request: Lost request object!!!");
		AjxDebug.println(AjxDebug.RPC, AjxDebug._getTimeStamp() + " Async RPC request: Lost request object!!!");
		callback.run( {text:null, xml:null, success:false, status:500} );
		AjxRpc.freeRpcCtxt(req);
		return;
	}

	if (req.__httpReq.readyState == 4) {
		if (callback._timedActionId !== null) {
			AjxTimedAction.cancelAction(callback._timedActionId);
		}

		var status = 500;
		try {
			status = req.__httpReq.status;
		} catch (ex) {
			// Use default status of 500 above.
		}
		if (status == 200 || status == 201) {
			callback.run( {text:req.__httpReq.responseText, xml:req.__httpReq.responseXML, success:true, reqId:req.id} );
		} else {
			callback.run( {text:req.__httpReq.responseText, xml:req.__httpReq.responseXML, success:false, status:status, reqId:req.id} );
		}

		AjxRpc.freeRpcCtxt(req);
	}

	} catch (ex) {
		if (window.AjxException) {
			AjxException.reportScriptError(ex);
		}
	}
};

/**
 * @private
 */
AjxRpcRequest.__init =
function() {
	if (!window.XMLHttpRequest && window.ActiveXObject) {
		// search for the latest xmlhttp version on user's machine (IE 6)
		var msxmlVers = ["MSXML2.XMLHTTP.4.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP"];
		for (var i = 0; i < msxmlVers.length; i++) {
			try {
				var x = new ActiveXObject(msxmlVers[i]);
				AjxRpcRequest.__msxmlVers = msxmlVers[i];
				break;
			} catch (ex) {
				// do nothing
			}
		}
		if (!AjxRpcRequest.__msxmlVers) {
			throw new AjxException("MSXML not installed", AjxException.INTERNAL_ERROR, "AjxRpc._init");
		}
	}
	AjxRpcRequest.__inited = true;
};

}
if (AjxPackage.define("ajax.net.AjxRpc")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * @constructor
 * @class
 * This static class provides an interface for send requests to a server. It
 * essentially wraps {@link AjxRpcRequest}. This {@link AjxRpc} link maintains a cache of
 * {@link AjxRpcRequest} objects which it attempts to reuse before allocating additional
 * objects. It also has a mechanism whereby if an {@link AjxRpcRequest} object is 
 * in a "busy" state for a extended period of time, it will reap it appropriately.
 *
 * @author Ross Dargahi
 * @author Conrad Damon
 * 
 * @see AjxRpcRequest
 */
AjxRpc = function() {
};

AjxRpc.__rpcCache		= [];		// The pool of RPC contexts available
AjxRpc.__rpcOutstanding	= {};		// The pool of RPC contexts in use

AjxRpc.__RPC_CACHE_MAX		= 500;		// maximum number of busy contexts we can have
AjxRpc.__RPC_ID				= 0;		// used for context IDs
AjxRpc.__RPC_IN_USE			= 0;		// number of contexts that are busy
AjxRpc.__RPC_HIGH_WATER		= 0;		// high water mark for busy contexts
AjxRpc.__RPC_REAP_AGE		= 300000;	// 5 minutes; mark any context older than this (in ms) as free
AjxRpc.__RPC_REAP_INTERVAL	= 1800000;	// 30 minutes; run the reaper this often

/**
 * Submits a request to a URL. The request is handled through a pool of request
 * contexts (each a wrapped XmlHttpRequest). The context does the real work.
 *
 * @param {string} [requestStr] 	the HTTP request string/document
 * @param {string} serverUrl 	the request target 
 * @param {array} [requestHeaders] an array of HTTP request headers
 * @param {AjxCallback} callback 	the callback for asynchronous requests. This callback 
 * 		will be invoked when the requests completes. It will be passed the same
 * 		values as when this method is invoked synchronously (see the return values
 * 		below) with the exception that if the call times out (see timeout param 
 * 		below), then the object passed to the callback will be the same as in the 
 * 		error case with the exception that the status will be set to 
 * 		{@link AjxRpcRequest.TIMEDOUT}.
 * @param {Constant} [method] 		the HTTP method -- GET, POST, PUT, DELETE. if <code>true</code>, use get method for backward compatibility
 * @param {number} [timeout] 		the timeout (in milliseconds) after which the request is canceled
 * 
 * @return {object|hash}	if invoking in asynchronous mode, then it will return the id of the 
 * 		underlying {@link AjxRpcRequest} object. Else if invoked synchronously, if
 * 		there is no error (i.e. we get a HTTP result code of 200 from the server),
 * 		an object with the following attributes is returned
 * 		<ul>
 * 		<li>text - the string response text</li>
 * 		<li>xml - the string response xml</li>
 * 		<li>success - boolean set to true</li>
 * 		</ul>
 * 		If there is an error, then the following will be returned
 * 		<ul>
 * 		<li>text - the string response text<li>
 * 		<li>xml - the string response xml </li>
 * 		<li>success - boolean set to <code>false</code></li>
 * 		<li>status - HTTP status</li>
 * 		</ul>
 * 
 * @throws	{AjxException.NETWORK_ERROR}	a network error occurs
 * @throws	{AjxException.UNKNOWN_ERROR}	an unknown error occurs
 * 
 * @see	AjxRpcRequest#invoke
 * 
 */
AjxRpc.invoke =
function(requestStr, serverUrl, requestHeaders, callback, method, timeout) {

	var asyncMode = (callback != null);
	var rpcCtxt = AjxRpc.__getFreeRpcCtxt();

	try {
		var response = rpcCtxt.invoke(requestStr, serverUrl, requestHeaders, callback, method, timeout);
	} catch (ex) {
		var newEx = new AjxException();
		newEx.method = "AjxRpc.prototype._invoke";
		if (ex instanceof Error) {
			newEx.detail = ex.message;
			newEx.code = AjxException.NETWORK_ERROR;
			newEx.msg = "Network error";
		} else if (ex.code == 101){
			// Chrome 
			newEx.detail = ex.message;
			newEx.code = AjxException.NETWORK_ERROR;
			newEx.msg = "Network error";
		} else {
			newEx.detail = ex.toString();
			newEx.code = AjxException.UNKNOWN_ERROR;
			newEx.msg = "Unknown Error";
		}
		// exception hit: we're done whether sync or async, free the context
		AjxRpc.freeRpcCtxt(rpcCtxt);
		throw newEx;
	}
	if (!asyncMode) {
		// we've returned from a sync request, free the context
		AjxRpc.freeRpcCtxt(rpcCtxt);
	}
	return response;
};

/**
 * @private
 */
AjxRpc.freeRpcCtxt =
function(rpcCtxt) {
	// we're done using this rpcCtxt. Add it back to the pool
	if (AjxRpc.__rpcOutstanding[rpcCtxt.id]) {
		AjxDebug.println(AjxDebug.RPC, AjxDebug._getTimeStamp() + " --- freeing rpcCtxt " + rpcCtxt.id);
		AjxRpc.__rpcCache.push(rpcCtxt);
		delete AjxRpc.__rpcOutstanding[rpcCtxt.id];
		AjxRpc.__RPC_IN_USE--;
	}
};

AjxRpc.removeRpcCtxt =
function(rpcCtxt) {
	AjxDebug.println(AjxDebug.RPC, AjxDebug._getTimeStamp() + " REMOVE rpcCtxt " + rpcCtxt.id);
	if (AjxRpc.__rpcOutstanding[rpcCtxt.id]) {
		delete AjxRpc.__rpcOutstanding[rpcCtxt.id];
		AjxRpc.__RPC_IN_USE--;
	}
	AjxUtil.arrayRemove(AjxRpc.__rpcCache, rpcCtxt);
};

/**
 * Returns the request from the RPC context with the given ID.
 *
 * @param {String} id RPC context ID
 * 
 * @return The <i>AjxRpcRequest</i> object associated with <code>id</code> or null
 * 		if no object exists for the supplied id
 * @type AjxRpcRequest
 * 
 * @private
 */
AjxRpc.getRpcRequestById = 
function(id) {
	return (AjxRpc.__rpcOutstanding[id]);
};

/**
 * Factory method for getting context objects.
 * 
 * @private
 */
AjxRpc.__getFreeRpcCtxt = 
function() {
	var rpcCtxt;

	if (AjxRpc.__rpcCache.length > 0) {
		rpcCtxt = AjxRpc.__rpcCache.pop();
		AjxDebug.println(AjxDebug.RPC, AjxDebug._getTimeStamp() + " reusing RPC ID " + rpcCtxt.id);
	} else {
		if (AjxRpc.__RPC_IN_USE < AjxRpc.__RPC_CACHE_MAX) {
			// we haven't reached our limit, so create a new AjxRpcRequest
			var id = "__RpcCtxt_" + AjxRpc.__RPC_ID;
			rpcCtxt = new AjxRpcRequest(id);
			AjxRpc.__RPC_ID++;
			AjxDebug.println(AjxDebug.RPC, AjxDebug._getTimeStamp() + " Created RPC " + id);
		} else {
			// yikes, we're out of rpc's! Look for an old one to kill.
			rpcCtxt = AjxRpc.__reap();

			// if reap didn't find one either, bail.
			if (!rpcCtxt) {
				var text = [];
				for (var i in AjxRpc.__rpcOutstanding) {
					var rpcCtxt = AjxRpc.__rpcOutstanding[i];
					text.push(rpcCtxt.methodName);
				}
				var detail = text.join("<br>") + "<br>";
				AjxDebug.println(AjxDebug.RPC, AjxDebug._getTimeStamp() + " Out of RPC cache!!! Outstanding requests: " + detail);
				throw new AjxException("Out of RPC cache", AjxException.OUT_OF_RPC_CACHE, "AjxRpc.__getFreeRpcCtxt", detail);
			}
		}
	}

	AjxRpc.__rpcOutstanding[rpcCtxt.id] = rpcCtxt;
	AjxRpc.__RPC_IN_USE++;
	if (AjxRpc.__RPC_IN_USE > AjxRpc.__RPC_HIGH_WATER) {
		AjxRpc.__RPC_HIGH_WATER = AjxRpc.__RPC_IN_USE;
		AjxDebug.println(AjxDebug.RPC, AjxDebug._getTimeStamp() + " High water mark: " + AjxRpc.__RPC_HIGH_WATER);
	}

	// always reset timestamp before returning rpcCtxt
	rpcCtxt.timestamp = (new Date()).getTime();
	return rpcCtxt;
};

/**
 * Frees expired contexts.
 * 
 * @param {boolean}	all		if true, frees all expired contexts; otherwise, returns the first one it finds
 * @private
 */
AjxRpc.__reap =
function(all) {
	var rpcCtxt;
	var time = (new Date()).getTime();
	AjxDebug.println(AjxDebug.RPC, AjxDebug._getTimeStamp() + " Running RPC context reaper");
	for (var i in AjxRpc.__rpcOutstanding) {
		rpcCtxt = AjxRpc.__rpcOutstanding[i];
		if ((rpcCtxt.timestamp + AjxRpc.__RPC_REAP_AGE) < time) {
			DBG.println(AjxDebug.DBG1, "AjxRpc.__reap: cleared RPC context " + rpcCtxt.id);
			AjxDebug.println(AjxDebug.RPC, AjxDebug._getTimeStamp() + " AjxRpc.__reap: cleared RPC context " + rpcCtxt.id);
			rpcCtxt.cancel();
			delete AjxRpc.__rpcOutstanding[i];
			AjxRpc.__RPC_IN_USE--;
			if (!all) {
				return rpcCtxt;
			}
		}
	}
	return null;
};

window.setInterval(AjxRpc.__reap.bind(null, true), AjxRpc.__RPC_REAP_INTERVAL);
}
if (AjxPackage.define("ajax.util.AjxVector")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

// AjxVector class

/**
 * Creates a vector.
 * @class
 * This class represents a vector.
 * 
 */
AjxVector = function(array) {
	this._array = array || [];
};

AjxVector.prototype.isAjxVector = true;

/**
 * Returns a string representation of the object.
 * 
 * @param	{string}	sep		the seperator
 * @param	{boolean}	compress	if <code>true</code>, compress
 * 
 * @return	{string}	a string representation of the object
 */
AjxVector.prototype.toString =
function(sep, compress) {
	if (compress !== true)
		return this._array.join(sep);

	var a = new Array();
	for (var i = 0; i < this._array.length; i++) {
		var x = this._array[i];
		if  (x != undefined && x != null && x != "")
			a.push(x);
	}
	return a.join(sep);
};

/**
 * Creates a vector from a given array.
 * 
 * @param	{array}	list		an array
 * @return	{AjxVector}		the vector
 */
AjxVector.fromArray =
function(list) {
	var vec = new AjxVector();
	if (AjxUtil.isArray1(list)) {
		vec._array = list;
	}
	return vec;
};

/**
 * Gets the size of the vector.
 * 
 * @return	{number}	the size
 */
AjxVector.prototype.size =
function() {
	return this._array.length;
};

/**
 * Adds a object to the vector.
 * 
 * @param	{Object}	obj		the object
 * @param	{number}		index	the index where to add
 * @param	{boolean}	noDuplicates	if <code>true</code>, confirm the object is not in vector before adding
 */
AjxVector.prototype.add =
function(obj, index, noDuplicates) {
	// if no duplicates, search for the obj in list and return if found.
	if (noDuplicates && this.contains(obj)) {
		return;
	}

	AjxUtil.arrayAdd(this._array, obj, index);
};

/**
 * Adds the given array.
 * 
 * @param	{array}		list		an array
 */
AjxVector.prototype.addList =
function(list) {
	if (!list) return;

	if (list.length) {// array
		this._array = this._array.concat(list);
	} else if (list.size && list.size()) {// AjxVector
		// in new window, IE seems to lose its rtti :(
		if (AjxEnv.isIE && (!(list._array instanceof Array))) {
			var newList = [];
			for (var i = 0; i < list._array.length; i++) {
				newList.push(list._array[i]);
			}
			list._array = newList;
		}

		this._array = this._array.concat(list._array);
	}
};

/**
 * Removes the object.
 * 
 * @param	{Object}	obj		the object to remove
 * @return	{boolean}	<code>true</code> if the object is removed
 */
AjxVector.prototype.remove =
function(obj) {
	return AjxUtil.arrayRemove(this._array, obj);
};

/**
 * Removes the object at the given index.
 * 
 * @param	{number}	index		the index
 * @return	{Object}	the object at the index or <code>null</code> if no object at index
 */
AjxVector.prototype.removeAt =
function(index) {
	if (index >= this._array.length || index < 0)
		return null;

	var delArr = this._array.splice(index, 1);
	var ret = null;
	if (delArr) {
		ret = delArr[0];
	}
	return ret;
};

/**
 * Removes all objects from vector.
 * 
 */
AjxVector.prototype.removeAll =
function() {
	// Actually blow away the array items so that garbage
	// collection can take place (XXX: does this really force GC?)
	for (var i = 0; i < this._array.length; i++)
		this._array[i] = null;
	this._array.length = 0;
};

/**
 * Removes the last object in the vector.
 * 
 */
AjxVector.prototype.removeLast =
function() {
	return this._array.length > 0 ? this._array.pop() : null;
};

/**
 * Reverses the order of the objects in the vector.
 * 
 */
AjxVector.prototype.reverse =
function() {
	this._array.reverse();
};

/**
 * Replaces the object at a given index.
 * 
 * @param	{number}	index		the index
 * @param	{Object}	newObj	the new object
 * @return	{Object}	the old object
 */
AjxVector.prototype.replace =
function(index, newObj) {
	var oldObj = this._array[index];
	this._array[index] = newObj;
	return oldObj;
};

/**
 * Replaces an object.
 * 
 * @param	{Object}	obj		the object to replace
 * @param	{Object}	newObj	the new object
 * @return	{Object}	the replaced object or <code>null</code> if not replaced
 */
AjxVector.prototype.replaceObject =
function(obj, newObj) {
	for (var i = 0; i < this._array.length; i++) {
		if (this._array[i] == obj) {
			this._array[i] = newObj;
			return obj;
		}
	}
	return null;
};

/**
 * Returns the index of the obj given w/in vector
 *
 * @param {Object}	    obj			the object being looked for
 * @param {function}	func	    (optional) a function for transforming objects
 *
 * @return	{number}	the index or -1 if not found
 */
AjxVector.prototype.indexOf = function(obj, func) {

	if (obj == null) {
		return -1;
	}
    obj = func ? func.call(obj) : obj;

	for (var i = 0; i < this._array.length; i++) {
        var member = this._array[i],
            test = func ? func.call(member) : member;
		if (test === obj) {
			return i;
		}
	}
	return -1;
};

AjxVector.prototype.indexOfLike = AjxVector.prototype.indexOf;

/**
 * Returns the last index of the obj given w/in vector
 *
 * @param {Object}	    obj			the object being looked for
 * @param {function}	func	    (optional) a function for transforming objects
 *
 * @return	{number}	the index or -1 if not found
 */
AjxVector.prototype.lastIndexOf = function(obj, func) {

	if (obj == null) {
		return -1;
	}
    obj = func ? func.call(obj) : obj;

	for (var i = this._array.length - 1; i >= 0; i--) {
        var member = this._array[i],
            test = func ? func.call(member) : member;
		if (member === obj) {
			return i;
		}
	}
	return -1;
};

AjxVector.prototype.lastIndexOfLike = AjxVector.prototype.lastIndexOf;

/**
 * Returns the last index of the obj given w/in vector
 *
 * @param {Object}	obj			the object being looked for
 * @param {function}	keyFunc	a function for transforming objects
 * @return	{number}	the index or -1 if not found
 */
AjxVector.prototype.lastIndexOfLike =
function(obj, keyFunc) {
	var value = keyFunc.call(obj);

	for (var i = this._array.length - 1; i >= 0; i--) {
		var test = keyFunc.call(this._array[i]);
		if (test == value)
			return i;
	}
	return -1;
};

/**
 * Clones the vector.
 * 
 * @return	{AjxVector}	the new vector
 */
AjxVector.prototype.clone =
function() {
	var vec = new AjxVector();
	vec.addList(this);
	return vec;
};

/**
 * Checks if the vector contains an object.
 * 
 * @param	{Object}	obj		the object
 * @return	{boolean}	<code>true</code> if the object is found
 */
AjxVector.prototype.contains =
function(obj) {
	return AjxUtil.arrayContains(this._array, obj);
};


/**
 * Returns true if the vector contains the given object, using the given
 * function to compare objects. The comparison function should return a
 * type for which the equality test (==) is meaningful, such as a string
 * or a base type.
 *
 * @param {Object}	obj			the object being looked for
 * @param {function}	keyFunc	a function for transforming objects
 * @return	{boolean}	<code>true</code> if the object is found
 */
AjxVector.prototype.containsLike =
function(obj, keyFunc) {
	var value = keyFunc.call(obj);
	for (var i = 0; i < this._array.length; i++) {
		var test = keyFunc.call(this._array[i]);
		if (test == value)
			return true;
	}
	return false;
};

/**
 * Gets the object at a given index.
 * 
 * @param	{number}	index		the index
 * @return	{Object}	the object or <code>null</code> if not found
 */
AjxVector.prototype.get =
function(index) {
	return index >= this._array.length || index < 0
		? null : this._array[index];
};

/**
 * Gets an array of the vector.
 * 
 * @return	{array}	an array
 */
AjxVector.prototype.getArray =
function() {
	return this._array;
};

/**
 * Gets the last object in the vector.
 * 
 * @return	{Object}	the object or <code>null</code> if vector is empty
 */
AjxVector.prototype.getLast =
function() {
	return this._array.length == 0
		? null : this._array[this._array.length-1];
};

/**
 * Gets the next object in the vector after a given object.
 * 
 * @param	{Object}	obj		the object
 * @return	{Object}	the object or <code>null</code> if object not found
 */
AjxVector.prototype.getNext =
function(obj) {
	var idx = this.indexOf(obj);
	if (idx == -1)
		return null;
	return this.get(++idx);
};

/**
 * Gets the previous object in the vector before a given object.
 * 
 * @param	{Object}	obj		the object
 * @return	{Object}	the object or <code>null</code> if object not found
 */
AjxVector.prototype.getPrev =
function(obj) {
	var idx = this.indexOf(obj);
	if (idx == -1)
		return null;
	return this.get(--idx);
};

/**
 * Sorts the vector.
 * 
 * @param	{function}	sortFunc		the function
 */
AjxVector.prototype.sort =
function(sortFunc) {
	if (!sortFunc) {
		sortFunc = AjxVector._defaultArrayComparator;
	}
	this._array.sort(sortFunc);
};

/**
 * Performs a binary search.
 * 
 * @param	{Object}	valueToFind		the value
 * @param	{function}	sortFunc		the sort function
 * @return	{number}	the index
 */
AjxVector.prototype.binarySearch =
function(valueToFind, sortFunc) {
	if (!sortFunc) {
		sortFunc = AjxVector._defaultArrayComparator;
	}

	var l = 0;
	var arr = this._array;
	var u = arr.length - 1;

	while(true) {
		if (u < l) {
			return -1;
		}

		var i = Math.floor((l + u)/ 2);
		var comparisonResult = sortFunc(valueToFind, arr[i]);

		if (comparisonResult < 0) {
			u = i - 1;
		} else if (comparisonResult > 0) {
			l = i + 1;
		} else {
			return i;
		}
	}
};

AjxVector.prototype.merge =
function(offset, list) {

	if (offset < 0)
		return;

	var rawList = list instanceof AjxVector ? list.getArray() : list;

	var limit = this._array.length < (offset+rawList.length)
		? this._array.length
		: offset+rawList.length;

	if (offset < this._array.length) {
		// replace any overlapping items in vector
		var count = 0;
		for (var i=offset; i<limit; i++)
			this._array[i] = rawList[count++];

		// and append the rest
		if (count < rawList.length)
			this._array = this._array.concat(rawList.slice(count));
	} else {
		// otherwise, just append the raw list to the end
		this._array = this._array.concat(rawList);
	}
};


// Static methods

AjxVector._defaultArrayComparator =
function(a, b) {
	return a < b ? -1 : (a > b ? 1 : 0);
};

// Apply function f for each element of the array.  Optionally call it
// in the context of obj object.  If "f" is a string, then for each
// non-null array element call its "f" member function.
AjxVector.prototype.foreach = function(f, obj) {
	var l = this.size(), i = 0, el;
	if (typeof f == "function") {
		while (--l >= 0)
			f.call(obj, this.get(i), i++);
	} else {
		while (--l >= 0) {
			el = this.get(i++);
			if (el != null)
				el[f].call(el); // assuming function
		}
	}
};

/**
 * Return a new AjxVector which contains the results of calling f
 * (optionally in the context obj) for each element of this array.
 * <ul>
 * <li>If "f" is a string, then for each element el:
 * <ul>
 * <li>if el[f] is a function, call el[f] and push the result in the returned array.</li>
 * <li>otherwise push el[f]</li>
 * </ul>
 * </li>
 * </ul>
 * 
 * @param	{function}	f 	the function
 * @param	{Object}	obj		the obj context
 * @return	{AjxVector}		the resulting vector
 */
AjxVector.prototype.map = function(f, obj) {
	var a = [], i = this.size(), el;
	if (typeof f == "function") {
		while (--i >= 0)
			a[i] = f.call(obj, this.get(i), i);
	} else if (f instanceof AjxCallback) {
		while (--i >= 0)
			a[i] = f.run(this.get(i), i);
	} else {
		while (--i >= 0) {
			el = this.get(i);
			if (el != null) {
				if (typeof el[f] == "function")
					a.unshift(el[f].call(el));
				else
					a.unshift(el[f]);
			}
		}
	}
	return AjxVector.fromArray(a);
};

/**
 * Returns an AjxVector with all the members of the given array for which the
 * filtering function returns true.
 *
 * @param {Function}    func        filtering function
 * @param {Object}      context     scope for filtering function
 *
 * @returns {Array} array of members for which the filtering function returns true
 */
AjxVector.prototype.filter = function(func, context) {
	return AjxVector.fromArray(AjxUtil.filter(this._array, func, context));
};

/**
 * Joins the vector.
 * 
 * @param	{string}	sep		the string separator
 * @return	{string}	a string representation of the vector
 */
AjxVector.prototype.join = function(sep) {
	return this._array.join(sep);
};

/**
 * Return true if the given function returns true for a member of this vector,
 * otherwise false.
 *
 * @param	{function}	f 	the function
 * @param	{Object}	obj		the obj context
*/
AjxVector.prototype.some =
function(f, obj) {
	return this._array.some(f, obj);
};


/**
 * Return a new AjxVector containing the elements from this vector
 * except those for which f(el) returns true.  Otherwise said,
 * "SUBtracts" from this vector those elements for which f(el) returns true.
 *
 * @param	{function}	f 	the function
 * @param	{Object}	obj		the obj context
 * @return	{AjxVector}		the resulting vector
 */
AjxVector.prototype.sub = function(f, obj) {
	var a = [], l = this.size(), i = 0, el;
	while (--l >= 0) {
		el = this.get(i++);
		if (!f.call(obj, el, i))
			a.push(el);
	}
	return AjxVector.fromArray(a);
};

AjxVector.prototype.slice =
function(start, end) {
	return AjxVector.fromArray(this._array.slice(start, end));
};
}
if (AjxPackage.define("ajax.util.AjxStringUtil")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * Default constructor does nothing (static class).
 * @constructor
 * @class
 * This class provides static methods to perform miscellaneous string-related utility functions.
 *
 * @author Ross Dargahi
 * @author Roland Schemers
 * @author Conrad Damon
 */
AjxStringUtil = function() {};

AjxStringUtil.TRIM_RE = /^\s+|\s+$/g;
AjxStringUtil.COMPRESS_RE = /\s+/g;
AjxStringUtil.ELLIPSIS = " ... ";
AjxStringUtil.ELLIPSIS_NO_SPACE = "...";
AjxStringUtil.LIST_SEP = ", ";

AjxStringUtil.CRLF = "\r\n";
AjxStringUtil.CRLF2 = "\r\n\r\n";
AjxStringUtil.CRLF_HTML = "<br>";
AjxStringUtil.CRLF2_HTML = "<div><br></div><div><br></div>";

//Regex for image tag having src starting with cid:
AjxStringUtil.IMG_SRC_CID_REGEX = /<img([^>]*)\ssrc=["']cid:/gi;

AjxStringUtil.makeString =
function(val) {
	return val ? String(val) : "";
};

/**
 * Capitalizes the specified string by upper-casing the first character
 * and lower-casing the rest of the string.
 *
 * @param {string} str  The string to capitalize.
 */
AjxStringUtil.capitalize = function(str) {
	return str && str.length > 0 ? str.charAt(0).toUpperCase() + str.substr(1).toLowerCase() : "";
};

/**
 * Capitalizes the specified string by upper-casing the first character.
 * Unlike AjxStringUtil.capitalize - don't change the rest of the letters.
 *
 * @param {string} str  The string to capitalize.
 */
AjxStringUtil.capitalizeFirstLetter = function(str) {
	return str && str.length > 0 ? str.charAt(0).toUpperCase() + str.substr(1) : "";
};


/**
 * Capitalizes all the words in the specified string by upper-casing the first
 * character of each word (does not change following characters, so something like MTV stays MTV
 *
 * @param {string} str  The string to capitalize.
 */
AjxStringUtil.capitalizeWords = function(str) {
    return str ? AjxUtil.map(str.split(/\s+/g), AjxStringUtil.capitalizeFirstLetter).join(" ") : "";
};

/**
 * Converts the given text to mixed-case. The input text is one or more words
 * separated by spaces. The output is a single word in mixed (or camel) case.
 * 
 * @param {string}	text		text to convert
 * @param {string|RegEx}	sep		text separator (defaults to any space)
 * @param {boolean}	camel		if <code>true</code>, first character of result is lower-case
 * @return	{string}	the resulting string
 */
AjxStringUtil.toMixed =
function(text, sep, camel) {
	if (!text || (typeof text != "string")) { return ""; }
	sep = sep || /\s+/;
	var wds = text.split(sep);
	var newText = [];
	newText.push(camel ? wds[0].toLowerCase() : wds[0].substring(0, 1).toUpperCase() + wds[0].substring(1).toLowerCase());
	for (var i = 1; i < wds.length; i++) {
		newText.push(wds[i].substring(0, 1).toUpperCase() + wds[i].substring(1).toLowerCase());
	}
	return newText.join("");
};

/**
 * Converts the given mixed-case text to a string of one or more words
 * separated by spaces.
 *
 * @param {string} text The mixed-case text.
 * @param {string} sep  (Optional) The separator between words. Default
 *                      is a single space.
 */
AjxStringUtil.fromMixed = function(text, sep) {
    sep = ["$1", sep || " ", "$2"].join("");
    return AjxStringUtil.trim(text.replace(/([a-z])([A-Z]+)/g, sep));
};

/**
 * Removes white space from the beginning and end of a string, optionally compressing internal white space. By default, white
 * space is defined as a sequence of  Unicode whitespace characters (\s in regexes). Optionally, the user can define what
 * white space is by passing it as an argument.
 *
 * <p>TODO: add left/right options</p>
 *
 * @param {string}	str      	the string to trim
 * @param {boolean}	compress 	whether to compress internal white space to one space
 * @param {string}	space    	a string that represents a user definition of white space
 * @return	{string}	a trimmed string
 */
AjxStringUtil.trim =
function(str, compress, space) {

	if (!str) {return "";}

	var trim_re = AjxStringUtil.TRIM_RE;

	var compress_re = AjxStringUtil.COMPRESS_RE;
	if (space) {
		trim_re = new RegExp("^" + space + "+|" + space + "+$", "g");
		compress_re = new RegExp(space + "+", "g");
	} else {
		space = " ";
	}
	str = str.replace(trim_re, '');
	if (compress) {
		str = str.replace(compress_re, space);
	}

	return str;
};

/**
 * Returns the string repeated the given number of times.
 *
 * @param {string}	str		a string
 * @param {number}	num		number of times to repeat the string
 * @return	{string}	the string
 */
AjxStringUtil.repeat =
function(str, num) {
	var text = "";
	for (var i = 0; i < num; i++) {
		text += str;
	}
	return text;
};

/**
 * Gets the units from size string.
 * 
 * @param	{string}	sizeString	the size string
 * @return	{string}	the units
 */
AjxStringUtil.getUnitsFromSizeString =
function(sizeString) {
	var units = "px";
	if (typeof(sizeString) == "string") {
		var digitString = Number(parseInt(sizeString,10)).toString();
		if (sizeString.length > digitString.length) {
			units = sizeString.substr(digitString.length, (sizeString.length-digitString.length));
			if (!(units=="em" || units=="ex" || units=="px" || units=="in" || units=="cm" == units=="mm" || units=="pt" || units=="pc" || units=="%")) {
				units = "px";
			}
		}
	}
	return units;
};

/**
* Splits a string, ignoring delimiters that are in quotes or parentheses. Comma
* is the default split character, but the user can pass in a string of multiple
* delimiters. It can handle nested parentheses, but not nested quotes.
*
* <p>TODO: handle escaped quotes</p>
*
* @param {string} str	the string to split
* @param {string}	[dels]	an optional string of delimiter characters
* @return	{array}	an array of strings
*/
AjxStringUtil.split =
function(str, dels) {

	if (!str) {return [];}
	var i = 0;
	dels = dels ? dels : ',';
	var isDel = new Object();
	if (typeof dels == 'string') {
		isDel[dels] = 1;
	} else {
		for (i = 0; i < dels.length; i++) {
			isDel[dels[i]] = 1;
		}
	}

	var q = false;
	var p = 0;
	var start = 0;
	var chunk;
	var chunks = [];
	var j = 0;
	for (i = 0; i < str.length; i++) {
		var c = str.charAt(i);
		if (c == '"') {
			q = !q;
		} else if (c == '(') {
			p++;
		} else if (c == ')') {
			p--;
		} else if (isDel[c]) {
			if (!q && !p) {
				chunk = str.substring(start, i);
				chunks[j++] = chunk;
				start = i + 1;
			}
		}
	}
	chunk = str.substring(start, str.length);
	chunks[j++] = chunk;

	return chunks;
};

AjxStringUtil.SPACE_WORD_RE = new RegExp("\\s*\\S+", "g");
/**
 * Splits the line into words, keeping leading whitespace with each word.
 *
 * @param {string}	line	the text to split
 *
 * @return {array} the array of words
 */
AjxStringUtil.splitKeepLeadingWhitespace =
function(line) {
	var words = [], result;
	while (result = AjxStringUtil.SPACE_WORD_RE.exec(line)) {
		words.push(result[0]);
	}
	return words;
};

AjxStringUtil.WRAP_LENGTH				= 80;
AjxStringUtil.HDR_WRAP_LENGTH			= 120;
AjxStringUtil.MAX_HTMLNODE_COUNT		= 250;

// ID for a BLOCKQUOTE to mark it as ours
AjxStringUtil.HTML_QUOTE_COLOR			= "#1010FF";
AjxStringUtil.HTML_QUOTE_STYLE			= "color:#000;font-weight:normal;font-style:normal;text-decoration:none;font-family:Helvetica,Arial,sans-serif;font-size:12pt;";
AjxStringUtil.HTML_QUOTE_PREFIX_PRE		= '<blockquote style="border-left:2px solid ' +
									 AjxStringUtil.HTML_QUOTE_COLOR +
									 ';margin-left:5px;padding-left:5px;'+
									 AjxStringUtil.HTML_QUOTE_STYLE +
									 '">';
AjxStringUtil.HTML_QUOTE_PREFIX_POST	= '</blockquote>';
AjxStringUtil.HTML_QUOTE_NONPREFIX_PRE	= '<div style="' +
									 AjxStringUtil.HTML_QUOTE_STYLE +
									 '">';
AjxStringUtil.HTML_QUOTE_NONPREFIX_POST	= '</div><br/>';

/**
 * Wraps text to the given length and optionally quotes it. The level of quoting in the
 * source text is preserved based on the prefixes. Special lines such as email headers
 * always start a new line.
 *
 * @param {hash}	params	a hash of parameters
 * @param {string}      text 				the text to be wrapped
 * @param {number}      len					the desired line length of the wrapped text, defaults to 80
 * @param {string}      prefix				an optional string to prepend to each line (useful for quoting)
 * @param {string}      before				text to prepend to final result
 * @param {string}      after				text to append to final result
 * @param {boolean}		preserveReturns		if true, don't combine small lines
 * @param {boolean}		isHeaders			if true, we are wrapping a block of email headers
 * @param {boolean}		isFlowed			format text for display as flowed (RFC 3676)
 * @param {boolean}		htmlMode			if true, surround the content with the before and after
 *
 * @return	{string}	the wrapped/quoted text
 */
AjxStringUtil.wordWrap =
function(params) {

	if (!(params && params.text)) { return ""; }

	var text = params.text;
	var before = params.before || "";
	var after = params.after || "";
	var isFlowed = params.isFlowed;

	// For HTML, just surround the content with the before and after, which is
	// typically a block-level element that puts a border on the left
	if (params.htmlMode) {
		before = params.before || (params.prefix ? AjxStringUtil.HTML_QUOTE_PREFIX_PRE : AjxStringUtil.HTML_QUOTE_NONPREFIX_PRE);
		after = params.after || (params.prefix ? AjxStringUtil.HTML_QUOTE_PREFIX_POST : AjxStringUtil.HTML_QUOTE_NONPREFIX_POST);
		return [before, text, after].join("");
	}

	var max = params.len || (params.isHeaders ? AjxStringUtil.HDR_WRAP_LENGTH : AjxStringUtil.WRAP_LENGTH);
	var prefixChar = params.prefix || "";
	var eol = "\n";

	var lines = text.split(AjxStringUtil.SPLIT_RE);
	var words = [];

	// Divides lines into words. Each word is part of a hash that also has
	// the word's prefix, whether it's a paragraph break, and whether it
	// needs to be preserved at the start or end of a line.
	for (var l = 0, llen = lines.length; l < llen; l++) {
		var line = lines[l];
		// get this line's prefix
		var m = line.match(/^([\s>\|]+)/);
		var prefix = m ? m[1] : "";
		if (prefix) {
			line = line.substr(prefix.length);
		}
		if (AjxStringUtil._NON_WHITESPACE.test(line)) {
			var wds = AjxStringUtil.splitKeepLeadingWhitespace(line);
			if (wds && wds[0] && wds[0].length) {
				var mustStart = AjxStringUtil.MSG_SEP_RE.test(line) || AjxStringUtil.COLON_RE.test(line) ||
								AjxStringUtil.HDR_RE.test(line) || params.isHeaders || AjxStringUtil.SIG_RE.test(line);
				var mustEnd = params.preserveReturns;
				if (isFlowed) {
					var m = line.match(/( +)$/);
					if (m) {
						wds[wds.length - 1] += m[1];	// preserve trailing space at end of line
						mustEnd = false;
					}
					else {
						mustEnd = true;
					}
				}
				for (var w = 0, wlen = wds.length; w < wlen; w++) {
					words.push({
						w:			wds[w],
						prefix:		prefix,
						mustStart:	(w === 0) && mustStart,
						mustEnd:	(w === wlen - 1) && mustEnd
					});
				}
			}
		} else {
			// paragraph marker
			words.push({
				para:	true,
				prefix:	prefix
			});
		}
	}

	// Take the array of words and put them back together. We break for a new line
	// when we hit the max line length, change prefixes, or hit a word that must start a new line.
	var result = "", curLen = 0, wds = [], curPrefix = null;
	for (var i = 0, len = words.length; i < len; i++) {
		var word = words[i];
		var w = word.w, prefix = word.prefix;
		var addPrefix = !prefixChar ? "" : curPrefix ? prefixChar : prefixChar + " ";
		var pl = (curPrefix === null) ? 0 : curPrefix.length;
		pl = 0;
		var newPrefix = addPrefix + (curPrefix || "");
		if (word.para) {
			// paragraph break - output what we have, then add a blank line
			if (wds.length) {
				result += newPrefix + wds.join("").replace(/^ +/, "") + eol;
			}
			if (i < words.length - 1) {
				curPrefix = prefix;
				addPrefix = !prefixChar ? "" : curPrefix ? prefixChar : prefixChar + " ";
				newPrefix = addPrefix + (curPrefix || "");
				result += newPrefix + eol;
			}
			wds = [];
			curLen = 0;
			curPrefix = null;
		} else if ((pl + curLen + w.length <= max) && (prefix === curPrefix || curPrefix === null) && !word.mustStart) {
			// still room left on the current line, add the word
			wds.push(w);
			curLen += w.length;
			curPrefix = prefix;
			if (word.mustEnd && words[i + 1]) {
				words[i + 1].mustStart = true;
			}
		} else {
			// no more room - output what we have and start a new line
			if (wds.length) {
				result += newPrefix + wds.join("").replace(/^ +/, "") + eol;
			}
			wds = [w];
			curLen = w.length;
			curPrefix = prefix;
			if (word.mustEnd && words[i + 1]) {
				words[i + 1].mustStart = true;
			}
		}
	}

	// handle last line
	if (wds.length) {
		var addPrefix = !prefixChar ? "" : wds[0].prefix ? prefixChar : prefixChar + " ";
		var newPrefix = addPrefix + (curPrefix || "");
		result += newPrefix + wds.join("").replace(/^ /, "") + eol;
	}

	return [before, result, after].join("");
};

/**
 * Quotes text with the given quote character. For HTML, surrounds the text with the
 * given strings. Does no wrapping.
 *
 * @param {hash}	params	a hash of parameters
 * @param {string}      params.text 				the text to be wrapped
 * @param {string}      [params.pre]				prefix for quoting
 * @param {string}      [params.before]				text to prepend to final result
 * @param {string}      [params.after]				text to append to final result
 *
 * @return	{string}	the quoted text
 */
AjxStringUtil.quoteText =
function(params) {

	if (!(params && params.text)) { return ""; }

	var text = params.text;
	var before = params.before || "", after = params.after || "";

	// For HTML, just surround the content with the before and after, which is
	// typically a block-level element that puts a border on the left
	if (params.htmlMode || !params.pre) {
		return [before, text, after].join("");
	}

	var len = params.len || 80;
	var pre = params.pre || "";
	var eol = "\n";

	text = AjxStringUtil.trim(text);
	text = text.replace(/\n\r/g, eol);
	var lines = text.split(eol);
	var result = [];

	for (var l = 0, llen = lines.length; l < llen; l++) {
		var line = AjxStringUtil.trim(lines[l]);
		result.push(pre + line + eol);
	}

	return before + result.join("") + after;
};

AjxStringUtil.SHIFT_CHAR = { 48:')', 49:'!', 50:'@', 51:'#', 52:'$', 53:'%', 54:'^', 55:'&', 56:'*', 57:'(',
							59:':', 186:':', 187:'+', 188:'<', 189:'_', 190:'>', 191:'?', 192:'~',
							219:'{', 220:'|', 221:'}', 222:'"' };

/**
* Returns the character for the given key, taking the shift key into consideration.
*
* @param {number}	keycode	a numeric keycode (not a character code)
* @param {boolean}	shifted		whether the shift key is down
* @return	{char}	a character
*/
AjxStringUtil.shiftChar =
function(keycode, shifted) {
	return shifted ? AjxStringUtil.SHIFT_CHAR[keycode] || String.fromCharCode(keycode) : String.fromCharCode(keycode);
};

/**
 * Does a diff between two strings, returning the index of the first differing character.
 *
 * @param {string}	str1	a string
 * @param {string}	str2	another string
 * @return	{number}	the index at which they first differ
 */
AjxStringUtil.diffPoint =
function(str1, str2) {
	if (!(str1 && str2)) {
		return 0;
	}
	var len = Math.min(str1.length, str2.length);
	var i = 0;
	while (i < len && (str1.charAt(i) == str2.charAt(i))) {
		i++;
	}
	return i;
};

/*
* DEPRECATED
*
* Replaces variables in a string with values from a list. The variables are
* denoted by a '$' followed by a number, starting from 0. For example, a string
* of "Hello $0, meet $1" with a list of ["Harry", "Sally"] would result in the
* string "Hello Harry, meet Sally".
*
* @param str		the string to resolve
* @param values	 	an array of values to interpolate
* @returns			a string with the variables replaced
* 
* @deprecated
*/
AjxStringUtil.resolve =
function(str, values) {
	DBG.println(AjxDebug.DBG1, "Call to deprecated function AjxStringUtil.resolve");
	return AjxMessageFormat.format(str, values);
};

/**
 * Encodes a complete URL. Leaves delimiters alone.
 *
 * @param {string}	str	the string to encode
 * @return	{string}	the encoded string
 */
AjxStringUtil.urlEncode =
function(str) {
	if (!str) return "";
	var func = window.encodeURL || window.encodeURI;
	return func(str);
};

/**
 * Encodes a string as if it were a <em>part</em> of a URL. The
 * difference between this function and {@link AjxStringUtil.urlEncode}
 * is that this will also encode the following delimiters:
 *
 * <pre>
 *  			: / ? & =
 * </pre>
 * 
 * @param	{string}	str		the string to encode
 * @return	{string}	the resulting string
 */
AjxStringUtil.urlComponentEncode =
function(str) {
	if (!str) return "";
	var func = window.encodeURLComponent || window.encodeURIComponent;
	return func(str);
};

/**
 * Decodes a complete URL.
 *
 * @param {string}	str	the string to decode
 * @return	{string}	the decoded string
 */
AjxStringUtil.urlDecode =
function(str) {
	if (!str) return "";
	var func = window.decodeURL || window.decodeURI;
	try {
		return func(str);
	}
	catch(e) {
		return "";
	}
};

/**
 * Decodes a string as if it were a <em>part</em> of a URL. Falls back
 * to unescape() if necessary.
 * 
 * @param	{string}	str		the string to decode
 * @return	{string}	the decoded string
 */
AjxStringUtil.urlComponentDecode =
function(str) {
	if (!str) return "";
	var func = window.decodeURLComponent || window.decodeURIComponent;
	var result;
	try {
		result = func(str);
	} catch(e) {
		result = unescape(str);
	}

	return result || str;
};

AjxStringUtil.ENCODE_MAP = { '>' : '&gt;', '<' : '&lt;', '&' : '&amp;' };

/**
 * HTML-encodes a string.
 *
 * @param {string}	str	the string to encode
 * @param	{boolean}	includeSpaces		if <code>true</code>, to include encoding spaces
 * @return	{string}	the encoded string
 */
AjxStringUtil.htmlEncode =
function(str, includeSpaces) {

	if (!str) {return "";}
	if (typeof(str) != "string") {
		str = str.toString ? str.toString() : "";
	}

	if (!AjxEnv.isSafari || AjxEnv.isSafariNightly) {
		if (includeSpaces) {
			return str.replace(/[<>&]/g, function(htmlChar) { return AjxStringUtil.ENCODE_MAP[htmlChar]; }).replace(/  /g, ' &nbsp;');
		} else {
			return str.replace(/[<>&]/g, function(htmlChar) { return AjxStringUtil.ENCODE_MAP[htmlChar]; });
		}
	} else {
		if (includeSpaces) {
			return str.replace(/[&]/g, '&amp;').replace(/  /g, ' &nbsp;').replace(/[<]/g, '&lt;').replace(/[>]/g, '&gt;');
		} else {
			return str.replace(/[&]/g, '&amp;').replace(/[<]/g, '&lt;').replace(/[>]/g, '&gt;');
		}
	}
};

/**
 * encode quotes for using in inline JS code, so the text does not end a quoted param prematurely.
 * @param str
 */
AjxStringUtil.encodeQuotes =
function(str) {
	return str.replace(/"/g, '&quot;').replace(/'/g, "&#39;");
};


/**
 * Decodes the string.
 * 
 * @param	{string}	str		the string to decode
 * @param	{boolean}	decodeSpaces	if <code>true</code>, decode spaces
 * @return	{string}	the string
 */
AjxStringUtil.htmlDecode =
function(str, decodeSpaces) {
	 
	 if(decodeSpaces)
	 	str = str.replace(/&nbsp;/g," ");
	 	
     return str.replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
};

AjxStringUtil.__jsEscapeChar = function(c) {
	var codestr = c.charCodeAt(0).toString(16);

	if (codestr.length == 1)
		return '\\u000' + codestr;
	else if (codestr.length == 2)
		return '\\u00' + codestr;
	else if (codestr.length == 3)
		return '\\u0' + codestr;
	else if (codestr.length == 4)
		return '\\u' + codestr;

	// shouldn't happen -- ECMAscript proscribes that strings are
	// UTF-16 internally
	DBG.println(AjxDebug.NONE, "unexpected condition in " +
	            "AjxStringUtil.__jsEscapeChar -- code point 0x" +
	            codestr + " doesn't fit in 16 bits");
};

/**
 * Encodes non-ASCII and non-printable characters as \uXXXX, suitable
 * for JSON.
 *
 * @param	{string}	str		the string
 * @return	{string}	the encoded string
 */
AjxStringUtil.jsEncode =
function(str) {
	return str.replace(/[^\u0020-\u007e]/g,
	                   AjxStringUtil.__jsEscapeChar);
};

/**
 * Removes HTML tags from the given string.
 * 
 * @param {string}	str			text from which to strip tags
 * @param {boolean}	removeContent	if <code>true</code>, also remove content within tags
 * @return	{string}	the resulting HTML string
 */
AjxStringUtil.stripTags =
function(str, removeContent) {
	if (typeof str !== 'string') {
		return "";
	}
	if (removeContent) {
		str = str.replace(/(<(\w+)[^>]*>).*(<\/\2[^>]*>)/, "$1$3");
	}
	return str.replace(/<\/?[^>]+>/gi, '');
};

/**
 * Converts the string to HTML.
 * 
 * @param	{string}	str		the string
 * @return	{string}	the resulting string
 */
AjxStringUtil.convertToHtml =
function(str, quotePrefix, openTag, closeTag) {

	openTag = openTag || "<blockquote>";
	closeTag = closeTag || "</blockquote>";
	
	if (!str) {return "";}

	str = AjxStringUtil.htmlEncode(str);
	if (quotePrefix) {
		// Convert a section of lines prefixed with > or |
		// to a section encapsuled in <blockquote> tags
		var prefix_re = /^(>|&gt;|\|\s+)/;
		var lines = str.split(/\r?\n/);
		var level = 0;
		for (var i = 0; i < lines.length; i++) {
			var line = lines[i];
			if (line.length > 0) {
				var lineLevel = 0;
				// Remove prefixes while counting how many there are on the line
				while (line.match(prefix_re)) {
					line = line.replace(prefix_re, "");
					lineLevel++;
				}
				// If the lineLevel has changed since the last line, add blockquote start or end tags, and adjust level accordingly
				while (lineLevel > level) {
					line = openTag + line;
					level++;
				}
				while (lineLevel < level) {
					lines[i - 1] = lines[i - 1] + closeTag;
					level--;
				}
			}
			lines[i] = line;
		}
		while (level > 0) {
			lines.push(closeTag);
			level--;
		}

		str = lines.join("\n");
	}

	str = str
		.replace(/  /mg, ' &nbsp;')
		.replace(/^ /mg, '&nbsp;')
		.replace(/\t/mg, "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;")
		.replace(/\r?\n/mg, "<br>");
	return str;
};

AjxStringUtil.SPACE_ENCODE_MAP = { ' ' : '&nbsp;', '>' : '&gt;', '<' : '&lt;', '&' : '&amp;' , '\n': '<br>'};

/**
 * HTML-encodes a string.
 *
 * @param {string}	str	the string to encode
 * 
 * @private
 */
AjxStringUtil.htmlEncodeSpace =
function(str) {
	if (!str) { return ""; }
	return str.replace(/[&]/g, '&amp;').replace(/ /g, '&nbsp;').replace(/[<]/g, '&lt;').replace(/[>]/g, '&gt;');
};

/**
 * Encode
 * @param base {string} Ruby base.
 * @param text {string} Ruby text (aka furigana).
 */
AjxStringUtil.htmlRubyEncode = function(base, text) {
    if (base && text) {
        return [
            "<ruby>",
                "<rb>",AjxStringUtil.htmlEncode(base),"</rb> ",
                "<rp>(</rp><rt>",AjxStringUtil.htmlEncode(text),"</rt><rp>)</rp>",
            "</ruby>"
        ].join("");
    }
    return AjxStringUtil.htmlEncode(base || text || "");
};

// this function makes sure a leading space is preservered, takes care of tabs,
// then finally takes replaces newlines with <br>'s
AjxStringUtil.nl2br =
function(str) {
	if (!str) return "";
	return str.replace(/^ /mg, "&nbsp;").
		// replace(/\t/g, "<pre style='display:inline;'>\t</pre>").
		// replace(/\t/mg, "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;").
		replace(/\t/mg, "<span style='white-space:pre'>\t</span>").
		replace(/\n/g, "<br>");
};

AjxStringUtil.xmlEncode =
function(str) {
	if (str) {
		// bug fix #8779 - safari barfs if "str" is not a String type
		str = "" + str;
		return str.replace(/&/g,"&amp;").replace(/</g,"&lt;");
	}
	return "";
};

AjxStringUtil.xmlDecode =
function(str) {
	return str ? str.replace(/&amp;/g,"&").replace(/&lt;/g,"<") : "";
};

AjxStringUtil.xmlAttrEncode =
function(str) {
	return str ? str.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\x22/g, '&quot;').replace(/\x27/g,"&apos;") : "";
};

AjxStringUtil.xmlAttrDecode =
function(str) {
	return str ? str.replace(/&amp;/g,"&").replace(/&lt;/g,"<").replace(/&quot;/g, '"').replace(/&apos;/g,"'") : "";
};

AjxStringUtil.__RE_META = { " ":" ", "\n":"\\n", "\r":"\\r", "\t":"\\t" };
AjxStringUtil.__reMetaEscape = function($0, $1) {
	return AjxStringUtil.__RE_META[$1] || "\\"+$1;
};
AjxStringUtil.regExEscape =
function(str) {
	return str.replace(/(\W)/g, AjxStringUtil.__reMetaEscape);
};

AjxStringUtil._calcDIV = null; // used by 'clip()' and 'wrap()' functions

AjxStringUtil.calcDIV =
function() {
	if (AjxStringUtil._calcDIV == null) {
		AjxStringUtil._calcDIV = document.createElement("div");
		AjxStringUtil._calcDIV.style.zIndex = 0;
		AjxStringUtil._calcDIV.style.position = DwtControl.ABSOLUTE_STYLE;
		AjxStringUtil._calcDIV.style.visibility = "hidden";
		document.body.appendChild(AjxStringUtil._calcDIV);
	}
	return AjxStringUtil._calcDIV;
};

/**
 * Clips a string at "pixelWidth" using using "className" on hidden 'AjxStringUtil._calcDIV'.
 * Returns "origString" with "..." appended if clipped.
 *
 * NOTE: The same CSS style ("className") must be assigned to both the intended
 * display area and the hidden 'AjxStringUtil._calcDIV'.  "className" is
 * optional; if supplied, it will be assigned to 'AjxStringUtil._calcDIV' to
 * handle different CSS styles ("className"s) on same page.
 *
 * NOTE2: MSIE Benchmark - clipping an average of 17 characters each over 190
 * iterations averaged 27ms each (5.1 seconds total for 190)
 * 
 * @private
 */
AjxStringUtil.clip =
function(origString, pixelWidth, className) {
	var calcDIV = AjxStringUtil.calcDIV();
	if (arguments.length == 3) calcDIV.className = className;
	//calcDIV.innerHTML = "<div>" + origString + "</div>"; // prevents screen flash in IE?
	calcDIV.innerHTML = origString;
	if (calcDIV.offsetWidth <= pixelWidth) return origString;

	for (var i=origString.length-1; i>0; i--) {
		var newString = origString.substr(0,i);
		calcDIV.innerHTML = newString + AjxStringUtil.ELLIPSIS;
		if (calcDIV.offsetWidth <= pixelWidth) return newString + AjxStringUtil.ELLIPSIS;
	}
	return origString;
};

AjxStringUtil.clipByLength =
function(str,clipLen) {
	var len = str.length;
	return (len <= clipLen)
		?  str
		: [str.substr(0,clipLen/2), '...', str.substring(len - ((clipLen/2) - 3),len)].join("");
};

/**
 * Forces a string to wrap at "pixelWidth" using "className" on hidden 'AjxStringUtil._calcDIV'.
 * Returns "origString" with "&lt;br&gt;" tags inserted to force wrapping.
 * Breaks string on embedded space characters, EOL ("/n") and "&lt;br&gt;" tags when possible.
 *
 * @returns		"origString" with "&lt;br&gt;" tags inserted to force wrapping.
 * 
 * @private
 */
AjxStringUtil.wrap =
function(origString, pixelWidth, className) {
	var calcDIV = AjxStringUtil.calcDIV();
	if (arguments.length == 3) calcDIV.className = className;

	var newString = "";
	var newLine = "";
	var textRows = origString.split("/n");
	for (var trCount = 0; trCount < textRows.length; trCount++) {
		if (trCount != 0) {
			newString += newLine + "<br>";
			newLine = "";
		}
		htmlRows = textRows[trCount].split("<br>");
		for (var hrCount=0; hrCount<htmlRows.length; hrCount++) {
			if (hrCount != 0) {
				newString += newLine + "<br>";
				newLine = "";
			}
			words = htmlRows[hrCount].split(" ");
			var wCount=0;
			while (wCount<words.length) {
				calcDIV.innerHTML = newLine + " " + words[wCount];
				var newLinePixels = calcDIV.offsetWidth;
				if (newLinePixels > pixelWidth) {
					// whole "words[wCount]" won't fit on current "newLine" - insert line break, avoid incrementing "wCount"
					calcDIV.innerHTML = words[wCount];
					newLinePixels = newLinePixels - calcDIV.offsetWidth;
					if ( (newLinePixels >= pixelWidth) || (calcDIV.offsetWidth <= pixelWidth) ) {
						// either a) excess caused by <space> character or b) will fit completely on next line
						// so just break without incrementing "wCount" and append next time
						newString += newLine + "<br>";
						newLine = "";
					}
					else { // must break "words[wCount]"
						var keepLooping = true;
						var atPos = 0;
						while (keepLooping) {
							atPos++;
							calcDIV.innerHTML = newLine + " " + words[wCount].substring(0,atPos);
							keepLooping = (calcDIV.offsetWidth <= pixelWidth);
						}
						atPos--;
						newString += newLine + words[wCount].substring(0,atPos) + "<br>";
						words[wCount] = words[wCount].substr(atPos);
						newLine = "";
					}
				} else { // doesn't exceed pixelWidth, append to "newLine" and increment "wCount"
					newLine += " " + words[wCount];
					wCount++;
				}
			}
		}
	}
	newString += newLine;
	return newString;
};

// Regexes for finding stuff in msg content
AjxStringUtil.MSG_SEP_RE = new RegExp("^\\s*--+\\s*(" + AjxMsg.origMsg + "|" + AjxMsg.forwardedMessage + ")\\s*--+", "i");
AjxStringUtil.SIG_RE = /^(- ?-+)|(__+)\r?$/;
AjxStringUtil.SPLIT_RE = /\r\n|\r|\n/;
AjxStringUtil.HDR_RE = /^\s*\w+:/;
AjxStringUtil.COLON_RE = /\S+:$/;

// Converts a HTML document represented by a DOM tree to text
// XXX: There has got to be a better way of doing this!
AjxStringUtil._NO_LIST = 0;
AjxStringUtil._ORDERED_LIST = 1;
AjxStringUtil._UNORDERED_LIST = 2;
AjxStringUtil._INDENT = "    ";
AjxStringUtil._NON_WHITESPACE = /\S+/;
AjxStringUtil._LF = /\n/;

AjxStringUtil.convertHtml2Text =
function(domRoot, convertor, onlyOneNewLinePerP) {

	if (!domRoot) { return ""; }

	if (convertor && AjxUtil.isFunction(convertor._before)) {
		domRoot = convertor._before(domRoot);
	}

	if (typeof domRoot == "string") {
		var domNode = document.createElement("SPAN");
		domNode.innerHTML = domRoot;
		domRoot = domNode;
	}
	var text = [];
	var idx = 0;
	var ctxt = {};
	AjxStringUtil._traverse(domRoot, text, idx, AjxStringUtil._NO_LIST, 0, 0, ctxt, convertor, onlyOneNewLinePerP);

	var result = text.join("");

	if (convertor && AjxUtil.isFunction(convertor._after)) {
		result = convertor._after(result);
	}

	return result;
};

AjxStringUtil._traverse =
function(el, text, idx, listType, listLevel, bulletNum, ctxt, convertor, onlyOneNewLinePerP) {

	var nodeName = el.nodeName.toLowerCase();

	var result = null;
	if (convertor && convertor[nodeName]) {
		result = convertor[nodeName](el, ctxt);
	}

	if (result != null) {
		text[idx++] = result;
	} else if (nodeName == "#text") {
		if (el.nodeValue.search(AjxStringUtil._NON_WHITESPACE) != -1) {
			if (ctxt.lastNode == "ol" || ctxt.lastNode == "ul") {
				text[idx++] = "\n";
			}
			if (ctxt.isPreformatted) {
				text[idx++] = AjxStringUtil.trim(el.nodeValue) + " ";
			} else {
				text[idx++] = AjxStringUtil.trim(el.nodeValue.replace(AjxStringUtil._LF, " "), true) + " ";
			}
		}
	} else if (nodeName == "p") {
		text[idx++] = onlyOneNewLinePerP ? "\n" : "\n\n";
	} else if (nodeName === "a") {
		if (el.href) {
			//format as [ href | text ] (if no text, format as [ href ]
			text[idx++] = "[ ";
			text[idx++] = el.href;
			if (el.textContent) {
				text[idx++] = " | ";
				text[idx++] = el.textContent;
			}
			text[idx++] = " ] ";
			return idx; // returning since we take care of all the child nodes via the "textContent" above. No need to parse further.
		}
	} else if (listType == AjxStringUtil._NO_LIST && (nodeName == "br" || nodeName == "hr")) {
		text[idx++] = "\n";
	} else if (nodeName == "ol" || nodeName == "ul") {
		text[idx++] = "\n";
		if (el.parentNode.nodeName.toLowerCase() != "li" && ctxt.lastNode != "br" && ctxt.lastNode != "hr") {
			text[idx++] = "\n";
		}
		listType = (nodeName == "ol") ? AjxStringUtil._ORDERED_LIST : AjxStringUtil._UNORDERED_LIST;
		listLevel++;
		bulletNum = 0;
	} else if (nodeName == "li") {
		for (var i = 0; i < listLevel; i++) {
			text[idx++] = AjxStringUtil._INDENT;
		}
		if (listType == AjxStringUtil._ORDERED_LIST) {
			text[idx++] = bulletNum + ". ";
		} else {
			text[idx++] = "\u002A "; // TODO AjxMsg.bullet
		}
	} else if (nodeName == "tr" && el.parentNode.firstChild != el) {
		text[idx++] = "\n";
	} else if (nodeName == "td" && el.parentNode.firstChild != el) {
		text[idx++] = "\t";
	} else if (nodeName == "div" || nodeName == "address") {
        if (idx && text[idx - 1] !== "\n") {
            text[idx++] = "\n";
        }
	} else if (nodeName == "blockquote") {
		text[idx++] = "\n\n";
	} else if (nodeName == "pre") {
        if (idx && text[idx - 1] !== "\n") {
            text[idx++] = "\n";
        }
		ctxt.isPreformatted = true;
	} else if (nodeName == "#comment" ||
			   nodeName == "script" ||
			   nodeName == "select" ||
			   nodeName == "style") {
		return idx;
	}

	var childNodes = el.childNodes;
	var len = childNodes.length;
	for (var i = 0; i < len; i++) {
		var tmp = childNodes[i];
		if (tmp.nodeType == 1 && tmp.tagName.toLowerCase() == "li") {
			bulletNum++;
		}
		idx = AjxStringUtil._traverse(tmp, text, idx, listType, listLevel, bulletNum, ctxt, convertor, onlyOneNewLinePerP);
	}

	if (convertor && convertor["/"+nodeName]) {
		text[idx++] = convertor["/"+nodeName](el);
	}

	if (nodeName == "h1" || nodeName == "h2" || nodeName == "h3" || nodeName == "h4"
		|| nodeName == "h5" || nodeName == "h6" || nodeName == "div" || nodeName == "address") {
        if (idx && text[idx - 1] !== "\n") {
            text[idx++] = "\n";
        }
			ctxt.list = false;
	} else if (nodeName == "pre") {
        if (idx && text[idx - 1] !== "\n") {
            text[idx++] = "\n";
        }
		ctxt.isPreformatted = false;
	} else if (nodeName == "li") {
		if (!ctxt.list) {
			text[idx++] = "\n";
		}
		ctxt.list = false;
	} else if (nodeName == "ol" || nodeName == "ul") {
		ctxt.list = true;
	} else if (nodeName != "#text") {
		ctxt.list = false;
	}

	ctxt.lastNode = nodeName;
	return idx;
};

/**
 * Sets the given name/value pairs into the given query string. Args that appear
 * in both will get the new value. The order of args in the returned query string
 * is indeterminate.
 *
 * @param args		[hash]		name/value pairs to add to query string
 * @param qsReset	[boolean]	if true, start with empty query string
 * 
 * @private
 */
AjxStringUtil.queryStringSet =
function(args, qsReset) {
	var qs = qsReset ? "" : location.search;
	if (qs.indexOf("?") == 0) {
		qs = qs.substr(1);
	}
	var qsArgs = qs.split("&");
	var newArgs = {};
	for (var i = 0; i < qsArgs.length; i++) {
		var f = qsArgs[i].split("=");
		newArgs[f[0]] = f[1];
	}
	for (var name in args) {
		newArgs[name] = args[name];
	}
	var pairs = [];
	var i = 0;
	for (var name in newArgs) {
		if (name) {
			pairs[i++] = [name, newArgs[name]].join("=");
		}
	}

	return "?" + pairs.join("&");
};

/**
 * Removes the given arg from the query string.
 *
 * @param {String}	qs	a query string
 * @param {String}	name	the arg name
 * 
 * @return	{String}	the resulting query string
 */
AjxStringUtil.queryStringRemove =
function(qs, name) {
	qs = qs ? qs : "";
	if (qs.indexOf("?") == 0) {
		qs = qs.substr(1);
	}
	var pairs = qs.split("&");
	var pairs1 = [];
	for (var i = 0; i < pairs.length; i++) {
		if (pairs[i].indexOf(name) != 0) {
			pairs1.push(pairs[i]);
		}
	}

	return "?" + pairs1.join("&");
};

/**
 * Returns the given object/primitive as a string.
 *
 * @param {primitive|Object}	o		an object or primitive
 * @return	{String}	the string
 */
AjxStringUtil.getAsString =
function(o) {
	return !o ? "" : (typeof(o) == 'object') ? o.toString() : o;
};

AjxStringUtil.isWhitespace = 
function(str) {
	return (str.charCodeAt(0) <= 32);
};

AjxStringUtil.isDigit = 
function(str) {
	var charCode = str.charCodeAt(0);
	return (charCode >= 48 && charCode <= 57);
};

AjxStringUtil.compareRight = 
function(a,b) {
	var bias = 0;
	var idxa = 0;
	var idxb = 0;
	var ca;
	var cb;

	for (; (idxa < a.length || idxb < b.length); idxa++, idxb++) {
		ca = a.charAt(idxa);
		cb = b.charAt(idxb);

		if (!AjxStringUtil.isDigit(ca) &&
			!AjxStringUtil.isDigit(cb))
		{
			return bias;
		}
		else if (!AjxStringUtil.isDigit(ca))
		{
			return -1;
		}
		else if (!AjxStringUtil.isDigit(cb))
		{
			return +1;
		}
		else if (ca < cb)
		{
			if (bias == 0) bias = -1;
		}
		else if (ca > cb)
		{
			if (bias == 0) bias = +1;
		}
	}
};

AjxStringUtil.natCompare = 
function(a, b) {
	var idxa = 0, idxb = 0;
	var nza = 0, nzb = 0;
	var ca, cb;

	while (idxa < a.length || idxb < b.length)
	{
		// number of zeroes leading the last number compared
		nza = nzb = 0;

		ca = a.charAt(idxa);
		cb = b.charAt(idxb);

		// ignore overleading spaces/zeros and move the index accordingly
		while (AjxStringUtil.isWhitespace(ca) || ca =='0') {
			nza = (ca == '0') ? (nza+1) : 0;
			ca = a.charAt(++idxa);
		}
		while (AjxStringUtil.isWhitespace(cb) || cb == '0') {
			nzb = (cb == '0') ? (nzb+1) : 0;
			cb = b.charAt(++idxb);
		}

		// current index points to digit in both str
		if (AjxStringUtil.isDigit(ca) && AjxStringUtil.isDigit(cb)) {
			var result = AjxStringUtil.compareRight(a.substring(idxa), b.substring(idxb));
			if (result && result!=0) {
				return result;
			}
		}

		if (ca == 0 && cb == 0) {
			return nza - nzb;
		}

		if (ca < cb) {
			return -1;
		} else if (ca > cb) {
			return +1;
		}

		++idxa; ++idxb;
	}
};

AjxStringUtil.clipFile =
function(fileName, limit) {
	var index = fileName.lastIndexOf('.');

	// fallback - either not found or starts with delimiter
	if (index <= 0) {
		index = fileName.length;
	}

	if (index <= limit) {
		return fileName;
	}

	var fName = fileName.slice(0, index);
	var ext = fileName.slice(index);

	return [
		fName.slice(0, limit/2),
		AjxMsg.ellipsis,
		fName.slice(-Math.ceil(limit/2) + AjxMsg.ellipsis.length),
		ext
	].join("")
};


AjxStringUtil.URL_PARSE_RE = new RegExp("^(?:([^:/?#.]+):)?(?://)?(([^:/?#]*)(?::(\\d*))?)?((/(?:[^?#](?![^?#/]*\\.[^?#/.]+(?:[\\?#]|$)))*/?)?([^?#/]*))?(?:\\?([^#]*))?(?:#(.*))?");

AjxStringUtil.parseURL = 
function(sourceUri) {

	var names = ["source","protocol","authority","domain","port","path","directoryPath","fileName","query","anchor"];
	var parts = AjxStringUtil.URL_PARSE_RE.exec(sourceUri);
	var uri = {};

	for (var i = 0; i < names.length; i++) {
		uri[names[i]] = (parts[i] ? parts[i] : "");
	}

	if (uri.directoryPath.length > 0) {
		uri.directoryPath = uri.directoryPath.replace(/\/?$/, "/");
	}

	return uri;
};

/**
 * Parses a mailto: link into components. If the string is not a mailto: link, the object returned will
 * have a "to" property set to the string.
 *
 * @param {String}      str     email address, possibly within a "mailto:" link
 * @returns {Object}    object with at least a 'to' property, and possibly 'subject' and 'body'
 */
AjxStringUtil.parseMailtoLink = function(str) {

	var parts = {};

	if (!str) {
		return parts;
	}

	if (str.toLowerCase().indexOf('mailto:') === -1) {
		parts.to = str;
		return parts;
	}

	var match = str.match(/\bsubject=([^&]+)/i);
	parts.subject = match ? decodeURIComponent(match[1]) : null;

	match = str.match(/\bto\:([^&]+)/);
	if (!match) {
		match = str.match(/\bmailto\:([^\?]+)/i);
	}
	parts.to = match ? decodeURIComponent(match[1]) : null;

	match = str.match(/\bbody=([^&]+)/i);
	parts.body = match ? decodeURIComponent(match[1]) : null;

	return parts;
};

/**
 * Parse the query string (part after the "?") and return it as a hash of key/value pairs.
 * 
 * @param	{String}	sourceUri		the source location or query string
 * @return	{Object}	a hash of query string params
 */
AjxStringUtil.parseQueryString =
function(sourceUri) {

	var location = sourceUri || ("" + window.location);
	var idx = location.indexOf("?");
	var qs = (idx === -1) ? location : location.substring(idx + 1);
	qs = qs.replace(/#.*$/, '');    // strip anchor
	var list = qs.split("&");
	var params = {}, pair, key, value;
	for (var i = 0; i < list.length; i++) {
		pair = list[i].split("=");
		key = decodeURIComponent(pair[0]),
		value = pair[1] ? decodeURIComponent(pair[1]) : true;   // if no value given, set to true so we know it's there
		params[key] = value;
	}
	return params;
};

/**
 * Pretty-prints a JS object. Preferred over JSON.stringify for the debug-related dumping
 * of an object for several reasons:
 * 		- doesn't have an enclosing object, which shifts everything over one level
 * 		- doesn't put quotes around keys
 * 		- shows indexes for arrays (downside is that prevents output from being eval-able)
 * 
 * @param obj
 * @param recurse
 * @param showFuncs
 * @param omit
 */
AjxStringUtil.prettyPrint =
function(obj, recurse, showFuncs, omit) {

	AjxStringUtil._visited = new AjxVector();
	var text = AjxStringUtil._prettyPrint(obj, recurse, showFuncs, omit);
	AjxStringUtil._visited = null;

	return text;
};

AjxStringUtil._visited = null;

AjxStringUtil._prettyPrint =
function(obj, recurse, showFuncs, omit) {

	var indentLevel = 0;
	var showBraces = false;
	var stopRecursion = false;
	if (arguments.length > 4) {
		indentLevel = arguments[4];
		showBraces = arguments[5];
		stopRecursion = arguments[6];
	}

	if (AjxUtil.isObject(obj)) {
		var objStr = obj.toString ? obj.toString() : "";
		if (omit && objStr && omit[objStr]) {
			return "[" + objStr + "]";
		}
		if (AjxStringUtil._visited.contains(obj)) {
			return "[visited object]";
		} else {
			AjxStringUtil._visited.add(obj);
		}
	}

	var indent = AjxStringUtil.repeat(" ", indentLevel);
	var text = "";

	if (obj === undefined) {
		text += "[undefined]";
	} else if (obj === null) {
		text += "[null]";
	} else if (AjxUtil.isBoolean(obj)) {
		text += obj ? "true" : "false";
	} else if (AjxUtil.isString(obj)) {
		text += '"' + AjxStringUtil._escapeForHTML(obj) + '"';
	} else if (AjxUtil.isNumber(obj)) {
		text += obj;
	} else if (AjxUtil.isObject(obj)) {
		var isArray = AjxUtil.isArray(obj) || AjxUtil.isArray1(obj);
		if (stopRecursion) {
			text += isArray ? "[Array]" : obj.toString();
		} else {
			stopRecursion = !recurse;
			var keys = new Array();
			for (var i in obj) {
                if (obj.hasOwnProperty(i)) {
                    keys.push(i);
                }
			}

			if (isArray) {
				keys.sort(function(a,b) {return a - b;});
			} else {
				keys.sort();
			}

			if (showBraces) {
				text += isArray ? "[" : "{";
			}
			var len = keys.length;
			for (var i = 0; i < len; i++) {
				var key = keys[i];
				var nextObj = obj[key];
				var value = null;
				// For dumping events, and dom elements, though I may not want to
				// traverse the node, I do want to know what the attribute is.
				if (nextObj == window || nextObj == document || (!AjxEnv.isIE && nextObj instanceof Node)){
					value = nextObj.toString();
				}
				if ((typeof(nextObj) == "function")) {
					if (showFuncs) {
						value = "[function]";
					} else {
						continue;
					}
				}

				if (i > 0) {
					text += ",";
				}
				text += "\n" + indent;
                var keyString;
                if (isArray) {
                    keyString = "// [" + key + "]:\n" + indent;
                } else {
                    keyString = key + ": ";
                }
				if (omit && omit[key]) {
					text += keyString + "[" + key + "]";
				} else if (value != null) {
					text += keyString + value;
				} else {
					text += keyString + AjxStringUtil._prettyPrint(nextObj, recurse, showFuncs, omit, indentLevel + 2, true, stopRecursion);
				}
			}
			if (i > 0) {
				text += "\n" + AjxStringUtil.repeat(" ", indentLevel - 1);
			}
			if (showBraces) {
				text += isArray ? "]" : "}";
			}
		}
	}
	return text;
};

AjxStringUtil._escapeForHTML =
function(str){

	if (typeof(str) != 'string') { return str; }

	var s = str;
	s = s.replace(/\&/g, '&amp;');
	s = s.replace(/\</g, '&lt;');
	s = s.replace(/\>/g, '&gt;');
	s = s.replace(/\"/g, '&quot;');
	s = s.replace(/\xA0/g, '&nbsp;');

	return s;
};

// hidden SPANs for measuring regular and bold strings
AjxStringUtil._testSpan = null;
AjxStringUtil._testSpanBold = null;

// cached string measurements
AjxStringUtil.WIDTH			= {};		// regular strings
AjxStringUtil.WIDTH_BOLD	= {};		// bold strings
AjxStringUtil.MAX_CACHE		= 1000;		// max total number of cached strings
AjxStringUtil._cacheSize	= 0;		// current number of cached strings

/**
 * Returns the width in pixels of the given string.
 *
 * @param {string}	str		string to measure
 * @param {boolean}	bold	if true, string should be measured in bold font
 * @param {string|number}   font size to measure string in. If unset, use default font size
 */
AjxStringUtil.getWidth =
function(str, bold, fontSize) {

	if (!AjxStringUtil._testSpan) {
		var span1 = AjxStringUtil._testSpan = document.createElement("SPAN");
		var span2 = AjxStringUtil._testSpanBold = document.createElement("SPAN");
		span1.style.position = span2.style.position = Dwt.ABSOLUTE_STYLE;
		var shellEl = DwtShell.getShell(window).getHtmlElement();
		shellEl.appendChild(span1);
		shellEl.appendChild(span2);
		Dwt.setLocation(span1, Dwt.LOC_NOWHERE, Dwt.LOC_NOWHERE);
		Dwt.setLocation(span2, Dwt.LOC_NOWHERE, Dwt.LOC_NOWHERE);
		span2.style.fontWeight = "bold";
	}

	if (AjxUtil.isString(fontSize)) {
		fontSize = DwtCssStyle.asPixelCount(fontSize);
	}
	var sz = "" + (fontSize || 0); // 0 means "default";
	
	var cache = bold ? AjxStringUtil.WIDTH_BOLD : AjxStringUtil.WIDTH;
	if (cache[str] && cache[str][sz]) {
		return cache[str][sz];
	}

	if (AjxStringUtil._cacheSize >= AjxStringUtil.MAX_CACHE) {
		AjxStringUtil.WIDTH = {};
		AjxStringUtil.WIDTH_BOLD = {};
		AjxStringUtil._cacheSize = 0;
	}

	var span = bold ? AjxStringUtil._testSpanBold : AjxStringUtil._testSpan;
	span.innerHTML = str;
	span.style.fontSize = fontSize ? (fontSize+"px") : null;

	if (!cache[str]) {
		cache[str] = {};
	}

	var w = cache[str][sz] = Dwt.getSize(span).x;
	AjxStringUtil._cacheSize++;

	return w;
};

/**
 * Fits as much of a string within the given width as possible. If truncation is needed, adds an ellipsis.
 * Truncation could happen at any letter, and not necessarily at a word boundary.
 *
 * @param {String}  str     a string
 * @param {Number}  width   available width in pixels
 *
 * @returns {String}    string (possibly truncated) that fits in width
 */
AjxStringUtil.fitString = function(str, width) {

    var strWidth = AjxStringUtil.getWidth(str);
    if (strWidth < width) {
        return str;
    }

    var ell = AjxStringUtil.ELLIPSIS_NO_SPACE,
        ellWidth = AjxStringUtil.getWidth(ell);

    while (str.length > 0) {
        if (AjxStringUtil.getWidth(str) + ellWidth < width) {
            return str + ell;
        }
        else {
            str = str.substring(0, str.length - 1); // remove last letter and try again
        }
    }

    return '';
};

/**
 * correct the cross domain reference in passed url content
 * eg: http://<ipaddress>/ url might have rest url page which points to http://<server name>/ pages
 *
 */
AjxStringUtil.fixCrossDomainReference =
function(url, restUrlAuthority, convertToRelativeURL) {
	var urlParts = AjxStringUtil.parseURL(url);
	if (urlParts.authority == window.location.host) {
		return url;
	}

	if ((restUrlAuthority && url.indexOf(restUrlAuthority) >=0) || !restUrlAuthority) {
        if (convertToRelativeURL) {
            url = urlParts.path;
        }
        else {
            var oldRef = urlParts.protocol + "://" + urlParts.authority;
            var newRef = window.location.protocol + "//" + window.location.host;
            url = url.replace(oldRef, newRef);
        }
	}
	return url;
};


AjxStringUtil._dummyDiv = document.createElement("DIV");

AjxStringUtil.htmlPlatformIndependent =
function(html) {
	var div = AjxStringUtil._dummyDiv;
	div.innerHTML = html;
	var inner = div.innerHTML;
	div.innerHTML = "";
	return inner;
};

/**
 * compare two html code fragments, ignoring the case of tags, since the tags inside innnerHTML are returned differently by different browsers (and from Outlook)
 * e.g. IE returns CAPS for tag names in innerHTML while FF returns lowercase tag names. Outlook signature creation also returns lowercase.
 * this approach is also good in case the browser removes some of the innerHTML set to it, like I suspect might be in the case of stuff coming from Outlook. (e.g. it removes head tag since it's illegal inside a div)
 *
 * @param html1
 * @param html2
 */
AjxStringUtil.equalsHtmlPlatformIndependent =
function(html1, html2) {
	return AjxStringUtil.htmlPlatformIndependent(html1) == AjxStringUtil.htmlPlatformIndependent(html2);
};

// Stuff for parsing messages to find original (as opposed to quoted) content

// types of content related to finding original content; not all are used
AjxStringUtil.ORIG_UNKNOWN		= "UNKNOWN";
AjxStringUtil.ORIG_QUOTED		= "QUOTED";
AjxStringUtil.ORIG_SEP_STRONG	= "SEP_STRONG";
AjxStringUtil.ORIG_SEP_WEAK		= "SEP_WEAK";
AjxStringUtil.ORIG_WROTE_STRONG	= "WROTE_STRONG";
AjxStringUtil.ORIG_WROTE_WEAK	= "WROTE_WEAK";
AjxStringUtil.ORIG_HEADER		= "HEADER";
AjxStringUtil.ORIG_LINE			= "LINE";
AjxStringUtil.ORIG_SIG_SEP		= "SIG_SEP";

// regexes for parsing msg body content so we can figure out what was quoted and what's new
// TODO: should these be moved to AjxMsg to be fully localizable?
AjxStringUtil.MSG_REGEXES = [
	{
		// the two most popular quote characters, > and |
		type:	AjxStringUtil.ORIG_QUOTED,
		regex:	/^\s*(>|\|)/
	},
	{
		// marker for Original or Forwarded message, used by ZCS and others
		type:	AjxStringUtil.ORIG_SEP_STRONG,
		regex:	new RegExp("^\\s*--+\\s*(" + AjxMsg.origMsg + "|" + AjxMsg.forwardedMessage + "|" + AjxMsg.origAppt + ")\\s*--+\\s*$", "i")
	},
	{
		// marker for Original or Forwarded message, used by ZCS and others
		type:	AjxStringUtil.ORIG_SEP_STRONG,
		regex:	new RegExp("^" + AjxMsg.forwardedMessage1 + "$", "i")
	},
	{
		// one of the commonly quoted email headers
		type:	AjxStringUtil.ORIG_HEADER,
		regex:	new RegExp("^\\s*(" + [AjxMsg.from, AjxMsg.to, AjxMsg.subject, AjxMsg.date, AjxMsg.sent, AjxMsg.cc].join("|") + ")")
	},
	{
		// some clients use a series of underscores as a text-mode separator (text version of <hr>)
		type:	AjxStringUtil.ORIG_LINE,
		regex:	/^\s*_{5,}\s*$/
	}/*,
	{
		// in case a client doesn't use the exact words above
		type:	AjxStringUtil.ORIG_SEP_WEAK,
		regex:	/^\s*--+\s*[\w\s]+\s*--+$/
	},
	{
		// internet style signature separator
		type:	AjxStringUtil.ORIG_SIG_SEP,
		regex:	/^- ?-\s*$/
	}*/
];

// ID for an HR to mark it as ours
AjxStringUtil.HTML_SEP_ID = "zwchr";

// regexes for finding a delimiter such as "On DATE, NAME (EMAIL) wrote:"
AjxStringUtil.ORIG_EMAIL_RE = /[^@\s]+@[A-Za-z0-9\-]{2,}(\.[A-Za-z0-9\-]{2,})+/;    // see AjxUtil.EMAIL_FULL_RE
AjxStringUtil.ORIG_DATE_RE = /\d+\s*(\/|\-|, )20\d\d/;                                    // matches "03/07/2014" or "March 3, 2014" by looking for year 20xx
AjxStringUtil.ORIG_INTRO_RE = new RegExp("^(-{2,}|" + AjxMsg.on + "\\s+)", "i");


// Lazily creates a test hidden IFRAME and writes the given html to it, then returns the HTML element.
AjxStringUtil._writeToTestIframeDoc =
function(html) {
	var iframe;

	if (!AjxStringUtil.__curIframeId) {
		iframe = document.createElement("IFRAME");
		AjxStringUtil.__curIframeId = iframe.id = Dwt.getNextId();

		iframe.setAttribute('aria-hidden', true);
		document.body.appendChild(iframe);
		// position offscreen rather than set display:none so we can get metrics if needed; no perf difference seen
		Dwt.setPosition(iframe, Dwt.ABSOLUTE_STYLE);
		Dwt.setLocation(iframe, Dwt.LOC_NOWHERE, Dwt.LOC_NOWHERE);
	} else {
		iframe = document.getElementById(AjxStringUtil.__curIframeId);
	}

	var idoc = Dwt.getIframeDoc(iframe);

    html = html && html.replace(AjxStringUtil.IMG_SRC_CID_REGEX, '<img $1 pnsrc="cid:');
	idoc.open();
	idoc.write(html);
	idoc.close();

	return idoc.childNodes[0];
};

// Firefox only - clean up test iframe since we can't reuse it
AjxStringUtil._removeTestIframeDoc =
function() {
	if (AjxEnv.isFirefox) {
		var iframe = document.getElementById(AjxStringUtil.__curIframeId);
		if (iframe) {
			iframe.parentNode.removeChild(iframe);
		}
		AjxStringUtil.__curIframeId = null;
	}
};

/**
 * Analyze the text and return what appears to be original (as opposed to quoted) content. We
 * look for separators commonly used by mail clients, as well as prefixes that indicate that
 * a line is being quoted.
 * 
 * @param {string}	text		message body content
 * 
 * @return	{string}	original content if quoted content was found, otherwise NULL
 */
AjxStringUtil.getOriginalContent =
function(text, isHtml) {
	
	if (!text) { return ""; }
	
	if (isHtml) {
		return AjxStringUtil._getOriginalHtmlContent(text);
	}

	var results = [];
	var lines = text.split(AjxStringUtil.SPLIT_RE);
	
	var curType, curBlock = [], count = {}, isMerged, unknownBlock, isBugzilla = false;
	for (var i = 0; i < lines.length; i++) {
		var line = lines[i];
		var testLine = AjxStringUtil.trim(line);

		// blank lines are just added to the current block
		if (!AjxStringUtil._NON_WHITESPACE.test(testLine)) {
			curBlock.push(line);
			continue;
		}
		
		// Bugzilla summary looks like QUOTED; it should be treated as UNKNOWN
		if ((testLine.indexOf("| DO NOT REPLY") === 0) && (lines[i + 2].indexOf("bugzilla") !== -1)) {
			isBugzilla = true;
		}

		var type = AjxStringUtil._getLineType(testLine);
		if (type === AjxStringUtil.ORIG_QUOTED) {
			type = isBugzilla ? AjxStringUtil.ORIG_UNKNOWN : type;
		}
		else {
			isBugzilla = false;
		}

		// WROTE can stretch over two lines; if so, join them into one line
		var nextLine = lines[i + 1];
		var isMerged = false;
		if (nextLine && (type === AjxStringUtil.ORIG_UNKNOWN) && AjxStringUtil.ORIG_INTRO_RE.test(testLine) && nextLine.match(/\w+:$/)) {
			testLine = [testLine, nextLine].join(" ");
			type = AjxStringUtil._getLineType(testLine);
			isMerged = true;
		}
		
		// LINE sometimes used as delimiter; if HEADER follows, lump it in with them
		if (type === AjxStringUtil.ORIG_LINE) {
			var j = i + 1;
			nextLine = lines[j];
			while (!AjxStringUtil._NON_WHITESPACE.test(nextLine) && j < lines.length) {
				nextLine = lines[++j];
			}
			var nextType = nextLine && AjxStringUtil._getLineType(nextLine);
			if (nextType === AjxStringUtil.ORIG_HEADER) {
				type = AjxStringUtil.ORIG_HEADER;
			}
			else {
				type = AjxStringUtil.ORIG_UNKNOWN;
			}
		}
				
		// see if we're switching to a new type; if so, package up what we have so far
		if (curType) {
			if (curType !== type) {
				results.push({type:curType, block:curBlock});
				unknownBlock = (curType === AjxStringUtil.ORIG_UNKNOWN) ? curBlock : unknownBlock;
				count[curType] = count[curType] ? count[curType] + 1 : 1;
				curBlock = [];
				curType = type;
			}
		}
		else {
			curType = type;
		}
		
		if (isMerged && (type === AjxStringUtil.ORIG_WROTE_WEAK || type === AjxStringUtil.ORIG_WROTE_STRONG)) {
			curBlock.push(line);
			curBlock.push(nextLine);
			i++;
			isMerged = false;
		}
		else {
			curBlock.push(line);
		}
	}

	// Handle remaining content
	if (curBlock.length) {
		results.push({type:curType, block:curBlock});
		unknownBlock = (curType === AjxStringUtil.ORIG_UNKNOWN) ? curBlock : unknownBlock;
		count[curType] = count[curType] ? count[curType] + 1 : 1;
	}
	
	// Now it's time to analyze all these blocks that we've classified

	// Check for UNKNOWN followed by HEADER
	var first = results[0], second = results[1];
	if (first && first.type === AjxStringUtil.ORIG_UNKNOWN && second && (second.type === AjxStringUtil.ORIG_HEADER || second.type === AjxStringUtil.ORIG_WROTE_STRONG)) {
		var originalText = AjxStringUtil._getTextFromBlock(first.block);
		if (originalText) {
			var third = results[2];
			if (third && third.type === AjxStringUtil.ORIG_UNKNOWN) {
				var originalThirdText = AjxStringUtil._getTextFromBlock(third.block);
				if (originalThirdText && originalThirdText.indexOf(ZmItem.NOTES_SEPARATOR) !== -1) {
					return originalText + originalThirdText;
				}
			}
			return originalText;
		}
	}

	// check for special case of WROTE preceded by UNKNOWN, followed by mix of UNKNOWN and QUOTED (inline reply)
	var originalText = AjxStringUtil._checkInlineWrote(count, results, false);
	if (originalText) {
		return originalText;
	}

	// If we found quoted content and there's exactly one UNKNOWN block, return it.
	if (count[AjxStringUtil.ORIG_UNKNOWN] === 1 && count[AjxStringUtil.ORIG_QUOTED] > 0) {
		var originalText = AjxStringUtil._getTextFromBlock(unknownBlock);
		if (originalText) {
			return originalText;
		}
	}

	// If we have a STRONG separator (eg "--- Original Message ---"), consider it authoritative and return the text that precedes it
	if (count[AjxStringUtil.ORIG_SEP_STRONG] > 0) {
		var block = [];
		for (var i = 0; i < results.length; i++) {
			var result = results[i];
			if (result.type === AjxStringUtil.ORIG_SEP_STRONG) {
				break;
			}
			block = block.concat(result.block);
		}
		var originalText = AjxStringUtil._getTextFromBlock(block);
		if (originalText) {
			return originalText;
		}
	}

	return text;
};

// Matches a line of text against some regexes to see if has structural meaning within a mail msg.
AjxStringUtil._getLineType =
function(testLine) {

	var type = AjxStringUtil.ORIG_UNKNOWN;
	
	// see if the line matches any known delimiters or quote patterns
	for (var j = 0; j < AjxStringUtil.MSG_REGEXES.length; j++) {
		var msgTest = AjxStringUtil.MSG_REGEXES[j];
		var regex = msgTest.regex;
		if (regex.test(testLine.toLowerCase())) {
			// line that starts and ends with | is considered ASCII art (eg a table) rather than quoted
			if (msgTest.type == AjxStringUtil.ORIG_QUOTED && /^\s*\|.*\|\s*$/.test(testLine)) {
				continue;
			}
			type = msgTest.type;
			break;	// first match wins
		}
	}
	
	if (type === AjxStringUtil.ORIG_UNKNOWN) {
		// "so-and-so wrote:" takes a lot of different forms; look for various common parts and
		// assign points to determine confidence
		var m = testLine.match(/(\w+):$/);
		var verb = m && m[1] && m[1].toLowerCase();
		if (verb) {
			var points = 0;
			// look for "wrote:" (and discount "changed:", which is used by Bugzilla)
			points = points + (verb === AjxMsg.wrote) ? 5 : (verb === AjxMsg.changed) ? 0 : 2;
			if (AjxStringUtil.ORIG_EMAIL_RE.test(testLine)) {
				points += 4;
			}
			if (AjxStringUtil.ORIG_DATE_RE.test(testLine)) {
				points += 3;
			}
			var regEx = new RegExp("^(--|" + AjxMsg.on + ")", "i");
			if (AjxStringUtil.ORIG_INTRO_RE.test(testLine)) {
				points += 1;
			}
			if (points >= 7) {
				type = AjxStringUtil.ORIG_WROTE_STRONG;
			}
			else if (points >= 5) {
				type = AjxStringUtil.ORIG_WROTE_WEAK;
			}
		}
	}
	
	return type;
};

AjxStringUtil._getTextFromBlock =
function(block) {
	if (!(block && block.length)) { return null; }
	var originalText = block.join("\n") + "\n";
	originalText = originalText.replace(/\s+$/, "\n");
	return (AjxStringUtil._NON_WHITESPACE.test(originalText)) ? originalText : null;
};

AjxStringUtil.SCRIPT_REGEX = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi;

// nodes to ignore; they won't have anything we're interested in
AjxStringUtil.IGNORE_NODE_LIST = ["#comment", "br", "script", "select", "style"];
AjxStringUtil.IGNORE_NODE = AjxUtil.arrayAsHash(AjxStringUtil.IGNORE_NODE_LIST);

/**
 * For HTML, we strip off the html, head, and body tags and stick the rest in a temporary DOM node so that
 * we can go element by element. If we find one that is recognized as a separator, we remove all subsequent elements.
 *
 * @param {string}	text		message body content
 *
 * @return	{string}	original content if quoted content was found, otherwise NULL
 * @private
 */
AjxStringUtil._getOriginalHtmlContent = function(text) {

	// strip <script> tags (which should not be there)
	var htmlNode = AjxStringUtil._writeToTestIframeDoc(text);
    while (AjxStringUtil.SCRIPT_REGEX.test(text)) {
        text = text.replace(AjxStringUtil.SCRIPT_REGEX, "");
    }

	var done = false, nodeList = [];
	AjxStringUtil._flatten(htmlNode, nodeList);

	var ln = nodeList.length, i, results = [], count = {}, el, prevEl, nodeName, type, prevType, sepNode;
	for (i = 0; i < ln; i++) {
		el = nodeList[i];
		if (el.nodeType === AjxUtil.ELEMENT_NODE) {
			el.normalize();
		}
		nodeName = el.nodeName.toLowerCase();
		type = AjxStringUtil._checkNode(nodeList[i]);

		// Check for a multi-element "wrote:" attribution (usually a combo of #text and A nodes), for example:
		//
		//     On Feb 28, 2014, at 3:42 PM, Joe Smith &lt;<a href="mailto:jsmith@zimbra.com" target="_blank">jsmith@zimbra.com</a>&gt; wrote:

		// If the current node is a #text with a date or "On ...", find #text nodes within the next ten nodes, concatenate them, and check the result.
		if (type === AjxStringUtil.ORIG_UNKNOWN && el.nodeName === '#text' &&
			(AjxStringUtil.ORIG_DATE_RE.test(el.nodeValue) || AjxStringUtil.ORIG_INTRO_RE.test(el.nodeValue))) {

			var str = el.nodeValue;
			for (var j = 1; j < 10; j++) {
				var el1 = nodeList[i + j];
				if (el1 && el1.nodeName === '#text') {
					str += el1.nodeValue;
					if (/:$/.test(str)) {
						type = AjxStringUtil._getLineType(AjxStringUtil.trim(str));
						if (type === AjxStringUtil.ORIG_WROTE_STRONG) {
							i = i + j;
							break;
						}
					}
				}
			}
		}

		if (type !== null) {
			results.push({ type: type, node: el, nodeName: nodeName });
			count[type] = count[type] ? count[type] + 1 : 1;
			// definite separator
			if (type === AjxStringUtil.ORIG_SEP_STRONG || type === AjxStringUtil.ORIG_WROTE_STRONG) {
				sepNode = el;
				done = true;
				break;
			}
			// some sort of line followed by a header
			if (type === AjxStringUtil.ORIG_HEADER && prevType === AjxStringUtil.ORIG_LINE) {
				sepNode = prevEl;
				done = true;
				break;
			}
			prevEl = el;
			prevType = type;
		}
	}

	if (sepNode) {
		AjxStringUtil._prune(sepNode, true);
	}

	// convert back to text, restoring html, head, and body nodes; if there is nothing left, return original text
	var result = done && htmlNode.textContent ? "<html>" + htmlNode.innerHTML + "</html>" : text;

	AjxStringUtil._removeTestIframeDoc();
	return result;
};

/**
 * Traverse the given node depth-first to produce a list of descendant nodes. Some nodes are
 * ignored.
 *
 * @param {Element}     node        node
 * @param {Array}       list        result list which grows in place
 * @private
 */
AjxStringUtil._flatten = function(node, list) {

	var nodeName = node && node.nodeName.toLowerCase();
	if (AjxStringUtil.IGNORE_NODE[nodeName]) {
		return;
	}

	list.push(node);

	var children = node.childNodes || [];
	for (var i = 0; i < children.length; i++) {
		this._flatten(children[i], list);
	}
};

/**
 * Removes all subsequent siblings of the given node, and then does the same for its parent.
 * The effect is that all nodes that come after the given node in a depth-first traversal of
 * the DOM will be removed.
 *
 * @param {Element}     node
 * @param {Boolean}     clipNode    if true, also remove the node
 * @private
 */
AjxStringUtil._prune = function(node, clipNode) {

	var p = node && node.parentNode;
	// clip all subsequent nodes
	while (p && p.lastChild && p.lastChild !== node) {
		p.removeChild(p.lastChild);
	}
	// clip the node if asked
	if (clipNode && p && p.lastChild === node) {
		p.removeChild(p.lastChild);
	}
	var nodeName = p && p.nodeName.toLowerCase();
	if (p && nodeName !== 'body' && nodeName !== 'html') {
		AjxStringUtil._prune(p, false);
	}
};

/**
 * Tries to determine the type of the given node.
 *
 * @param {Element}     el      a DOM node
 * @return {String}     type, or null
 * @private
 */
AjxStringUtil._checkNode = function(el) {

	if (!el) { return null; }

	var nodeName = el.nodeName.toLowerCase();
	var type = null;

	// Text node: test against our regexes
	if (nodeName === "#text") {
		var content = AjxStringUtil.trim(el.nodeValue);
		if (AjxStringUtil._NON_WHITESPACE.test(content)) {
			type = AjxStringUtil._getLineType(content);
		}
	}
	// HR: look for a couple different forms that are used to delimit quoted content
	else if (nodeName === "hr") {
		// see if the HR is ours, or one commonly used by other mail clients such as Outlook
		if (el.id === AjxStringUtil.HTML_SEP_ID || (el.size === "2" && el.width === "100%" && el.align === "center")) {
			type = AjxStringUtil.ORIG_SEP_STRONG;
		}
		else {
			type = AjxStringUtil.ORIG_LINE;
		}
	}
	// PRE: treat as one big line of text (should maybe go line by line)
	else if (nodeName === "pre") {
		type = AjxStringUtil._checkNodeContent(el);
	}
	// DIV: check for Outlook class used as delimiter, or a top border used as a separator, and finally just
	// check the text content
	else if (nodeName === "div") {
		if (el.className === "OutlookMessageHeader" || el.className === "gmail_quote") {
			type = AjxStringUtil.ORIG_SEP_STRONG;
		}
		else if (el.style.borderTop) {
			var styleObj = DwtCssStyle.getComputedStyleObject(el);
			if (styleObj && styleObj.borderTopWidth && parseInt(styleObj.borderTopWidth) === 1 && styleObj.borderTopColor) {
				type = AjxStringUtil.ORIG_SEP_STRONG;
			}
		}
		type = type || AjxStringUtil._checkNodeContent(el);
	}
	// SPAN: check text content
	else if (nodeName === "span") {
		type = type || AjxStringUtil._checkNodeContent(el);
	}
	// IMG: treat as original content
	else if (nodeName === "img") {
		type = AjxStringUtil.ORIG_UNKNOWN;
	}
	// BLOCKQUOTE: treat as quoted section
	else if (nodeName === "blockquote") {
		type = AjxStringUtil.ORIG_QUOTED;
	}

	return type;
};

/**
 * Checks textContent to see if it's a separator.
 * @param {Element} node
 * @return {String}
 * @private
 */
AjxStringUtil._checkNodeContent = function(node) {
	var content = node.textContent || '';
	if (!AjxStringUtil._NON_WHITESPACE.test(content) || content.length > 200) {
		return null;
	}
	// We're really only interested in SEP_STRONG and WROTE_STRONG
	var type = AjxStringUtil._getLineType(content);
	return (type === AjxStringUtil.ORIG_SEP_STRONG || type === AjxStringUtil.ORIG_WROTE_STRONG) ? type : null;
};

/**
 * Checks the given HTML to see if it is "safe", and cleans it up if it is. It must have only
 * the tags in the given list, otherwise false is returned. Attributes in the given list will
 * be removed. It is not necessary to include "#text", "html", "head", and "body" in the list
 * of allowed tags.
 * 
 * @param {string}	html			HTML text
 * @param {array}	okTags			whitelist of allowed tags
 * @param {array}	untrustedAttrs	list of attributes to not allow in non-iframe.
 */
AjxStringUtil.checkForCleanHtml =
function(html, okTags, untrustedAttrs) {

	var htmlNode = AjxStringUtil._writeToTestIframeDoc(html);
	var ctxt = {
		allowedTags: AjxUtil.arrayAsHash(okTags),
		untrustedAttrs:	untrustedAttrs || []
	};
	AjxStringUtil._traverseCleanHtml(htmlNode, ctxt);

	var result = "<html>" + htmlNode.innerHTML + "</html>";

	var width = Math.max(htmlNode.scrollWidth, htmlNode.lastChild.scrollWidth);

	AjxStringUtil._removeTestIframeDoc();
	return {html:result, width:width, useIframe:ctxt.fail};
};

AjxStringUtil._traverseCleanHtml =
function(el, ctxt) {

    var isCleanHtml = true;

	var nodeName = el.nodeName.toLowerCase();
	
	// useless <style> that we used to add, remove it
	if (nodeName === "style" && el.innerHTML === "p { margin: 0; }") {
		el.doDelete = true;
	}
	
	// IE likes to insert an empty <title> in the <head>, let it go
	else if (nodeName === "title" && !el.innerHTML) {
	}
	
	// see if tag is allowed
	else if (ctxt.allowedTags[nodeName]) {

        //checks for invalid styles and removes them.  Bug: 78875 - bad styles from user = email displays incorrectly
        if (el.style) {
            var style = el.style && el.style.cssText;

            // Ignore empty style tags, we don't want to pollute DOM by adding empty style tags
            if (style !== "") {
                style = style.toLowerCase();
                if (!AjxStringUtil._checkStyle(style)){
                    isCleanHtml = false;
                }
                el.style.cssText = AjxStringUtil._fixStyle(style);
            }
        }

		if (el.removeAttribute && el.attributes && el.attributes.length) {
			// check for blacklisted attrs
			for (var i = 0; i < ctxt.untrustedAttrs.length; i++) {
				if (el.hasAttribute(ctxt.untrustedAttrs[i])) {
					isCleanHtml = false;
				}
			}
			
			// Note that DOM-based handling of attributes is horribly broken in IE, in all sorts of ways.
			// In IE it is impossible to find a reliable way to get an attribute's value. The attributes
			// collection is supposed to be attributes that were specified in the HTML, but IE fills it with every
			// possible attribute.
			for (var i = 0, attrs = el.attributes, l = attrs.length; i < l; i++) {
				var attr = attrs.item(i);
                if (!attr) {
                    continue;
                }
				var attrName = attr.nodeName && attr.nodeName.toLowerCase();
				// on* handlers (should have been removed by server, check again to be safe)
				if (attrName && attrName.indexOf("on") === 0) {
					el.removeAttribute(attrName);
					continue;
				}
				// this might not work in IE
				var attrValue = attr.nodeValue && String(attr.nodeValue);
				if (attrValue) {
					attrValue = attrValue.toLowerCase();
					// we have global CSS rules for TD that trump table properties, so bail
					if (nodeName === "table" && (attrName === "cellpadding" || attrName === "cellspacing" ||
							attrName === "border") && attrValue !== "0") {
						isCleanHtml = false;
					}
				}
			}
		}
	}
	
	// disallowed tag - bail
	else {
        isCleanHtml = false;
	}
	
	// process child nodes
	for (var i = 0, len = el.childNodes.length; i < len; i++) {
		var childNode = el.childNodes[i];
		AjxStringUtil._traverseCleanHtml(childNode, ctxt);
	}
	
	// remove nodes marked for deletion
	for (var i = el.childNodes.length - 1; i >= 0; i--) {
		var childNode = el.childNodes[i];
		if (childNode.doDelete) {
			el.removeChild(childNode);
		}
	}

    if (!isCleanHtml){
        ctxt.fail = true;
    }
};


AjxStringUtil._checkStyle =
    function(style) {

        //check for absolute positioning
        if (style.match(/\bposition\s*:\s*absolute[^;]*;?/)){
            return false;
        }

        //check for font-<anything>
        if (style.match(/\bfont-[^;]*;?/)){
            return false;
        }

        return true;
};

AjxStringUtil._fixStyle =
function(style) {

    //check for negative margins
    style = style.replace(/\bmargin-?(top|left|right|bottom)?\s*:[^;]*-\d+[^;]*;?/gi, "");

    //check for negative padding
    style = style.replace(/\bpadding-?(top|left|right|bottom)?\s*:[^;]*-\d+[^;]*;?/gi, "");
    
    //remove absolute and fixed positioning
    style = style.replace(/\bposition\s*:\s*(absolute|fixed)[^;]*;?/, "");

    return style;
};

/**
 * A "... wrote:" separator is not quite as authoritative, since the user might be replying inline. If we have
 * a single UNKNOWN block before the WROTE separator, return it unless there is a mix of QUOTED and UNKNOWN
 * following the separator, except if there's only a single unknown block after the separator and it comes last.
 * 
 * @private
 */
AjxStringUtil._checkInlineWrote =
function(count, results) {

	if (count[AjxStringUtil.ORIG_WROTE_STRONG] > 0) {
		var unknownBlock, foundSep = false, afterSep = {};
		for (var i = 0; i < results.length; i++) {
			var result = results[i], type = result.type;
			if (type === AjxStringUtil.ORIG_WROTE_STRONG) {
				foundSep = true;
			}
			else if (type === AjxStringUtil.ORIG_UNKNOWN && !foundSep) {
				if (unknownBlock) {
					return null;
				}
				else {
					unknownBlock = result.block;
				}
			}
			else if (foundSep) {
				afterSep[type] = true;
			}
		}

		var mixed = (afterSep[AjxStringUtil.ORIG_UNKNOWN] && afterSep[AjxStringUtil.ORIG_QUOTED]);
		var endsWithUnknown = (count[AjxStringUtil.ORIG_UNKNOWN] === 2 && results[results.length - 1].type === AjxStringUtil.ORIG_UNKNOWN);
		if (unknownBlock && (!mixed || endsWithUnknown)) {
			var originalText = AjxStringUtil._getTextFromBlock(unknownBlock);
			if (originalText) {
				return originalText;
			}
		}
	}
};

/**
 * Removes non-content HTML from the beginning and end. The idea is to remove anything that would
 * appear to the user as blank space. This function is an approximation since that's hard to do,
 * especially when dealing with HTML as a string.
 *
 * @param {String}  html    HTML to fix
 * @return {String} trimmed HTML
 * @adapts AjxStringUtil.trimHtml
 */
AjxStringUtil.trimHtml = function(html) {

	if (!html) {
		return '';
	}
	var trimmedHtml = html;

	// remove doc-level tags if they don't have attributes
	trimmedHtml = trimmedHtml.replace(AjxStringUtil.DOC_TAG_REGEX, '');

	// some editors like to put every <br> in a <div>
	trimmedHtml = trimmedHtml.replace(/<div><br ?\/?><\/div>/gi, '<br>');

	// remove leading/trailing <br>
	var len = 0;
	while (trimmedHtml.length !== len && (/^<br ?\/?>/i.test(trimmedHtml) || /<br ?\/?>$/i.test(trimmedHtml))) {
		len = trimmedHtml.length;	// loop prevention
		trimmedHtml = trimmedHtml.replace(/^<br ?\/?>/i, "").replace(/<br ?\/?>$/i, "");
	}

	// remove trailing <br> trapped in front of closing tags
	var m = trimmedHtml && trimmedHtml.match(/((<br ?\/?>)+)((<\/\w+>)+)$/i);
	if (m && m.length) {
		var regex = new RegExp(m[1] + m[3] + '$', 'i');
		trimmedHtml = trimmedHtml.replace(regex, m[3]);
	}

	// remove empty internal <div> containers
	trimmedHtml = trimmedHtml.replace(/(<div><\/div>)+/gi, '');

	return AjxStringUtil.trim(trimmedHtml);
};

// regex for removing empty doc tags from an HTML string
AjxStringUtil.DOC_TAG_REGEX = /<\/?(html|head|body)>/gi;

// Convert the html to DOM nodes, update the img src with the defanged field value,
// and then return the html inside the body.
// TODO: See about using a DocumentFragment
AjxStringUtil.defangHtmlContent = function(html) {
	var htmlNode = AjxStringUtil._writeToTestIframeDoc(html);
	var images = htmlNode.getElementsByTagName("img");
	if (images && images.length) {
		var imgEl;
		var dfSrcContent;
		var pnSrcContent;
		for (var i = 0; i < images.length; i++) {
			imgEl = images[i];
			dfSrcContent = imgEl.getAttribute("dfsrc");
			if (dfSrcContent && (dfSrcContent !== "#")) {
				imgEl.setAttribute("src", dfSrcContent);
			} else {
				pnSrcContent = imgEl.getAttribute("pnsrc");
				if (pnSrcContent && (pnSrcContent !== "#")) {
					imgEl.setAttribute("src", pnSrcContent);
				}
			}
			imgEl.removeAttribute("dfsrc");
		}
	}
	var content = "";
	var children = htmlNode.childNodes;
	for (var i = 0; i < children.length; i++) {
		if (children[i].tagName && (children[i].tagName.toLowerCase() === "body")) {
			content = children[i].innerHTML;
			break;
		}
	}
	AjxStringUtil._removeTestIframeDoc();
	return content;
};

}
if (AjxPackage.define("ajax.debug.AjxDebug")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * Creates a new debug window. The document inside is not kept open.  All the
 * output goes into a single &lt;div&gt; element.
 * @constructor
 * @class
 * This class pops up a debug window and provides functions to send output there
 * in various ways. The output is continuously appended to the bottom of the
 * window. The document is left unopened so that the browser doesn't think it's
 * continuously loading and keep its little icon flailing forever. Also, the DOM
 * tree can't be manipulated on an open document. All the output is added to the
 * window by appending it the DOM tree. Another method of appending output is to
 * open the document and use document.write(), but then the document is left open.
 * <p>
 * Any client that uses this class can turn off debugging by changing the first
 * argument to the constructor to {@link AjxDebug.NONE}.
 *
 * @author Conrad Damon
 * @author Ross Dargahi
 *
 * @param {constant}	level	 	debug level for the current debugger (no window will be displayed for a level of NONE)
 * @param {string}		name 		the name of the window (deprecated)
 * @param {boolean}		showTime	if <code>true</code>, display timestamps before debug messages
 * @param {constant}	target		output target (AjxDebug.TGT_WINDOW | AjxDebug.TGT_CONSOLE)
 *
 * @private
 */
AjxDebug = function(params) {

	if (arguments.length == 0) {
		params = {};
	}
	else if (typeof arguments[0] == "number") {
		params = {level:arguments[0], name:arguments[1], showTime:arguments[2]};
	}

	this._showTime = params.showTime;
	this._target = params.target || AjxDebug.TGT_WINDOW;
	this._showTiming = false;
	this._startTimePt = this._lastTimePt = 0;
	this._dbgWindowInited = false;

	this._msgQueue = [];
	this._isPrevWinOpen = false;
	this.setDebugLevel(params.level);
};

AjxDebug.prototype.toString = function() { return "AjxDebug"; };
AjxDebug.prototype.isAjxDebug = true;

/**
 * Defines "no debugging" level.
 */
AjxDebug.NONE = 0; // no debugging (window will not come up)
/**
 * Defines "minimal" debugging level.
 */
AjxDebug.DBG1 = 1; // minimal debugging
/**
 * Defines "moderate" debugging level.
 */
AjxDebug.DBG2 = 2; // moderate debugging
/**
 * Defines "all" debugging level.
 */
AjxDebug.DBG3 = 3; // anything goes

// log output targets
AjxDebug.TGT_WINDOW		= "window";
AjxDebug.TGT_CONSOLE	= "console";

// holds log output in memory so we can show it to user if requested; hash of arrays by type
AjxDebug.BUFFER		= {};
AjxDebug.BUFFER_MAX	= {};

// Special log types. These can be used to make high-priority log info available in prod mode.
// To turn off logging for a type, set its BUFFER_MAX to 0.
AjxDebug.DEFAULT_TYPE	= "debug";		// regular DBG messages
AjxDebug.RPC			= "rpc";		// for troubleshooting "Out of RPC cache" errors
AjxDebug.NOTIFY			= "notify";		// for troubleshooting missing new mail
AjxDebug.EXCEPTION		= "exception";	// JS errors
AjxDebug.CALENDAR		= "calendar";	// for troubleshooting calendar errors
AjxDebug.REPLY			= "reply";		// bug 56308
AjxDebug.SCROLL			= "scroll"; 	// bug 55775
AjxDebug.BAD_JSON		= "bad_json"; 	// bug 57066
AjxDebug.PREFS			= "prefs";		// bug 60942
AjxDebug.PROGRESS       = "progress";	// progress dialog
AjxDebug.REMINDER       = "reminder";   // bug 60692
AjxDebug.OFFLINE        = "offline";
AjxDebug.TAG_ICON       = "tagIcon";    // bug 62155
AjxDebug.DATA_URI       = "dataUri";    // bug 64693
AjxDebug.MSG_DISPLAY	= "msgDisplay";	// bugs 68599, 69616
AjxDebug.ZIMLET			= "zimlet";		// bugs 83009
AjxDebug.KEYBOARD		= "kbnav";		// keyboard manager debugging
AjxDebug.FOCUS			= "focus";		// focus
AjxDebug.FOCUS1			= "focus1";		// focus - minimal logging
AjxDebug.ACCESSIBILITY	= "a11y";		// accessibility logging
AjxDebug.DRAFT	        = "draft";		// draft auto-save

AjxDebug.BUFFER_MAX[AjxDebug.DEFAULT_TYPE]	= 0;	// this one can get big due to object dumps
AjxDebug.BUFFER_MAX[AjxDebug.RPC]			= 200;
AjxDebug.BUFFER_MAX[AjxDebug.NOTIFY]		= 400;
AjxDebug.BUFFER_MAX[AjxDebug.EXCEPTION]		= 100;
AjxDebug.BUFFER_MAX[AjxDebug.CALENDAR]		= 400;
AjxDebug.BUFFER_MAX[AjxDebug.REPLY]			= 400;
AjxDebug.BUFFER_MAX[AjxDebug.SCROLL]		= 100;
AjxDebug.BUFFER_MAX[AjxDebug.BAD_JSON]		= 200;
AjxDebug.BUFFER_MAX[AjxDebug.PREFS] 		= 200;
AjxDebug.BUFFER_MAX[AjxDebug.REMINDER]		= 200;
AjxDebug.BUFFER_MAX[AjxDebug.OFFLINE]		= 400;
AjxDebug.BUFFER_MAX[AjxDebug.TAG_ICON]		= 200;
AjxDebug.BUFFER_MAX[AjxDebug.PROGRESS]		= 200;
AjxDebug.BUFFER_MAX[AjxDebug.DATA_URI]		= 200;
AjxDebug.BUFFER_MAX[AjxDebug.MSG_DISPLAY]	= 200;
AjxDebug.BUFFER_MAX[AjxDebug.ZIMLET]		= 200;
AjxDebug.BUFFER_MAX[AjxDebug.KEYBOARD]		= null;
AjxDebug.BUFFER_MAX[AjxDebug.FOCUS]			= null;
AjxDebug.BUFFER_MAX[AjxDebug.ACCESSIBILITY]	= null;
AjxDebug.BUFFER_MAX[AjxDebug.DRAFT]	        = 200;

AjxDebug.MAX_OUT = 25000; // max length capable of outputting an XML msg

AjxDebug._CONTENT_FRAME_ID	= "AjxDebug_CF";
AjxDebug._LINK_FRAME_ID		= "AjxDebug_LF";
AjxDebug._BOTTOM_FRAME_ID	= "AjxDebug_BFI";
AjxDebug._BOTTOM_FRAME_NAME	= "AjxDebug_BFN";

AjxDebug.prototype.setTitle =
function(title) {
	if (this._document && !AjxEnv.isIE) {
		this._document.title = title;
	}
};

/**
 * Set debug level. May open or close the debug window if moving to or from level {@link AjxDebug.NONE}.
 *
 * @param {constant}	level	 	debug level for the current debugger
 */
AjxDebug.prototype.setDebugLevel =
function(level) {

	this._level = parseInt(level) || level;
	this._enable(this._level != AjxDebug.NONE);
};

/**
 * Gets the current debug level.
 * 
 * @return	{constant}	the debug level
 */
AjxDebug.prototype.getDebugLevel =
function() {
	return this._level;
};

/**
 * Prints a debug message. Any HTML will be rendered, and a line break is added.
 *
 * @param {constant}	level	 	debug level for the current debugger
 * @param {string}	msg		the text to display
 */
AjxDebug.prototype.println =
function(level, msg, linkName) {
	
	if (!this._isWriteable()) { return; }

	try {
		var result = this._handleArgs(arguments);
		if (!result) { return; }

		msg = result.args.join("");
		var eol = (this._target != AjxDebug.TGT_CONSOLE) ? "<br>" : "";
		this._add({msg:this._timestamp() + msg + eol, linkName:result.linkName, level:level});
	} catch (ex) {
		// do nothing
	}
};

/**
 * Checks if debugging is disabled.
 * 
 * @return	{boolean}		<code>true</code> if disabled
 */
AjxDebug.prototype.isDisabled =
function () {
	return !this._enabled;
};

/**
 * Prints an object into a table, with a column for properties and a column for values. Above the table is a header with the object
 * class and the CSS class (if any). The properties are sorted (numerically if they're all numbers). Creating and appending table
 * elements worked in Mozilla but not IE. Using the insert* methods works for both. Properties that are function
 * definitions are skipped.
 *
 * @param {constant}	level	 	debug level for the current debugger
 * @param {object}	obj		the object to be printed
 * @param {boolean}	showFuncs		if <code>true</code>, show props that are functions
 */
AjxDebug.prototype.dumpObj =
function(level, obj, showFuncs, linkName) {
	if (!this._isWriteable()) { return; }

	var result = this._handleArgs(arguments);
	if (!result) { return; }

	obj = result.args[0];
	if (!obj) { return; }

	showFuncs = result.args[1];
	this._add({obj:obj, linkName:result.linkName, showFuncs:showFuncs, level:level});
};

/**
 * Dumps a bunch of text into a &lt;textarea&gt;, so that it is wrapped and scrollable. HTML will not be rendered.
 *
 * @param {constant}	level	 	debug level for the current debugger
 * @param {string}	text		the text to output as is
 */
AjxDebug.prototype.printRaw =
function(level, text, linkName) {
	if (!this._isWriteable()) { return; }

	var result = this._handleArgs(arguments);
	if (!result) { return; }

	this._add({obj:result.args[0], isRaw:true, linkName:result.linkName, level:level});
};

/**
 * Pretty-prints a chunk of XML, doing color highlighting for different types of nodes.
 *
 * @param {constant}	level	 	debug level for the current debugger
 * @param {string}	text		some XML
 * 
 * TODO: fix for printing to console
 */
AjxDebug.prototype.printXML =
function(level, text, linkName) {
	if (!this._isWriteable()) { return; }

	var result = this._handleArgs(arguments);
	if (!result) { return; }

	text = result.args[0];
	if (!text) { return; }

	// skip generating pretty xml if theres too much data
	if (text.length > AjxDebug.MAX_OUT) {
		this.printRaw(text);
		return;
	}
	this._add({obj:text, isXml:true, linkName:result.linkName, level:level});
};

/**
 * Reveals white space in text by replacing it with tags.
 *
 * @param {constant}	level	 	debug level for the current debugger
 * @param {string}	text		the text to be displayed
 */
AjxDebug.prototype.display =
function(level, text, linkName) {
	if (!this._isWriteable()) { return; }

	var result = this._handleArgs(arguments);
	if (!result) { return; }

	text = result.args[0];
	text = text.replace(/\r?\n/g, '[crlf]');
	text = text.replace(/ /g, '[space]');
	text = text.replace(/\t/g, '[tab]');
	this.printRaw(level, text, linkName);
};

/**
 * Turn the display of timing statements on/off.
 *
 * @param {boolean}	on			if <code>true</code>, display timing statements
 * @param {string}	msg		the message to show when timing is turned on
 */
AjxDebug.prototype.showTiming =
function(on, msg) {
	this._showTiming = on;
	if (on) {
		this._enable(true);
	}
	var state = on ? "on" : "off";
	var text = "Turning timing info " + state;
	if (msg) {
		text = text + ": " + msg;
	}

	var debugMsg = new DebugMessage({msg:text});
	this._addMessage(debugMsg);
	this._startTimePt = this._lastTimePt = new Date().getTime();
};

/**
 * Displays time elapsed since last time point.
 *
 * @param {string}	msg		the text to display with timing info
 * @param {boolean}	restart	if <code>true</code>, set timer back to zero
 */
AjxDebug.prototype.timePt =
function(msg, restart) {
	if (!this._showTiming || !this._isWriteable()) { return; }

	if (restart) {
		this._startTimePt = this._lastTimePt = new Date().getTime();
	}
	var now = new Date().getTime();
	var elapsed = now - this._startTimePt;
	var interval = now - this._lastTimePt;
	this._lastTimePt = now;

	var spacer = restart ? "<br/>" : "";
	msg = msg ? " " + msg : "";
	var text = [spacer, "[", elapsed, " / ", interval, "]", msg].join("");
	var html = "<div>" + text + "</div>";

	// Add the message to our stack
	this._addMessage(new DebugMessage({msg:html}));
	return interval;
};

AjxDebug.prototype.getContentFrame =
function() {
	if (this._contentFrame) {
		return this._contentFrame;
	}
	if (this._debugWindow && this._debugWindow.document) {
		return this._debugWindow.document.getElementById(AjxDebug._CONTENT_FRAME_ID);
	}
	return null;
};

AjxDebug.prototype.getLinkFrame =
function(noOpen) {
	if (this._linkFrame) {
		return this._linkFrame;
	}
	if (this._debugWindow && this._debugWindow.document) {
		return this._debugWindow.document.getElementById(AjxDebug._LINK_FRAME_ID);
	}
	if (!noOpen) {
		this._openDebugWindow();
		return this.getLinkFrame(true);
	}
	return null;
};

// Private methods

AjxDebug.prototype._enable =
function(enabled) {

	this._enabled = enabled;
	if (this._target == AjxDebug.TGT_WINDOW) {
		if (enabled) {
			if (!this._dbgName) {
				this._dbgName = "AjxDebugWin_" + location.hostname.replace(/\./g,'_');
			}
			if (this._debugWindow == null || this._debugWindow.closed) {
				this._openDebugWindow();
			}
		} else {
			if (this._debugWindow) {
				this._debugWindow.close();
				this._debugWindow = null;
			}
		}
	}
};

AjxDebug.prototype._isWriteable =
function() {
	if (this.isDisabled()) {
		return false;
	}
	if (this._target == AjxDebug.TGT_WINDOW) {
		try {
			return (!this._isPaused && this._debugWindow && !this._debugWindow.closed);
		} catch (ex) {
			// OMG accessing the debugWindow in IE12 is sometimes throwing a COM exception 'An outgoing call
			// cannot be made since the application is dispatching an input-synchronous call'.  IOleWindow.GetWindow
			// is marked with input-sync and the exception implies an attempt to access another COM apartment while
			// executing it.  Sounds like an IE12 Bug with this preview version.

			// Just suppress the logging for this call, since it appears _debugWindow is inaccessible
			return false;

		}
	}
	return true;
};

AjxDebug.prototype._getHtmlForObject =
function(obj, params) {

	params = params || {};
	var html = [];
	var idx = 0;

	if (obj === undefined) {
		html[idx++] = "<span>Undefined</span>";
	} else if (obj === null) {
		html[idx++] = "<span>NULL</span>";
	} else if (AjxUtil.isBoolean(obj)) {
		html[idx++] = "<span>" + obj + "</span>";
	} else if (AjxUtil.isNumber(obj)) {
		html[idx++] = "<span>" + obj +"</span>";
	} else {
		if (params.isRaw) {
			html[idx++] = this._timestamp();
			html[idx++] = "<textarea rows='25' style='width:100%' readonly='true'>";
			html[idx++] = obj;
			html[idx++] = "</textarea><p></p>";
		} else if (params.isXml) {
			var xmldoc = new AjxDebugXmlDocument;
			var doc = xmldoc.create();
			// IE bizarrely throws error if we use doc.loadXML here (bug 40451)
			if (doc && ("loadXML" in doc)) {
				doc.loadXML(obj);
				html[idx++] = "<div style='border-width:2px; border-style:inset; width:100%; height:300px; overflow:auto'>";
				html[idx++] = this._createXmlTree(doc, 0, {"authToken":true});
				html[idx++] = "</div>";
			} else {
				html[idx++] = "<span>Unable to create XmlDocument to show XML</span>";
			}
		} else {
			html[idx++] = "<div style='border-width:2px; border-style:inset; width:100%; height:300px; overflow:auto'><pre>";
			html[idx++] = this._dump(obj, true, params.showFuncs, {"ZmAppCtxt":true, "authToken":true});
			html[idx++] = "</div></pre>";
		}
	}
	return html.join("");
};

// Pretty-prints a Javascript object
AjxDebug.prototype._dump =
function(obj, recurse, showFuncs, omit) {

	return AjxStringUtil.prettyPrint(obj, recurse, showFuncs, omit);
};

/**
 * Marshals args to public debug functions. In general, the debug level is an optional
 * first arg. If the first arg is a debug level, check it and then strip it from the args.
 * The last argument is an optional name for the link from the left panel.
 *
 * Returns an object with the link name and a list of the arguments (other than level and
 * link name).
 *
 * @param {array}	args				an arguments list
 *
 * @private
 */
AjxDebug.prototype._handleArgs =
function(args) {

	// don't output anything if debugging is off, or timing is on
	if (this._level == AjxDebug.NONE || this._showTiming || args.length == 0) { return; }

	// convert args to a true Array so they're easier to deal with
	var argsArray = new Array(args.length);
	for (var i = 0; i < args.length; i++) {
		argsArray[i] = args[i];
	}

	var result = {args:null, linkName:null};

	// remove link name from arg list if present - check if last arg is *Request or *Response
	var origLen = argsArray.length;
	if (argsArray.length > 1) {
		var lastArg = argsArray[argsArray.length - 1];
		if (lastArg && lastArg.indexOf && (lastArg.indexOf("DebugWarn") != -1 || ((lastArg.indexOf(" ") == -1) && (/Request|Response$/.test(lastArg))))) {
			result.linkName = lastArg;
			argsArray.pop();
		}
	}

	// check level if provided, strip it from args; level is either a number, or 1-8 lowercase letters/numbers
	var userLevel = null;
	var firstArg = argsArray[0];
	var gotUserLevel = (typeof firstArg == "number" || ((origLen > 1) && firstArg.length <= 8 && /^[a-z0-9]+$/.test(firstArg)));
	if (gotUserLevel) {
		userLevel = firstArg;
		argsArray.shift();
	}
	if (userLevel && (AjxDebug.BUFFER_MAX[userLevel] == null)) {
		if (typeof this._level == "number") {
			if (typeof userLevel != "number" || (userLevel > this._level)) { return; }
		} else {
			if (userLevel != this._level) { return; }
		}
	}
	result.args = argsArray;

	return result;
};

AjxDebug.prototype._openDebugWindow =
function(force) {
	var name = AjxEnv.isIE ? "_blank" : this._dbgName;
	this._debugWindow = window.open("", name, "width=600,height=400,resizable=yes,scrollbars=yes");

	if (this._debugWindow == null) {
		this._enabled = false;
		return;
	}

	this._enabled = true;
	this._isPrevWinOpen = this._debugWindow.debug;
	this._debugWindow.debug = true;

	try {
		this._document = this._debugWindow.document;
		this.setTitle("Debug");

		if (!this._isPrevWinOpen) {
			this._document.write(
				"<html>",
					"<head>",
						"<script>",
							"function blank() {return [",
								"'<html><head><style type=\"text/css\">',",
									"'P, TD, DIV, SPAN, SELECT, INPUT, TEXTAREA, BUTTON {',",
											"'font-family: Tahoma, Arial, Helvetica, sans-serif;',",
											"'font-size:11px;}',",
									"'.Content {display:block;margin:0.25em 0em;}',",
									"'.Link {cursor: pointer;color:blue;text-decoration:underline;white-space:nowrap;width:100%;}',",
									"'.DebugWarn {color:red;font-weight:bold;}',",
									"'.Run {color:black; background-color:red;width:100%;font-size:18px;font-weight:bold;}',",
									"'.RunLink {display:block;color:black;background-color:red;font-weight:bold;white-space:nowrap;width:100%;}',",
								"'</style></head><body></body></html>'].join(\"\");}",
						"</script>",
					"</head>",
					"<frameset cols='125, *'>",
						"<frameset rows='*,40'>",
							"<frame name='", AjxDebug._LINK_FRAME_ID, "' id='", AjxDebug._LINK_FRAME_ID, "' src='javascript:parent.parent.blank();'>",
							"<frame name='", AjxDebug._BOTTOM_FRAME_NAME, "' id='", AjxDebug._BOTTOM_FRAME_ID, "' src='javascript:parent.parent.blank();' scrolling=no frameborder=0>",
						"</frameset>",
						"<frame name='", AjxDebug._CONTENT_FRAME_ID, "' id='", AjxDebug._CONTENT_FRAME_ID, "' src='javascript:parent.blank();'>",
					"</frameset>",
				"</html>"
			);
			this._document.close();
			
			var ta = new AjxTimedAction(this, AjxDebug.prototype._finishInitWindow);
			AjxTimedAction.scheduleAction(ta, 2500);
		} else {
			this._finishInitWindow();

			this._contentFrame = this._document.getElementById(AjxDebug._CONTENT_FRAME_ID);
			this._linkFrame = this._document.getElementById(AjxDebug._LINK_FRAME_ID);
			this._createLinkNContent("RunLink", "NEW RUN", "Run", "NEW RUN");

			this._attachHandlers();

			this._dbgWindowInited = true;
			// show any messages that have been queued up, while the window loaded.
			this._showMessages();
		}
	} catch (ex) {
		if (this._debugWindow) {
			this._debugWindow.close();
		}
		this._openDebugWindow(true);
	}
};

AjxDebug.prototype._finishInitWindow =
function() {
	try {
		this._contentFrame = this._debugWindow.document.getElementById(AjxDebug._CONTENT_FRAME_ID);
		this._linkFrame = this._debugWindow.document.getElementById(AjxDebug._LINK_FRAME_ID);

		var frame = this._debugWindow.document.getElementById(AjxDebug._BOTTOM_FRAME_ID);
		var doc = frame.contentWindow.document;
		var html = [];
		var i = 0;
		html[i++] = "<table><tr><td><button id='";
		html[i++] = AjxDebug._BOTTOM_FRAME_ID;
		html[i++] = "_clear'>Clear</button></td><td><button id='";
		html[i++] = AjxDebug._BOTTOM_FRAME_ID;
		html[i++] = "_pause'>Pause</button></td></tr></table>";
		if (doc.body) {
			doc.body.innerHTML = html.join("");
		}
	}
	catch (ex) {
		// IE chokes on the popup window on cold start-up (when IE is started
		// for the first time after system reboot). This should not prevent the
		// app from running and should not bother the user
	}

	if (doc) {
		this._clearBtn = doc.getElementById(AjxDebug._BOTTOM_FRAME_ID + "_clear");
		this._pauseBtn = doc.getElementById(AjxDebug._BOTTOM_FRAME_ID + "_pause");
	}

	this._attachHandlers();
	this._dbgWindowInited = true;
	this._showMessages();
};

AjxDebug.prototype._attachHandlers =
function() {
	// Firefox allows us to attach an event listener, and runs it even though
	// the window with the code is gone ... odd, but nice. IE, though will not
	// run the handler, so we make sure, even if we're  coming back to the
	// window, to attach the onunload handler. In general reattach all handlers
	// for IE
	var unloadHandler = AjxCallback.simpleClosure(this._unloadHandler, this);
	if (this._debugWindow.attachEvent) {
		this._unloadHandler = unloadHandler;
		this._debugWindow.attachEvent('onunload', unloadHandler);
	}
	else {
		this._debugWindow.onunload = unloadHandler;
	}

	if (this._clearBtn) {
		this._clearBtn.onclick = AjxCallback.simpleClosure(this._clear, this);
	}
	if (this._pauseBtn) {
		this._pauseBtn.onclick = AjxCallback.simpleClosure(this._pause, this);
	}
};

/**
 * Scrolls to the bottom of the window. How it does that depends on the browser.
 *
 * @private
 */
AjxDebug.prototype._scrollToBottom =
function() {
	var contentFrame = this.getContentFrame();
	var contentBody = contentFrame ? contentFrame.contentWindow.document.body : null;
	var linkFrame = this.getLinkFrame();
	var linkBody = linkFrame ? linkFrame.contentWindow.document.body : null;

	if (contentBody && linkBody) {
		contentBody.scrollTop = contentBody.scrollHeight;
		linkBody.scrollTop = linkBody.scrollHeight;
	}
};

/**
 * Returns a timestamp string, if we are showing them.
 * @private
 */
AjxDebug.prototype._timestamp =
function() {
	return this._showTime ? this._getTimeStamp() + ": " : "";
};

AjxDebug.prototype.setShowTimestamps =
function(show) {
	this._showTime = show;
};

/**
 * This function takes an XML node and returns an HTML string that displays that node
 * the indent argument is used to describe what depth the node is at so that
 * the HTML code can create a nice indentation.
 * 
 * @private
 */
AjxDebug.prototype._createXmlTree =
function (node, indent, omit) {
	if (node == null) { return ""; }

	var str = "";
	var len;
	switch (node.nodeType) {
		case 1:	// Element
			str += "<div style='color: blue; padding-left: 16px;'>&lt;<span style='color: DarkRed;'>" + node.nodeName + "</span>";

			if (omit && omit[node.nodeName]) {
				return str + "/&gt;</div>";
			}

			var attrs = node.attributes;
			len = attrs.length;
			for (var i = 0; i < len; i++) {
				str += this._createXmlAttribute(attrs[i]);
			}

			if (!node.hasChildNodes()) {
				return str + "/&gt;</div>";
			}
			str += "&gt;<br />";

			var cs = node.childNodes;
			len = cs.length;
			for (var i = 0; i < len; i++) {
				str += this._createXmlTree(cs[i], indent + 3, omit);
			}
			str += "&lt;/<span style='color: DarkRed;'>" + node.nodeName + "</span>&gt;</div>";
			break;

		case 9:	// Document
			var cs = node.childNodes;
			len = cs.length;
			for (var i = 0; i < len; i++) {
				str += this._createXmlTree(cs[i], indent, omit);
			}
			break;

		case 3:	// Text
			if (!/^\s*$/.test(node.nodeValue)) {
				var val = node.nodeValue.replace(/</g, "&lt;").replace(/>/g, "&gt;");
				str += "<span style='color: WindowText; padding-left: 16px;'>" + val + "</span><br />";
			}
			break;

		case 7:	// ProcessInstruction
			str += "&lt;?" + node.nodeName;

			var attrs = node.attributes;
			len = attrs.length;
			for (var i = 0; i < len; i++) {
				str += this._createXmlAttribute(attrs[i]);
			}
			str+= "?&gt;<br />"
			break;

		case 4:	// CDATA
			str = "<div style=''>&lt;![CDATA[<span style='color: WindowText; font-family: \"Courier New\"; white-space: pre; display: block; border-left: 1px solid Gray; padding-left: 16px;'>" +
				  node.nodeValue +
				  "</span>]" + "]></div>";
			break;

		case 8:	// Comment
			str = "<div style='color: blue; padding-left: 16px;'>&lt;!--<span style='white-space: pre; font-family: \"Courier New\"; color: Gray; display: block;'>" +
				  node.nodeValue +
				  "</span>--></div>";
			break;

		case 10:
				str = "<div style='color: blue; padding-left: 16px'>&lt;!DOCTYPE " + node.name;
				if (node.publicId) {
					str += " PUBLIC \"" + node.publicId + "\"";
					if (node.systemId)
						str += " \"" + node.systemId + "\"";
				}
				else if (node.systemId) {
					str += " SYSTEM \"" + node.systemId + "\"";
				}
				str += "&gt;</div>";

				// TODO: Handle custom DOCTYPE declarations (ELEMENT, ATTRIBUTE, ENTITY)
				break;

		default:
			this._inspect(node);
	}

	return str;
};

AjxDebug.prototype._createXmlAttribute =
function(a) {
	return [" <span style='color: red'>", a.nodeName, "</span><span style='color: blue'>=\"", a.nodeValue, "\"</span>"].join("");
};

AjxDebug.prototype._inspect =
function(obj) {
	var str = "";
	for (var k in obj) {
		str += "obj." + k + " = " + obj[k] + "\n";
	}
	window.alert(str);
};

AjxDebug.prototype._add =
function(params) {

	params.extraHtml = params.obj && this._getHtmlForObject(params.obj, params);

	// Add the message to our stack
    this._addMessage(new DebugMessage(params));
};

AjxDebug.prototype._addMessage =
function(msg) {
	this._msgQueue.push(msg);
	this._showMessages();
};

AjxDebug.prototype._showMessages =
function() {

	switch (this._target) {
		case AjxDebug.TGT_WINDOW:
			this._showMessagesInWindow();
			break;
		case AjxDebug.TGT_CONSOLE:
			this._showMessagesInConsole();
	}
	this._addMessagesToBuffer();
	this._msgQueue = [];
};

AjxDebug.prototype._showMessagesInWindow =
function() {

	if (!this._dbgWindowInited) {
		// For now, don't show the messages-- assuming that this case only
		// happens at startup, and many messages will be written
		return;
	}
	try {
		if (this._msgQueue.length > 0) {
			var contentFrame = this.getContentFrame();
			var linkFrame = this.getLinkFrame();
			if (!contentFrame || !linkFrame) { return; }

			var contentFrameDoc = contentFrame.contentWindow.document;
			var linkFrameDoc = linkFrame.contentWindow.document;
			var now = new Date();
			for (var i = 0, len = this._msgQueue.length; i < len; ++i ) {
				var msg = this._msgQueue[i];
				var linkLabel = msg.linkName;
				var contentLabel = [msg.message, msg.extraHtml].join("");
				this._createLinkNContent("Link", linkLabel, "Content", contentLabel, now);
			}
		}

		this._scrollToBottom();
	} catch (ex) {}
};

AjxDebug.prototype._addMessagesToBuffer =
function() {

	var eol = (this._target == AjxDebug.TGT_CONSOLE) ? "<br>" : "";
	for (var i = 0, len = this._msgQueue.length; i < len; ++i ) {
		var msg = this._msgQueue[i];
		AjxDebug._addMessageToBuffer(msg.type, msg.message + msg.extraHtml + eol);
	}
};

AjxDebug._addMessageToBuffer =
function(type, msg) {

	type = type || AjxDebug.DEFAULT_TYPE;
	var max = AjxDebug.BUFFER_MAX[type];
	if (max > 0) {
		var buffer = AjxDebug.BUFFER[type] = AjxDebug.BUFFER[type] || [];
		while (buffer.length >= max) {
			buffer.shift();
		}
		buffer.push(msg);
	}
};

AjxDebug.prototype._showMessagesInConsole =
function() {

	if (!window.console) { return; }

	var now = new Date();
	for (var i = 0, len = this._msgQueue.length; i < len; ++i ) {
		var msg = this._msgQueue[i];
		if (window.console && window.console.log) {
			window.console.log(AjxStringUtil.stripTags(msg.message + msg.extraHtml));
		}
	}
};

AjxDebug.prototype._getTimeStamp =
function(date) {
	if (!AjxDebug._timestampFormatter) {
		AjxDebug._timestampFormatter = new AjxDateFormat("HH:mm:ss.SSS");
	}
	date = date || new Date();
	return AjxStringUtil.htmlEncode(AjxDebug._timestampFormatter.format(date), true);
};

AjxDebug.prototype._createLinkNContent =
function(linkClass, linkLabel, contentClass, contentLabel, now) {

	var linkFrame = this.getLinkFrame();
	if (!linkFrame) { return; }

	now = now || new Date();
	var timeStamp = ["[", this._getTimeStamp(now), "]"].join("");
	var id = "Lnk_" + now.getTime();

	// create link
	if (linkLabel) {
		var linkFrameDoc = linkFrame.contentWindow.document;
		var linkEl = linkFrameDoc.createElement("DIV");
		linkEl.className = linkClass;
		linkEl.innerHTML = [linkLabel, timeStamp].join(" - ");
		linkEl._targetId = id;
		linkEl._dbg = this;
		linkEl.onclick = AjxDebug._linkClicked;

		var linkBody = linkFrameDoc.body;
		linkBody.appendChild(linkEl);
	}

	// create content
	var contentFrameDoc = this.getContentFrame().contentWindow.document;
	var contentEl = contentFrameDoc.createElement("DIV");
	contentEl.className = contentClass;
	contentEl.id = id;
	contentEl.innerHTML = contentLabel;

	contentFrameDoc.body.appendChild(contentEl);

	// always show latest
	this._scrollToBottom();
};

AjxDebug._linkClicked =
function() {
	var contentFrame = this._dbg.getContentFrame();
	var el = contentFrame.contentWindow.document.getElementById(this._targetId);
	var y = 0;
	while (el) {
		y += el.offsetTop;
		el = el.offsetParent;
	}

	contentFrame.contentWindow.scrollTo(0, y);
};

AjxDebug.prototype._clear =
function() {
	this.getContentFrame().contentWindow.document.body.innerHTML = "";
	this.getLinkFrame().contentWindow.document.body.innerHTML = "";
};

AjxDebug.prototype._pause =
function() {
	this._isPaused = !this._isPaused;
	this._pauseBtn.innerHTML = this._isPaused ? "Resume" : "Pause";
};

AjxDebug.prototype._unloadHandler =
function() {
	if (!this._debugWindow) { return; } // is there anything to do?

	// detach event handlers
	if (this._debugWindow.detachEvent) {
		this._debugWindow.detachEvent('onunload', this._unloadHandler);
	} else {
		this._debugWindow.onunload = null;
	}
};

AjxDebug.println =
function(type, msg) {
	AjxDebug._addMessageToBuffer(type, msg + "<br>");
};

AjxDebug.dumpObj =
function(type, obj) {
	AjxDebug._addMessageToBuffer(type, "<pre>" + AjxStringUtil.prettyPrint(obj, true) + "</pre>");
};

/**
 *
 * @param {hash}	params			hash of params:
 * @param {string}	methodNameStr	SOAP method, eg SearchRequest or SearchResponse
 * @param {boolean}	asyncMode		true if request made asynchronously
 */
AjxDebug.logSoapMessage =
function(params) {

	if (params.methodNameStr == "NoOpRequest" || params.methodNameStr == "NoOpResponse") { return; }

	var ts = AjxDebug._getTimeStamp();
	var msg = ["<b>", params.methodNameStr, params.asyncMode ? "" : " (SYNCHRONOUS)" , " - ", ts, "</b>"].join("");
	for (var type in AjxDebug.BUFFER) {
		if (type == AjxDebug.DEFAULT_TYPE) { continue; }
		AjxDebug.println(type, msg);
	}
	if (window.DBG) {
        // Link is written here:
        var linkName = params.methodNameStr;
        if (!params.asyncMode) {
            linkName = "<span class='DebugWarn'>SYNCHRONOUS </span>" + linkName;
        }
        window.DBG.println(window.DBG._level, msg, linkName);
	}
};

AjxDebug._getTimeStamp =
function(date) {
	return AjxDebug.prototype._getTimeStamp.apply(null, arguments);
};

AjxDebug.getDebugLog =
function(type) {

	type = type || AjxDebug.DEFAULT_TYPE;
	var buffer = AjxDebug.BUFFER[type];
	return buffer ? buffer.join("") : "";
};

/**
 * Simple wrapper for log messages.
 * @private
 */
DebugMessage = function(params) {

	params = params || {};
	this.message = params.msg || "";
	this.type = params.type || null;
	this.category = params.category || "";
	this.time = params.time || (new Date().getTime());
	this.extraHtml = params.extraHtml || "";
	this.linkName = params.linkName;
	this.type = (params.level && typeof(params.level) == "string") ? params.level : AjxDebug.DEFAULT_TYPE;
};
}
if (AjxPackage.define("ajax.debug.AjxDebugXmlDocument")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * XmlDocument factory
 * 
 * @private
 */
AjxDebugXmlDocument = function() {
}

// used to find the Automation server name
getDomDocumentPrefix = function() {
	if (getDomDocumentPrefix.prefix)
		return getDomDocumentPrefix.prefix;
	
	var prefixes = ["MSXML2", "Microsoft", "MSXML", "MSXML3"];
	var o;
	var len = prefixes.length;
	for (var i = 0; i < len; i++) {
		try {
			// try to create the objects
			o = new ActiveXObject(prefixes[i] + ".DomDocument");
			return getDomDocumentPrefix.prefix = prefixes[i];
		}
		catch (ex) {};
	}
	
	throw new Error("Could not find an installed XML parser");
}

AjxDebugXmlDocument.prototype.create = 
function () {
	try {
		// DOM2
		if (document.implementation && document.implementation.createDocument) {
			var doc = document.implementation.createDocument("", "", null);
			
			// some versions of Moz do not support the readyState property
			// and the onreadystate event so we patch it!
			if (doc.readyState == null) {
				doc.readyState = 1;
				doc.addEventListener("load", function () {
					doc.readyState = 4;
					if (typeof doc.onreadystatechange == "function")
						doc.onreadystatechange();
				}, false);
			}
			
			return doc;
		}
		if (window.ActiveXObject)
			return new ActiveXObject(getDomDocumentPrefix() + ".DomDocument");
	}
	catch (ex) {}
	throw new Error("Your browser does not support XmlDocument objects");
}

// Create the loadXML method and xml getter for Mozilla
if (window.DOMParser &&
	window.XMLSerializer &&
	window.Node && Node.prototype && Node.prototype.__defineGetter__)
{
	if (AjxEnv.isSafari) {
		Document.prototype.loadXML = function(s) {
			// parse the string to a new doc
			var doc2 = (new DOMParser()).parseFromString(s, "text/xml");

			// remove all initial children
			while (this.hasChildNodes()) {
				this.removeChild(this.lastChild);
			}

			// insert and import nodes
			var len = doc2.childNodes.length;
			for (var i = 0; i < len; i++) {
				this.appendChild(this.importNode(doc2.childNodes[i], true));
			}
		};

		// This serializes the DOM tree to an XML String
		// Usage: var sXml = oNode.xml
		Document.prototype.__defineGetter__("xml", function () {
			return (new XMLSerializer()).serializeToString(this);
		});
	}
	//
	// XMLDocument did not extend Document interface in some versions of Mozilla
	// so explicitly define it here.
	//
	else {
		AjxDebugXmlDocument.prototype.loadXML = function(s) {
			// parse the string to a new doc
			var doc2 = (new DOMParser()).parseFromString(s, "text/xml");
		
			// remove all initial children
			while (this.hasChildNodes())
				this.removeChild(this.lastChild);

			// insert and import nodes
			var len = doc2.childNodes.length;
			for (var i = 0; i < len; i++)
				this.appendChild(this.importNode(doc2.childNodes[i], true));
		};

		// This serializes the DOM tree to an XML String
		// Usage: var sXml = oNode.xml
		AjxDebugXmlDocument.prototype.__defineGetter__("xml", function () {
			return (new XMLSerializer()).serializeToString(this);
		});
	}
};
}
if (AjxPackage.define("ajax.xml.AjxXmlDoc")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * Default constructor.
 * @class
 * Do not directly instantiate {@link AjxXmlDoc}, use one of the create factory methods instead.
 * 
 */
AjxXmlDoc = function() {
	if (!AjxXmlDoc._inited)
		AjxXmlDoc._init();
}

AjxXmlDoc.prototype.isAjxXmlDoc = true;
AjxXmlDoc.prototype.toString = function() {	return "AjxXmlDoc"; }

//
// Constants
//

/**
 * <strong>Note:</strong>
 * Anybody that uses these regular expressions MUST reset the <code>lastIndex</code>
 * property to zero or else the results are not guaranteed to be correct. You should
 * use {@link AjxXmlDoc.replaceInvalidChars} instead.
 * 
 * @private
 */
AjxXmlDoc.INVALID_CHARS_RE = /[\u0000-\u0008\u000B-\u000C\u000E-\u001F\uD800-\uDFFF\uFFFE-\uFFFF]/g;
AjxXmlDoc.REC_AVOID_CHARS_RE = /[\u007F-\u0084\u0086-\u009F\uFDD0-\uFDDF]/g;

//
// Data
//

AjxXmlDoc._inited = false;
AjxXmlDoc._msxmlVers = null;
AjxXmlDoc._useDOM =
    Boolean(document.implementation && document.implementation.createDocument);
AjxXmlDoc._useActiveX =
    !AjxXmlDoc._useDOM && Boolean(window.ActiveXObject);

/**
 * Creates an XML doc.
 * 
 * @return	{AjxXmlDoc}	the XML doc
 */
AjxXmlDoc.create =
function() {
	var xmlDoc = new AjxXmlDoc();
	var newDoc = null;
	if (AjxXmlDoc._useActiveX) {
		newDoc = new ActiveXObject(AjxXmlDoc._msxmlVers);
		newDoc.async = true; // Force Async loading
		if (AjxXmlDoc._msxmlVers == "MSXML2.DOMDocument.4.0") {
			newDoc.setProperty("SelectionLanguage", "XPath");
			newDoc.setProperty("SelectionNamespaces", "xmlns:zimbra='urn:zimbra' xmlns:mail='urn:zimbraMail' xmlns:account='urn:zimbraAccount'");
		}
	} else if (AjxXmlDoc._useDOM) {
		newDoc = document.implementation.createDocument("", "", null);
	} else {
		throw new AjxException("Unable to create new Doc", AjxException.INTERNAL_ERROR, "AjxXmlDoc.create");
	}
	xmlDoc._doc = newDoc;
	return xmlDoc;
}

/**
 * Creates an XML doc from a document object.
 * 
 * @param	{Document}		doc		the document object
 * @return	{AjxXmlDoc}		the XML doc
 */
AjxXmlDoc.createFromDom =
function(doc) {
	var xmlDoc = new AjxXmlDoc();
	xmlDoc._doc = doc;
	return xmlDoc;
}

/**
 * Creates an XML doc from an XML string.
 * 
 * @param	{string}		xml		the XML string
 * @return	{AjxXmlDoc}		the XML doc
 */
AjxXmlDoc.createFromXml =
function(xml) {
	var xmlDoc = AjxXmlDoc.create();
	xmlDoc.loadFromString(xml);
	return xmlDoc;
}

/**
 * Replaces invalid characters in the given string.
 * 
 * @param	{string}	s	the string
 * @return	{string}	the resulting string
 */
AjxXmlDoc.replaceInvalidChars = function(s) {
	AjxXmlDoc.INVALID_CHARS_RE.lastIndex = 0;
	return s.replace(AjxXmlDoc.INVALID_CHARS_RE, "?");
};

AjxXmlDoc.getXml = function(node) {

    if (!node) {
        return '';
    }

    var xml = node.xml;
    if (!xml) {
        var ser = new XMLSerializer();
        xml = ser.serializeToString(node);
    }

    return AjxXmlDoc.replaceInvalidChars(xml);
};

/**
 * Gets the document.
 * 
 * @return	{Document}	the document
 */
AjxXmlDoc.prototype.getDoc =
function() {
	return this._doc;
}

AjxXmlDoc.prototype.loadFromString =
function(str) {
	var doc = this._doc;
	doc.loadXML(str);
	if (AjxXmlDoc._useActiveX) {
		if (doc.parseError.errorCode != 0)
			throw new AjxException(doc.parseError.reason, AjxException.INVALID_PARAM, "AjxXmlDoc.loadFromString");
	}
}

AjxXmlDoc.prototype.loadFromUrl =
function(url) {
	if(AjxEnv.isChrome || AjxEnv.isSafari) {
		var xmlhttp = new window.XMLHttpRequest();
		xmlhttp.open("GET", url, false);
		xmlhttp.send(null);
		var xmlDoc = xmlhttp.responseXML;
		this._doc = xmlDoc;
	} else {
		this._doc.load(url);
	}
}

/**
 * This function tries to create a JavaScript representation of the DOM. In some cases,
 * it is easier to work with JS objects rather than do DOM lookups.
 *
 * <p>
 * Rules:
 * <ol>
 * <li>The top-level tag gets lost; only it's content is seen important.</li>
 * <li>Each node will be represented as a JS object.  It's textual content
 *      will be saved in node.__msh_content (returned by <code>toString()</code>).</li>
 * <li>Attributes get discarded.</li>
 * <li>Each subnode will map to a property with its tagName in the parent
 *      node <code>parent[subnode.tagName] == subnode</code></li>
 * <li>If multiple nodes with the same tagName have the same parent node, then
 *      <code>parent[tagName]</code> will be an array containing the objects, rather than a
 *      single object.</li>
 * </ol>
 * 
 * So what this function allows us to do is for instance this, starting with this XML doc:
 *
 * <pre>
 * &lt;error>
 *   &lt;code>404&lt;/code>
 *   &lt;name>Not Found&lt;/name>
 *   &lt;description>Page wasn't found on this server.&lt;/description>
 * &lt;/error>
 * </pre>
 * 
 * <pre>
 * var obj = AjxXmlDoc.createFromXml(XML).toJSObject();
 * alert(obj.code + " " + obj.name + " " + obj.description);
 * </pre>
 * 
 * Here's an array example:
 * <pre>
 * &lt;return>
 *   &lt;item>
 *     &lt;name>John Doe&lt;/name>
 *     &lt;email>foo@bar.com&lt;/email>
 *   &lt;/item>
 *   &lt;item>
 *     &lt;name>Johnny Bravo&lt;/name>
 *     &lt;email>bravo@cartoonnetwork.com&lt;/email>
 *   &lt;/item>
 * &lt;/return>
 * </pre>
 * 
 * <pre>
 * var obj = AjxXmlDoc.createFromXml(XML).toJSObject();
 * for (var i = 0; i < obj.item.length; ++i) {
 *   alert(obj.item[i].name + " / " + obj.item[i].email);
 * }
 * </pre>
 *
 * Note that if there's only one &lt;item> tag, then obj.item will be an object
 * rather than an array.  And if there is no &lt;item> tag, then obj.item will be
 * undefined.  These are cases that the calling application must take care of.
 */
AjxXmlDoc.prototype.toJSObject = 
function(dropns, lowercase, withAttrs) {
	_node = function() { this.__msh_content = ''; };
	_node.prototype.toString = function() { return this.__msh_content; };
	rec = function(i, o) {
		var tags = {}, t, n;
		for (i = i.firstChild; i; i = i.nextSibling) {
			if (i.nodeType == 1) {
				t = i.tagName;
				if (dropns)      t = t.replace(/^.*?:/, "");
				if (lowercase)   t = t.toLowerCase();
				n = new _node();
				if (tags[t]) {
					if (tags[t] == 1) {
						o[t] = [ o[t] ];
						tags[t] = 2;
					}
					o[t].push(n);
				} else {
					o[t] = n;
					tags[t] = 1;
				}
				//do attributes
				if(withAttrs) {
					if(i.attributes && i.attributes.length) {
						for(var ix = 0;ix<i.attributes.length;ix++) {
							attr = i.attributes[ix];
							n[attr.name] = AjxUtil.isNumeric(attr.value) ? attr.value : String(attr.value);
						}
					}
				}
				rec(i, n);
			} else if (i.nodeType == 3)
				o.__msh_content += i.nodeValue;
		}
	};
	var o = new _node();
	rec(this._doc.documentElement, o);
	return o;
};

AjxXmlDoc.prototype.getElementsByTagNameNS = 
function(ns, tag) {
	var doc = this.getDoc();
	return !doc.getElementsByTagNameNS
		? doc.getElementsByTagName(ns + ":" + tag)
		: doc.getElementsByTagNameNS(ns, tag);
};

AjxXmlDoc.prototype.getFirstElementByTagNameNS = 
function(ns, tag) {
	return this.getElementsByTagNameNS(ns, tag)[0];
};

AjxXmlDoc.prototype.getElementsByTagName = 
function(tag) {
	var doc = this.getDoc();
	return doc.getElementsByTagName(tag);
};

AjxXmlDoc._init =
function() {
	if (AjxXmlDoc._useActiveX) {
		var msxmlVers = ["MSXML4.DOMDocument", "MSXML3.DOMDocument", "MSXML2.DOMDocument.4.0",
				 "MSXML2.DOMDocument.3.0", "MSXML2.DOMDocument", "MSXML.DOMDocument",
				 "Microsoft.XmlDom"];
		for (var i = 0; i < msxmlVers.length; i++) {
			try {
				new ActiveXObject(msxmlVers[i]);
				AjxXmlDoc._msxmlVers = msxmlVers[i];
				break;
			} catch (ex) {
			}
		}
		if (!AjxXmlDoc._msxmlVers) {
			throw new AjxException("MSXML not installed", AjxException.INTERNAL_ERROR, "AjxXmlDoc._init");
		}
	} else if (!Document.prototype.loadXML) {
		// add loadXML to Document's API
		Document.prototype.loadXML = function(str) {
			var domParser = new DOMParser();
			var domObj = domParser.parseFromString(str, "text/xml");
			// remove old child nodes since we recycle DOMParser and append new
			while (this.hasChildNodes()) {
				this.removeChild(this.lastChild);
			}
			var len = domObj.childNodes.length;
            for (var i = 0; i < len; i++) {
                var importedNode = this.importNode(domObj.childNodes[i], true);
                this.appendChild(importedNode);
            }
		}
		
		if (AjxEnv.isNav) {
			_NodeGetXml = function() {
				var ser = new XMLSerializer();
				return ser.serializeToString(this);
			}
			Node.prototype.__defineGetter__("xml", _NodeGetXml);
		}
	}
	
	AjxXmlDoc._inited = true;
};

AjxXmlDoc.prototype.set =
function(name, value, element) {
   var p = this._doc.createElement(name);
      if (value != null) {
         var cdata = this._doc.createTextNode("");
         p.appendChild(cdata);
         cdata.nodeValue = value;
      }
      if (element == null) {
         this.root.appendChild(p);
      } else {
         element.appendChild(p);
      }
   return p;
};

AjxXmlDoc.prototype.getXml = function() {
    return AjxXmlDoc.getXml(this.getDoc());
};
AjxXmlDoc.prototype.getDocXml = AjxXmlDoc.prototype.getXml;     // back-compatibility with old name

/**
 * Creates an XML document with a root element.
 * 
 * @param	{string}	rootName	the root name
 * @return	{AjxXmlDoc}	the XML document
 */
AjxXmlDoc.createRoot =
function(rootName) {
   var xmldoc = AjxXmlDoc.create();
   var d = xmldoc.getDoc();
   xmldoc.root = d.createElement(rootName);

   d.appendChild(xmldoc.root);
   return xmldoc;
};

/**
 * Creates an XML document with the element.
 * 
 * @param	{string}	name	the element name
 * @param	{string}	value	the element value
 * @return	{AjxXmlDoc}	the XML document
 */
AjxXmlDoc.createElement =
function(name, value) {
	
   var xmldoc = AjxXmlDoc.create();
   var d = xmldoc.getDoc();
   xmldoc.root = d.createElement(name);
   if (value != null) {
   		//xmldoc.root.nodeValue = value;
   	 	var cdata = d.createTextNode("");
        xmldoc.root.appendChild(cdata);
        cdata.nodeValue = value;
   }
   
   d.appendChild(xmldoc.root);
   return xmldoc;
   
};


AjxXmlDoc.prototype.appendChild =
function(xmldoc){
   //Security Exception WRONG_DOCUMENT_ERR thrown when we append nodes created of diff. documents
   //Chrome/Safari does not like it.
   if(this._doc != xmldoc._doc && ( AjxEnv.isChrome || AjxEnv.isSafari )){
        this.root.appendChild(this.getDoc().importNode(xmldoc.root, true));
   }else{
        this.root.appendChild(xmldoc.root);
   }
};

}
if (AjxPackage.define("ajax.xml.AjxSerializer")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

//
// Base class
//

AjxSerializer = function() {
    if (arguments.length == 0) return;
}

// Public methods

AjxSerializer.prototype.serialize = function(node) { throw "NOT IMPLEMENTED"; };

//
// Classes
//

/**
 * This class attempts to serialize a DOM document in the same format
 * as the Zimbra Server.
 * @class
 * @constructor
 * @private
 */
AjxJsonSerializer = function(minimize) {
    AjxSerializer.call(this, null);
    this._minimize = Boolean(minimize);
}
AjxJsonSerializer.prototype = new AjxSerializer;
AjxJsonSerializer.prototype.constructor = AjxJsonSerializer;

// Constants

AjxJsonSerializer.E_ATTRS = "_attrs";
AjxJsonSerializer.A_CONTENT = "_content";
AjxJsonSerializer.A_NAMESPACE = "_jsns";

// AjxSerializer methods

// TODO: handle namespaces
AjxJsonSerializer.prototype.serialize = function(node) {
    // gather elements and content
    var elems = {};
    var elemCount = 0;
    var content = null;
    for (var child = node.firstChild; child; child = child.nextSibling) {
        var type = child.nodeType;
        // elements
        if (type == 1) {
            var name = child.nodeName;
            if (!elems[name]) {
                elems[name] = [];
                elemCount++;
            }
            elems[name].push(child);
            continue;
        }
        // text and CDATA nodes
        if (type == 3 || type == 4) {
            if (!content) {
                content = [];
            }
            content.push(child.nodeValue);
            continue;
        }
    }

    // gather attributes
    var attrs = {};
    var attrCount = 0;
    if (node.attributes) {
        for (var i = 0; i < node.attributes.length; i++) {
            var attr = node.attributes[i];
            var name = attr.nodeName;
            var value = this.quote(attr.nodeValue);
            if (elems[name]) {
                attrs[name] = value;
                attrCount++;
            }
            else {
                elems[name] = value;
                elemCount++;
            }
        }
    }

    // escape content
    content = content && content.join("");
    if (content && content.match(/^\s*$/)) {
        content = null;
    }
    if (content) {
        content = this.quote(content);

        // do we only have content?
        if (attrCount == 0 && elemCount == 0) {
            return content;
        }
    }

    // is there anything to do?
    if (content == null && elemCount == 0 && attrCount == 0) {
//        return "null";
        return "{}";
    }

    // serialize content
    var a = [ "{" ];
    if (content) {
        a.push(this.quote(AjxJsonSerializer.A_CONTENT), ":", content);
        if (attrCount > 0 || elemCount > 0) {
            a.push(",");
        }
    }

    // serialize attributes
    if (attrCount > 0) {
        a.push(this.quote(AjxJsonSerializer.E_ATTRS), ": { ");
        var i = 0;
        for (var name in attrs) {
            if (i > 0) {
                a.push(",");
            }
            a.push(this.quote(name), ":", attrs[name]);
            i++;
        }
        a.push("}");
        if (elemCount > 0) {
            a.push(", ");
        }
    }

    // serialize elements
    var j = 0;
    for (var name in elems) {
        if (j > 0) {
            a.push(",");
        }
        var elem = elems[name];
        if (typeof elem == "string") {
            a.push(this.quote(name), ":", elem);
            j++;
            continue;
        }
        a.push(this.quote(name), ":");
        if (!this._minimize || elem.length > 1) {
            a.push("[");
        }
        for (var i = 0; i < elem.length; i++) {
            if (i > 0) {
                a.push(",");
            }
            a.push(this.serialize(elem[i]));
        }
        if (!this._minimize || elem.length > 1) {
            a.push("]");
        }
        j++;
    }
    a.push("}");

    return a.join("");
};

// convenience methods

AjxJsonSerializer.prototype.quote = function(s) {
    return [ '"', this.escape(s), '"' ].join("");
};

AjxJsonSerializer.prototype.escape = function(s) {
    return s.replace(/\\/g, "\\\\").replace(/"/g, "\\\"").replace(/\n/g, "\\n");
};
}
if (AjxPackage.define("ajax.core.AjxImg")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * @class
 * This static class provides basic image support by using CSS and background 
 * images rather than &lt;img&gt; tags.
 *  
 * @author Conrad Damon
 * @author Ross Dargahi
 * 
 * @private
 */
AjxImg = function() {};

AjxImg.prototype = new Object;
AjxImg.prototype.constructor = null;

AjxImg._VIEWPORT_ID = "AjxImg_VP";

AjxImg.DISABLED = true;

AjxImg.RE_COLOR = /^(.*?),color=(.*)$/;

/**
 * This method will set the image for <i>parentEl</i>. <i>parentEl</i> should 
 * only contain this image and no other children
 *
 * @param parentEl 		the parent element for the image
 * @param imageName 		the name of the image.  The CSS class for the image will be "Img&lt;imageName&gt;".
 * @param useParenEl 	if <code>true</code> will use the parent element as the root for the image and will not create an intermediate DIV
 * @param _disabled		if <code>true</code>, will append " ZDisabledImage" to the CSS class for the image,
 * @param {array}       classes             array of class names to be applied to this image
 *							which will make the image partly transparent
 * @param {string}		altText			alternative text for non-visual users
 */
AjxImg.setImage =
function(parentEl, imageName, useParentEl, _disabled, classes, altText) {
	
	if (!parentEl) { return; }
	
	classes = classes || [];
	var origImageName = imageName;
    var color, m = imageName && imageName.match(AjxImg.RE_COLOR);
	if (m) {
		imageName = m && m[1];
		color = m && m[2];
	}

	var className = AjxImg.getClassForImage(imageName, _disabled);
	if (useParentEl) {
		classes.push(className);
		parentEl.className = classes.join(" ");
		return;
	}
	var id = parentEl.firstChild && parentEl.firstChild.id;
        
	var overlayName = className+"Overlay";
	var maskName = className+"Mask";
	if (color && window.AjxImgData && AjxImgData[overlayName] && AjxImgData[maskName]) {
		color = (color.match(/^\d$/) ? ZmOrganizer.COLOR_VALUES[color] : color) ||
				ZmOrganizer.COLOR_VALUES[ZmOrganizer.ORG_DEFAULT_COLOR];
		parentEl.innerHTML = AjxImg.getImageHtml({
			imageName: origImageName,
			attrStr: id ? "id='"+id+"'" : null,
			altText: altText,
			disabled: _disabled
		});
		return;
	}

	if (parentEl.firstChild == null || parentEl.firstChild.nodeName.toLowerCase() != "div") {
		var html = [], i = 0;
		html[i++] = "<div ";
		if (id) {
			html[i++] = " id='";
			html[i++] = id;
			html[i++] = "' ";
		}
		if (className) {
			classes.push(className);
		}
		html[i++] = AjxUtil.getClassAttr(classes);
		html[i++] = ">";
		if (altText) {
			html[i++] = "<div class='ScreenReaderOnly'>";
			html[i++] = AjxStringUtil.htmlEncode(altText);
			html[i++] = "</div>";
		}
		html[i++] = "</div>";
		parentEl.innerHTML = html.join("");
		return;
	}
	if (className) {
		classes.push(className);
	}
	parentEl.firstChild.className = classes.join(" ");
};

AjxImg.setDisabledImage = function(parentEl, imageName, useParentEl, classes) {
	return AjxImg.setImage(parentEl, imageName, useParentEl, true, classes);
};

AjxImg.getClassForImage =
function(imageName, disabled) {
	var className = imageName ? "Img" + imageName : "";
	if (disabled) className += " ZDisabledImage";
	return className;
};

AjxImg.getImageClass =
function(parentEl) {
	return parentEl.firstChild ? parentEl.firstChild.className : parentEl.className;
};

AjxImg.getImageElement =
function(parentEl) {
	return parentEl.firstChild ? parentEl.firstChild : parentEl;
};

AjxImg.getParentElement =
function(imageEl) {
	return imageEl.parentNode;
};

AjxImg.GET_IMAGE_HTML_PARAMS = [
	"imageName",
	"styles",
	"attrStr",
	"wrapInTable",
	"disabled",
	"classes",
	"altText"
];

/**
 * Returns the HTML needed to display the given image.
 *
 * @param {object}		params		hash of params:
 * @param {string}		imageName		the image you want to render
 * @param {string}		styles			optional style info (for example, "display:inline")
 * @param {string}		attrStr			optional attributes (for example, "id=X748")
 * @param {boolean}		wrapInTable		if true, wrap the HTML in a TABLE
 * @param {boolean}		disabled		if true, show image as disabled
 * @param {array}		classes			array of class names to be applied to this image
 * @param {string}		altText			alternative text for non-visual users
 * 
 * @return	{string}	the image string
 */
AjxImg.getImageHtml = 
function() {
	var params = Dwt.getParams(arguments, AjxImg.GET_IMAGE_HTML_PARAMS);

	var imageName = params.imageName;
	var styles = params.styles || "";
	var styleStr = styles ? " style='" + styles + "'" : "";
	var attrStr = params.attrStr ? " " + params.attrStr : "";
	var disabled = params.disabled;
	var classes = params.classes || [];
	var altText = params.altText;

	var pre = params.wrapInTable ? "<table style='display:inline' cellpadding=0 cellspacing=0 border=0><tr><td align=center valign=bottom>" : "";
    var html = "";
	var post = params.wrapInTable ? "</td></tr></table>" : "";

	if (imageName) {
        var color, m = imageName.match(AjxImg.RE_COLOR);
        if (m) {
            imageName = m && m[1];
            color = m && m[2];
        }

        var className = AjxImg.getClassForImage(imageName, disabled);
        var overlayName = className + "Overlay";
        var maskName = className + "Mask";
        if (color && window.AjxImgData && AjxImgData[overlayName] && AjxImgData[maskName]) {
            color = (color.match(/^\d$/) ? ZmOrganizer.COLOR_VALUES[color] : color) ||
                    ZmOrganizer.COLOR_VALUES[ZmOrganizer.ORG_DEFAULT_COLOR];

            var overlay = AjxImgData[overlayName], mask = AjxImgData[maskName];

            // we're creating IMG elements here, so we can use the alt attribute
            if (altText) {
                attrStr += " alt='" + AjxStringUtil.encodeQuotes(altText) + "'";
            }

            if (!overlay[color]) {
                var width = overlay.w, height = overlay.h;

                var canvas = document.createElement("CANVAS");
                canvas.width = width;
                canvas.height = height;

                var ctx = canvas.getContext("2d");

                ctx.save();
                ctx.clearRect(0,0,width,height);

                ctx.save();
                var imgId = attrStr;
                if (!imgId) {
                    imgId = Dwt.getNextId("CANVAS_IMG_");  //create an imgId in case we need to update the img.src for an element without an id
                    attrStr = " id='" + imgId + "'";
                }
                else {
                    var match = attrStr.match(/id=[\"\']([^\"\']+)[\"\']+/);
                    if (match && match.length > 1) {
                        imgId = match[1]; //extract the ID value
                    }
                    AjxDebug.println(AjxDebug.TAG_ICON, "imgId = " + imgId);
                }
                var maskElement = document.getElementById(maskName);
                var overlayElement = document.getElementById(overlayName);
                if (!maskElement.complete || !overlayElement.complete) {
                    AjxDebug.println(AjxDebug.TAG_ICON, "mask status = " + maskElement.complete + " for " + imgId);
                    AjxDebug.println(AjxDebug.TAG_ICON, "overlay status = " + overlayElement.complete + " for " + imgId);
                    var maskImg = new Image();
                    maskImg.onload = function() {
                        AjxDebug.println(AjxDebug.TAG_ICON, "mask image loaded");
                        var overlayImg = new Image();
                        overlayImg.onload = function() {
                            AjxImg._drawCanvasImage(ctx, maskImg, overlayImg, mask, overlay, color, width, height)
                            AjxDebug.println(AjxDebug.TAG_ICON, "overlay image loaded");
                            var el = document.getElementById(imgId);
                            if (el) {
                                AjxDebug.println(AjxDebug.TAG_ICON, "element found for id = " + imgId);
                                el.src = canvas.toDataURL();
                                overlay[color] = canvas.toDataURL(); //only save if successful
                            }
                            else {
                                AjxDebug.println(AjxDebug.TAG_ICON, "no element found for id = " + imgId);
                            }
                        }
                        overlayImg.src = document.getElementById(overlayName).src;
                    }
                    maskImg.src = document.getElementById(maskName).src;
                }
                else {
                    //image already downloaded
                    AjxImg._drawCanvasImage(ctx, maskElement, overlayElement, mask, overlay, color, width, height);
                    overlay[color] = canvas.toDataURL();
                }
            }

            html = [
                "<img src='", overlay[color], "'"," border=0 ", AjxUtil.getClassAttr(classes), styleStr, attrStr, ">"
            ].join("");
        }
        else {
	        classes.push("Img" + imageName);
            html = [
                "<div ", AjxUtil.getClassAttr(classes), styleStr, attrStr, ">"
            ];
            if (altText) {
                // alt is invalid on DIVs, so use a hidden element
                html.push(
                    "<span class='ScreenReaderOnly'>",
                    AjxStringUtil.htmlEncode(altText),
                    "</span>"
                );
            };
            html.push("</div>");

            html = html.join("");
        }
	}
    else {
        html = [
            "<div", styleStr, attrStr, ">"
        ];
        if (altText) {
            // alt is invalid on DIVs, so use a hidden element
            html.push(
                "<span class='ScreenReaderOnly'>",
                AjxStringUtil.htmlEncode(altText),
                "</span>"
            );
        };
        html.push("</div>");
        html = html.join("");
    }
	return pre || post ? [pre,html,post].join("") : html;
};

/**
 * Gets the "image" as an HTML string.
 *
 * @param imageName		     the image you want to render
 * @param imageStyleStr      optional style info (for example, "display:inline")
 * @param attrStr		     optional attributes (for example, "id=X748")
 * @param label			     the text that follows this image
 * @param containerClassName class to use instead of the default inlineIcon class
 * @return	{string}	     the image string
 */
AjxImg.getImageSpanHtml =
function(imageName, imageStyleStr, attrStr, label, containerClassName) {
    containerClassName = containerClassName || "inlineIcon";
	var html = [
        "<span style='white-space:nowrap'>",
        "<span class='",
        containerClassName,
        "'>",
        AjxImg.getImageHtml(imageName, imageStyleStr, attrStr),
        (label || ""),
        "</span>",
        "</span>"
    ];

	return html.join("");
};

/**
 * Helper method to draw the image using both the mask image and the overlay image
 * 
 * @param ctx  {Object} canvas context
 * @param maskImg   {HtmlElement} mask image object
 * @param overlayImg {HtmlElement} overlay image object
 * @param mask  {Object} mask object
 * @param overlay {Object} overlay object
 * @param color {String} color for fill
 * @param width {int} width
 * @param height {int} height
 * 
 * @private
 */
AjxImg._drawCanvasImage = 
function(ctx, maskImg, overlayImg, mask, overlay, color, width, height) {
	ctx.drawImage(maskImg, mask.l, mask.t);
	ctx.globalCompositeOperation = "source-out";
	ctx.fillStyle = color;
	ctx.fillRect(0, 0, width, height);
	ctx.restore();
	ctx.drawImage(overlayImg, overlay.l, overlay.t);
	ctx.restore();	
};
}
if (AjxPackage.define("ajax.core.AjxColor")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * Creates a color object.
 * @class
 * This class represents a color and is useful for color operations inspired by the code in SkinResources.java.
 * 
 */
AjxColor = function(r, g, b) {
	if (arguments.length == 0) return;
	this.r = r;
	this.g = g;
	this.b = b;
};

/**
 * Returns a string representation of the object.
 * 
 * @return		{string}		a string representation of the object
 */
AjxColor.prototype.toString = function() {
	return AjxColor.color(this.r, this.g, this.b);
};

//
// Static functions
//

/**
 * Returns the RGB components (as an array) of the given color.
 *
 * @param {string}	color 	the color string defined as "#rrggbb"
 * @return	{array}		the color
 */
AjxColor.components = function(color) {
	var m = AjxColor.__RE.exec(color);
	return m ? [parseInt(m[1],16),parseInt(m[2],16),parseInt(m[3],16)] : null;
};

/**
 * Returns a color string of the form "#rrggbb" from the given color
 * components.
 *
 * @param {number}	r the Red component value between 0 and 255, inclusive
 * @param {number}	g the Green component value between 0 and 255, inclusive
 * @param {number}	b the Blue component value between 0 and 255, inclusive
 * @return	{string}	the color string
 */
AjxColor.color = function(r, g, b) {
	return [
		"#",
		AjxColor.__pad(Number(Math.round(r)).toString(16), 2),
		AjxColor.__pad(Number(Math.round(g)).toString(16), 2),
		AjxColor.__pad(Number(Math.round(b)).toString(16), 2)
	].join("");
};

/**
 * Returns a color string that is the inverse of the given color.
 *
 * @param color [string] Color value defined as "#rrggbb".
 */
//AjxColor.invert = function(color) {
//	var n = ~parseInt(color.substr(1),16) & 0x0FFFFFF;
//	return AjxColor.color((n >> 16) & 0x0FF, (n >> 8) & 0x0FF, n & 0x0FF);
//};

/**
 * Lightens the specified color by the given amount.
 *
 * @param {string}	color 	the color value defined as "#rrggbb"
 * @param {number}	delta the amount to change
 * @return	{string}	the color string
 */
AjxColor.lighten = function(color, delta) {
	var comps = AjxColor.components(color);
	return comps ? AjxColor.color(
		AjxColor.__lighten(comps[0],delta),
		AjxColor.__lighten(comps[1],delta),
		AjxColor.__lighten(comps[2],delta)
	) : "";
};

/**
 * Darkens the specified color by the given amount.
 *
 * @param {string}	color 	the color value defined as "#rrggbb"
 * @param {number}	delta the amount to change
 * @return	{string}	the color string
 */
AjxColor.darken = function(color, delta) {
	var comps = AjxColor.components(color);
	return comps ? AjxColor.color(
		AjxColor.__darken(comps[0],delta),
		AjxColor.__darken(comps[1],delta),
		AjxColor.__darken(comps[2],delta)
	) : "";
};

/**
 * Deepens the specified color. This operation is different than darken
 * because it retains the brightness of the color even when it gets
 * darker. Just making a color darker tends to result in a color that
 * is "muddy".
 * <p>
 * The color is deepened by first determining the largest individual
 * component value and then multiplying each component value by the ratio
 * of its value to the largest value. Then, optionally, each value is
 * multiplied by the adjustment value in order to deepen a little more
 * or a little less. Typical adjustment values are around 1 such as .9
 * or 1.1.
 *
 * @param {string}	color 	the color value defined as "#rrggbb"
 * @param {number}		[adjustment]	the multiplier adjustment
 * @return	{string}	the color string
 */
AjxColor.deepen = function(color, adjustment) {
	var comps = AjxColor.components(color);
	var index = 0;
	for (var i = 1; i < comps.length; i++) {
		if (comps[i] > comps[index]) {
			index = i;
		}
	}
	for (var i = 0; i < comps.length; i++) {
		var multiplier = comps[index] ? (comps[i] / comps[index]) : 1;
		comps[i] = Math.floor(comps[i] * multiplier * (adjustment || 1));
	}
	return AjxColor.color(comps[0],comps[1],comps[2]);
};

//
// Private
//

AjxColor.__RE = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})/i;

AjxColor.__pad = function(value, width, prefix) {
	if (!prefix) prefix = "0";
	var s = String(value);
	for (var i = s.length; i < width; i++) {
		s = prefix + s;
	}
	return s;
};

AjxColor.__lighten = function(value, delta) {
	return Math.max(0, Math.min(255, value + (255-value)*delta));
};
AjxColor.__darken = function(value, delta) {
	return Math.max(0, Math.min(255, value + (1-value)*delta));
};
}
if (AjxPackage.define("ajax.events.AjxEvent")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * Default constructor.
 * @class
 * 
 * @private
 */
AjxEvent = function() {
	this.data = null;
}

AjxEvent.HISTORY = "HISTORY";

/**
 * Returns a string representation of the object.
 * 
 * @return	{string}		a string representation of the object
 */
AjxEvent.prototype.toString = 
function() {
	return "AjxEvent";
}
}
if (AjxPackage.define("ajax.events.AjxEventMgr")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * @class
 * This class represents the event manager.
 * 
 * @private
 */
AjxEventMgr = function() {
	this._listeners = new Object();
}

/**
 * Returns a string representation of the object.
 * 
 * @return	{string}		a string representation of the object
 */
AjxEventMgr.prototype.toString = 
function() {
	return "AjxEventMgr";
}

AjxEventMgr.prototype.addListener =
function(eventType, listener, index) {
	var lv = this._listeners[eventType];
	if (lv == null) {
		lv = this._listeners[eventType] = new AjxVector();
	}         	 
	if (!lv.contains(listener)) {
		if (this._notifyingListeners) {
			lv = this._listeners[eventType] = lv.clone();
		}
		lv.add(listener, index);
		return true;
	}
	return false;
}

AjxEventMgr.prototype.notifyListeners =
function(eventType, event) {
	this._notifyingListeners = true;
	var lv = this._listeners[eventType];
	if (lv != null) {
		var a = lv.getArray();
		var s = lv.size();
		var retVal = null;
		var c = null;
		for (var i = 0; i < s; i++) {
			c = a[i];
			// listener must be an AjxListener or a function
			if (!(c && ((c instanceof AjxListener) || (typeof c == "function")))) {
				continue;
			}
			retVal = c.handleEvent ? c.handleEvent(event) : c(event);
			if (retVal === false) {
				break;
			}
		}
	}	
	this._notifyingListeners = false;
	return retVal;
}

AjxEventMgr.prototype.isListenerRegistered =
function(eventType) {
	var lv = this._listeners[eventType];
	return (lv != null && lv.size() > 0);
}

AjxEventMgr.prototype.removeListener = 
function(eventType, listener) {
	var lv = this._listeners[eventType];
	if (lv != null) {
		if (this._notifyingListeners) {
			lv = this._listeners[eventType] = lv.clone();
		}
		lv.remove(listener);
		return true;
	}
	return false;
}

AjxEventMgr.prototype.removeAll = 
function(eventType) {
	var lv = this._listeners[eventType];
	if (lv != null) {
		if (this._notifyingListeners) {
			lv = this._listeners[eventType] = lv.clone();
		}
		lv.removeAll();
		return true;
	}
	return false;
}

AjxEventMgr.prototype.clearAllEvents =
function() {
	var listeners = this._listeners;
    for (var eventType in listeners) {
        this.removeAll(eventType);
    }
};
}
if (AjxPackage.define("ajax.util.AjxTimedAction")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * 
 * @private
 */
AjxTimedAction = function(obj, func, args) {
	AjxCallback.call(this, obj, func, args);
	this._tid = -1;
	this._id = -1;
    this._runResult = null;
}
AjxTimedAction.prototype = new AjxCallback();
AjxTimedAction.prototype.constructor = AjxTimedAction;

// Setting a timeout of 25 days or more appears to revert it
// to 0 in FF3 and Safari3. There's really no reason to set
// it to anything above a few days, so set a max of 20 days.
AjxTimedAction.MAX_TIMEOUT = 20 * 24 * 60 * 60 * 1000;

AjxTimedAction.prototype.toString = 
function() {
	return "AjxTimedAction";
};

AjxTimedAction.prototype.getRunResult =
function() {
    return this._runResult;
};

AjxTimedAction._pendingActions = {};
AjxTimedAction._nextActionId = 1;

AjxTimedAction.scheduleAction =
function(action, timeout){
	if (!action) { return; }
	// if tid already exists, cancel previous timeout before setting a new one
	if (action._tid && action._tid != -1) {
		AjxTimedAction.cancelAction(action._id);
	}

	timeout = timeout || 0; // make sure timeout is numeric
	if (timeout > AjxTimedAction.MAX_TIMEOUT) {
		if (window.DBG) {
			DBG.println(AjxDebug.DBG1, "timeout value above maximum: " + timeout);
		}
		timeout = AjxTimedAction.MAX_TIMEOUT;
	}
	var id = action._id = AjxTimedAction._nextActionId++;
	AjxTimedAction._pendingActions[id] = action;
	var actionStr = "AjxTimedAction._exec(" + id + ")";
	action._tid = window.setTimeout(actionStr, timeout);
	return action._id;
};

AjxTimedAction.cancelAction =
function(actionId) {
	var action = AjxTimedAction._pendingActions[actionId];
	if (action) {
		window.clearTimeout(action._tid);
		delete AjxTimedAction._pendingActions[actionId];
		delete action._tid;
	}
};

AjxTimedAction._exec =
function(actionId) {

	try {

	var action = AjxTimedAction._pendingActions[actionId];
	if (action) {
		delete AjxTimedAction._pendingActions[actionId];
		delete action._tid;
	    action._runResult = action.run();
	}

	} catch (ex) {
		AjxException.reportScriptError(ex);
	}
};

}
if (AjxPackage.define("ajax.net.AjxInclude")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * Utility function (NOT object!) that loads external files in a specified
 * order (thus it'll work fine if scripts have dependencies, you just need to
 * pass them all in the includes array).  If a callback is given, it will be
 * called when all the scripts in the includes array (and possibly dependencies
 * generated by them using document.write) are loaded.
 *
 * Note that scripts are loaded asynchronously -- this function returns
 * immediately, but there's no guarantee that scripts have finished loading by
 * that time.  DO pass a callback if you want to execute code that rely on
 * those scripts.
 *
 * @param {array}	includes 	An array of strings or object; each is the URL to
 *                              some script OR an object with a required src property
 *                              and an optional id property. The id, if specified,
 *                              will be attached to the SCRIPT tag so that the caller
 *                              can access the element later.
 * @param {string}	baseurl 	the URL that will be prepended to scripts with a
 *                            relative address (not starting with http://, ftp:// or /)
 * @param {AjxCallback}	callback the callback will be called when all scripts were processed
 *
 * @author Mihai Bazon
 * 
 * @private
 */
AjxInclude = function(includes, baseurl, callback, proxy) {
	var head = document.getElementsByTagName("head")[0];

	function loadNextScript(script) {
		if (AjxEnv.isIE && script && !/loaded|complete/.test(script.readyState))
			return;
		if (script) {
			// Clear the event handler so IE won't leak.  (Did you know
			// that Microsoft knew about the mem. leak bug in 1998
			// and by the end of 2005 it's still not fixed? :-p
			// http://www.bazon.net/mishoo/home.epl?NEWS_ID=1281 )
			script[AjxInclude.eventName] = null;
		}
		window.status = "";
		if (includes.length > 0) {
            var object = includes.shift();
			var fullurl = typeof object == "string" ? object : object.src;
			var orig = fullurl;
			if (!/^((https?|ftps?):\x2f\x2f|\x2f)/.test(fullurl)) {
				if (baseurl)
					fullurl = baseurl + fullurl;
				if (cacheKillerVersion)
					fullurl += "?v=" + cacheKillerVersion;
			} else if (proxy && fullurl.indexOf('/') != 0) {
 				// fully qualified URL-s will go through our proxy
 				fullurl = proxy + AjxStringUtil.urlEncode(fullurl);
			}
			var script = document.createElement("script");
			var handler = AjxCallback.simpleClosure(loadNextScript, null, script);
			if (script.attachEvent) {
				script.attachEvent("onreadystatechange", handler);
				script.attachEvent("onerror", handler);
			}
            else if (script.addEventListener) {
				script.addEventListener("load", handler, true);
				script.addEventListener("error", handler, true);
			}
			script.type = "text/javascript";
			script.src = fullurl;
			window.status = "Loading script: " + orig;

            var oscript = null;
            if (object.id) {
                script.id = object.id;
                oscript = document.getElementById(object.id);
            }
            if (oscript) {
                oscript.parentNode.replaceChild(script, oscript);
            }
            else {
                head.appendChild(script);
            }
		} else if (includes.length == 0) {
			script = null;
			head = null;
			if (callback)
				callback.run();
		}
	};

	loadNextScript(null);
};
}
if (AjxPackage.define("ajax.events.AjxListener")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
* Creates a new listener.
* @constructor
* @class
* This class represents a listener, which is a function to be called in response to an event.
* A listener is a slightly specialized callback: it has a {@link #handleEvent} method, and it does not
* return a value.
*
* @author Ross Dargahi
* 
* @param {Object}	obj	the object to call the function from
* @param {function}	func	the listener function
* @param {primative|array}	args   the default arguments
* 
* @extends		AjxCallback
*/
AjxListener = function(obj, method, args) {
	AjxCallback.call(this, obj, method, args);
}

AjxListener.prototype = new AjxCallback();
AjxListener.prototype.constructor = AjxListener;

AjxListener.prototype.isAjxListener = true;
AjxListener.prototype.toString = function() { return "AjxListener"; }

/**
* Invoke the listener function.
*
* @param {AjxEvent}		ev		the event object that gets passed to an event handler
*/
AjxListener.prototype.handleEvent =
function(ev) {
	return this.run(ev);
}
}
if (AjxPackage.define("ajax.util.AjxText")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


// NOTE: The API for the classes in this file are inspired by the Java text
//		 formatting classes but the implementation was NOT copied or ported
//		 from the Java sources.

//
// Format class
//

/** 
 * Base class for all formats. To format an object, instantiate the
 * format of your choice and call the <code>format</code> method which
 * returns the formatted string.
 * 
 * @private
 */
AjxFormat = function(pattern) {
    if (arguments.length == 0) { return; }
	this._pattern = pattern;
	this._segments = [];
}

/**
 * Returns a string representation of this object.
 * 
 * @return	{string}	a string representation of this object
 */
AjxFormat.prototype.toString = function() { 
	var s = [];
	s.push("pattern=\"",this._pattern,'"');
	if (this._segments.length > 0) {
		s.push(", segments={ ");
		for (var i = 0; i < this._segments.length; i++) {
			if (i > 0) { s.push(", "); }
			s.push(String(this._segments[i]));
		}
		s.push(" }");
	}
	return s.join("");
};

// Static functions

AjxFormat.initialize = function() {
	AjxDateFormat.initialize();
	AjxNumberFormat.initialize();
};

// Public methods

/** 
 * This method does <em>not</em> need to be overridden unless
 * the subclass doesn't use format segments and takes complete 
 * responsibility for formatting.
 */
AjxFormat.prototype.format = function(object) { 
	var s = [];
	for (var i = 0; i < this._segments.length; i++) {
		s.push(this._segments[i].format(object));
	}
	return s.join("");
};

/** 
 * Parses the given string according to this format's pattern and returns
 * an object.
 * <p>
 * <strong>Note:</strong>
 * The default implementation of this method assumes that the sub-class
 * has implemented the <code>_createParseObject</code> method.
 */
AjxFormat.prototype.parse = function(s) {
	var object = this._createParseObject();
	var index = 0;
	for (var i = 0; i < this._segments.length; i++) {
		var segment = this._segments[i];
		index = segment.parse(object, s, index);
	}
	// REVISIT: Should this return null instead?
	if (index < s.length) {
		throw new AjxFormat.ParsingException(this, null, "input too long"); // I18n
	}
	return object;
};

/** 
 * Returns an array of segments that comprise this format. 
 * <p>
 * <strong>Note:</strong>
 * This method is specific to this implementation and does not follow
 * the format classes found in the <code>java.text</code> package.
 */
AjxFormat.prototype.getSegments = function() {
	return this._segments;
};

/** Returns a string pattern for this format. */
AjxFormat.prototype.toPattern = function() {
	return this._pattern;
};

/** Returns a copy of this format. */
AjxFormat.prototype.clone = function() {
	return new this.constructor(this._pattern);
};

// Protected methods

/**
 * Creates the object that is initialized by parsing
 * <p>
 * <strong>Note:</strong>
 * This must be implemented by sub-classes.
 */
AjxFormat.prototype._createParseObject = function(s) {
	throw new AjxFormat.ParsingException(this, null, "not implemented"); // I18n
};

// Protected static methods

AjxFormat._zeroPad = function(s, length, zeroChar, rightSide) {
	s = typeof s == "string" ? s : String(s);

	if (s.length >= length) return s;

	zeroChar = zeroChar || '0';
	
	var a = [];
	for (var i = s.length; i < length; i++) {
		a.push(zeroChar);
	}
	a[rightSide ? "unshift" : "push"](s);

	return a.join("");
};

//
// Format exception base class
//

AjxFormat.FormatException = function(format, message) {
	this._format = format;
	this._message = message;
};
AjxFormat.FormatException.prototype.toString = function() { 
	return this._message; 
};


//
// Formatting exception class
//

AjxFormat.FormattingException = function(format, segment, message) {
	AjxFormat.FormatException.call(this, format, message);
	this._segment = segment;
};
AjxFormat.FormattingException.prototype = new AjxFormat.FormatException;
AjxFormat.FormattingException.prototype.constructor = AjxFormat.FormattingException;


//
// Parsing exception class
//

AjxFormat.ParsingException = function(format, segment, message) {
	AjxFormat.FormatException.call(this, format, message);
	this._segment = segment;
};
AjxFormat.ParsingException.prototype = new AjxFormat.FormatException;
AjxFormat.ParsingException.prototype.constructor = AjxFormat.ParsingException;

//
// Segment class
//

AjxFormat.Segment = function(format, s) {
    if (arguments.length == 0) return;
	this._parent = format;
	this._s = s;
};

AjxFormat.Segment.prototype.toString = function() { 
	return "segment: \""+this._s+'"'; 
};

// Public methods

AjxFormat.Segment.prototype.format = function(o) { 
	return this._s; 
};

/**
 * Parses the string at the given index, initializes the parse object
 * (as appropriate), and returns the new index within the string for
 * the next parsing step.
 * <p>
 * <strong>Note:</strong>
 * This method must be implemented by sub-classes.
 *
 * @param o     [object] The parse object to be initialized.
 * @param s     [string] The input string to be parsed.
 * @param index [number] The index within the string to start parsing.
 */
AjxFormat.Segment.prototype.parse = function(o, s, i) {
	throw new AjxFormat.ParsingException(this._parent, this, "not implemented"); // I18n
};

AjxFormat.Segment.prototype.getFormat = function() {
	return this._parent;
};
AjxFormat.Segment.prototype.toSubPattern = function() {
	return this._s;
};

// Protected methods

AjxFormat.Segment.prototype._getFixedLength = function() {
	var fixedlen;
	if (this._index + 1 < this._parent._segments.length) {
		var nextSegment = this._parent._segments[this._index + 1];
		if (!(nextSegment instanceof AjxFormat.TextSegment)) {
			fixedlen = this._s.length;
		}
	}
	return fixedlen;
};

// Protected static methods

AjxFormat.Segment._parseLiteral = function(literal, s, index) {
	if (s.length - index < literal.length) {
		throw new AjxFormat.ParsingException(this._parent, this, "input too short"); // I18n
	}
	for (var i = 0; i < literal.length; i++) {
		if (literal.charAt(i) != s.charAt(index + i)) {
			throw new AjxFormat.ParsingException(this._parent, this, "input doesn't match"); // I18n
		}
	}
	return index + literal.length;
};

AjxFormat.Segment._parseLiterals = function(o, f, adjust, literals, s, index) {
	for (var i = 0; i < literals.length; i++) {
		try {
			var literal = literals[i];
			var nindex = AjxFormat.Segment._parseLiteral(literal, s, index);
			if (f) {
				var target = o || window;
				if (typeof f == "function") {
					f.call(target, i + adjust);
				}
				else {
					target[f] = i + adjust;
				}
			}
			return nindex;
		}
		catch (e) {
			// ignore. keep trying to find a match
		}
	}
	return -1;
};

/**
 * Parses an integer at the offset of the given string and calls a
 * method on the specified object.
 *
 * @param o         [object]   The target object.
 * @param f         [function|string] The method to call on the target object.
 *                             If this parameter is a string, then it is used
 *                             as the name of the property to set on the
 *                             target object.
 * @param adjust    [number]   The numeric adjustment to make on the
 *                             value before calling the object method.
 * @param s         [string]   The string to parse.
 * @param index     [number]   The index within the string to start parsing.
 * @param fixedlen  [number]   If specified, specifies the required number
 *                             of digits to be parsed.
 * @param radix     [number]   Optional. Specifies the radix of the parse
 *                             string. Defaults to 10 if not specified.
 */
AjxFormat.Segment._parseInt = function(o, f, adjust, s, index, fixedlen, radix) {
	var len = fixedlen || s.length - index;
	var head = index;
	for (var i = 0; i < len; i++) {
		if (!s.charAt(index++).match(/\d/)) {
			index--;
			break;
		}
	}
	var tail = index;
	if (head == tail) {
		throw new AjxFormat.ParsingException(this._parent, this, "number not present"); // I18n
	}
	if (fixedlen && tail - head != fixedlen) {
		throw new AjxFormat.ParsingException(this._parent, this, "number too short"); // I18n
	}
	var value = parseInt(s.substring(head, tail), radix || 10);
	if (f) {
		var target = o || window;
		if (typeof f == "function") {
			f.call(target, value + adjust);
		}
		else {
			target[f] = value + adjust;
		}
	}
	return tail;
};

//
// Date format class
//

/**
 * The AjxDateFormat class formats Date objects according to a specified 
 * pattern. The patterns are defined the same as the SimpleDateFormat
 * class in the Java libraries. <strong>Note:</strong> <em>Only the
 * Gregorian Calendar is supported at this time.</em> Supporting other
 * calendars would require a lot more information downloaded to the
 * client. Limiting dates to the Gregorian calendar is a trade-off.
 * <p>
 * <strong>Note:</strong>
 * The date format differs from the Java patterns a few ways: the pattern
 * "EEEEE" (5 'E's) denotes a <em>short</em> weekday and the pattern "MMMMM"
 * (5 'M's) denotes a <em>short</em> month name. This matches the extended 
 * pattern found in the Common Locale Data Repository (CLDR) found at: 
 * http://www.unicode.org/cldr/.
 *
 * @param {string} pattern The date format pattern.
 *
 * @class
 * @constructor
 */
AjxDateFormat = function(pattern) {
    if (arguments.length == 0) { return; }
	AjxFormat.call(this, pattern);
	if (pattern == null) { return; }
	if (typeof pattern == "number") {
		switch (pattern) {
			case AjxDateFormat.SHORT: pattern = I18nMsg.formatDateShort; break;
			case AjxDateFormat.MEDIUM: pattern = I18nMsg.formatDateMedium; break;
			case AjxDateFormat.LONG: pattern = I18nMsg.formatDateLong; break;
			case AjxDateFormat.FULL: pattern = I18nMsg.formatDateFull; break;
            case AjxDateFormat.NUMBER: pattern = I18nMsg.formatDateNumber; break;
		}
	}	
	for (var i = 0; i < pattern.length; i++) {
		// literal
		var c = pattern.charAt(i);
		if (c == "'") {
			var head = i + 1;
			for (i++ ; i < pattern.length; i++) {
				var c = pattern.charAt(i);
				if (c == "'") {
					if (i + 1 < pattern.length && pattern.charAt(i + 1) == "'") {
						pattern = pattern.substr(0, i) + pattern.substr(i + 1);
					}
					else {
						break;
					}
				}
			}
//			if (i == pattern.length) {
				// NOTE: try to avoid silent errors
//				throw new FormatException(this, "unterminated string literal"); // I18n
//			}
			var tail = i;
			var segment = new AjxFormat.TextSegment(this, pattern.substring(head, tail));
			this._segments.push(segment);
			continue;
		}

		// non-meta chars
		var head = i;
		while(i < pattern.length) {
			c = pattern.charAt(i);
			if (AjxDateFormat._META_CHARS.indexOf(c) != -1 || c == "'") {
				break;
			}
			i++;
		}
		var tail = i;
		if (head != tail) {
			var segment = new AjxFormat.TextSegment(this, pattern.substring(head, tail));
			this._segments.push(segment);
			i--;
			continue;
		}
		
		// meta char
		var head = i;
		while(++i < pattern.length) {
			if (pattern.charAt(i) != c) {
				break;
			}		
		}
		var tail = i--;
		var count = tail - head;
		var field = pattern.substr(head, count);
		var segment = null;
		switch (c) {
			case 'G': segment = new AjxDateFormat.EraSegment(this, field); break;
			case 'y': segment = new AjxDateFormat.YearSegment(this, field); break;
			case 'M': segment = new AjxDateFormat.MonthSegment(this, field); break;
			case 'w': segment = new AjxDateFormat.WeekSegment(this, field); break;
			case 'W': segment = new AjxDateFormat.WeekSegment(this, field); break;
			case 'D': segment = new AjxDateFormat.DaySegment(this, field); break;
			case 'd': segment = new AjxDateFormat.DaySegment(this, field); break;
			case 'F': segment = new AjxDateFormat.WeekdaySegment(this, field); break;
			case 'E': segment = new AjxDateFormat.WeekdaySegment(this, field); break;
			case 'a': segment = new AjxDateFormat.AmPmSegment(this, field); break;
			case 'H': segment = new AjxDateFormat.HourSegment(this, field); break;
			case 'k': segment = new AjxDateFormat.HourSegment(this, field); break;
			case 'K': segment = new AjxDateFormat.HourSegment(this, field); break;
			case 'h': segment = new AjxDateFormat.HourSegment(this, field); break;
			case 'm': segment = new AjxDateFormat.MinuteSegment(this, field); break;
			case 's': segment = new AjxDateFormat.SecondSegment(this, field); break;
			case 'S': segment = new AjxDateFormat.SecondSegment(this, field); break;
			case 'z': segment = new AjxDateFormat.TimezoneSegment(this, field); break;
			case 'Z': segment = new AjxDateFormat.TimezoneSegment(this, field); break;
		}
		if (segment != null) {
			segment._index = this._segments.length;
			this._segments.push(segment);
		}
	}
}
AjxDateFormat.prototype = new AjxFormat;
AjxDateFormat.prototype.constructor = AjxDateFormat;

AjxDateFormat.prototype.toString = function() {
	return "[AjxDateFormat: "+AjxFormat.prototype.toString.call(this)+"]";
};

// Constants

/** Short date/time format style. */
AjxDateFormat.SHORT = 0;
/** Medium date/time format style. */
AjxDateFormat.MEDIUM = 1;
/** Long date/time format style. */
AjxDateFormat.LONG = 2;
/** Full date/time format style. */
AjxDateFormat.FULL = 3;
/** Default date/time format style. */
AjxDateFormat.DEFAULT = AjxDateFormat.MEDIUM;

AjxDateFormat._META_CHARS = "GyMwWDdFEaHkKhmsSzZ";

/** Number date . */
AjxDateFormat.NUMBER = 4;
// Static methods

/**
 * Get a date formatter.
 *
 * @param style The format style.
 * @return {AjxDateFormat} The date formatter.
 *
 * @see {AjxDateFormat.SHORT}
 * @see {AjxDateFormat.MEDIUM}
 * @see {AjxDateFormat.LONG}
 * @see {AjxDateFormat.FULL}
 */
AjxDateFormat.getDateInstance = function(style) {
	// lazily create formatters
	style = style != null ? style : AjxDateFormat.DEFAULT;
	if (!AjxDateFormat._DATE_FORMATTERS[style]) {
		AjxDateFormat._DATE_FORMATTERS[style] = new AjxDateFormat(AjxDateFormat._dateFormats[style]);
	}
	return AjxDateFormat._DATE_FORMATTERS[style];
};

/**
 * Get a time formatter.
 *
 * @param style The format style.
 * @return {AjxDateFormat} The time formatter.
 *
 * @see {AjxDateFormat.SHORT}
 * @see {AjxDateFormat.MEDIUM}
 * @see {AjxDateFormat.LONG}
 * @see {AjxDateFormat.FULL}
 */
AjxDateFormat.getTimeInstance = function(style) {
	// lazily create formatters
	style = style != null ? style : AjxDateFormat.DEFAULT;
	if (!AjxDateFormat._TIME_FORMATTERS[style]) {
		AjxDateFormat._TIME_FORMATTERS[style] = new AjxDateFormat(AjxDateFormat._timeFormats[style]);
	}
	return AjxDateFormat._TIME_FORMATTERS[style];
};

/**
 * Get a date and time formatter.
 *
 * @param dateStyle The format style for the date.
 * @param timeStyle The format style for the time.
 * @return {AjxDateFormat} The date and time formatter. 
 *
 * @see {AjxDateFormat.SHORT}
 * @see {AjxDateFormat.MEDIUM}
 * @see {AjxDateFormat.LONG}
 * @see {AjxDateFormat.FULL}
 */
AjxDateFormat.getDateTimeInstance = function(dateStyle, timeStyle) {
	// lazily create formatters
	dateStyle = dateStyle != null ? dateStyle : AjxDateFormat.DEFAULT;
	timeStyle = timeStyle != null ? timeStyle : AjxDateFormat.DEFAULT;
	var style = dateStyle * 10 + timeStyle;
	if (!AjxDateFormat._DATETIME_FORMATTERS[style]) {
		var pattern = I18nMsg.formatDateTime;
		var params = [ AjxDateFormat._dateFormats[dateStyle], AjxDateFormat._timeFormats[timeStyle] ];
		
		var dateTimePattern = AjxMessageFormat.format(pattern, params);
		AjxDateFormat._DATETIME_FORMATTERS[style] = new AjxDateFormat(dateTimePattern);
	}
	return AjxDateFormat._DATETIME_FORMATTERS[style];
};

/**
 * Format a date. Equivalent to <code>new AjxDateFormat(pattern).format(date)</code>.
 *
 * @param {string} pattern  The format.
 * @param {Date}   date     The date to format.
 * @return {string} The formatted string.
 */
AjxDateFormat.format = function(pattern, date) {
	return new AjxDateFormat(pattern).format(date);
};

/**
 * Parse a date. Equivalent to <code>new AjxDateFormat(pattern).parse(dateStr)</code>.
 *
 * @param {string} pattern  The format.
 * @param {string} dateStr  The input string to parse.
 * @return {Date} The parsed date object.
 */
AjxDateFormat.parse = function(pattern, dateStr) {
	return new AjxDateFormat(pattern).parse(dateStr);
};

AjxDateFormat.initialize = function() {
	// format
	AjxDateFormat._dateFormats = [
		I18nMsg.formatDateShort, I18nMsg.formatDateMedium,
		I18nMsg.formatDateLong, I18nMsg.formatDateFull,I18nMsg.formatDateNumber
	];
	AjxDateFormat._timeFormats = [
		I18nMsg.formatTimeShort, I18nMsg.formatTimeMedium,
		I18nMsg.formatTimeLong, I18nMsg.formatTimeFull
	];
	AjxDateFormat._timeParsers = [];
	for (var i=1, fmt; fmt = I18nMsg["parseTime"+i]; i++) {
		AjxDateFormat._timeParsers.push(new RegExp(fmt,"i"));
	}
	

	AjxDateFormat._DATE_FORMATTERS = {};
	AjxDateFormat._TIME_FORMATTERS = {};
	AjxDateFormat._DATETIME_FORMATTERS = {};

	// segments
	AjxDateFormat.MonthSegment.initialize();
	AjxDateFormat.WeekdaySegment.initialize();
};

// Public methods

/**
 * Parses the given time using one of the AjxDateFormat._timeParsers, which are regexes defined in the properties
 */
AjxDateFormat.parseTime = function(timeStr) {
	for (var i=0; i<AjxDateFormat._timeParsers.length; i++) {
		var result = AjxDateFormat._timeParsers[i].exec(timeStr);
		if (result) {
			var hours = parseInt(result[1],10) || 0;
			var minutes = parseInt(result[2],10) || 0;
			var ampm = result[3];
			if (ampm) {
				var pmChars = I18nMsg.parseTimePMChars;
				if (hours == 12) {
					hours = 0;
				}
				if (pmChars.indexOf(ampm)!=-1) {
					hours += 12;
				}
			}
			if (hours < 24 && minutes < 60) {
				date = new Date();
				date.setHours(hours);
				date.setMinutes(minutes);
				date.setSeconds(0);
				return date;
			}
		}
	}
};

/** 
 * Parses the given string and returns a date. If the string cannot be
 * parsed as a date, <code>null</code> is returned.
 *
 * @param {string} s The string to parse.
 * @return {Date} The parsed date object.
 */
AjxDateFormat.prototype.parse = function(s) {
	var object = null;
	try {
		object = AjxFormat.prototype.parse.call(this, s);
		
		// set the date components in proper order

		// Use day 2 for the initial date - even if the setFullYear call screws up (see Bugzilla@Mozilla,
		// Bug 1079720), it won't get the wrong year.
		var date = new Date(0, 0, 2, 0, 0, 0, 0);
		if (object.year != null) { date.setFullYear(object.year); }
		if (object.month != null) { date.setMonth(object.month); }
		// To insure the same behavior (if object does not set the day), init the day to 1.
		date.setDate(1);
		if (object.dayofmonth != null) { date.setDate(object.dayofmonth); }
		else if (object.dayofyear != null) { date.setMonth(0, object.dayofyear); }
		if (object.hours != null) { date.setHours(object.hours); }
		if (object.minutes != null) { date.setMinutes(object.minutes); }
		if (object.seconds != null) { date.setSeconds(object.seconds); }
		if (object.milliseconds != null) { date.setMilliseconds(object.milliseconds); }
		if (object.ampm != null) {
			var hours = date.getHours();
			if (hours == 12 && object.ampm == 0) {
				hours = 0;
			}
			else if (hours != 12 && object.ampm == 1) {
				hours += 12;
			}
			date.setHours(hours);
		}
        if (object.timezone != null) { date.setMinutes(date.getMinutes() - object.timezone); }
		// TODO: era

		if (isNaN(date.getTime())) {
			return null; //in some cases (see bug 51266) the date is invalid without throwing an exception. return null in this case 
		}

		object = date;
	}
	catch (e) {
        DBG.println(AjxDebug.DBG3, e);
		// do nothing
	}
	return object;
};

// Protected methods

AjxDateFormat.prototype._createParseObject = function() {
	// NOTE: An object to hold the parsed parts is returned instead of
	//       a Date object because setting the day is dependent on which
	//       year is set. For example, if the user parsed "2/29/2008",
	//       which is a leap year, with the pattern "M/d/yyyy", then the
	//       year must be set before the month and date or else the Date
	//       object will roll it over to Mar 1.
	return { 
		year: null, month: null, dayofmonth: null, dayofyear: null,
		hours: null, minutes: null, seconds: null, milliseconds: null,
		ampm: null, era: null, timezone: null
	};
};

//
// Text segment class
//

AjxFormat.TextSegment = function(format, s) {
    if (arguments.length == 0) return;
	AjxFormat.Segment.call(this, format, s);
};
AjxFormat.TextSegment.prototype = new AjxFormat.Segment;
AjxFormat.TextSegment.prototype.constructor = AjxFormat.TextSegment;

AjxFormat.TextSegment.prototype.toString = function() { 
	return "text: \""+this._s+'"'; 
};

// Public methods

AjxFormat.TextSegment.prototype.parse = function(o, s, index) {
	return AjxFormat.Segment._parseLiteral(this._s, s, index);
};

//
// Date segment class
//

AjxDateFormat.DateSegment = function(format, s) {
    if (arguments.length == 0) return;
	AjxFormat.Segment.call(this, format, s);
}
AjxDateFormat.DateSegment.prototype = new AjxFormat.Segment;
AjxDateFormat.DateSegment.prototype.constructor = AjxDateFormat.DateSegment;

//
// Date era segment class
//

AjxDateFormat.EraSegment = function(format, s) {
    if (arguments.length == 0) return;
	AjxDateFormat.DateSegment.call(this, format, s);
};
AjxDateFormat.EraSegment.prototype = new AjxDateFormat.DateSegment;
AjxDateFormat.EraSegment.prototype.constructor = AjxDateFormat.EraSegment;

AjxDateFormat.EraSegment.prototype.toString = function() { 
	return "dateEra: \""+this._s+'"'; 
};

// Public methods

AjxDateFormat.EraSegment.prototype.format = function(date) { 
	// NOTE: Only support current era at the moment...
	return I18nMsg.eraAD;
};

//
// Date year segment class
//

AjxDateFormat.YearSegment = function(format, s) {
    if (arguments.length == 0) return;
	AjxDateFormat.DateSegment.call(this, format, s);
};
AjxDateFormat.YearSegment.prototype = new AjxDateFormat.DateSegment;
AjxDateFormat.YearSegment.prototype.constructor = AjxDateFormat.YearSegment;

AjxDateFormat.YearSegment.prototype.toString = function() { 
	return "dateYear: \""+this._s+'"'; 
};

// Public methods

AjxDateFormat.YearSegment.prototype.format = function(date) { 
	var year = String(date.getFullYear());
	return this._s.length < 4 ? year.substr(year.length - 2) : AjxFormat._zeroPad(year, this._s.length);
};

AjxDateFormat.YearSegment.prototype.parse = function(object, s, index) {
	var fixedlen = this._getFixedLength();
	var nindex = AjxFormat.Segment._parseInt(object, "year", 0, s, index, fixedlen);
	// adjust 2-digit years
	if (nindex - index == 2) {
		if (!AjxDateFormat._2digitStartYear) {
			AjxDateFormat._2digitStartYear = parseInt(AjxMsg.dateParsing2DigitStartYear);
		}
		var syear = AjxDateFormat._2digitStartYear;
		var pyear = parseInt(s.substr(index,2), 10);
		var century = (Math.floor(syear / 100) + (pyear < (syear % 100) ? 1 : 0)) * 100;
		var year = century + pyear;
		object.year = year;
	}
	return nindex;
};

//
// Date month segment class
//

AjxDateFormat.MonthSegment = function(format, s) {
    if (arguments.length == 0) return;
	AjxDateFormat.DateSegment.call(this, format, s);
};
AjxDateFormat.MonthSegment.prototype = new AjxDateFormat.DateSegment;
AjxDateFormat.MonthSegment.prototype.constructor = AjxDateFormat.MonthSegment;

AjxDateFormat.MonthSegment.prototype.toString = function() { 
	return "dateMonth: \""+this._s+'"'; 
};

// Static functions

AjxDateFormat.MonthSegment.initialize = function() {
	AjxDateFormat.MonthSegment.MONTHS = {};
	AjxDateFormat.MonthSegment.MONTHS[AjxDateFormat.SHORT] = [
		AjxMsg.monthJanShort, AjxMsg.monthFebShort, AjxMsg.monthMarShort,
		AjxMsg.monthAprShort, AjxMsg.monthMayShort, AjxMsg.monthJunShort,
		AjxMsg.monthJulShort, AjxMsg.monthAugShort, AjxMsg.monthSepShort,
		AjxMsg.monthOctShort, AjxMsg.monthNovShort, AjxMsg.monthDecShort
	];
	AjxDateFormat.MonthSegment.MONTHS[AjxDateFormat.MEDIUM] = [
		I18nMsg.monthJanMedium, I18nMsg.monthFebMedium, I18nMsg.monthMarMedium,
		I18nMsg.monthAprMedium, I18nMsg.monthMayMedium, I18nMsg.monthJunMedium,
		I18nMsg.monthJulMedium, I18nMsg.monthAugMedium, I18nMsg.monthSepMedium,
		I18nMsg.monthOctMedium, I18nMsg.monthNovMedium, I18nMsg.monthDecMedium
	];
	AjxDateFormat.MonthSegment.MONTHS[AjxDateFormat.LONG] = [
		I18nMsg.monthJanLong, I18nMsg.monthFebLong, I18nMsg.monthMarLong,
		I18nMsg.monthAprLong, I18nMsg.monthMayLong, I18nMsg.monthJunLong,
		I18nMsg.monthJulLong, I18nMsg.monthAugLong, I18nMsg.monthSepLong,
		I18nMsg.monthOctLong, I18nMsg.monthNovLong, I18nMsg.monthDecLong
	];
};

// Public methods

AjxDateFormat.MonthSegment.prototype.format = function(date) {
	var month = date.getMonth();
	switch (this._s.length) {
		case 1: return String(month + 1);
		case 2: return AjxFormat._zeroPad(month + 1, 2);
		case 3: return AjxDateFormat.MonthSegment.MONTHS[AjxDateFormat.MEDIUM][month];
		case 5: return AjxDateFormat.MonthSegment.MONTHS[AjxDateFormat.SHORT][month];
	}
	return AjxDateFormat.MonthSegment.MONTHS[AjxDateFormat.LONG][month];
};

AjxDateFormat.MonthSegment.prototype.parse = function(object, s, index) {
	var months;
	switch (this._s.length) {
		case 3: 
			months = AjxDateFormat.MonthSegment.MONTHS[AjxDateFormat.MEDIUM];
		case 4: 
			months = months || AjxDateFormat.MonthSegment.MONTHS[AjxDateFormat.LONG];
		case 5: {
			months = months || AjxDateFormat.MonthSegment.MONTHS[AjxDateFormat.SHORT];
			var nindex = AjxFormat.Segment._parseLiterals(object, "month", 0, months, s, index);
			if (nindex == -1) {
				throw new AjxFormat.ParsingException(this._parent, this, "no match"); // I18n
			}
			return nindex;
		}
	}
	var fixedlen = this._getFixedLength();
	return AjxFormat.Segment._parseInt(object, "month", -1, s, index, fixedlen);
};

//
// Date week segment class
//

AjxDateFormat.WeekSegment = function(format, s) {
    if (arguments.length == 0) return;
	AjxDateFormat.DateSegment.call(this, format, s);
};
AjxDateFormat.WeekSegment.prototype = new AjxDateFormat.DateSegment;
AjxDateFormat.WeekSegment.prototype.constructor = AjxDateFormat.WeekSegment;

AjxDateFormat.WeekSegment.prototype.toString = function() { 
	return "weekMonth: \""+this._s+'"'; 
};

// Public methods

AjxDateFormat.WeekSegment.prototype.format = function(date) {
	var year = date.getYear();
	var month = date.getMonth();
	var day = date.getDate();
	
	var ofYear = /w/.test(this._s);
	var date2 = new Date(year, ofYear ? 0 : month, 1);

	var week = 0;
	while (true) {
		week++;
		if (date2.getMonth() > month || (date2.getMonth() == month && date2.getDate() >= day)) {
			break;
		}
		date2.setDate(date2.getDate() + 7);
	}

	return AjxFormat._zeroPad(week, this._s.length);
};

AjxDateFormat.WeekSegment.prototype.parse = function(object, s, index) {
	var fixedlen = this._getFixedLength();
	return AjxFormat.Segment._parseInt(null, null, 0, s, index, fixedlen)
};

//
// Date day segment class
//

AjxDateFormat.DaySegment = function(format, s) {
    if (arguments.length == 0) return;
	AjxDateFormat.DateSegment.call(this, format, s);
};
AjxDateFormat.DaySegment.prototype = new AjxDateFormat.DateSegment;
AjxDateFormat.DaySegment.prototype.constructor = AjxDateFormat.DaySegment;

AjxDateFormat.DaySegment.prototype.toString = function() { 
	return "dateDay: \""+this._s+'"'; 
};

// Public methods

AjxDateFormat.DaySegment.prototype.format = function(date) {
	var month = date.getMonth();
	var day = date.getDate();
	if (/D/.test(this._s) && month > 0) {
		var year = date.getYear();
		do {
			// set date to first day of month and then go back one day
			var date2 = new Date(year, month, 1);
			date2.setDate(0); 
			
			day += date2.getDate();
			month--;
		} while (month > 0);
	}
	return AjxFormat._zeroPad(day, this._s.length);
};

AjxDateFormat.DaySegment.prototype.parse = function(object, s, index) {
	var fixedlen = this._getFixedLength();
    var dayofmonth = function(day) {
                      if(day > AjxDateUtil.MAX_DAYS_PER_MONTH) { throw new AjxFormat.ParsingException(this._parent, this, "number too long"); }
                      else { object["dayofmonth"] = day; }
                     };
	var pname = /D/.test(this._s) ? "dayofyear" : dayofmonth;
	return AjxFormat.Segment._parseInt(object, pname, 0, s, index, fixedlen);
};

//
// Date weekday segment class
//

AjxDateFormat.WeekdaySegment = function(format, s) {
    if (arguments.length == 0) return;
	AjxDateFormat.DateSegment.call(this, format, s);
};
AjxDateFormat.WeekdaySegment.prototype = new AjxDateFormat.DateSegment;
AjxDateFormat.WeekdaySegment.prototype.constructor = AjxDateFormat.WeekdaySegment;

AjxDateFormat.DaySegment.prototype.toString = function() { 
	return "dateDay: \""+this._s+'"'; 
};

// Static functions

AjxDateFormat.WeekdaySegment.initialize = function() {
	AjxDateFormat.WeekdaySegment.WEEKDAYS = {};
	// NOTE: The short names aren't available in Java so we have to define them.
	AjxDateFormat.WeekdaySegment.WEEKDAYS[AjxDateFormat.SHORT] = [
		AjxMsg.weekdaySunShort, AjxMsg.weekdayMonShort, AjxMsg.weekdayTueShort,
		AjxMsg.weekdayWedShort, AjxMsg.weekdayThuShort, AjxMsg.weekdayFriShort,
		AjxMsg.weekdaySatShort
	];
	AjxDateFormat.WeekdaySegment.WEEKDAYS[AjxDateFormat.MEDIUM] = [
		I18nMsg.weekdaySunMedium, I18nMsg.weekdayMonMedium, I18nMsg.weekdayTueMedium,
		I18nMsg.weekdayWedMedium, I18nMsg.weekdayThuMedium, I18nMsg.weekdayFriMedium,
		I18nMsg.weekdaySatMedium
	];
	AjxDateFormat.WeekdaySegment.WEEKDAYS[AjxDateFormat.LONG] = [
		I18nMsg.weekdaySunLong, I18nMsg.weekdayMonLong, I18nMsg.weekdayTueLong,
		I18nMsg.weekdayWedLong, I18nMsg.weekdayThuLong, I18nMsg.weekdayFriLong,
		I18nMsg.weekdaySatLong
	];
};

// Public methods

AjxDateFormat.WeekdaySegment.prototype.format = function(date) {
	var weekday = date.getDay();
	if (/E/.test(this._s)) {
		var style;
		switch (this._s.length) {
			case 4: style = AjxDateFormat.LONG; break;
			case 5: style = AjxDateFormat.SHORT; break;
			default: style = AjxDateFormat.MEDIUM;
		}
		return AjxDateFormat.WeekdaySegment.WEEKDAYS[style][weekday];
	}
	return AjxFormat._zeroPad(weekday, this._s.length);
};

AjxDateFormat.WeekdaySegment.prototype.parse = function(object, s, index) {
	var weekdays;
	switch (this._s.length) {
		case 3: 
			weekdays = AjxDateFormat.WeekdaySegment.WEEKDAYS[AjxDateFormat.MEDIUM];
		case 4: 
			weekdays = weekdays || AjxDateFormat.WeekdaySegment.WEEKDAYS[AjxDateFormat.LONG];
		case 5: {
			weekdays = weekdays || AjxDateFormat.WeekdaySegment.WEEKDAYS[AjxDateFormat.SHORT];
			var nindex = AjxFormat.Segment._parseLiterals(null, null, 0, weekdays, s, index);
			if (nindex == -1) {
				throw new AjxFormat.ParsingException(this._parent, this, "no match"); // I18n
			}
			return nindex;
		}
	}
	var fixedlen = this._getFixedLength();
	return AjxFormat.Segment._parseInt(null, null, 0, s, index, fixedlen);
};

//
// Time segment class
//

AjxDateFormat.TimeSegment = function(format, s) {
    if (arguments.length == 0) return;
	AjxFormat.Segment.call(this, format, s);
};
AjxDateFormat.TimeSegment.prototype = new AjxFormat.Segment;
AjxDateFormat.TimeSegment.prototype.constructor = AjxDateFormat.TimeSegment;

//
// Time hour segment class
//

AjxDateFormat.HourSegment = function(format, s) {
    if (arguments.length == 0) return;
	AjxFormat.Segment.call(this, format, s);
};
AjxDateFormat.HourSegment.prototype = new AjxDateFormat.TimeSegment;
AjxDateFormat.HourSegment.prototype.constructor = AjxDateFormat.HourSegment;

AjxDateFormat.HourSegment.prototype.toString = function() { 
	return "timeHour: \""+this._s+'"'; 
};

// Public methods

AjxDateFormat.HourSegment.prototype.format = function(date) {
	//getHours returns 0-23
	var hours = date.getHours();
    if (hours > 12 && /[hK]/.test(this._s)) {
		//changing 13-23 to 1-11 (pm)
		hours -= 12;
	}
    else if (hours == 0 && /[h]/.test(this._s)) {
		//h: 1-12 am/pm
        hours = 12;
    }
	else if (hours === 12 && /K/.test(this._s)) {
		//K: 0-11 am/pm
		hours = 0;
 	}
	else if (hours === 0 && /k/.test(this._s)) {
		//k: 1-24
		hours = 24;
	}
    /***
	// NOTE: This is commented out to match the Java formatter output
	//       but from the comments for these meta-chars, it doesn't
	//       seem right.
	if (/[Hk]/.test(this._s)) {
		hours--;
	}
	/***/
	return AjxFormat._zeroPad(hours, this._s.length);
};

AjxDateFormat.HourSegment.prototype.parse = function(object, s, index) {
	var fixedlen = this._getFixedLength();
	return AjxFormat.Segment._parseInt(object, "hours", 0, s, index, fixedlen);
};

//
// Time minute segment class
//

AjxDateFormat.MinuteSegment = function(format, s) {
    if (arguments.length == 0) return;
	AjxFormat.Segment.call(this, format, s);
};
AjxDateFormat.MinuteSegment.prototype = new AjxDateFormat.TimeSegment;
AjxDateFormat.MinuteSegment.prototype.constructor = AjxDateFormat.MinuteSegment;

AjxDateFormat.MinuteSegment.prototype.toString = function() { 
	return "timeMinute: \""+this._s+'"'; 
};

// Public methods

AjxDateFormat.MinuteSegment.prototype.format = function(date) {
	var minutes = date.getMinutes();
	return AjxFormat._zeroPad(minutes, this._s.length);
};

AjxDateFormat.MinuteSegment.prototype.parse = function(object, s, index) {
	var fixedlen = this._getFixedLength();
	return AjxFormat.Segment._parseInt(object, "minutes", 0, s, index, fixedlen);
};

//
// Time second segment class
//

AjxDateFormat.SecondSegment = function(format, s) {
    if (arguments.length == 0) return;
	AjxFormat.Segment.call(this, format, s);
};
AjxDateFormat.SecondSegment.prototype = new AjxDateFormat.TimeSegment;
AjxDateFormat.SecondSegment.prototype.constructor = AjxDateFormat.SecondSegment;

AjxDateFormat.SecondSegment.prototype.toString = function() { 
	return "timeSecond: \""+this._s+'"'; 
};

// Public methods

AjxDateFormat.SecondSegment.prototype.format = function(date) {
	var minutes = /s/.test(this._s) ? date.getSeconds() : date.getMilliseconds();
	return AjxFormat._zeroPad(minutes, this._s.length);
};

AjxDateFormat.SecondSegment.prototype.parse = function(object, s, index) {
    var isSeconds = /s/.test(this._s);
    var pname = isSeconds ? "seconds" : "milliseconds";
	var fixedlen = isSeconds ? this._getFixedLength() : 0;
	return AjxFormat.Segment._parseInt(object, pname, 0, s, index, fixedlen);
};

//
// Time am/pm segment class
//

AjxDateFormat.AmPmSegment = function(format, s) {
    if (arguments.length == 0) return;
	AjxFormat.Segment.call(this, format, s);
};
AjxDateFormat.AmPmSegment.prototype = new AjxDateFormat.TimeSegment;
AjxDateFormat.AmPmSegment.prototype.constructor = AjxDateFormat.AmPmSegment;

AjxDateFormat.AmPmSegment.prototype.toString = function() { 
	return "timeAmPm: \""+this._s+'"'; 
};

// Public methods

AjxDateFormat.AmPmSegment.prototype.format = function(date) {
	var hours = date.getHours();
	return hours < 12 ? I18nMsg.periodAm : I18nMsg.periodPm;
};

AjxDateFormat.AmPmSegment.prototype.parse = function(object, s, index) {
	var periods = [ 
		I18nMsg.periodAm.toLowerCase(), I18nMsg.periodPm.toLowerCase(),
		I18nMsg.periodAm.toUpperCase(), I18nMsg.periodPm.toUpperCase()
	];
	var nindex = AjxFormat.Segment._parseLiterals(object, "ampm", 0, periods, s, index);
	if (nindex == -1) {
		throw new AjxFormat.ParsingException(this._parent, this, "no match"); // I18n
	}
	object.ampm = object.ampm % 2;
	return nindex;
};

//
// Time timezone segment class
//

AjxDateFormat.TimezoneSegment = function(format, s) {
    if (arguments.length == 0) return;
	AjxFormat.Segment.call(this, format, s);
};
AjxDateFormat.TimezoneSegment.prototype = new AjxDateFormat.TimeSegment;
AjxDateFormat.TimezoneSegment.prototype.constructor = AjxDateFormat.TimezoneSegment;

AjxDateFormat.TimezoneSegment.prototype.toString = function() { 
	return "timeTimezone: \""+this._s+'"'; 
};

// Public methods

AjxDateFormat.TimezoneSegment.prototype.format = function(date) {
	var clientId = date.timezone || AjxTimezone.DEFAULT;
	if (/Z/.test(this._s)) {
		return AjxTimezone.getShortName(clientId);
	}
	return this._s.length < 4 ? AjxTimezone.getMediumName(clientId) : AjxTimezone.getLongName(clientId);
};

//
// Message format class
//

/**
 * Message formatter based on the Java <code>MessageFormat</code> class. 
 * <p>
 * <strong>Note:</strong>
 * This implementation augments Java's <code>MessageFormat</code> patterns
 * to support list formatting. The following forms differ from the originals
 * defined in the JavaDoc for <code>MessageFormat</code>:
 * <pre>
 * <i>FormatElement</i>:
 *       { <i>ArgumentIndex</i> }
 *       { <i>ArgumentIndex</i> , <i>FormatType</i> }
 *       { <i>ArgumentIndex</i> , <i>ListFormatType</i> , <i>FormatType</i> }
 *       { <i>ArgumentIndex</i> , <i>FormatType</i> , <i>FormatStyle</i> }
 *       { <i>ArgumentIndex</i> , <i>ListFormatType , <i>FormatType</i> , <i>FormatStyle</i> }
 * <i>ListFormatType</i>:
 *       list
 * </pre>
 *
 * @param {string} pattern The message format pattern.
 *
 * @class
 * @constructor
 */
AjxMessageFormat = function(pattern) {
    if (arguments.length == 0) { return; }
	AjxFormat.call(this, pattern);
	if (pattern == null) { return; }
	for (var i = 0; i < pattern.length; i++) {
		// literal
		var c = pattern.charAt(i);
		if (c == "'") {
			if (i + 1 < pattern.length && pattern.charAt(i + 1) == "'") {
				var segment = new AjxFormat.TextSegment(this, "'");
				this._segments.push(segment);
				i++;
				continue;
			}
			var head = i + 1;
			for (i++ ; i < pattern.length; i++) {
				var c = pattern.charAt(i);
				if (c == "'") {
					if (i + 1 < pattern.length && pattern.charAt(i + 1) == "'") {
						pattern = pattern.substr(0, i) + pattern.substr(i + 1);
					}
					else {
						break;
					}
				}
			}
//			if (i == pattern.length) {
				// NOTE: try to avoid silent errors
//				throw new AjxFormat.FormatException(this, "unterminated string literal"); // I18n
//)			}
			var tail = i;
			var segment = new AjxFormat.TextSegment(this, pattern.substring(head, tail));
			this._segments.push(segment);
			continue;
		}
		
		// non-meta chars
		var head = i;
		while(i < pattern.length) {
			c = pattern.charAt(i);
			if (c == '{' || c == "'") {
				break;
			}
			i++;
		}
		var tail = i;
		if (head != tail) {
			var segment = new AjxFormat.TextSegment(this, pattern.substring(head, tail));
			this._segments.push(segment);
			i--;
			continue;
		}
		
		// meta char
		var head = i + 1;
		var depth = 0;
		while(++i < pattern.length) {
			var c = pattern.charAt(i);
			if (c == '{') {
				depth++;
			}
			else if (c == '}') {
				if (depth == 0) {
					break;
				}
				depth--;
			}		
		}
		var tail = i;
		var count = tail - head;
		var field = pattern.substr(head, count);
		var segment = new AjxMessageFormat.MessageSegment(this, field);		
		if (segment != null) {
			this._segments.push(segment);
		}
	}
}
AjxMessageFormat.prototype = new AjxFormat;
AjxMessageFormat.prototype.constructor = AjxMessageFormat;

AjxMessageFormat.prototype.toString = function() {
	return "[AjxMessageFormat: "+AjxFormat.prototype.toString.call(this)+"]";
};

// Static methods

/**
 * Format a message pattern with replacement parameters. Equivalent to
 * <code>new AjxMessageFormat(pattern).format(params)</code>.
 *
 * @param {string} pattern  Message pattern.
 * @param {Array}  params   Replacement parameters.
 * @return {string} Formatted message.
 */
AjxMessageFormat.format = function(pattern, params) {
	return new AjxMessageFormat(pattern).format(params);
};

// Public methods

/**
 * Format with replacement parameters.
 *
 * @param {Array}  params   Replacement parameters.
 * @return {string} Formatted message.
 */
AjxMessageFormat.prototype.format = function(params) {
	if (!(params instanceof Array)) {
		params = [ params ];
	}
	return AjxFormat.prototype.format.call(this, params);
};

AjxMessageFormat.prototype.getFormats = function() {
	var formats = [];
	for (var i = 0; i < this._segments.length; i++) {
		var segment = this._segments[i];
		if (segment instanceof AjxMessageFormat.MessageSegment) {
			formats.push(segment.getSegmentFormat());
		}
	}
	return formats;
};
AjxMessageFormat.prototype.getFormatsByArgumentIndex = function() {
	var formats = [];
	for (var i = 0; i < this._segments.length; i++) {
		var segment = this._segments[i];
		if (segment instanceof AjxMessageFormat.MessageSegment) {
			formats[segment.getIndex()] = segment.getSegmentFormat();
		}
	}
	return formats;
};

//
// AjxMessageFormat.MessageSegment class
//

AjxMessageFormat.MessageSegment = function(format, s) {
    if (arguments.length == 0) return;
	AjxFormat.Segment.call(this, format, s);
	var parts = AjxMessageFormat.MessageSegment._split(s, ',');
	this._index = Number(parts[0]);
	this._type = parts[1] || "string";
	this._style = parts[2];
	if (this._type == "list") {
		this._isList = true;
		this._type = parts[2] || "string";
		this._style = parts[3];
	}
	switch (this._type) {
		case "number": {
			switch (this._style) {
				case "integer": this._formatter = AjxNumberFormat.getIntegerInstance(); break;
				case "currency": this._formatter = AjxNumberFormat.getCurrencyInstance(); break;
				case "percent": this._formatter = AjxNumberFormat.getPercentInstance(); break;
				default: this._formatter = this._style == null ? AjxNumberFormat.getInstance() : new AjxNumberFormat(this._style);
			}
			break;
		}
		case "date": case "time": {
			var func = this._type == "date" ? AjxDateFormat.getDateInstance : AjxDateFormat.getTimeInstance;
			switch (this._style) {
				case "short": this._formatter = func(AjxDateFormat.SHORT); break;
				case "medium": this._formatter = func(AjxDateFormat.MEDIUM); break;
				case "long": this._formatter = func(AjxDateFormat.LONG); break;
				case "full": this._formatter = func(AjxDateFormat.FULL); break;
				default: this._formatter = this._style == null ? func(AjxDateFormat.DEFAULT) : new AjxDateFormat(this._style);
			}
			break;
		}
		case "choice": {
			this._formatter = new AjxChoiceFormat(this._style);
			break;
		}
	}
	if (this._isList) {
		this._formatter = new AjxListFormat(this._formatter);
	}	
};
AjxMessageFormat.MessageSegment.prototype = new AjxFormat.Segment;
AjxMessageFormat.MessageSegment.prototype.constructor = AjxMessageFormat.MessageSegment;

AjxMessageFormat.MessageSegment.prototype.toString = function() {
	var a = [ "message: \"", this._s, "\", index: ", this._index ];
	if (this._isList) a.push(", list: ", this._isList);
	if (this._type) a.push(", type: ", this._type);
	if (this._style) a.push(", style: ", this._style);
	if (this._formatter) a.push(", formatter: ", this._formatter.toString());
	return a.join("");
};

// Data

AjxMessageFormat.MessageSegment.prototype._isList = false;

// Public methods

AjxMessageFormat.MessageSegment.prototype.format = function(args) {
	var object = args[this._index];
	if (this._formatter instanceof AjxChoiceFormat) {
		return this._formatter.format(args, this._index);
	}
	return this._formatter ? this._formatter.format(object) : String(object);
};

AjxMessageFormat.MessageSegment.prototype.getIndex = function() {
	return this._index;
};
AjxMessageFormat.MessageSegment.prototype.getType = function() {
	return this._type;
};
AjxMessageFormat.MessageSegment.prototype.getStyle = function() {
	return this._style;
};
AjxMessageFormat.MessageSegment.prototype.getSegmentFormat = function() {
	return this._formatter;
};

// Protected static functions

AjxMessageFormat.MessageSegment._split = function(s, delimiter) {
	var parts = [];
	var head = 0;
	var tail;
	var depth = 0;
	for (tail = 0; tail < s.length; tail++) {
		var c = s.charAt(tail);
		if (c == '{') {
			depth++;
		}
		else if (c == '}') {
			depth--;
		}
		else if (c == delimiter && depth == 0) {
			parts.push(s.substring(head, tail));
			head = tail + 1;
		}
	}
	if (tail > head) {
		parts.push(s.substring(head, tail));
	}
	return parts;
};


//
// AjxNumberFormat class
//

/**
 * Number formatter based on Java's <code>DecimalFormat</code>.
 *
 * @param {string}  pattern       The number pattern.
 * @param {boolean} skipNegFormat Specifies whether to skip the generation of this
 *                                format's negative value formatter.
 *                                <p>
 *                                <strong>Note:</strong>
 *                                This parameter is only used by the implementation
 *                                and should not be passed by application code
 *                                instantiating a custom number format.
 * @class
 * @constructor
 */
AjxNumberFormat = function(pattern, skipNegFormat) {
    if (arguments.length == 0) { return; }
	AjxFormat.call(this, pattern);
	if (!pattern) { return; }

	var patterns = pattern.split(/;/);
	var pattern = patterns[0];
	
	// parse prefix
	var i = 0;
	var results = this.__parseStatic(pattern, i);
	i = results.offset;
	var hasPrefix = results.text != "";
	if (hasPrefix) {
		this._segments.push(new AjxFormat.TextSegment(this, results.text));
	}
	
	// parse number descriptor
	var start = i;
	while (i < pattern.length &&
	       AjxNumberFormat._META_CHARS.indexOf(pattern.charAt(i)) != -1) {
		i++;
	}
	var end = i;

	var numPattern = pattern.substring(start, end);
	var e = numPattern.indexOf('E');
	var expon = e != -1 ? numPattern.substring(e + 1) : null;
	if (expon) {
		numPattern = numPattern.substring(0, e);
		this._showExponent = true;
	}
	
	var dot = numPattern.indexOf(I18nMsg.numberSeparatorDecimal !='' ? I18nMsg.numberSeparatorDecimal : '.');
	var whole = dot != -1 ? numPattern.substring(0, dot) : numPattern;
	if (whole) {
		var comma = whole.lastIndexOf(I18nMsg.numberSeparatorGrouping !='' ? I18nMsg.numberSeparatorGrouping : ',');
		if (comma != -1) {
			this._groupingOffset = whole.length - comma - 1;
		}
		whole = whole.replace(/[^#0]/g,"");
		var zero = whole.indexOf('0');
		if (zero != -1) {
			this._minIntDigits = whole.length - zero;
		}
		this._maxIntDigits = whole.length;
	}
	
	var fract = dot != -1 ? numPattern.substring(dot + 1) : null;
	if (fract) {
		var zero = fract.lastIndexOf('0');
		if (zero != -1) {
			this._minFracDigits = zero + 1;
		}
		this._maxFracDigits = fract.replace(/[^#0]/g,"").length;
	}
	
	this._segments.push(new AjxNumberFormat.NumberSegment(this, numPattern));
	
	// parse suffix
	var results = this.__parseStatic(pattern, i);
	i = results.offset;
	if (results.text != "") {
		this._segments.push(new AjxFormat.TextSegment(this, results.text));
	}
	
	// add negative formatter
	if (skipNegFormat) return;
	
	if (patterns.length > 1) {
		var pattern = patterns[1];
		this._negativeFormatter = new AjxNumberFormat(pattern, true);
	}
	else {
		// no negative pattern; insert minus sign before number segment
		var formatter = new AjxNumberFormat("");
		formatter._segments = formatter._segments.concat(this._segments);

		var index = hasPrefix ? 1 : 0;
		var minus = new AjxFormat.TextSegment(formatter, I18nMsg.numberSignMinus);
		formatter._segments.splice(index, 0, minus);
		
		this._negativeFormatter = formatter;
	}
}
AjxNumberFormat.prototype = new AjxFormat;
AjxNumberFormat.prototype.constructor = AjxNumberFormat;

AjxNumberFormat.prototype.toString = function() {
	var array = [ 
		"[AjxNumberFormat: ", 
		"formatter=", AjxFormat.prototype.toString.call(this) 
	];
	if (this._negativeFormatter) {
		array.push(", negativeFormatter=", this._negativeFormatter.toString());
	}
	array.push(']');
	return array.join("");
};

// Constants

AjxNumberFormat._NUMBER = "number";
AjxNumberFormat._INTEGER = "integer";
AjxNumberFormat._CURRENCY = "currency";
AjxNumberFormat._PERCENT = "percent";

AjxNumberFormat._META_CHARS = "0#.,E";

// Data

AjxNumberFormat.prototype._groupingOffset = Number.MAX_VALUE;
AjxNumberFormat.prototype._minIntDigits = 1;
AjxNumberFormat.prototype._isCurrency = false;
AjxNumberFormat.prototype._isPercent = false;
AjxNumberFormat.prototype._isPerMille = false;
AjxNumberFormat.prototype._showExponent = false;

// Static functions

/**
 * Get general number formatter.
 *
 * @return {AjxNumberFormat} Number formatter.
 */
AjxNumberFormat.getInstance = function() {
	if (!AjxNumberFormat._FORMATTERS[AjxNumberFormat._NUMBER]) {
		AjxNumberFormat._FORMATTERS[AjxNumberFormat._NUMBER] = new AjxNumberFormat(I18nMsg.formatNumber);
	}
	return AjxNumberFormat._FORMATTERS[AjxNumberFormat._NUMBER];
};
/**
 * Get general number formatter.
 * <strong>Note:</strong>
 * Same as <code>AjxNumberFormat.getInstance()</code>.
 *
 * @return {AjxNumberFormat} Number formatter.
 */
AjxNumberFormat.getNumberInstance = AjxNumberFormat.getInstance;
/**
 * Get currency number formatter.
 *
 * @return {AjxNumberFormat} Number formatter.
 */
AjxNumberFormat.getCurrencyInstance = function() {
	if (!AjxNumberFormat._FORMATTERS[AjxNumberFormat._CURRENCY]) {
		AjxNumberFormat._FORMATTERS[AjxNumberFormat._CURRENCY] = new AjxNumberFormat(I18nMsg.formatNumberCurrency);
	}
	return AjxNumberFormat._FORMATTERS[AjxNumberFormat._CURRENCY];
};
/**
 * Get integer number formatter.
 *
 * @return {AjxNumberFormat} Number formatter.
 */
AjxNumberFormat.getIntegerInstance = function() {
	if (!AjxNumberFormat._FORMATTERS[AjxNumberFormat._INTEGER]) {
		AjxNumberFormat._FORMATTERS[AjxNumberFormat._INTEGER] = new AjxNumberFormat(I18nMsg.formatNumberInteger);
	}
	return AjxNumberFormat._FORMATTERS[AjxNumberFormat._INTEGER];
};
/**
 * Get percent number formatter.
 *
 * @return {AjxNumberFormat} Number formatter.
 */
AjxNumberFormat.getPercentInstance = function() {
	if (!AjxNumberFormat._FORMATTERS[AjxNumberFormat._PERCENT]) {
		AjxNumberFormat._FORMATTERS[AjxNumberFormat._PERCENT] = new AjxNumberFormat(I18nMsg.formatNumberPercent);
	}
	return AjxNumberFormat._FORMATTERS[AjxNumberFormat._PERCENT];
};

/**
 * Formats a number based on a given pattern. Equivalent to
 * <code>new AjxNumberFormat(pattern).format(number)</code>.
 *
 * @param {string}  pattern The format pattern.
 * @param {number}  number  The number to format.
 * @return {string} The formatted number string.
 */
AjxNumberFormat.format = function(pattern, number) {
	return new AjxNumberFormat(pattern).format(number);
};

AjxNumberFormat.initialize = function() {
	AjxNumberFormat._FORMATTERS = {};
};

// Public methods

/**
 * Formats a number.
 *
 * @param {number}  number  The number to format.
 * @return {string} The formatted number string.
 */
AjxNumberFormat.prototype.format = function(number) {
	if (number < 0 && this._negativeFormatter) {
		return this._negativeFormatter.format(number);
	}
	return AjxFormat.prototype.format.call(this, number);
};

// Private methods

AjxNumberFormat.prototype.__parseStatic = function(s, i) {
	var data = [];
	while (i < s.length) {
		var c = s.charAt(i++);
		if (AjxNumberFormat._META_CHARS.indexOf(c) != -1) {
			i--;
			break;
		}
		switch (c) {
			case "'": {
				var start = i;
				while (i < s.length && s.charAt(i++) != "'") {
					// do nothing
				}
				var end = i;
				c = end - start == 0 ? "'" : s.substring(start, end);
				break;
			}
			case '%': {
				c = I18nMsg.numberSignPercent; 
				this._isPercent = true;
				break;
			}
			case '\u2030': {
				c = I18nMsg.numberSignPerMill; 
				this._isPerMille = true;
				break;
			}
			case '\u00a4': {
				c = s.charAt(i) == '\u00a4'
				  ? I18nMsg.currencyCode : I18nMsg.currencySymbol;
				this._isCurrency = true;
				break;
			}
		}
		data.push(c);
	}
	return { text: data.join(""), offset: i };
};

//
// AjxNumberFormat.NumberSegment class
//

AjxNumberFormat.NumberSegment = function(format, s) {
    if (arguments.length == 0) return;
	AjxFormat.Segment.call(this, format, s);
};
AjxNumberFormat.NumberSegment.prototype = new AjxFormat.Segment;
AjxNumberFormat.NumberSegment.prototype.constructor = AjxNumberFormat.NumberSegment;

AjxNumberFormat.NumberSegment.prototype.toString = function() {
	return "number: \""+this._s+"\"";
};

// Public methods

AjxNumberFormat.NumberSegment.prototype.format = function(number) {
	// special values
	if (isNaN(number)) return I18nMsg.numberNaN;
	if (number === Number.NEGATIVE_INFINITY || number === Number.POSITIVE_INFINITY) {
		return I18nMsg.numberInfinity;
	}

	// adjust value
	if (typeof number != "number") number = Number(number);
	number = Math.abs(number); // NOTE: minus sign is part of pattern
	if (this._parent._isPercent) number *= 100;
	else if (this._parent._isPerMille) number *= 1000;

	// format
	var s = this._parent._showExponent
	      ? number.toExponential(this._parent._maxFracDigits).toUpperCase().replace(/E\+/,"E")
	      : number.toFixed(this._parent._maxFracDigits || 0);
	s = this._normalize(s);
	return s;
};

// Protected methods

AjxNumberFormat.NumberSegment.prototype._normalize = function(s) {
	var match = s.split(/[\.Ee]/);
	
	// normalize whole part
	var whole = match.shift();
	if (whole.length < this._parent._minIntDigits) {
		whole = AjxFormat._zeroPad(whole, this._parent._minIntDigits, I18nMsg.numberZero);
	}
	if (whole.length > this._parent._groupingOffset) {
		var a = [];
		
		var i = whole.length - this._parent._groupingOffset;
		while (i > 0) {
			a.unshift(whole.substr(i, this._parent._groupingOffset));
			a.unshift(I18nMsg.numberSeparatorGrouping);
			i -= this._parent._groupingOffset;
		}
		a.unshift(whole.substring(0, i + this._parent._groupingOffset));
		
		whole = a.join("");
	}
	
	// normalize rest
	var fract = '0';
	var expon;

    if(s.match(/\./))
        fract = match.shift();
    else if(s.match(/\e/) || s.match(/\E/))
        expon = match.shift();

    fract = fract.replace(/0+$/,"");
	if (fract.length < this._parent._minFracDigits) {
		fract = AjxFormat._zeroPad(fract, this._parent._minFracDigits, I18nMsg.numberZero, true);
	}
	
	var a = [ whole ];
	if (fract.length > 0) {
		var decimal = this._parent._isCurrency
		            ? I18nMsg.numberSeparatorMoneyDecimal
		            : I18nMsg.numberSeparatorDecimal;
		a.push(decimal, fract);
	}
	if (expon) {
		a.push('E', expon.replace(/^\+/,""));
	}
	
	// return normalize result
	return a.join("");
};

//
// AjxChoiceFormat class
//

/**
 * Choice formatter typically used to format plurals. This class is
 * modeled after Java's <code>ChoiceFormat</code>.
 * <p>
 * The arguments passed to this constructor can be either:
 * <ul>
 * <li>A single argument that represents a string pattern that specifies the 
 *     limits and formats separated by pipe characters (|).
 * <li>Two arguments, an array of limits and and array of format patterns.
 * </ul>
 * <p>
 * For complete details, see the JavaDoc for java.text.ChoiceFormat.
 *
 * @param {string} pattern Format pattern.
 *
 * @class
 * @constructor
 */
AjxChoiceFormat = function(pattern) {
    if (arguments.length == 0) { return; }
	AjxFormat.call(this, pattern);
	if (pattern == null) { return; }
	var choices = pattern.split("|");
	if (arguments.length == 1) {
		this._limits = new Array(choices.length);
		this._lessThan = new Array(choices.length);
		this._formats = new Array(choices.length);
		var regex = new RegExp("^([^#<\u2264]+)([#<\u2264])(.*)$");
		for (var i = 0; i < choices.length; i++) {
			var choice = choices[i];
			var results = regex.exec(choice);
			var limit = results[1];
			var separator = results[2];
			var message = results[3];
			// set limit
			if (limit == '\u221E') {
				this._limits[i] = Number.POSITIVE_INFINITY;
			}
			else if (limit == '-\u221E') {
				this._limits[i] = Number.NEGATIVE_INFINITY;
			}
			else {
				this._limits[i] = parseFloat(limit);
			}
			// set less-than
			this._lessThan[i] = separator == '#' || separator == '\u2264';
			// set format
			this._formats[i] = new AjxMessageFormat(message);
		}
	}
	else {
		this._limits = arguments[0];
		this._lessThan = new Array(arguments[0].length);
		this._formats = arguments[1];
		this._pattern = [];
		for (var i = 0; i < this._formats.length; i++) {
			if (i > 0) {
				this._pattern.push("|");
			}
			this._pattern.push(this._limits[i], '#', this._formats[i]);
			this._lessThan[i] = false;
			this._formats[i] = new AjxMessageFormat(this._formats[i]);
		}
		this._pattern = this._pattern.join("");
	}
}
AjxChoiceFormat.prototype = new AjxFormat;
AjxChoiceFormat.prototype.constructor = AjxChoiceFormat;

AjxChoiceFormat.prototype.toString = function() {
	return [
		"[AjxChoiceFormat: ",
		"limits={ ", this._limits.join(", "), " }, ",
		"formats={ ", this._formats.join(", "), " }, ",
		"lessThan={ ", this._lessThan.join(", "), " }]"
	].join("");
};

// Public methods

AjxChoiceFormat.prototype.getLimits = function() {
	return this._limits;
};
AjxChoiceFormat.prototype.getFormats = function() {
	return this._formats;
};

/**
 * Format a number based on the choice pattern.
 *
 * @param {number|Array} number Specifies the number to format. If called
 *                              from a message segment, this argument is
 *                              the array of arguments passed to the message
 *                              formatter.
 * @param {number}       index  Optional. If called from a message format,
 *                              this argument is the index into the array that
 *                              is passed as the first argument. The value at
 *                              the index in the array is the number to format.
 * @return {string} The formatted choice.
 */
AjxChoiceFormat.prototype.format = function(number, index) {
	var num = number instanceof Array ? number[index] : number;
	var formatter;
	if (isNaN(num) || num < this._limits[0]) {
		formatter = this._formats[0];
	}
	else {
		for (var i = 0; i < this._limits.length - 1; i++) {
			var a = this._limits[i];
			var b = this._limits[i+1];
			var aGEb = num >= a;
			var aLTb = this._lessThan[i+1] ? num < b : num <= b;
			if (aGEb && aLTb) {
				formatter = this._formats[i];
				break;
			}
		}
		if (!formatter) {
			formatter = this._formats[this._formats.length-1];
		}
	}
	return formatter.format(number);
};

//
// AjxListFormat class
//

/**
 * This class allows the user to format a list by applying a specific 
 * format to each object in an array and joining the results. Each formatted
 * item in the list is separated by a list separator string.
 * <p>
 * <strong>Note:</strong>
 * This format is <em>not</em> one of the standard formatter classes 
 * available in Java. 
 *
 * @param {AjxFormat} formatter     The formatter.
 * @param {string}    separator     Optional. The list separator string. If
 *                                  not specified, <code>AjxMsg.separatorList</code> 
 *                                  is used.
 * @param {string}    lastSeparator Optional. The list separator string for
 *                                  the last item in the list (e.g. " and ").
 *                                  If not specified, <code>AjxMsg.separatorListLast</code>
 *                                  is used.
 * @param {string}    twoSeparator	Optional. Separator used if the list consists of 
 * 									exactly two items. If not specified, <code>AjxMsg.listSeparatorTwo</code>
 * 									is used.	
 */
AjxListFormat = function(formatter, separator, lastSeparator, twoSeparator) {
	AjxFormat.call(this, formatter ? formatter.toPattern() : "");
	this._formatter = formatter;
	this._separator = separator || AjxMsg.listSeparator;
	this._lastSeparator = lastSeparator || AjxMsg.listSeparatorLast;
	this._twoSeparator = twoSeparator || AjxMsg.listSeparatorTwo;
}
AjxListFormat.prototype = new AjxFormat;
AjxListFormat.prototype.constructor = AjxListFormat;

// Public methods

/**
 * Formats a list of items.
 *
 * @param {Array} array Array of objects to be formatted in a list.
 * @return {string} The formatted list string.
 */
AjxListFormat.prototype.format = function(array) {
	array = array instanceof Array ? array : [ array ];
	var list = [];
	var num = array.length;
	for (var i = 0; i < num; i++) {
		if (i > 0) {
			list.push((i < num - 1) ? this._separator : (num == 2) ?
					this._twoSeparator : this._lastSeparator);
		}
		var item = array[i];
		list.push(this._formatter ? this._formatter.format(item) : String(item));
	}
	return list.join("");
};

//
// INITIALIZE
//

AjxFormat.initialize();
}
if (AjxPackage.define("ajax.util.AjxDateUtil")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * 
 * @private
 */
AjxDateUtil = function() {
};

AjxDateUtil.YEAR		= 1;
AjxDateUtil.MONTH		= 2;
AjxDateUtil.WEEK		= 3;
AjxDateUtil.DAY			= 4;
AjxDateUtil.TWO_WEEKS	= 5;

AjxDateUtil.MSEC_PER_MINUTE = 60000;
AjxDateUtil.MSEC_PER_FIFTEEN_MINUTES = 900000;
AjxDateUtil.MSEC_PER_HALF_HOUR = 1800000;
AjxDateUtil.MSEC_PER_HOUR = 3600000;
AjxDateUtil.MSEC_PER_DAY = 24 * AjxDateUtil.MSEC_PER_HOUR;

AjxDateUtil.MINUTES_PER_DAY = 60 * 24;
AjxDateUtil.SECONDS_PER_DAY = 60 * 60 * 24;

AjxDateUtil.DAYS_PER_WEEK = 7;

AjxDateUtil.WEEKDAY_SHORT = AjxDateFormat.WeekdaySegment.WEEKDAYS[AjxDateFormat.SHORT];
AjxDateUtil.WEEKDAY_MEDIUM = AjxDateFormat.WeekdaySegment.WEEKDAYS[AjxDateFormat.MEDIUM];
AjxDateUtil.WEEKDAY_LONG = AjxDateFormat.WeekdaySegment.WEEKDAYS[AjxDateFormat.LONG];

AjxDateUtil.MONTH_SHORT = AjxDateFormat.MonthSegment.MONTHS[AjxDateFormat.SHORT];
AjxDateUtil.MONTH_MEDIUM = AjxDateFormat.MonthSegment.MONTHS[AjxDateFormat.MEDIUM];
AjxDateUtil.MONTH_LONG = AjxDateFormat.MonthSegment.MONTHS[AjxDateFormat.LONG];

AjxDateUtil._daysPerMonth = {
	0:31,
	1:29,
	2:31,
	3:30,
	4:31,
	5:30,
	6:31,
	7:31,
	8:30,
	9:31,
	10:30,
	11:31
};

AjxDateUtil.MAX_DAYS_PER_MONTH = 31;

AjxDateUtil.WEEK_ONE_JAN_DATE = 1;

AjxDateUtil._init =
function() {
	AjxDateUtil._dateFormat = AjxDateFormat.getDateInstance(AjxDateFormat.SHORT).clone();
	var segments = AjxDateUtil._dateFormat.getSegments();
	for (var i = 0; i < segments.length; i++) {
		if (segments[i] instanceof AjxDateFormat.YearSegment) {
			segments[i] = new AjxDateFormat.YearSegment(AjxDateUtil._dateFormat, "yyyy");
		}
	}
	AjxDateUtil._dateTimeFormat = 
		new AjxDateFormat(AjxDateUtil._dateFormat.toPattern() + " " + AjxDateFormat.getTimeInstance(AjxDateFormat.SHORT));

	AjxDateUtil._dateFormatNoYear = new AjxDateFormat(AjxMsg.formatDateMediumNoYear);
};

AjxDateUtil._init();                    

/* return true if the specified date (yyyy|yy, m (0-11), d (1-31)) 
 * is valid or not.
 */
AjxDateUtil.validDate =
function(y, m, d) {
	var date = new Date(y, m, d);
	var year = y > 999 ? date.getFullYear() : date.getYear();
	return date.getMonth() == m && date.getDate() == d && year == y;
};

/* return number of days (1-31) in specified month (yyyy, mm (0-11))
 */
AjxDateUtil.daysInMonth =
function(y, m) {
	var date = new Date(y, m, 1, 12);
	date.setMonth(date.getMonth()+1);
	date.setDate(date.getDate()-1);
	return date.getDate();
};

/* return true if year is a leap year
 */
AjxDateUtil.isLeapYear =
function(y) {
	return (new Date(y, 1, 29)).getMonth() == 1;
};

/* returns true if user's locale uses 24-hour time
 */
AjxDateUtil.isLocale24Hour =
function() {
	// XXX: is there better/easier way to determine this?!
	var timeFormatter = AjxDateFormat.getTimeInstance(AjxDateFormat.SHORT);
	var len = timeFormatter._segments.length;
	for (var j = 0; j < len; j++) {
		if (timeFormatter._segments[j]._s == "a")
			return false;
	}
	return true;
};

/**
 * rolls the month/year. If the day of month in the date passed in is greater
 * then the max day in the new month, set it to the max. The date passed in is
 * modified and also returned.
 */
AjxDateUtil.roll = 
function(date, field, offset) {
	var d = date.getDate();
	 // move back to first day before rolling in case previous
	 // month/year has less days

	if (field == AjxDateUtil.MONTH) {
		date.setDate(1);	
		date.setMonth(date.getMonth() + offset);
		var max = AjxDateUtil.daysInMonth(date.getFullYear(), date.getMonth());
		date.setDate(Math.min(d, max));		
	} else if (field == AjxDateUtil.YEAR) {
		date.setDate(1);		
		date.setFullYear(date.getFullYear() + offset);
		var max = AjxDateUtil.daysInMonth(date.getFullYear(), date.getMonth());
		date.setDate(Math.min(d, max));		
	} else if (field == AjxDateUtil.WEEK) {
		date.setDate(date.getDate() + 7*offset);
	} else if (field == AjxDateUtil.DAY) {
		date.setDate(date.getDate() + offset);
	} else if (field == AjxDateUtil.TWO_WEEKS) {
		date.setDate(date.getDate() + 14*offset);
	} else {
		return date;
	}
	return date;
};

/**
 * checks whether given date is derived from DST shift
 */
AjxDateUtil.isDayShifted =
function(date) {
    var refDate = new Date(date.getTime());

    //advance it by 1 day and reset to beginning of the day
    refDate.setDate(refDate.getDate() +1)
    refDate.setHours(0,0,0,0);

    //if DST has no effect the advanced time should differ from given time
    return refDate.getTime() == date.getTime();
};

/**
 * rolls to next day. This can be used to roll to next day avoiding the daylight saving shift in time.
 */
AjxDateUtil.rollToNextDay =
function(date) {
    date.setHours(0,0,0,0);
    date.setTime(date.getTime() + AjxDateUtil.MSEC_PER_DAY);
};

// Computes the difference between now and <dateMSec>. Returns a string describing
// the difference
AjxDateUtil.computeDateDelta =
function(dateMSec) {
	var deltaMSec = (new Date()).getTime() - dateMSec;
	var durationStr = AjxDateUtil.computeDuration(deltaMSec);
	return durationStr ? (durationStr + " " + AjxMsg.ago) : null;
};

// Computes the difference between now and <dateMSec>. Returns a simplified string describing
// the difference
AjxDateUtil.agoTime =
function(dateMSec) {
	var deltaMSec = (new Date()).getTime() - dateMSec;
	var durationStr = AjxDateUtil.computeDuration(deltaMSec, false, true);
	return durationStr ? (durationStr + " " + AjxMsg.ago) : null;
};



// Returns a string describing the duration, which is in milliseconds.
AjxDateUtil.computeDuration =
function(duration, brief, simplified) {
	// bug fix #2203 - if delta is less than zero, dont bother computing
	if (duration < 0) return null;

	var years =  Math.floor(duration / (AjxDateUtil.MSEC_PER_DAY * 365));
	if (years != 0)
		duration -= years * AjxDateUtil.MSEC_PER_DAY * 365;
	var months = Math.floor(duration / (AjxDateUtil.MSEC_PER_DAY * 30.42));
	if (months > 0)
		duration -= Math.floor(months * AjxDateUtil.MSEC_PER_DAY * 30.42);
	var days = Math.floor(duration / AjxDateUtil.MSEC_PER_DAY);
	if (days > 0)
		duration -= days * AjxDateUtil.MSEC_PER_DAY;
	var hours = Math.floor(duration / AjxDateUtil.MSEC_PER_HOUR);
	if (hours > 0) 
		duration -= hours * AjxDateUtil.MSEC_PER_HOUR;
	var mins = Math.floor(duration / 60000);
	if (mins > 0)
		duration -= mins * 60000;
	var secs = Math.floor(duration / 1000);

	var formatter = brief ? AjxDurationFormatConcise : AjxDurationFormatVerbose;
	if (years > 0) {
		return simplified
            ? formatter.formatYears(years)
            : formatter.formatYears(years, months);
	} else if (months > 0) {
		return simplified
            ? formatter.formatMonths(months)
            : formatter.formatMonths(months, days);
	} else if (days > 0) {
		return simplified
            ? formatter.formatDays(days)
            : formatter.formatDays(days, hours);
	} else if (hours > 0) {
		return simplified
            ? formatter.formatHours(hours)
            : formatter.formatHours(hours, mins);
	} else if (mins > 0) {
		return simplified
            ? formatter.formatMinutes(mins)
            : formatter.formatMinutes(mins, secs);
	} else {
		return formatter.formatSeconds(secs);
	}
};

AjxDateUtil.simpleComputeDateStr = 
function(date, stringToPrepend) {
	var dateStr = AjxDateUtil._dateFormat.format(date);
	return stringToPrepend ? stringToPrepend + dateStr : dateStr;
};
AjxDateUtil.simpleParseDateStr =
function(dateStr) {
	return AjxDateUtil._dateFormat.parse(dateStr);
};

AjxDateUtil.simpleComputeDateTimeStr = 
function(date, stringToPrepend) {
	var dateTimeStr = AjxDateUtil._dateTimeFormat.format(date);
	return stringToPrepend ? stringToPrepend + dateTimeStr : dateTimeStr;
};
AjxDateUtil.simpleParseDateTimeStr =
function(dateTimeStr) {
	return AjxDateUtil._dateTimeFormat.parse(dateTimeStr);
};

AjxDateUtil.longComputeDateStr = 
function(date) {
	var formatter = AjxDateFormat.getDateInstance(AjxDateFormat.FULL);
	return formatter.format(date);
}

AjxDateUtil.computeDateStr =
function(now, dateMSec) {
	if (dateMSec == null)
		return "";

	var date = new Date(dateMSec);
	if (now.getTime() - dateMSec < AjxDateUtil.MSEC_PER_DAY &&
		now.getDay() == date.getDay()) {
		return AjxDateUtil.computeTimeString(date);
	}

	if (now.getFullYear() == date.getFullYear()) {
		return AjxDateUtil._dateFormatNoYear.format(date);
	}

	return AjxDateUtil.simpleComputeDateStr(date);
};

AjxDateUtil.computeDateStrNoYear =
function(date) {
    return AjxDateUtil._dateFormatNoYear.format(date);
};

// Example output: "Today, 9:44 AM" "Yesterday, 12:22 PM" "Sun, 1/11/01 1:11 PM"
AjxDateUtil.computeWordyDateStr =
function(now, dateMSec) {
	if (dateMSec == null) {
		return "";
	}

	var date = new Date(dateMSec);
	if (now.getTime() - dateMSec < AjxDateUtil.MSEC_PER_DAY && now.getDay() == date.getDay()) {
		if (!AjxDateUtil._wordyDateToday) {
			AjxDateUtil._wordyDateToday = new AjxDateFormat(AjxMsg.formatWordyDateToday);
		}
		return AjxDateUtil._wordyDateToday.format(date);
	} else if ((now.getTime() - dateMSec) < (2 * AjxDateUtil.MSEC_PER_DAY) && (now.getDay() - 1) == date.getDay()) {
		if (!AjxDateUtil._wordyDateYesterday) {
			AjxDateUtil._wordyDateYesterday = new AjxDateFormat(AjxMsg.formatWordyDateYesterday);
		}
		return AjxDateUtil._wordyDateYesterday.format(date);
	} else {
		if (!AjxDateUtil._wordyDate) {
			AjxDateUtil._wordyDate = new AjxDateFormat(AjxMsg.formatWordyDate);
		}
		return AjxDateUtil._wordyDate.format(date);
	}
};

/* returns true if dateString is a valid and understandable date string
 * in compliance with the locale of the user ie. dd/mm/yy or mm/dd/yy etc.
 * Also for date strings like 1/32/2000 (that roll over to 2/1/2000), false is returned.
 */
AjxDateUtil.isValidSimpleDateStr =
function(str){
        if(!str) {return false};
        var dateValue = AjxDateUtil.getSimpleDateFormat().parse(str);
        if (!dateValue) {return false};
        var dateValueStr = AjxDateUtil.simpleComputeDateStr(dateValue);
        return (str == dateValueStr);
}

AjxDateUtil.computeTimeString =
function(date) {
	var formatter = AjxDateFormat.getTimeInstance(AjxDateFormat.SHORT);
	return formatter.format(date);
};

AjxDateUtil.computeDateTimeString =
function(date) {
	var formatter = AjxDateFormat.getDateTimeInstance(AjxDateFormat.LONG);
	return formatter.format(date);
};

AjxDateUtil._getHoursStr =
function(date, pad, useMilitary) {
	var myVal = date.getHours();
	if (!useMilitary) {
		myVal %= 12;
		if (myVal == 0) myVal = 12;
	}
	return pad ? AjxDateUtil._pad(myVal) : myVal;
};

AjxDateUtil._getMinutesStr = 
function(date) {
	return AjxDateUtil._pad(date.getMinutes());
};

AjxDateUtil._getSecondsStr = 
function(date) {
	return AjxDateUtil._pad(date.getSeconds());
};

AjxDateUtil._getAMPM = 
function (date, upper) {
	var myHour = date.getHours();
	return (myHour < 12) ? (upper ? 'AM' : 'am') : (upper ? 'PM' : 'pm');
};

AjxDateUtil._getMonthName = 
function(date, abbreviated) {
	return abbreviated
		? AjxDateUtil.MONTH_MEDIUM[date.getMonth()]
		: AjxDateUtil.MONTH_LONG[date.getMonth()];
};

AjxDateUtil._getMonth = 
function(date, pad) {
	var myMonth = date.getMonth() + 1;
	if (pad) {
		return AjxDateUtil._pad(myMonth);
	} else {
		return myMonth;
	}
};

AjxDateUtil._getDate = 
function(date, pad) {
	var myVal = date.getDate();
	return pad ? AjxDateUtil._pad(myVal) : myVal;
};

AjxDateUtil._getWeekday =
function (date) {
	var myVal = date.getDay();
	return AjxDateUtil.WEEKDAY_LONG[myVal];
};

// Returns "Mon", "Tue", etc.
AjxDateUtil._getWeekdayMedium =
function (date) {
	var myVal = date.getDay();
	return AjxDateUtil.WEEKDAY_MEDIUM[myVal];
};

AjxDateUtil._getFullYear =
function(date) {
	return date.getFullYear();
};

AjxDateUtil.getFirstDayOfWeek =
function (dt, startOfWeek) {
    startOfWeek = startOfWeek || 0;
    var dayOfWeekIndex = dt.getDay();
    var dayOfWeek = (dayOfWeekIndex - startOfWeek + 7) % 7;
    dt.setDate(dt.getDate() - dayOfWeek);
    return dt;
};

AjxDateUtil.getLastDayOfWeek =
function (dt, startOfWeek) {
    startOfWeek = startOfWeek || 0;
    var dayOfWeekIndex = dt.getDay();
    var dayOfWeek = (dayOfWeekIndex - startOfWeek + 7) % 7;
    dt.setDate(dt.getDate() - dayOfWeek + 6);
    dt.setHours(23, 59, 59, 999);
    return dt;
};

AjxDateUtil.getWeekNumber =
function(date, firstDayOfWeek, janDate, isISO8601WeekNum) {

    // Setup Defaults
    firstDayOfWeek = firstDayOfWeek || 0;
    janDate = janDate || AjxDateUtil.WEEK_ONE_JAN_DATE;
    date = date || new Date();

    date.setHours(12,0,0,0);
    var targetDate = date,
            startOfWeek,
            endOfWeek;

    if (targetDate.getDay() === firstDayOfWeek) {
        startOfWeek = targetDate;
    } else {
        startOfWeek = AjxDateUtil.getFirstDayOfWeek(targetDate, firstDayOfWeek);
    }

    var startYear = startOfWeek.getFullYear(),
            startTime = startOfWeek.getTime();

    // DST shouldn't be a problem here, math is quicker than setDate();
    endOfWeek = new Date(startOfWeek.getTime() + 6*AjxDateUtil.MSEC_PER_DAY);

    var weekNum;

    if(!isISO8601WeekNum) {
        if (startYear !== endOfWeek.getFullYear() && endOfWeek.getDate() >= janDate) {
            weekNum = 1;
        } else {
            var weekOne = (new Date(startYear, 0, janDate));
            weekOne.setHours(12,0,0,0);
            var weekOneDayOne = AjxDateUtil.getFirstDayOfWeek(weekOne, firstDayOfWeek);

            // Round days to smoothen out 1 hr DST diff
            var daysDiff  = Math.round((targetDate.getTime() - weekOneDayOne.getTime())/AjxDateUtil.MSEC_PER_DAY);

            // Calc. Full Weeks
            var rem = daysDiff % 7;
            var weeksDiff = (daysDiff - rem)/7;
            weekNum = weeksDiff + 1;
        }
        return weekNum;
    }else {

        var newYear = new Date(date.getFullYear(),0,1);
        var day = newYear.getDay() - 1;
        day = (day >= 0 ? day : day + 7);
        var dayOftheYear = Math.floor((date.getTime()-newYear.getTime() - (date.getTimezoneOffset()-newYear.getTimezoneOffset())*60000)/AjxDateUtil.MSEC_PER_DAY) + 1;

        if(day < 4)
        {
            weekNum = Math.floor((dayOftheYear+day-1)/7) + 1;
            if(weekNum > 52)
            {
                var nxtYear = new Date(date.getFullYear() + 1,0,1);
                var nxtDay = nxtYear.getDay() - 1;
                nxtDay = nxtDay >= 0 ? nxtDay : nxtDay + 7;
                weekNum = nxtDay < 4 ? 1 : 53;
            }
        }else {
            weekNum = Math.floor((dayOftheYear+day -1 )/7);
            if(weekNum == 0)
            {
                var prevYear = new Date(date.getFullYear()-1,0,1);
                var prevDay = prevYear.getDay()-1;
                prevDay = (prevDay >= 0 ? prevDay : prevDay + 7);
                weekNum = ( prevDay==3 || ( AjxDateUtil.isLeapYear(prevYear.getFullYear()) && prevDay==2 ) ) ? 53 : 52;
            }
        }
        return weekNum;
    }
};

AjxDateUtil.getTimeStr = 
function(date, format) {
	var s = format;
	s = s.replace(/%d/g, AjxDateUtil._getDate(date, true));				// zero padded day of the month
	s = s.replace(/%D/g, AjxDateUtil._getDate(date, false));			// day of the month without padding
	s = s.replace(/%w/g, AjxDateUtil._getWeekday(date));				// day of the week
	s = s.replace(/%M/g, AjxDateUtil._getMonthName(date));				// full month name
	s = s.replace(/%t/g, AjxDateUtil._getMonthName(date, true));		// abbr. month name
	s = s.replace(/%n/g, AjxDateUtil._getMonth(date, true));		    // zero padded month
	s = s.replace(/%Y/g, AjxDateUtil._getFullYear(date));				// full year
	s = s.replace(/%h/g, AjxDateUtil._getHoursStr(date, false, false));	// non-padded hours
	s = s.replace(/%H/g, AjxDateUtil._getHoursStr(date, true, false ));	// padded hours
	s = s.replace(/%m/g, AjxDateUtil._getMinutesStr(date));				// padded minutes
	s = s.replace(/%s/g, AjxDateUtil._getSecondsStr(date));				// padded seconds
	s = s.replace(/%P/g, AjxDateUtil._getAMPM(date, true));				// upper case AM PM
	s = s.replace(/%p/g, AjxDateUtil._getAMPM(date, false));			// lower case AM PM
	return s;
};

AjxDateUtil.getRoundedMins = 
function (date, roundTo) {
	var mins = date.getMinutes();
	if (mins != 0 && roundTo)
		mins = (Math.ceil( (mins/roundTo) )) * roundTo;
	return mins;
};

AjxDateUtil.roundTimeMins = 
function(date, roundTo) {
	var mins = date.getMinutes();
	var hours = date.getHours();
	if (mins != 0 && roundTo){
		mins = (Math.ceil( (mins/roundTo) )) * roundTo;
		if (mins == 60) {
			mins = 0;
			hours++;
		}
		date.setMinutes(mins);
		date.setHours(hours);
	}
	return date;
};

AjxDateUtil.isInRange = 
function(startTime1, endTime1, startTime2, endTime2) {
	return (startTime1 < endTime2 && endTime1 > startTime2);
}

AjxDateUtil.getSimpleDateFormat =
function() {
	return AjxDateUtil._dateFormat;
};

/**
 * The following are helper routines for processing server date/time which comes
 * in this format: YYYYMMDDTHHMMSSZ
*/
AjxDateUtil.getServerDate = 
function(date) {
	if (!AjxDateUtil._serverDateFormatter) {
		AjxDateUtil._serverDateFormatter = new AjxDateFormat("yyyyMMdd");
	}
	return AjxDateUtil._serverDateFormatter.format(date);
};

AjxDateUtil.getServerDateTime = 
function(date, useUTC) {
	var newDate = date;
	var formatter = null;

	if (useUTC) {
		if (!AjxDateUtil._serverDateTimeFormatterUTC) {
			AjxDateUtil._serverDateTimeFormatterUTC = new AjxDateFormat("yyyyMMdd'T'HHmmss'Z'");
		}
		formatter = AjxDateUtil._serverDateTimeFormatterUTC;
		// add timezone offset to this UTC date
		newDate = new Date(date.getTime());
		newDate.setMinutes(newDate.getMinutes() + newDate.getTimezoneOffset());
	} else {
		if (!AjxDateUtil._serverDateTimeFormatter) {
			AjxDateUtil._serverDateTimeFormatter = new AjxDateFormat("yyyyMMdd'T'HHmmss");
		}
		formatter = AjxDateUtil._serverDateTimeFormatter;
	}

	return formatter.format(newDate);
};

AjxDateUtil.parseServerTime = 
function(serverStr, date, noSpecialUtcCase) {
	if (serverStr.charAt(8) == 'T') {
		var hh = parseInt(serverStr.substr(9,2), 10);
		var mm = parseInt(serverStr.substr(11,2), 10);
		var ss = parseInt(serverStr.substr(13,2), 10);
		if (!noSpecialUtcCase && serverStr.charAt(15) == 'Z') {
			mm += AjxTimezone.getOffset(AjxTimezone.DEFAULT, date);
		}
		date.setHours(hh, mm, ss, 0);
	}
	return date;
};

AjxDateUtil.parseISO8601Date = function(s) {
    var formatters = AjxDateUtil.__ISO8601_formats;
    if (!formatters) {
        formatters = AjxDateUtil.__ISO8601_formats = [
            new AjxDateUtil.TZDFormat("yyyy-MM-dd'T'HH:mm:ss.SZ"),
            new AjxDateUtil.TZDFormat("yyyy-MM-dd'T'HH:mm:ssZ"),
            new AjxDateUtil.TZDFormat("yyyy-MM-dd'T'HH:mmZ"),
            new AjxDateFormat("yyyy-MM-dd"),
            new AjxDateFormat("yyyy-MM"),
            new AjxDateFormat("yyyy")
        ];
    }
    for (var i = 0; i < formatters.length; i++) {
        var date = formatters[i].parse(s);
        if (date) return date;
    }
    return null;
};

AjxDateUtil.TZDFormat = function(pattern) {
    if (arguments.length == 0) return;
    AjxDateFormat.apply(this, arguments);
    var segments = this._segments || [];
    for (var i = 0; i < segments.length; i++) {
        var segment = segments[i];
        if (segment instanceof AjxDateFormat.TimezoneSegment) {
            segments[i] = new AjxDateUtil.TZDSegment(segment.toSubPattern());
        }
    }
};
AjxDateUtil.TZDFormat.prototype = new AjxDateFormat;
AjxDateUtil.TZDFormat.prototype.constructor = AjxDateUtil.TZDFormat;
AjxDateUtil.TZDFormat.prototype.toString = function() { return "TZDFormat"; };

AjxDateUtil.TZDSegment = function(pattern) {
    if (arguments.length == 0) return;
    AjxDateFormat.TimezoneSegment.apply(this, arguments);
};
AjxDateUtil.TZDSegment.prototype = new AjxDateFormat.TimezoneSegment;
AjxDateUtil.TZDSegment.prototype.constructor = AjxDateUtil.TZDSegment;
AjxDateUtil.TZDSegment.prototype.toString = function() { return "TZDSegment"; };

AjxDateUtil.TZDSegment.prototype.parse = function(o, s, i) {
    var m = /^(Z)|^(\+|\-)(\d\d):(\d\d)/.exec(s.substr(i));
    if (m) {
        var offset = new Date().getTimezoneOffset();
        if (m[1]) o.timezone = offset;
        else {
            var hours = parseInt(m[3],10), mins = parseInt(m[4],10);
            o.timezone = hours * 60 + mins;
            if (m[2] != "-") o.timezone *= -1;
            o.timezone -= offset;
        }
    }
    return i + (m ? m[0].length : 0);
};

AjxDateUtil.parseServerDateTime = 
function(serverStr, noSpecialUtcCase) {
	if (serverStr == null) return null;

	var d = new Date();
	var yyyy = parseInt(serverStr.substr(0,4), 10);
	var MM = parseInt(serverStr.substr(4,2), 10);
	var dd = parseInt(serverStr.substr(6,2), 10);
	d.setFullYear(yyyy);
	d.setMonth(MM - 1);
	d.setMonth(MM - 1); // DON'T remove second call to setMonth (see bug #3839)
	d.setDate(dd);
	AjxDateUtil.parseServerTime(serverStr, d, noSpecialUtcCase);
	return d;
};

AjxDateUtil._pad = 
function(n) {
	return n < 10 ? ('0' + n) : n;
};

/**
 * Returns the year portion of the given date as a YYYY string.
 *
 * @param {Date}    date    (optional, defaults to current date) a date
 * @returns {string}    year as YYYY
 */
AjxDateUtil.getYearStr = function(date) {
    date = date || new Date();
    return date.getFullYear() + "";
};

AjxDurationFormatVerbose = function() { }

AjxDurationFormatVerbose.formatYears =
function(years, months) {
	var deltaStr =  years + " ";
	deltaStr += (years > 1) ? AjxMsg.years : AjxMsg.year;
	if (years <= 3 && months > 0) {
		deltaStr += " " + months;
		deltaStr += " " + ((months > 1) ? AjxMsg.months : AjxMsg.months);
	}
	return deltaStr;
};

AjxDurationFormatVerbose.formatMonths =
function(months, days) {
	var deltaStr =  months + " ";
	deltaStr += (months > 1) ? AjxMsg.months : AjxMsg.month;
	if (months <= 3 && days > 0) {
		deltaStr += " " + days;
		deltaStr += " " + ((days > 1) ? AjxMsg.days : AjxMsg.day);
	}
	return deltaStr;
};

AjxDurationFormatVerbose.formatDays =
function(days, hours) {
	var deltaStr = days + " ";
	deltaStr += (days > 1) ? AjxMsg.days : AjxMsg.day;
	if (days <= 2 && hours > 0) {
		deltaStr += " " + hours;
		deltaStr += " " + ((hours > 1) ? AjxMsg.hours : AjxMsg.hour);
	}
	return deltaStr;
};

AjxDurationFormatVerbose.formatHours =
function(hours, mins) {
	var deltaStr = hours + " ";
	deltaStr += (hours > 1) ? AjxMsg.hours : AjxMsg.hour;
	if (hours < 5 && mins > 0) {
		deltaStr += " " + mins;
		deltaStr += " " + ((mins > 1) ? AjxMsg.minutes : AjxMsg.minute);
	}
	return deltaStr;
};

AjxDurationFormatVerbose.formatMinutes =
function(mins, secs) {
	var deltaStr = mins + " ";
	deltaStr += ((mins > 1) ? AjxMsg.minutes : AjxMsg.minute);
	if (mins < 5 && secs > 0) {
		deltaStr += " " + secs;
		deltaStr += " " + ((secs > 1) ? AjxMsg.seconds : AjxMsg.second);
	}
	return deltaStr;
};

AjxDurationFormatVerbose.formatSeconds =
function(secs) {
	return (secs + " " + ((secs > 1) ? AjxMsg.seconds : AjxMsg.second));
};

AjxDurationFormatConcise = function() { }

AjxDurationFormatConcise.formatYears =
function(years, months) {
	return this._format(years, months);
};

AjxDurationFormatConcise.formatMonths =
function(months, days) {
	return this._format(months, days);
};

AjxDurationFormatConcise.formatDays =
function(days, hours) {
	return this._format(days, hours);
};

AjxDurationFormatConcise.formatHours =
function(hours, mins) {
	return this._format(hours, mins);
};

AjxDurationFormatConcise.formatMinutes =
function(mins, secs) {
	return this._format(mins, secs);
};

AjxDurationFormatConcise.formatSeconds =
function(secs) {
	return this._format(0, secs);
};

AjxDurationFormatConcise._format =
function(a, b) {
	var i = 0;
	var result = [];
	result[i++] = a;
	result[i++] = ':';
	if (b < 10) {
		result[i++] = '0';
	}
	result[i++] = b;
	return result.join('');
};

/**
 * Added more utility functions for date finding and navigating
 */

AjxDateUtil.SUNDAY = 0;
AjxDateUtil.MONDAY = 1;
AjxDateUtil.TUESDAY = 2;
AjxDateUtil.WEDNESDAY = 3;
AjxDateUtil.THURSDAY = 4;
AjxDateUtil.FRIDAY = 5;
AjxDateUtil.SATURDAY = 6;                                                                              

/**
 *
 * @param fromThisDate The searching starts from this date.
 * @param thisWeekday  The day to find ( eg. AjxDateUtil.SUNDAY)
 * @param count Which occurence, like first, second.. has to be always positive
 * 
 */
AjxDateUtil.getDateForNextDay =
function(fromThisDate, thisWeekday, count) {
	count = count || 1;
	var r = new Date(fromThisDate);
	for (var i = 0; i < count; i++) {
		r = AjxDateUtil._getDateForNextWeekday(r, thisWeekday);
		if (i < count-1) {
			r.setDate(r.getDate() + 1);
		}
	}
	return r;
}

/**
 *
 * @param fromThisDate The searching work week days starting from this date
 * @param count Which occurence, like first, second.. has to be always positive
 *
 */
AjxDateUtil.getDateForNextWorkWeekDay =
function(fromThisDate, count) {
	count = count?count:1;
	var r = new Date(fromThisDate);
	for (var i = 0; i < count; i++) {
		r = AjxDateUtil._getDateForNextWorkWeekday(r);
		if (i < count-1) {
			r.setDate(r.getDate() + 1);
		}
	}
	return r;
}

/**
 *
 * @param fromThisDate The starting point
 * @param thisWeekday  The day to find
 * @param count this many positions to navigate, if negative goes in reverse, if positive goes forward
 */
AjxDateUtil.getDateForThisDay =
function(fromThisDate, thisWeekday, count) {
	if (count < 0 ) {
		return AjxDateUtil.getDateForPrevDay(fromThisDate, thisWeekday, -count);//-(-)  is plus
	} else {
		return AjxDateUtil.getDateForNextDay(fromThisDate, thisWeekday, count);
	}
}

/**
 *
 * @param fromThisDate The starting point
 * @param count this many positions to navigate, if negative goes in reverse, if positive goes forward
 */
AjxDateUtil.getDateForThisWorkWeekDay =
function(fromThisDate, count) {
	if (count < 0 ) {
		return AjxDateUtil.getDateForPrevWorkWeekDay(fromThisDate, -count);		//-(-)  is plus
	}else{
		return AjxDateUtil.getDateForNextWorkWeekDay(fromThisDate, count);
	}
}

/**
 *
 * @param fromThisDate The searching starts from this date in reverse direction. 
 * @param thisWeekday  The day to find ( eg. AjxDateUtil.SUNDAY)
 * @param count Which occurence, like first, second..has to be always positive
 */
AjxDateUtil.getDateForPrevDay =
function(fromThisDate,thisWeekday,count) {
	count = count || 1;
	var r = new Date(fromThisDate);
	for (var i = 0; i < count; i++) {
		r = AjxDateUtil._getDateForPrevWeekday(r, thisWeekday);
		if (i < count-1) {
			r.setDate(r.getDate()-1);
		}
	}
	return r;
}

/**
 *
 * @param fromThisDate The searching for work week days starting from this date in reverse direction.
 * @param count Which occurence, like first, second..has to be always positive
 */

AjxDateUtil.getDateForPrevWorkWeekDay =
function(fromThisDate, count) {
	count = count || 1;
	var r = new Date(fromThisDate);
	for(var i = 0; i < count; i++) {
		r = AjxDateUtil._getDateForPrevWorkWeekday(r);
		if (i < count-1) {
			r.setDate(r.getDate()-1);
		}
	}
	return r;
}

/**
 * note - this deals with the format we save from Prefs page. Careful if using for other cases.
 * @param value
 * @return {String}
 */
AjxDateUtil.dateLocal2GMT =
function(value) {
	if (!value) { return ""; }

	var yr, mo, da, hr, mi, se; // really smart parsing.
	yr = parseInt(value.substr(0,  4), 10);
	mo = parseInt(value.substr(4,  2), 10);
	da = parseInt(value.substr(6,  2), 10);
	hr = parseInt(value.substr(8,  2), 10);
	mi = parseInt(value.substr(10, 2), 10);
	se = parseInt(value.substr(12, 2), 10);
	var date = new Date(yr, mo - 1, da, hr, mi, se, 0);
	yr = date.getUTCFullYear();
	mo = date.getUTCMonth() + 1;
	da = date.getUTCDate();
	hr = date.getUTCHours();
	mi = date.getUTCMinutes();
	se = date.getUTCSeconds();
	var a = [ yr, mo, da, hr, mi, se ];
	for (var i = a.length; --i > 0;) {
		var n = a[i];
		if (n < 10)
			a[i] = "0" + n;
	}
	return (a.join("") + "Z");
};

/**
 * note - this deals with the format we save from Prefs page. Careful if using for other cases.
 * @param value
 * @return {String}
 */
AjxDateUtil.dateGMT2Local =
function(value) {
	if (!value) { return ""; }

	var yr, mo, da, hr, mi, se; // really smart parsing.
	yr = parseInt(value.substr(0,  4), 10);
	mo = parseInt(value.substr(4,  2), 10);
	da = parseInt(value.substr(6,  2), 10);
	hr = parseInt(value.substr(8,  2), 10);
	mi = parseInt(value.substr(10, 2), 10);
	se = parseInt(value.substr(12, 2), 10);
	var date = new Date();
	date.setUTCMilliseconds(0);
	date.setUTCSeconds(se);
	date.setUTCMinutes(mi);
	date.setUTCHours(hr);
	date.setUTCDate(da);
	date.setUTCMonth(mo - 1);
	date.setUTCFullYear(yr);
	yr = date.getFullYear();
	mo = date.getMonth() + 1;
	da = date.getDate();
	hr = date.getHours();
	mi = date.getMinutes();
	se = date.getSeconds();
	var a = [yr, mo, da, hr, mi, se];
	for (var i = a.length; --i > 0;) {
		var n = a[i];
		if (n < 10)
			a[i] = "0" + n;
	}
	return (a.join("") + "Z");
};


AjxDateUtil._getDateForNextWeekday =
function(fromThisDate,thisWeekday) {
	var newDate = new Date(fromThisDate);
	var weekDay = fromThisDate.getDay();
	if (weekDay == thisWeekday) {
		return newDate;
	}
	var diff = (thisWeekday-weekDay);
	if (diff > 0) {
		newDate.setDate(fromThisDate.getDate() + diff);
	} else {
		newDate.setDate(fromThisDate.getDate() + (7 + diff));
	}
	return newDate;
}

AjxDateUtil._getDateForNextWorkWeekday =
function(fromThisDate) {
	var newDate = new Date(fromThisDate);
	var weekDay = fromThisDate.getDay();
	if (weekDay == AjxDateUtil.SUNDAY) {
		newDate.setDate(fromThisDate.getDate()+1);
	} else if (weekDay == AjxDateUtil.SATURDAY) {
		newDate.setDate(fromThisDate.getDate()+2);
	}
	return newDate;
}

AjxDateUtil._getDateForPrevWeekday =
function(fromThisDate, thisWeekday) {
	var newDate = new Date(fromThisDate);
	var weekDay = fromThisDate.getDay();
	if (weekDay == thisWeekday) {
		return newDate;
	}
	var diff = (weekDay-thisWeekday);
	if (diff > 0) {
		newDate.setDate(fromThisDate.getDate() - diff);
	} else {
		newDate.setDate(fromThisDate.getDate() - (7 + diff));
	}
	return newDate;
}

AjxDateUtil._getDateForPrevWorkWeekday =
function(fromThisDate) {
	var newDate = new Date(fromThisDate);
	var weekDay = fromThisDate.getDay();
	if (weekDay == AjxDateUtil.SUNDAY) {
		newDate.setDate(fromThisDate.getDate() - 2);
	} else if (weekDay == AjxDateUtil.SATURDAY) {
		newDate.setDate(fromThisDate.getDate() - 1);
	}
	return newDate;
}

//
// Date calculator functions
//

AjxDateUtil.calculate =
function(rule, date) {
	// initialize
	if (!AjxDateUtil.__calculate_initialized) {
		AjxDateUtil.__calculate_initialized = true;
		AjxDateUtil.__calculate_init();
	}

	var now = date || new Date;
	rule = rule.replace(/^\s*|\s*$/, "").replace(/\s*=\s*/g,"=").replace(/\s*,\s*/g,",");
	var a = rule.split(/\s+/g);
	var s, m, plusminus, number, type, amount, weekord, daynum;
	for (var i = 0; i < a.length; i++) {
		s = a[i];
		// comment
		if (s.match(AjxDateUtil.RE_COMMENT)) {
			break;
		}
		// context date
		if (s.match(AjxDateUtil.RE_NOW)) {
			date = new Date(now.getTime());
			continue;
		}
		// add
		if (m = s.match(AjxDateUtil.RE_ADD_NUMBER)) {
			plusminus = m[1];
			number = AjxDateUtil.__calculate_parseInt(m[2]);
			type = a[++i];
			amount = plusminus == '+' ? number : number * -1;
			AjxDateUtil.__calculate_add(date, type, amount);
			continue;
		}
		// set
		if (m = s.match(AjxDateUtil.RE_SET)) {
			AjxDateUtil.__calculate_set(date, m[1], m[2]);
			continue;
		}
		// try to parse as a date
		date = AjxDateFormat.parse("yyyyy-MM-dd", s);
		if (!date && (date = AjxDateFormat.parse("yyyy-MM-dd'T'hh:mm:ss'Z'", s))) {
			date.setMinutes(date.getMinutes() - date.getTimezoneOffset());
		}
		if (!date) date = AjxDateFormat.parse("yyyy-MM-dd'T'HH:mm:ss", s);
		if (!date) throw "invalid date pattern: \""+s+"\"";
	}
	return date;
};

//
// Date calculator constants
//

AjxDateUtil.S_DAYNAME = [
	AjxMsg["calc.dayname.sunday"],
	AjxMsg["calc.dayname.monday"],
	AjxMsg["calc.dayname.tuesday"],
	AjxMsg["calc.dayname.wednesday"],
	AjxMsg["calc.dayname.thursday"],
	AjxMsg["calc.dayname.friday"],
	AjxMsg["calc.dayname.saturday"]
].join("|");

AjxDateUtil.S_MONTHNAME = [
	AjxMsg["calc.monthname.january"],
	AjxMsg["calc.monthname.february"],
	AjxMsg["calc.monthname.march"],
	AjxMsg["calc.monthname.april"],
	AjxMsg["calc.monthname.may"],
	AjxMsg["calc.monthname.june"],
	AjxMsg["calc.monthname.july"],
	AjxMsg["calc.monthname.august"],
	AjxMsg["calc.monthname.september"],
	AjxMsg["calc.monthname.october"],
	AjxMsg["calc.monthname.november"],
	AjxMsg["calc.monthname.december"]
].join("|");

AjxDateUtil.S_WEEKORD = [
	AjxMsg["calc.ordinal.first"],
	AjxMsg["calc.ordinal.second"],
	AjxMsg["calc.ordinal.third"],
	AjxMsg["calc.ordinal.fourth"],
	AjxMsg["calc.ordinal.fifth"],
	AjxMsg["calc.ordinal.last"]
].join("|");

AjxDateUtil.WEEKORD_RE = [
    new RegExp("(first|"+AjxMsg["calc.ordinal.first"]+")",  "i"),
    new RegExp("(second|"+AjxMsg["calc.ordinal.second"]+")", "i"),
    new RegExp("(third|"+AjxMsg["calc.ordinal.third"]+")",  "i"),
    new RegExp("(fourth|"+AjxMsg["calc.ordinal.fourth"]+")", "i"),
    new RegExp("(last|"+AjxMsg["calc.ordinal.last"]+")",   "i")
];

// NOTE: Originally, the keywords for the date calculation rules
//       were in the message bundle so that they could be translated.
//       But while the keywords were translated, the rules were not
//       updated to use the translated keywords. So none of the date
//       matching worked in other languages. So I am reverting that
//       decision and hard-coding all of the relevant keywords. The
//       ordinals, day names, and month names still need to be
//       translated, though.

AjxMsg["calc.now"]	= "now";
AjxMsg["calc.date"]	= "date";

AjxMsg["calc.duration.year"]		= "year|years";
AjxMsg["calc.duration.month"]		= "mons|month|months";
AjxMsg["calc.duration.day"]			= "day|days";
AjxMsg["calc.duration.hour"]		= "hour|hours";
AjxMsg["calc.duration.minute"]		= "min|mins|minute|minutes";
AjxMsg["calc.duration.week"]        = "week";
AjxMsg["calc.duration.second"]		= "sec|secs|second|seconds";
AjxMsg["calc.duration.millisecond"]	= "milli|millis|millisecond|milliseconds";

AjxDateUtil.S_DURATION = [
	AjxMsg["calc.duration.year"],
	AjxMsg["calc.duration.month"],
    AjxMsg["calc.duration.week"],
	AjxMsg["calc.duration.day"],
	AjxMsg["calc.duration.hour"],
	AjxMsg["calc.duration.minute"],
	AjxMsg["calc.duration.second"],
	AjxMsg["calc.duration.millisecond"]
].join("|");

//
// Date calculator private functions
//

AjxDateUtil.__calculate_init =
function() {
	AjxDateUtil.WEEKDAYS = {};
	var weekdays = [
		"sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"
	];
	for (var i = 0; i < weekdays.length; i++) {
		var weekday = AjxMsg["calc.dayname."+weekdays[i]].split("|");
		for (var j = 0; j < weekday.length; j++) {
			AjxDateUtil.WEEKDAYS[weekday[j].toLowerCase()] = i;
		}
	}

	AjxDateUtil.MONTHNAME2MONTHNUM = {};
	var months = [
		"january", "february", "march", "april", "may", "june",
		"july", "august", "september", "october", "november", "december"
	];
	for (var i = 0; i < months.length; i++) {
		var month = AjxMsg["calc.monthname."+months[i]].split("|");
		for (var j = 0; j < month.length; j++) {
			AjxDateUtil.MONTHNAME2MONTHNUM[month[j].toLowerCase()] = i;
		}
	}

	AjxDateUtil.RE_YEAR = new RegExp("^("+AjxMsg["calc.duration.year"]+")$", "i");
	AjxDateUtil.RE_MONTH = new RegExp("^("+AjxMsg["calc.duration.month"]+")$", "i");
	AjxDateUtil.RE_WEEK = new RegExp("^("+AjxMsg["calc.duration.week"]+")$", "i");
	AjxDateUtil.RE_DAY = new RegExp("^("+AjxMsg["calc.duration.day"]+")$", "i");
	AjxDateUtil.RE_HOUR = new RegExp("^("+AjxMsg["calc.duration.hour"]+")$", "i");
	AjxDateUtil.RE_MINUTE = new RegExp("^("+AjxMsg["calc.duration.minute"]+")$", "i");
	AjxDateUtil.RE_SECOND = new RegExp("^("+AjxMsg["calc.duration.second"]+")$", "i");
	AjxDateUtil.RE_MILLISECOND = new RegExp("^("+AjxMsg["calc.duration.millisecond"]+")$", "i");

	AjxDateUtil.RE_DATE = new RegExp("^("+AjxMsg["calc.date"]+")$", "i");
	
	AjxDateUtil.RE_DAYNAME = new RegExp("^("+AjxDateUtil.S_DAYNAME+")$", "i");
	AjxDateUtil.RE_MONTHNAME = new RegExp("^("+AjxDateUtil.S_MONTHNAME+")$", "i");
	AjxDateUtil.RE_WEEKORD = new RegExp("^("+AjxDateUtil.S_WEEKORD+")$", "i");

	AjxDateUtil.RE_COMMENT = /^#/;
	AjxDateUtil.RE_NOW = new RegExp("^("+AjxMsg["calc.now"]+")$", "i");
	AjxDateUtil.RE_ADD_NUMBER = new RegExp("^([+\\-])(\\d+)$", "i");
	AjxDateUtil.RE_SET = new RegExp("^("+AjxDateUtil.S_DURATION+"|"+AjxMsg["calc.date"]+")=(.*)$", "i");
};

AjxDateUtil.__calculate_normalizeFullWidthDigit =
function(digit) {
	var charCode = "0".charCodeAt(0) + digit.charCodeAt(0) - "\uff10".charCodeAt(0);
	return String.fromCharCode(charCode);
};

/** This is needed to handle asian full-width digits. */
AjxDateUtil.__calculate_replaceFullWidthDigit =
function($0, digit) {
	return AjxDateUtil.__calculate_normalizeFullWidthDigit(digit);
};

AjxDateUtil.__calculate_parseInt =
function(s) {
	s = s.replace(/([\uFF10-\uFF19])/g, AjxDateUtil.__calculate_normalizeFullWidthDigit);
	return parseInt(s, 10);
};

AjxDateUtil.__calculate_add =
function(date, type, amount) {
	if (type.match(AjxDateUtil.RE_YEAR)) {
		date.setFullYear(date.getFullYear() + amount);
		return;
	}
	if (type.match(AjxDateUtil.RE_MONTH)) {
		var month = date.getMonth();
		date.setMonth(month + amount);
		// avoid roll
		if (Math.abs(month + amount) % 12 != date.getMonth()) {
			date.setDate(0);
		}
		return;
	}
	if (type.match(AjxDateUtil.RE_WEEK)) {
		date.setDate(date.getDate() + amount * 7);
		return;
	}
	if (type.match(AjxDateUtil.RE_DAY)) {
		date.setDate(date.getDate() + amount);
		return;
	}
	if (type.match(AjxDateUtil.RE_HOUR)) {
		date.setHours(date.getHours() + amount);
		return;
	}
	if (type.match(AjxDateUtil.RE_MINUTE)) {
		date.setMinutes(date.getMinutes() + amount);
		return;
	}
	if (type.match(AjxDateUtil.RE_SECOND)) {
		date.setSeconds(date.getSeconds() + amount);
		return;
	}
	if (type.match(AjxDateUtil.RE_MILLISECOND)) {
		date.setMilliseconds(date.getMilliseconds() + amount);
		return;
	}
	if (type.match(AjxDateUtil.RE_MONTHNAME)) {
		var monthnum = AjxDateUtil.MONTHNAME2MONTHNUM[type.toLowerCase()];
		if (monthnum < date.getMonth()) {
			amount += amount > 0 ? 0 : 1;
		}
		else if (monthnum > date.getMonth()) {
			amount += amount > 0 ? -1 : 0;
		}
		date.setFullYear(date.getFullYear() + amount, monthnum, 1);
		return;
	}
	if (type.match(AjxDateUtil.RE_DAYNAME)) {
		var daynum = AjxDateUtil.WEEKDAYS[type.toLowerCase()];
		if (daynum < date.getDay()) {
			amount += amount > 0 ? 0 : 1;
		}
		else if (daynum > date.getDay()) {
			amount += amount > 0 ? -1 : 0;
		}
		date.setDate(date.getDate() + (daynum - date.getDay()) + 7 * amount);
		return;
	}
	throw "unknown type: "+type;
};

AjxDateUtil.__calculate_add_ordinal =
function() {
	throw "TODO: not implemented";
};

AjxDateUtil.__calculate_set =
function(date, type, value) {
	var args = value.split(/,/);
	//Add support for Japanese Heisei year format represented by H{year-number}
	//The year is H23 in H23/12/31, means 2011/12/31; we get that by adding year 1988 to 23
	//For example: H23 = 23 + 1988 = 2011(English year)
	if(args[0].indexOf("H") == 0) {
		args[0] = parseInt(args[0].replace("H", "")) + 1988;
	}
	if (type.match(AjxDateUtil.RE_YEAR)) {
		args[0] = AjxDateUtil.__calculate_fullYear(args[0]); // year
		if (args[1] != null) args[1] = AjxDateUtil.__calculate_month(args[1]); // month
		if (args[2] != null) args[2] = parseInt(args[2], 10); // date
		date.setFullYear.apply(date, args);
		return;
	}
	if (type.match(AjxDateUtil.RE_MONTH)) {
		args[0] = AjxDateUtil.__calculate_month(args[0]); // month
		if (args[1] != null) args[1] = parseInt(args[1], 10); // date
		date.setMonth.apply(date, args);
		return;
	}
    if (type.match(AjxDateUtil.RE_WEEK)) {
        var ord = AjxDateUtil.__calculate_week(args[0]); // week
        var day = args[1] ? AjxDateUtil.__calculate_day(args[1]) : date.getDay(); // day

        var target;
        if (ord != -1) {
            var firstday = new Date(date.getFullYear(), date.getMonth(), 1, 12, 0, 0, 0);
            var firstdow = firstday.getDay();
            var delta = firstdow - day;

            target = new Date(firstday.getTime());
            target.setDate(1 - delta);
            if (delta > 0) {
                target.setDate(target.getDate() + 7);
            }
            target.setDate(target.getDate() + 7 * ord);
        }
        else {
            var lastday = new Date(date.getFullYear(), date.getMonth()+1, 0, 12, 0, 0, 0);

            target = new Date(lastday.getTime());
            target.setDate(target.getDate() - (target.getDay() - day));
            if (target.getMonth() != lastday.getMonth()) {
                target.setDate(target.getDate() - 7);
            }
        }

        if (target && (date.getMonth() == target.getMonth())) {
            date.setTime(target.getTime());
        }
        return;
    }
	if (type.match(AjxDateUtil.RE_DATE)) {
		args[0] = parseInt(args[0], 10); // date
		date.setDate.apply(date, args);
		return;
	}
	if (type.match(AjxDateUtil.RE_HOUR)) {
		args[0] = parseInt(args[0], 10); // hour
		if (args[1] != null) args[1] = parseInt(args[1], 10); // minutes
		if (args[2] != null) args[2] = parseInt(args[2], 10); // seconds
		if (args[3] != null) args[3] = parseInt(args[3], 10); // milliseconds
		date.setHours.apply(date, args);
		return;
	}
	if (type.match(AjxDateUtil.RE_MINUTE)) {
		args[0] = parseInt(args[0], 10); // minutes
		if (args[1] != null) args[1] = parseInt(args[1], 10); // seconds
		if (args[2] != null) args[2] = parseInt(args[2], 10); // milliseconds
		date.setMinutes.apply(date, args);
		return;
	}
	if (type.match(AjxDateUtil.RE_SECOND)) {
		args[0] = parseInt(args[0], 10); // seconds
		if (args[1] != null) args[1] = parseInt(args[1], 10); // milliseconds
		date.setSeconds.apply(date, args);
		return;
	}
	if (type.match(AjxDateUtil.RE_MILLISECOND)) {
		date.setMilliseconds.apply(date, args); // milliseconds
		return;
	}
	throw "unknown type: "+type;
};

AjxDateUtil.__calculate_fullYear =
function(value) {
	if (value.length == 2) {
		var d = new Date;
		d.setYear(parseInt(value, 10));
        var fullYear = d.getFullYear();
        if (fullYear <= AjxMsg.dateParsing2DigitStartYear) {
            value = String(fullYear + 100);
        }
        else {
            value = String(fullYear).substr(0,2) + value;
        }
	}
	return parseInt(value, 10);
};

AjxDateUtil.__calculate_month =
function(value) {
	var monthnum = AjxDateUtil.MONTHNAME2MONTHNUM[value.toLowerCase()];
	return monthnum != null ? monthnum : parseInt(value, 10) - 1;
};

AjxDateUtil.__calculate_week = function(value) {
    for (var i = 0; i < AjxDateUtil.WEEKORD_RE.length; i++) {
        if (value.match(AjxDateUtil.WEEKORD_RE[i])) {
            if (i == AjxDateUtil.WEEKORD_RE.length - 1) {
                return -1;
            }
            return i;
        }
    }
    return 0;
};

AjxDateUtil.__calculate_day =
function(value) {
	var daynum = AjxDateUtil.WEEKDAYS[value.toLowerCase()];
	return daynum != null ? daynum : parseInt(value, 10);
};
}
if (AjxPackage.define("ajax.util.AjxSelectionManager")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * This requires an "owner" which is the object that owns the full set of items, implementing:
 * getItemCount() to return the number of items
 * getItem(index) to return the item at a given index.
 * 
 * And optionally implementing
 * itemSelectionChanged(item, index, isSelected) which is called
 *         for each item that is selected or deselected
 * selectionChanged() which is called after a batch of items have
 *         been selected or deselected with select()
 *
 * @private
 */
AjxSelectionManager = function(anOwner) {
	this._owner = anOwner;
};

// -----------------------------------------------------------
// Constants
// -----------------------------------------------------------

// Actions for select()
AjxSelectionManager.SELECT_ONE_CLEAR_OTHERS = 0;
AjxSelectionManager.TOGGLE_ONE_LEAVE_OTHERS = 1;
AjxSelectionManager.SELECT_TO_ANCHOR = 2;
AjxSelectionManager.DESELECT_ALL = 3;
AjxSelectionManager.SELECT_ALL = 4;

// -----------------------------------------------------------
// API Methods
// -----------------------------------------------------------

/**
 * returns an AjxVector
 */
AjxSelectionManager.prototype.getItems = function() {
	if (this._selectedItems == null) {
		this._selectedItems = this._createItemsCollection();
	}
	return this._selectedItems;
};

/**
 * returns the number of selected items
 */	
AjxSelectionManager.prototype.getLength = function() {
	return this.getItems().length;
};
	
/**
 * returns the anchor, unless nothing is selected
 */
AjxSelectionManager.prototype.getAnchor = function() {
	if (this._anchor == null) {
		var items = this.getItems();
		if (items.length > 0) {
			this._anchor = items[0];
		}
	}
	return this._anchor;
};
    
/**
 * The cursor probably changes when the users navigates with 
 * the keyboard. This returns the item that is currently the cursor,
 * and null if nothing is selected.
 */
AjxSelectionManager.prototype.getCursor = function() {
	if (this._cursor == null) {
		this._cursor = this.getAnchor();
	}
	return this._cursor;
};
    
    
/**
 * Returns true if the given item is selected.
 */
AjxSelectionManager.prototype.isSelected = function(item) {
	return this.getItems().binarySearch(item) != -1;
};
    
AjxSelectionManager.prototype.selectOneItem = function(item) {
	this.select(item, AjxSelectionManager.SELECT_ONE_CLEAR_OTHERS);
};
    
AjxSelectionManager.prototype.toggleItem = function(item) {
	this.select(item, AjxSelectionManager.TOGGLE_ONE_LEAVE_OTHERS);
};
	
AjxSelectionManager.prototype.selectFromAnchorToItem = function(item) {
	this.select(item, AjxSelectionManager.SELECT_TO_ANCHOR);
};
    
AjxSelectionManager.prototype.deselectAll = function() {
	this.select(null, AjxSelectionManager.DESELECT_ALL);
};
	
AjxSelectionManager.prototype.selectAll = function() {
	this.select(null, AjxSelectionManager.SELECT_ALL);
};
    
    
/**
 * This method will notify the owner of any changes by calling
 * itemSelectionChanged() (if the owner defines it) for each item whose
 * selection changes and also by calling selectionChanged() (if the
 * owner defines it) once at the end, if anything changed selection.
 *
 */
AjxSelectionManager.prototype.select = function(item, action) {
	
	// Update the anchor and cursor, if necessary
	this._setAnchorAndCursor(item, action);
    
	// save off the old set of selected items
	var oldItems = this._selectedItems;
	var oldItemsCount = (oldItems == null) ? 0 : oldItems.length;
	
	// create a fresh set of selected items
	this._selectedItems = null;
	this._selectedItems = this._createItemsCollection();
	
	// Now update the selection
	var itemCount = this._owner.getItemCount();
	var needsSort = false;
	var selectionChanged = false;
	var selecting = false;
	for (var i = 0; i < itemCount; ++i) {
		var testItem = this._owner.getItem(i);
		var oldSelectionExists = this._isItemOldSelection(testItem, oldItems);
		var newSelectionExists = oldSelectionExists;
		
		switch (action) {
		case AjxSelectionManager.SELECT_TO_ANCHOR:
			if (this._anchor == null) {
				// If we have no anchor, let it be the first item
				// in the list
				this._anchor = testItem;
			}
			var atEdge = (testItem == this._anchor || testItem == item);
			var changed = false;
			// mark the beginning of the selection for the iteration
			if (!selecting && atEdge) {
				selecting = true;
				changed = true;
			}
			newSelectionExists = selecting;
			// mark the end of the selection if we're there
			if ((!changed || this._anchor == item) 
				&& selecting && atEdge) {
				selecting = false;
			}

			break;
		case AjxSelectionManager.SELECT_ONE_CLEAR_OTHERS:
			newSelectionExists = (testItem == item);
			break;
		case AjxSelectionManager.TOGGLE_ONE_LEAVE_OTHERS:
			if (testItem == item) {
				newSelectionExists = !oldSelectionExists ;
			}
			break;
		case AjxSelectionManager.DESELECT_ALL:
			newSelectionExists = false;
			break;
		case AjxSelectionManager.SELECT_ALL:
			newSelectionExists = true;
			break;
		}

		if (newSelectionExists) {
			this._selectedItems.add(testItem);
			needsSort = (this._selectedItems.length > 1);
		}

		if ( newSelectionExists != oldSelectionExists) {
			// Something changed so notify the owner.
			if (this._owner.itemSelectionChanged != null) {
				this._owner.itemSelectionChanged(testItem, 
												 i, newSelectionExists);
			}
			selectionChanged = true;
		}
	}
	selectionChanged = selectionChanged || (oldItemsCount != 
											this._selectedItems.length);

	if (needsSort) this._selectedItems.sort();
	
	if (selectionChanged && this._owner.selectionChanged != null) {
		this._owner.selectionChanged(item);
	}
};

/**
 * Remove an item from the selection managers selected items
 * collection if it exists.
 */
AjxSelectionManager.prototype.removeItem = function(item) {
	if (this._selectedItems) {
		var index = this._selectedItems.binarySearch(item);
		if (index > -1) this._selectedItems.removeAt(index);
	}
};

// -----------------------------------------------------------
// Internal Methods
// -----------------------------------------------------------
	
/**
 * Creates an array suitable for use as the sorted list of selected
 * items and returns it.
 */
AjxSelectionManager.prototype._createItemsCollection = function() {
	return new AjxVector();
};

AjxSelectionManager.prototype._isItemOldSelection = function (testItem, oldItems) {
	var ret = false;
	if (oldItems) {
		var oldSelectionIndex = oldItems.binarySearch(testItem);
		if (oldSelectionIndex > -1) {
			oldItems.removeAt(oldSelectionIndex);
		}
		ret = (oldSelectionIndex != -1);
	}
	return ret;
};

AjxSelectionManager.prototype._setAnchorAndCursor = function (item, action) {
	switch (action) {
	case AjxSelectionManager.SELECT_TO_ANCHOR:
		this._cursor = item;
		break;
	case AjxSelectionManager.SELECT_ONE_CLEAR_OTHERS:		
		this._anchor = item;
		this._cursor = item;
		break;
	case AjxSelectionManager.TOGGLE_ONE_LEAVE_OTHERS:
		this._anchor = item;
		this._cursor = item;
		break;
	case AjxSelectionManager.DESELECT_ALL:
		this._anchor = null;
		this._cursor = null;
		break;
	case AjxSelectionManager.SELECT_ALL:
		return;
	}
};
}
if (AjxPackage.define("ajax.net.AjxPost")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * Resets the AjxPost object.
 * @constructor
 * @class
 * This singleton class makes an HTTP POST to the server and receives the response, passing returned data
 * to a callback. This class is used to upload files from the client browser to the server using the file
 * upload feature of POST.
 *
 * @param	{string}	iframeId		the iframe ID
 * 
 * @author Conrad Damon
 * 
 * @private
 */
AjxPost = function(iframeId) {
	this._callback = null;
	this._iframeId = iframeId;
}


// Globals

AjxPost._reqIds = 0;
AjxPost._outStandingRequests = new Object();


// Consts 

// Common HttpServletResponse error codes
// - see full list: http://java.sun.com/products/servlet/2.2/javadoc/javax/servlet/http/HttpServletResponse.html
AjxPost.SC_CONTINUE					= 100;
AjxPost.SC_OK						= 200;
AjxPost.SC_ACCEPTED 				= 202;
AjxPost.SC_NO_CONTENT 				= 204;
AjxPost.SC_BAD_REQUEST				= 400;
AjxPost.SC_UNAUTHORIZED				= 401;
AjxPost.SC_REQUEST_TIMEOUT			= 408;
AjxPost.SC_CONFLICT					= 409;
AjxPost.SC_REQUEST_ENTITY_TOO_LARGE = 413;
AjxPost.SC_INTERNAL_SERVER_ERROR	= 500;
AjxPost.SC_BAD_GATEWAY 				= 502;
AjxPost.SC_SERVICE_UNAVAILABLE		= 503;


// Public methods

/**
* Submits the form.
*
* @param callback		function to return to after the HTTP response is received
* @param formId			DOM ID of the form
*/
AjxPost.prototype.execute =
function(callback, form, optionalTimeout) {
	// bug fix #7361
	var tags = form.getElementsByTagName("input");
	var inputs = new Array();
	for (var i = 0; i < tags.length; i++) {
		var tag = tags[i];
		if (tag.type == "file") {
			inputs.push(tag);
			continue;
		}
		// clean up form from previous posts
		if (tag.name && tag.name.match(/^filename\d+$/)) {
			tag.parentNode.removeChild(tag);
			i--; // list is live, so stay on same index
			continue;
		}
	}
	if (window.csrfToken) {
		this._addHiddenField(inputs[0], "csrfToken", window.csrfToken);
	}
    this._addHiddenFileNames(inputs);

	form.target = this._iframeId;
	this._callback = callback;
	var req = new AjxPostRequest(form);
	var failureAction = new AjxTimedAction(this, this._onFailure, [req.id]);
	var timeout = optionalTimeout? optionalTimeout: 5000;
	AjxPost._outStandingRequests[req.id] = req;
	try {
		req.send(failureAction, timeout);
	} catch (ex) {
		if (AjxEnv.isIE) {
			if (ex.number == -2147024891) { // 0x80070005: E_ACCESSDENIED (Couldn't open file)
				throw new AjxException(ZmMsg.uploadErrorAccessDenied, ex.number);
			}
		}
		throw ex;
	}
};

AjxPost.prototype._addHiddenFileNames =
function(inputs){
    var m = 0;
    for (var i = 0; i < inputs.length; i++) {
        var fileInput = inputs[i];
        if(fileInput.files && fileInput.files.length > 1){
            var files = fileInput.files, fileStr=[];
            for(var j=0; j<files.length; j++){
               var f = files[j];
               fileStr.push(f.name || f.fileName);
            }
            this._addHiddenFileName(inputs[i], fileStr.join('\n'), ++m);
        }else{
            this._addHiddenFileName(inputs[i], inputs[i].value, ++m);
        }
    }

};

AjxPost.prototype._addHiddenFileName =
function(inputField, fileName, index){
	this._addHiddenField(inputField, "filename" + (index), fileName);
};
AjxPost.prototype._addHiddenField = function(referenceElement, fieldName, fieldValue){
	var hidden   = document.createElement("input");
	hidden.type  = "hidden";
	hidden.name  = fieldName;
	hidden.value = fieldValue;
	referenceElement.parentNode.insertBefore(hidden, referenceElement);
};


// Private methods

AjxPost.prototype._onFailure =
function (reqId){
	var req = AjxPost._outStandingRequests[reqId];
	req.cancel();
	delete AjxPost._outStandingRequests[reqId];
	if (this._callback) {
		this._callback.run([404]);
		this._callback = null;
	}
};



/**
* Processes the HTTP response from the form post. The server needs to make sure this function is
* called and passed the appropriate args. Something like the following should do the trick:
* <code>
*        out.println("<html><head></head><body onload=\"window.parent._uploadManager.loaded(" + results +");\"></body></html>");
* </code>
*
* @param status		an HTTP status
* @param id			the id for any attachments that were uploaded
*/
AjxPost.prototype.loaded =
function(status, reqId, id) {
	//alert(document.getElementById(this._iframeId).contentWindow.document.documentElement.innerHTML);
	var req = AjxPost._outStandingRequests[reqId];
	if (req && !req.hasBeenCancelled()) {
		req.cancelTimeout();
	}
	delete AjxPost._outStandingRequests[reqId];
	if (this._callback) {
		this._callback.run(status, id);
		this._callback = null;
	}
};

/**
 * @class
 * 
 * @private
 */
AjxPostRequest = function(form) {
	this.id = AjxPost._reqIds++;
	this._cancelled = false;
	this._form = form;
	var inp = form.elements.namedItem("requestId");
	if (!inp) {
		inp = form.ownerDocument.createElement('input');
		inp.type = "hidden";
		inp.name = "requestId";
	}
	inp.value = this.id;
	form.appendChild(inp);
};

AjxPostRequest.prototype.send =
function(failureAction, timeout) {
	this._form.submit();
};

AjxPostRequest.prototype.hasBeenCancelled =
function() {
	return this._cancelled;
};

AjxPostRequest.prototype.cancelTimeout =
function() {
	AjxTimedAction.cancelAction(this._timeoutId);
};

AjxPostRequest.prototype.cancel =
function() {
	this._cancelled = true;
};
}
if (AjxPackage.define("ajax.util.AjxBuffer")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * @class
 * Use this class to implement an efficient String Buffer. It is especially useful for assembling HTML.
 * <p>
 * Usage:
 * <ol>
 * <li>For a small amount of text, call it statically as:
 * <pre>
 * AjxBuffer.concat("a", 1, "b", this.getFoo(), ...);
 * </pre>
 * </li>
 * <li>Or create an instance and use that to assemble a big pile of HTML:
 * <pre>
 * var buffer = new AjxBuffer();
 * buffer.append("foo", myObject.someOtherFoo(), ...);
 * ...
 * buffer.append(fooo.yetMoreFoo());
 * return buffer.toString();
 * </pre>
 * </li>
 * </ol>
 * 
 * It is useful (and quicker!) to create a single buffer and then pass that to subroutines
 * that are doing assembly of HTML pieces for you.
 * </p><p>
 * Note: in both modes you can pass as many arguments you like to the
 * methods -- this is quite a bit faster than concatenating the arguments
 * with the + sign (eg: do not do <code>buffer.append("a" + b.foo());</code>).
 *
 * @author Owen Williams
 * 
 * @private
 */
AjxBuffer = function() {
	this.clear();
	if (arguments.length > 0) {
		arguments.join = this.buffer.join;
		this.buffer[this.buffer.length] = arguments.join("");
	}
}
AjxBuffer.prototype.toString = function () {
	return this.buffer.join("");
}
AjxBuffer.prototype.join = function (delim) {
	if (delim == null) delim = "";
	return this.buffer.join(delim);
}
AjxBuffer.prototype.append = function () {
	arguments.join = this.buffer.join;
	this.buffer[this.buffer.length] = arguments.join("");
}
AjxBuffer.prototype.join = function (str) {
	return this.buffer.join(str);
}
AjxBuffer.prototype.set = function(str) {
	this.buffer = [str];
}
AjxBuffer.prototype.clear = function() {
	this.buffer = [];
}
AjxBuffer.concat = function() {
	arguments.join = Array.prototype.join;
	return arguments.join("");
}
AjxBuffer.append = AjxBuffer.concat;
}
if (AjxPackage.define("ajax.util.AjxTimezone")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * This class holds all of the known timezone rules. Each timezone
 * is represented by an object that has a unique identifier and the
 * offset to UTC in standard time. If the timezone defines daylight
 * savings time, then additional information is provided (e.g. when
 * the DST takes effect and it's offset to UTC).
 * <p>
 * Both the standard and daylight information are specified as objects
 * with the following properties:
 * <dl>
 * <dt> offset
 *   <dd> The offset to UTC (in minutes)
 * <dt> mon
 *   <dd> The transition month of the year (January = 1, ...).
 * <dt> week
 *   <dd> The transition week of the month (First = 1, ..., Fourth = 4,
 *        Last = -1).
 * <dt> wkday
 *   <dd> The transition day of the week (Sunday = 1, ...).
 * <dt> mday
 *   <dd> The transition day of the month (1, ... 31).
 * <dt> hour
 *   <dd> The transition hour (midnight = 0, noon = 12, ...).
 * <dt> min
 *   <dd> The transition minute.
 * <dt> sec
 *   <dt> The transition second (which is usually 0).
 * </dl>
 *
 * <h5>Notes</h5>
 * <ul>
 * <li> Timezones with no DST only specify an id and a standard info
 *      object with a single "offset" property.
 * <li> Timezones with a DST <em>must</em> provide standard and
 *      daylight info objects.
 * <li> If timezone has DST, then the following properties of the
 *      standard and daylight info objects are <em>required</em>:
 *      offset, month, hour, min, sec.
 * <li> Transition dates are specified in only one of the following ways:
 *   <ul>
 *   <li> by specifying a specific date of the year (e.g. March 10);
 *   <li> or by specifying the day of a specific week within some
 *        month (e.g. Second Wednesday, Last Saturday, etc).
 *   </ul>
 * <li> If the transition date is specified as a specific date of the
 *      year, then the following field in the standard and/or daylight
 *      info objects are <em>required</em>: mday.
 * <li> If the transition date is specified as the day of a specific
 *      week, then the following fields in the standard and/or daylight
 *      info objects are <em>required</em>: week, wkday.
 * </ul>
 *
 * <h5>Examples</h5>
 * <dl>
 * <dt> Timezone with no DST
 *   <dd>
 *   <pre>
 *   var timezone = { clientId: "My Timezone", standard: { offset: -480 } };
 *   </pre>
 * <dt> America/Los_Angeles, 2007
 *   <dd>
 *   <pre>
 *   var standard = {
 *     offset: -480,
 *     mon: 11, week: 1, wkday: 1,
 *     hour: 2, min: 0, sec: 0    
 *   };
 *   var daylight = {
 *     offset: -420,
 *     mon: 3, week: 2, wkday: 1,
 *     hour: 2, min: 0, sec: 0
 *   };
 *   var timezone = { clientId: "My Timezone",
 *                    standard: standard, daylight: daylight };
 *   </pre>
 * <dt> Custom US/Pacific using 11 Mar 2007 and 2 Dec 2007
 *   <dd>
 *   <pre>
 *   var standard = {
 *     offset: -480,
 *     mon: 11, mday: 2,
 *     hour: 2, min: 0, sec: 0
 *   };
 *   var daylight = {
 *     offset: -420,
 *     mon: 3, mday: 11,
 *     hour: 2, min: 0, sec: 0
 *   };
 *   var timezone = { clientId: "My Timezone",
 *                    standard: standard, daylight: daylight };
 *   </pre>
 * </dl>
 * <p>
 * <strong>Note:</strong>
 * Specifying a transition date using a specific date of the year
 * <em>should</em> be avoided.
 *
 * <hr>
 *
 * <p>
 * This class stores mappings between client and server identifiers for
 * timezones as well as attempting to guess the default timezone. The 
 * application can override this value, through a user preference perhaps, 
 * by setting the <code>DEFAULT</code> property's value. The default 
 * timezone is specified using the client identifier.
 *
 * @class
 */
AjxTimezone = function() {};

//
// Static methods
//

AjxTimezone.convertTimezone = function(date, fromClientId, toClientId) {
	if (fromClientId == toClientId) {
		return date;
	}
	var offset1 = AjxTimezone.getOffset(toClientId, date);
	var offset2 = AjxTimezone.getOffset(fromClientId, date);
	//returning a new Date object since we might not always want to modify the parameter Date object
	return new Date(date.getTime() + (offset1 - offset2) * 60 * 1000);
};


AjxTimezone.getTransition = function(onset, year) {
	var trans = [ year || new Date().getFullYear(), onset.mon, 1 ];
	if (onset.mday) {
		trans[2] = onset.mday;
	}
	else if (onset.wkday) {
		var date = new Date(year, onset.mon - 1, 1, onset.hour, onset.min, onset.sec);

		// last wkday of month
		if (onset.week == -1) {
			// NOTE: This creates a date of the *last* day of specified month by
			//       setting the month to *next* month and setting day of month
			//       to zero (i.e. the day *before* the first day).
			var last = new Date(new Date(date.getTime()).setMonth(onset.mon, 0));
			var count = last.getDate();
			var wkday = last.getDay() + 1;
			var adjust = wkday >= onset.wkday ? wkday - onset.wkday : 7 - onset.wkday - wkday;
			trans[2] = count - adjust;
		}

		// Nth wkday of month
		else {
			var wkday = date.getDay() + 1;
			var adjust = onset.wkday == wkday ? 1 :0;
			trans[2] = onset.wkday + 7 * (onset.week - adjust) - wkday + 1;
		}
	}
	return trans;
};

AjxTimezone.createMDayTransition = function(date, offset) {
	if (date instanceof Date) {
		offset = offset != null ? offset : date.getTimezoneOffset();
		date = [
			date.getFullYear(), date.getMonth() + 1, date.getDate(),
			date.getHours(), date.getMinutes(), date.getSeconds()
		];
	}
	var onset = { offset: offset, trans: date };
	return AjxTimezone.addMDayTransition(onset);
};

AjxTimezone.addMDayTransition = function(onset) {
	var trans = onset.trans;
	onset.mon = trans[1];
	onset.mday = trans[2];
	onset.hour = trans[3];
	onset.min = trans[4];
	onset.sec = trans[5];
	return onset;
};

AjxTimezone.createWkDayTransition = function (date, offset) {
	if (date instanceof Date) {
		offset = offset != null ? offset : date.getTimezoneOffset();
		date = [
			date.getFullYear(), date.getMonth() + 1, date.getDate(),
			date.getHours(), date.getMinutes(), date.getSeconds()
		];
	}
	var onset = { offset: offset, trans: date };
	return AjxTimezone.addWkDayTransition(onset);
};

AjxTimezone.addWkDayTransition = function(onset) {
	var trans = onset.trans;
	var mon = trans[1];
	var monDay = trans[2];
	var week = Math.floor((monDay - 1) / 7);
	var date = new Date(trans[0], trans[1] - 1, trans[2], 12, 0, 0);

	// NOTE: This creates a date of the *last* day of specified month by
	//       setting the month to *next* month and setting day of month
	//       to zero (i.e. the day *before* the first day).
	var count = new Date(new Date(date.getTime()).setMonth(mon - 1, 0)).getDate();
	var last = count - monDay < 7;

	// set onset values
	onset.mon =  mon;
	onset.week = last ? -1 : week + 1;
	onset.wkday = date.getDay() + 1;
	onset.hour = trans[3];
	onset.min = trans[4];
	onset.sec = trans[5];
	return onset;
};

AjxTimezone.createTransitionDate = function(onset) {
    var date = new Date(AjxTimezoneData.TRANSITION_YEAR, onset.mon - 1, 1, 12, 0, 0);
    if (onset.mday) {
        date.setDate(onset.mday);
    }
    else if (onset.week == -1) {
        date.setMonth(date.getMonth() + 1, 0);
        for (var i = 0; i < 7; i++) {
            if (date.getDay() + 1 == onset.wkday) {
                break;
            }
            date.setDate(date.getDate() - 1);
        }
    }
    else {
        for (var i = 0; i < 7; i++) {
            if (date.getDay() + 1 == onset.wkday) {
                break;
            }
            date.setDate(date.getDate() + 1);
        }
        date.setDate(date.getDate() + 7 * (onset.week - 1));
    }
    var trans = [ date.getFullYear(), date.getMonth() + 1, date.getDate() ];
    return trans;
};

AjxTimezone.getZonePreferences =
function() {
	if (AjxTimezone._PREF_ZONE_DISPLAY) {
		var count = AjxTimezone._PREF_ZONE_DISPLAY.length;
		var total = AjxTimezone.STANDARD_RULES.length + AjxTimezone.DAYLIGHT_RULES.length;
		if (count != total) {
			AjxTimezone._PREF_ZONE_DISPLAY = null;
		}
	}

	if (!AjxTimezone._PREF_ZONE_DISPLAY) {
		AjxTimezone._PREF_ZONE_DISPLAY = [];
		AjxTimezone.getAbbreviatedZoneChoices();
		for (var i = 0; i < AjxTimezone._ABBR_ZONE_OPTIONS.length; i++) {
			AjxTimezone._PREF_ZONE_DISPLAY.push(AjxTimezone._ABBR_ZONE_OPTIONS[i].displayValue);
		}
	}
	return AjxTimezone._PREF_ZONE_DISPLAY;
};

AjxTimezone.getZonePreferencesOptions =
function() {
	if (AjxTimezone._PREF_ZONE_OPTIONS) {
		var count = AjxTimezone._PREF_ZONE_OPTIONS.length;
		var total = AjxTimezone.STANDARD_RULES.length + AjxTimezone.DAYLIGHT_RULES.length;
		if (count != total) {
			AjxTimezone._PREF_ZONE_OPTIONS = null;
		}
	}

	if (!AjxTimezone._PREF_ZONE_OPTIONS) {
		AjxTimezone._PREF_ZONE_OPTIONS = [];
		AjxTimezone.getAbbreviatedZoneChoices();
		for (var i = 0; i < AjxTimezone._ABBR_ZONE_OPTIONS.length; i++) {
			AjxTimezone._PREF_ZONE_OPTIONS.push(AjxTimezone._ABBR_ZONE_OPTIONS[i].value); //use value is better, serverID is usd by compare operator.
		}
	}
	return AjxTimezone._PREF_ZONE_OPTIONS;
};

AjxTimezone.getServerId = function(clientId) {
	return AjxTimezone._CLIENT2SERVER[clientId] || clientId;
};
AjxTimezone.getClientId = function(serverId) {
	return AjxTimezone._SERVER2CLIENT[serverId] || serverId;
};

AjxTimezone.getShortName = function(clientId) {
	var rule = AjxTimezone.getRule(clientId);
    if (rule && rule.shortName) return rule.shortName;
    var generatedShortName = ["GMT",AjxTimezone._SHORT_NAMES[clientId]].join("");
    if(rule) rule.shortName = generatedShortName;
	return generatedShortName;
};

AjxTimezone.getMediumName = function(clientId) {
	var rule = AjxTimezone.getRule(clientId);
    if (rule && rule.mediumName) return rule.mediumName;
    var generatedMediumName = TzMsg[clientId] || ['(',AjxTimezone.getShortName(clientId),') ',clientId].join("");
    if(rule) rule.mediumName = generatedMediumName;
	return generatedMediumName;
};

AjxTimezone.getLongName = AjxTimezone.getMediumName;

AjxTimezone.addRule = function(rule) {
    var serverId = rule.serverId;
    var clientId = rule.clientId;

    AjxTimezone._CLIENT2SERVER[clientId] = serverId;
    AjxTimezone._SERVER2CLIENT[serverId] = clientId;
    AjxTimezone._SHORT_NAMES[clientId] = AjxTimezone._generateShortName(rule.standard.offset);
    AjxTimezone._CLIENT2RULE[clientId] = rule;

    var array = rule.daylight ? AjxTimezone.DAYLIGHT_RULES : AjxTimezone.STANDARD_RULES;
    array.push(rule);
};

AjxTimezone.getRule = function(clientId, tz) {
	var rule = AjxTimezone._CLIENT2RULE[clientId];
    if (!rule) {
        // try to find the rule treating the clientId as the serverId
        clientId = AjxTimezone._SERVER2CLIENT[clientId];
        rule = AjxTimezone._CLIENT2RULE[clientId];
    }
    if (!rule && tz) {
        var names = [ "standard", "daylight" ];
        var rules = tz.daylight ? AjxTimezone.DAYLIGHT_RULES : AjxTimezone.STANDARD_RULES;
        for (var i = 0; i < rules.length; i++) {
            rule = rules[i];

            var found = true;
            for (var j = 0; j < names.length; j++) {
                var name = names[j];
                var onset = rule[name];
                if (!onset) continue;
			
				var breakOuter = false;

                for (var p in tz[name]) {
                    if (tz[name][p] != onset[p]) {
                        found = false;
                        breakOuter = true;
                        break;
                    }
                }
                
                if(breakOuter){
                	break;
                }
            }
            if (found) {
                return rule;
            }
        }
        return null;
    }

    return rule;
};

AjxTimezone.getOffset = function(clientId, date) {
	var rule = AjxTimezone.getRule(clientId || AjxTimezone.DEFAULT);
	if (rule && rule.daylight) {
		var year = date.getFullYear();

		var standard = rule.standard, daylight  = rule.daylight;
		var stdTrans = AjxTimezone.getTransition(standard, year);
		var dstTrans = AjxTimezone.getTransition(daylight, year);

		var month    = date.getMonth()+1, day = date.getDate();
		var stdMonth = stdTrans[1], stdDay = stdTrans[2];
		var dstMonth = dstTrans[1], dstDay = dstTrans[2];

		// northern hemisphere
		var isDST = false;
		if (dstMonth < stdMonth) {
			isDST = month > dstMonth && month < stdMonth;
			isDST = isDST || (month == dstMonth && day >= dstDay);
			isDST = isDST || (month == stdMonth && day <  stdDay);
		}

		// sorthern hemisphere
		else {
			isDST = month < stdMonth || month > dstMonth;
			isDST = isDST || (month == dstMonth && day >=  dstDay);
			isDST = isDST || (month == stdMonth && day < stdDay);
		}

		return isDST ? daylight.offset : standard.offset;
	}
	return rule ? rule.standard.offset : -(new Date().getTimezoneOffset());
};

AjxTimezone.guessMachineTimezone = function() {
	return AjxTimezone._guessMachineTimezone().clientId;
};

AjxTimezone.getAbbreviatedZoneChoices = function() {
	if (AjxTimezone._ABBR_ZONE_OPTIONS) {
		var count = AjxTimezone._ABBR_ZONE_OPTIONS.length;
		var total = AjxTimezone.STANDARD_RULES.length + AjxTimezone.DAYLIGHT_RULES.length;
		if (count != total) {
			AjxTimezone._ABBR_ZONE_OPTIONS = null;
		}
	}
	if (!AjxTimezone._ABBR_ZONE_OPTIONS) {
		AjxTimezone._ABBR_ZONE_OPTIONS = [];
		for (var clientId in AjxTimezone._CLIENT2SERVER) {
			var rule = AjxTimezone._CLIENT2RULE[clientId];
			var serverId = rule.serverId;
			var option = {
				displayValue: AjxTimezone.getMediumName(clientId),
				value: serverId,
				// these props used by sort comparator
				standard: rule.standard,
				serverId: serverId, //In _BY_OFFSET, the attribute name is serverId.
                clientId: clientId
			};
			AjxTimezone._ABBR_ZONE_OPTIONS.push(option);
		}
		AjxTimezone._ABBR_ZONE_OPTIONS.sort(AjxTimezone._BY_OFFSET);
	}
	return AjxTimezone._ABBR_ZONE_OPTIONS;
};

AjxTimezone.getMatchingTimezoneChoices = function() {
	if (AjxTimezone._MATCHING_ZONE_OPTIONS) {
		var count = AjxTimezone._MATCHING_ZONE_OPTIONS.length;
		var total = AjxTimezone.STANDARD_RULES.length + AjxTimezone.DAYLIGHT_RULES.length;
		if (count != total) {
			AjxTimezone._MATCHING_ZONE_OPTIONS = null;
		}
	}
	if (!AjxTimezone._MATCHING_ZONE_OPTIONS) {
		AjxTimezone._MATCHING_ZONE_OPTIONS = [];
		for (var i in AjxTimezone.MATCHING_RULES) {
			var rule = AjxTimezone.MATCHING_RULES[i];
			var clientId = rule.clientId;
			var serverId = rule.serverId;
            if(clientId == AjxTimezone.AUTO_DETECTED) continue;
			var option = {
				displayValue: AjxTimezone.getMediumName(clientId),
				value: serverId,
				// these props used by sort comparator
				standard: rule.standard,
				serverId: serverId, //In _BY_OFFSET, the attribute name is serverId.
                clientId: clientId
			};
			AjxTimezone._MATCHING_ZONE_OPTIONS.push(option);
		}
		AjxTimezone._MATCHING_ZONE_OPTIONS.sort(AjxTimezone._BY_OFFSET);
	}
	return AjxTimezone._MATCHING_ZONE_OPTIONS;
};

AjxTimezone._BY_OFFSET = function(arule, brule) {
	// sort by offset and then by name
	var delta = arule.standard.offset - brule.standard.offset;
	if (delta == 0) {
		var aname = arule.serverId;
		var bname = brule.serverId;
		if (aname < bname) delta = -1;
		else if (aname > bname) delta = 1;
	}
	return delta;
};

// Constants

/**
 * Client identifier for GMT.
 * <p>
 * <strong>Note:</strong>
 * UK observes daylight savings time so this constant should
 * <em>not</em> be used as the reference point (i.e. UTC) --
 * use {@link AjxTimezone.GMT_NO_DST} instead. The name of
 * this constant is historical.
 */
AjxTimezone.GMT = "Europe/London";

/**
 * Client identifier for GMT with no daylight savings time.
 */
AjxTimezone.GMT_NO_DST = "UTC";

/**
 * <strong>Note:</strong>
 * Do NOT change this value because it is used to reference messages.
 */
AjxTimezone.AUTO_DETECTED = "Auto-Detected";

/**
 * The default timezone is set by guessing the machine timezone later
 * in this file. See the static initialization section below for details.
 */

AjxTimezone._CLIENT2SERVER = {};
AjxTimezone._SERVER2CLIENT = {};
AjxTimezone._SHORT_NAMES = {};
AjxTimezone._CLIENT2RULE = {};

/** 
 * The data is specified using the server identifiers for historical
 * reasons. Perhaps in the future we'll use the client (i.e. Java)
 * identifiers on the server as well.
 */
AjxTimezone.STANDARD_RULES = [];
AjxTimezone.DAYLIGHT_RULES = [];
(function() {
    for (var i = 0; i < AjxTimezoneData.TIMEZONE_RULES.length; i++) {
        var rule = AjxTimezoneData.TIMEZONE_RULES[i];
        var array = rule.daylight ? AjxTimezone.DAYLIGHT_RULES : AjxTimezone.STANDARD_RULES;
        array.push(rule);
    }
})();

/**
 * One problem with firefox, is if the timezone on the machine changes,
 * the browser isn't updated. You have to restart firefox for it to get the 
 * new machine timezone.
 * <p>
 * <strong>Note:</strong>
 * It looks like the current versions of FF always reflect the current
 * timezone w/o needing to restart the browser.
 * timezonePreference - optional value used to decide timezone rule in case of conflict 
 */
AjxTimezone._guessMachineTimezone = 
function(timezonePreference) {
	var dec1 = new Date(AjxTimezoneData.TRANSITION_YEAR, 11, 1, 0, 0, 0);
	var jun1 = new Date(AjxTimezoneData.TRANSITION_YEAR, 5, 1, 0, 0, 0);
	var dec1offset = -dec1.getTimezoneOffset();
	var jun1offset = -jun1.getTimezoneOffset();

    AjxTimezone.MATCHING_RULES = [];
    AjxTimezone.TIMEZONE_CONFLICT = false;
    var matchingRules = [];
    var matchingRulesMap = {};
    var offsetMatchingRules = [];
    var daylightMatchingFound = false;

    // if the offset for jun is the same as the offset in december,
	// then we have a timezone that doesn't deal with daylight savings.
	if (jun1offset == dec1offset) {
		var rules = AjxTimezone.STANDARD_RULES;
 		for (var i = 0; i < rules.length ; ++i ) {
            var rule = rules[i];
            if (rule.standard.offset == jun1offset) {
				 if(!matchingRulesMap[rule.serverId]) {
                     matchingRules.push(rule);
                     matchingRulesMap[rule.serverId] = true;
                 }
                 AjxTimezone.MATCHING_RULES.push(rule);
			}
		}
	}

    // we need to find a rule that matches both offsets
    else {
		var rules = AjxTimezone.DAYLIGHT_RULES;
		var dst = Math.max(dec1offset, jun1offset);
		var std = Math.min(dec1offset, jun1offset);
        var now = new Date();
        var currentOffset = -now.getTimezoneOffset();
        for (var i = 0; i < rules.length ; ++i ) {
			var rule = rules[i];
			if (rule.standard.offset == std && rule.daylight.offset == dst) {
                var strans = rule.standard.trans;
                var dtrans = rule.daylight.trans;

                var s0 = new Date(strans[0], strans[1]-1, strans[2]-1);
                var s1 = new Date(strans[0], strans[1]-1, strans[2]+2);
                var d0 = new Date(dtrans[0], dtrans[1]-1, dtrans[2]-1);
                var d1 = new Date(dtrans[0], dtrans[1]-1, dtrans[2]+2);
                if (-s1.getTimezoneOffset() == std && -d1.getTimezoneOffset() == dst &&
                    -s0.getTimezoneOffset() == dst && -d0.getTimezoneOffset() == std) {
                    if(!matchingRulesMap[rule.serverId]) {
                        matchingRules.push(rule);
                        matchingRulesMap[rule.serverId] = true;
                    }                    
                    daylightMatchingFound = true;
                }
            }
            //used for conflict resolution when server rules are wrong 
            if (rule.standard.offset == currentOffset || rule.daylight.offset == currentOffset) {
                    AjxTimezone.MATCHING_RULES.push(rule);
            }
		}
	}

    //when there is a timezone conflict use the preference to find better match
    if((matchingRules.length > 0) && timezonePreference != null) {
        var rules = matchingRules; 
        for(var i in rules) {
            if(rules[i].serverId == timezonePreference) {
                return rules[i];
            }
        }
    }

    if(matchingRules.length > 0) {
        // resolve conflict, if possible
        if (matchingRules.length > 1) {
            matchingRules.sort(AjxTimezone.__BY_SCORE);
            if (matchingRules[0].score != matchingRules[1].score) {
                matchingRules.length = 1;
            }
        }
        // mark if conflict and return best guess
        AjxTimezone.TIMEZONE_CONFLICT = (matchingRules.length > 1);  
        return matchingRules[0];        
    }

    if((AjxTimezone.MATCHING_RULES.length > 0) && timezonePreference != null) {
        var rules = AjxTimezone.MATCHING_RULES; 
        for(var i in rules) {
            if(rules[i].serverId == timezonePreference) {
                return rules[i];
            }
        }
    }

    // generate default rule
    return AjxTimezone._generateDefaultRule();
};

AjxTimezone.__BY_SCORE = function(a, b) {
    return b.score - a.score;
};

// Thanks to Jiho for this new, improved logic for generating the timezone rule.
AjxTimezone._generateDefaultRule = function() {
	var byMonth = 0;
	var byDate = 1;
	var byHour = 2;
	var byMinute = 3;
	var bySecond = 4;

	// Sweep the range between d1 and d2 looking for DST transitions.
	// Iterate the range by "by" unit.  When a transition is detected,
	// sweep the range between before/after dates by increasingly
	// smaller unit, month then date then hour then minute then finally second.
	function sweepRange(d1, d2, by, rule) {
		var upperBound = d2.getTime();
		var d = new Date();
		d.setTime(d1.getTime());
		var prevD = new Date();
		prevD.setTime(d.getTime());
		var prevOffset = d1.getTimezoneOffset() * -1;

		// initialize rule
		if (!rule) {
			rule = {
				clientId: AjxTimezone.AUTO_DETECTED,
				autoDetected: true
			};
		}

		// perform sweep
		while (d.getTime() <= upperBound) {
			// Increment by the right unit.
			if (by == byMonth) {
				d.setUTCMonth(d.getUTCMonth() + 1);
			}
			else if (by == byDate) {
				d.setUTCDate(d.getUTCDate() + 1);
			}
			else if (by == byHour) {
				d.setUTCHours(d.getUTCHours() + 1);
			}
			else if (by == byMinute) {
				d.setUTCMinutes(d.getUTCMinutes() + 1);
			}
			else if (by == bySecond) {
				d.setUTCSeconds(d.getUTCSeconds() + 1);
			}
			else {
				return rule;
			}

			var offset = d.getTimezoneOffset() * -1;
			if (offset != prevOffset) {
				if (by < bySecond) {
					// Drill down.
					rule = sweepRange(prevD, d, by + 1, rule);
				}
				else {
					// Tricky:
					// Initialize a Date object whose UTC fields are set to prevD's local fields.
					// Then add 1 second to get UTC version of onset time.  We want to work in UTC
					// to prevent the date object from experiencing the DST jump when we add 1 second.
					var trans = new Date();
					trans.setUTCFullYear(prevD.getFullYear(), prevD.getMonth(), prevD.getDate());
					trans.setUTCHours(prevD.getHours(), prevD.getMinutes(),     prevD.getSeconds() + 1);

					var onset = rule[prevOffset < offset ? "daylight" : "standard"] = {
						offset: offset,
						trans: [
							trans.getUTCFullYear(), trans.getUTCMonth() + 1, trans.getUTCDate(),    // yyyy-MM-dd
							trans.getUTCHours(),    trans.getUTCMinutes(),   trans.getUTCSeconds()  //   HH:mm:ss
						]
					};
					AjxTimezone.addWkDayTransition(onset);
					return rule;
				}
			}

			prevD.setTime(d.getTime());
			prevOffset = offset;
		}

		return rule;
	}

	// Find DST transitions between yyyy/07/71 00:00:00 and yyyy+1/06/30 23:59:59.
	// We can detect transition on/around 12/31 and 01/01.  Assume no one will
	// transition on/around 6/30 and 07/01.
	var d1 = new Date();
	var d2 = new Date();

	// set sweep start to yesterday
	var year = d1.getFullYear();
	d1.setUTCFullYear(year, d1.getMonth(), d1.getDate() - 1);
	d1.setUTCHours(0, 0, 0, 0);

	// set sweep end to tomorrow + 1 year
	d2.setTime(d1.getTime());
	d2.setUTCFullYear(year + 1, d1.getMonth(), d1.getDate() + 1);

	// case 1: no onset returned -> TZ doesn't use DST
	// case 2: two onsets returned -> TZ uses DST
	// case 3: only one onset returned -> mid-year policy change -> simplify and assume it's non-DST
	// case 4: three or more onsets returned -> shouldn't happen
	var rule = sweepRange(d1, d2, byMonth);

	// handle case 1 and 3
	if (!rule.daylight || !rule.standard) {
		rule.standard = { offset: d1.getTimezoneOffset() * -1 };
		delete rule.daylight;
	}

	// now that standard offset is determined, set serverId
	rule.serverId = ["(GMT",AjxTimezone._generateShortName(rule.standard.offset, true),") ",AjxTimezone.AUTO_DETECTED].join("");

	// bug 33800: guard against inverted daylight/standard onsets
	if (rule.daylight && rule.daylight.offset < rule.standard.offset) {
		var onset = rule.daylight;
		rule.daylight = rule.standard;
		rule.standard = onset;
	}

	// add generated rule to proper list
	//AjxTimezoneData.TIMEZONE_RULES.unshift(rule);
	//var rules = rule.daylight ? AjxTimezone.DAYLIGHT_RULES : AjxTimezone.STANDARD_RULES;
	//rules.unshift(rule);

	return rule;
};

AjxTimezone._generateShortName = function(offset, period) {
	if (offset == 0) return "";
	var sign = offset < 0 ? "-" : "+";
	var stdOffset = Math.abs(offset);
	var hours = Math.floor(stdOffset / 60);
	var minutes = stdOffset % 60;
	hours = hours < 10 ? '0' + hours : hours;
	minutes = minutes < 10 ? '0' + minutes : minutes;
	return [sign,hours,period?".":"",minutes].join("");
};

// Static initialization

AjxTimezone.DEFAULT_RULE = AjxTimezone._guessMachineTimezone();


/*** DEBUG ***
// This forces the client to create an auto-detected timezone rule,
// regardless of whether the actual timezone was detected correctly
// from the known list.
AjxTimezone.DEFAULT_RULE = AjxTimezone._generateDefaultRule();
/***/

(function() {
    AjxTimezoneData.TIMEZONE_RULES.sort(AjxTimezone._BY_OFFSET);
    for (var j = 0; j < AjxTimezoneData.TIMEZONE_RULES.length; j++) {
        var rule = AjxTimezoneData.TIMEZONE_RULES[j];
        AjxTimezone.addRule(rule);
    }
})();

AjxTimezone.DEFAULT = AjxTimezone.getClientId(AjxTimezone.DEFAULT_RULE.serverId);
}
if (AjxPackage.define("ajax.xslt.AjxXslt")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * XSLT engine <a href="http://www.w3.org/TR/xslt">http://www.w3.org/TR/xslt</a>
 * @class
 * Supports IE and Firefox. Use the following static methods to create instance.
 *
 * <pre>
 * xslt = AjxXslt.createFromUrl(url of the stylesheet)
 * xslt = AjxXslt.createFromString(stylesheet in string)
 * </pre>
 *
 * Then apply the transformation on a document.  Two methods are available depending on the needs.
 *
 * <pre>
 * dom = xslt.transformToDom(doc);
 * xml = xslt.transformToString(doc);
 * </pre>
 * 
 * @private
 */
AjxXslt = function() {
	var doc = AjxXmlDoc.create();
	if (AjxEnv.isIE) {
		var msdoc = null;
		var vers = ["MSXML2.FreeThreadedDOMDocument.5.0", "MSXML2.FreeThreadedDOMDocument.3.0"];
		for (var i = 0; i < vers.length; i++) {
			try {
				msdoc = new ActiveXObject(vers[i]);
				break;
			} catch (ex) {
			}
		}
		if (!msdoc) {
			throw new AjxException("FreeThreadedDOMDocument", AjxException.UNSUPPORTED, "AjxXslt");
		}
		msdoc.async = false;
		doc._doc = msdoc;
	}
	this._doc = doc;
};

AjxXslt.prototype.toString =
function() {
	return "AjxXslt";
};

AjxXslt.createFromUrl =
function(url) {
	var xslt = new AjxXslt();

	xslt.loadUrl(url);

	return xslt;
};

AjxXslt.createFromString =
function(str) {
	var xslt = new AjxXslt();
	
	xslt._doc.loadFromString(str);
	xslt.createProcessor();
	
	return xslt;
};

AjxXslt.prototype.createProcessor =
function() {
	var doc = this._doc.getDoc();
	if (AjxEnv.isIE) {
		var err = doc.parseError;
	    if (err.errorCode != 0) {
			DBG.println(AjxDebug.DBG1, "Parse error (" + err.reason + ") at line " + err.line + ", character " + err.linepos + "\n" + err.srcText);
			throw new AjxException(err.reason, AjxException.INVALID_PARAM, "AjxXslt.createProcessor");
		}

		var proc = null;
		var vers = ["MSXML2.XSLTemplate.5.0", "MSXML2.XSLTemplate.3.0"];
		for (var i = 0; i < vers.length; i++) {
			try {
				proc = new ActiveXObject(vers[i]);
				break;
			} catch (ex) {
			}
		}
		if (!proc) {
			throw new AjxException("XSLTemplate", AjxException.UNSUPPORTED, "AjxXslt.createProcessor");
		}
        this._processor = proc;
		if(this._processor) {
			this._processor.stylesheet = doc;
		}
	} else {
		this._processor = new XSLTProcessor();
		if(this._processor) {
			this._processor.importStylesheet(doc);
		}
	}
};

AjxXslt._finishedLoading =
function() {
	var xslt = this._xslt;  // "this" is the document which xsl is being loaded to.
	xslt.createProcessor();
};

AjxXslt.prototype.loadUrl =
function(url) {
	var doc = this._doc;
	
	if (AjxEnv.isNav) {
		var docImpl = doc.getDoc();
		docImpl._xslt = this;  // for callback
		docImpl.addEventListener("load", AjxXslt._finishedLoading, false);
	}

	doc.loadFromUrl(url);

	if (AjxEnv.isIE || AjxEnv.isChrome || AjxEnv.isSafari) {
		this.createProcessor();
	}
};

AjxXslt.prototype.transformToDom =
function(dom) {
	var ret;
	if (AjxEnv.isIE) {
		ret = this.transformIE(dom);
	} else {
		return this.transformNav(dom);  // already in dom
	}
	var doc = AjxXmlDoc.createFromXml(ret);
	return doc.getDoc();
};

AjxXslt.prototype.transformToString =
function(dom) {
	var ret;
	if (AjxEnv.isIE) {
		return this.transformIE(dom);  // already in str
	} else if (AjxEnv.isNav || AjxEnv.isChrome || AjxEnv.isSafari) {
		ret = this.transformNav(dom);
	} else {
		DBG.println(AjxDebug.DBG1, "No XSL transformation due to browser incompatibility.");
		return dom.documentElement.innerHTML;
	}
	
	if (!ret || !ret.documentElement) {
		throw new AjxException("XSL transformation failed.", AjxException.INVALID_PARAM, "AjxXslt.transformToString");
	}
	
	var elem = ret.documentElement;
	if ((elem instanceof HTMLElement) ||
		(elem instanceof HTMLHtmlElement)) {
		// good.
		return elem.innerHTML;
	} else if (elem instanceof Element) {
		// ok.
		return AjxXmlDoc.replaceInvalidChars(elem.xml);
	}
	DBG.println(AjxDebug.DBG1, "Transformation resulted in non-element.");
	return dom.documentElement.innerHTML;
};

/**
* IE returns html text.
*/
AjxXslt.prototype.transformIE =
function(dom) {
	try {
		var xsltProc = this._processor.createProcessor();
        xsltProc.input = dom;
        xsltProc.transform();
		return xsltProc.output;
	} catch (exception) {
		DBG.println(AjxDebug.DBG1, "Exception in XSL transformation: "+exception.description);
		throw new AjxException(exception.description, AjxException.INVALID_PARAM, "AjxXslt.transformIE");
	}
};

/**
* Returns either HTMLDocument or XMLDocument, depending on the transformation.
*/
AjxXslt.prototype.transformNav =
function(dom) {
	if(!this._processor) {
		return "";
	}
	return this._processor.transformToDocument(dom);
};

/**
* Returns DocumentFragment
*/
AjxXslt.prototype.transformNav2 =
function(dom) {
	this._fragment = document.implementation.createDocument("", "", null);
	if(!this._processor) {
		return "";
	}
	return this._processor.transformToFragment(dom, this._fragment);
};
}
if (AjxPackage.define("ajax.util.AjxSHA1")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only
/*
 * Based on code by Paul Johnston:
 *
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var AjxSHA1 = function() {

	/*
	 * Configurable variables. You may need to tweak these to be compatible with
	 * the server-side, but the defaults work in most cases.
	 */
	var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
	var b64pad  = ""; /* base-64 pad character. "=" for strict RFC compliance   */
	var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

	/*
	 * These are the functions you'll usually want to call
	 * They take string arguments and return either hex or base-64 encoded strings
	 */
	function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));};
	function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));};
	function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));};
	function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));};
	function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));};
	function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));};

	/*
	 * Perform a simple self-test to see if the VM is working
	 */
	function sha1_vm_test()
	{
		return hex_sha1("abc") == "a9993e364706816aba3e25717850c26c9cd0d89d";
	};

	/*
	 * Calculate the SHA-1 of an array of big-endian words, and a bit length
	 */
	function core_sha1(x, len)
	{
		/* append padding */
		x[len >> 5] |= 0x80 << (24 - len % 32);
		x[((len + 64 >> 9) << 4) + 15] = len;

		var w = Array(80);
		var a =  1732584193;
		var b = -271733879;
		var c = -1732584194;
		var d =  271733878;
		var e = -1009589776;

		for(var i = 0; i < x.length; i += 16) {
			var olda = a;
			var oldb = b;
			var oldc = c;
			var oldd = d;
			var olde = e;

			for(var j = 0; j < 80; j++) {
				if(j < 16) w[j] = x[i + j];
				else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
				var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
						 safe_add(safe_add(e, w[j]), sha1_kt(j)));
				e = d;
				d = c;
				c = rol(b, 30);
				b = a;
				a = t;
			}

			a = safe_add(a, olda);
			b = safe_add(b, oldb);
			c = safe_add(c, oldc);
			d = safe_add(d, oldd);
			e = safe_add(e, olde);
		}
		return Array(a, b, c, d, e);

	};

	/*
	 * Perform the appropriate triplet combination function for the current
	 * iteration
	 */
	function sha1_ft(t, b, c, d)
	{
		if(t < 20) return (b & c) | ((~b) & d);
		if(t < 40) return b ^ c ^ d;
		if(t < 60) return (b & c) | (b & d) | (c & d);
		return b ^ c ^ d;
	};

	/*
	 * Determine the appropriate additive constant for the current iteration
	 */
	function sha1_kt(t)
	{
		return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
			(t < 60) ? -1894007588 : -899497514;
	};

	/*
	 * Calculate the HMAC-SHA1 of a key and some data
	 */
	function core_hmac_sha1(key, data)
	{
		var bkey = str2binb(key);
		if(bkey.length > 16) bkey = core_sha1(bkey, key.length * chrsz);

		var ipad = Array(16), opad = Array(16);
		for(var i = 0; i < 16; i++) {
			ipad[i] = bkey[i] ^ 0x36363636;
			opad[i] = bkey[i] ^ 0x5C5C5C5C;
		}

		var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
		return core_sha1(opad.concat(hash), 512 + 160);
	};

	/*
	 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	 * to work around bugs in some JS interpreters.
	 */
	function safe_add(x, y)
	{
		var lsw = (x & 0xFFFF) + (y & 0xFFFF);
		var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
		return (msw << 16) | (lsw & 0xFFFF);
	};

	/*
	 * Bitwise rotate a 32-bit number to the left.
	 */
	function rol(num, cnt)
	{
		return (num << cnt) | (num >>> (32 - cnt));
	};

	/*
	 * Convert an 8-bit or 16-bit string to an array of big-endian words
	 * In 8-bit function, characters >255 have their hi-byte silently ignored.
	 */
	function str2binb(str)
	{
		var bin = Array();
		var mask = (1 << chrsz) - 1;
		for(var i = 0; i < str.length * chrsz; i += chrsz)
			bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (32 - chrsz - i%32);
		return bin;
	};

	/*
	 * Convert an array of big-endian words to a string
	 */
	function binb2str(bin)
	{
		var str = "";
		var mask = (1 << chrsz) - 1;
		for(var i = 0; i < bin.length * 32; i += chrsz)
			str += String.fromCharCode((bin[i>>5] >>> (32 - chrsz - i%32)) & mask);
		return str;
	};

	/*
	 * Convert an array of big-endian words to a hex string.
	 */
	function binb2hex(binarray)
	{
		var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
		var str = "";
		for(var i = 0; i < binarray.length * 4; i++) {
			str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +
				hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);
		}
		return str;
	};

	/*
	 * Convert an array of big-endian words to a base-64 string
	 */
	function binb2b64(binarray)
	{
		var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		var str = "";
		for(var i = 0; i < binarray.length * 4; i += 3) {
			var triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16)
				| (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 )
				|  ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);
			for(var j = 0; j < 4; j++) {
				if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;
				else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);
			}
		}
		return str;
	};

	// export functions
	this.hex_sha1 = hex_sha1;
	this.b64_sha1 = b64_sha1;
	this.str_sha1 = str_sha1;
	this.hex_hmac_sha1 = hex_hmac_sha1;
	this.b64_hmac_sha1 = b64_hmac_sha1;
	this.str_hmac_sha1 = str_hmac_sha1;

	this.sha1_vm_test = sha1_vm_test;

};

AjxSHA1 = new AjxSHA1();
}
if (AjxPackage.define("ajax.util.AjxEmailAddress")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * Creates a new emal address, either by parsing an email string or from component parts.
 * @constructor
 * @class
 * This class represents an email address and defines some related constants. The class does not attempt full compliance
 * with RFC2822, so there are limitations for some of the edge cases.
 *
 * @author Conrad Damon
 * 
 * @param {string}	address		an email string, or just the address portion
 * @param {constant}	type		from, to, cc, bcc, or reply-to
 * @param {string}	name		the personal name portion
 * @param {string}	dispName	a brief display version of the name
 * @param {boolean}	isGroup		if <code>true</code>, the address param is really a list of email addresses
 * 
 */
AjxEmailAddress = function(address, type, name, dispName, isGroup, canExpand) {
	this.address = address;
	this.name = this._setName(name);
	this.dispName = dispName;
	this.type = type || AjxEmailAddress.TO;
	this.isGroup = isGroup;
	this.canExpand = canExpand;
};

AjxEmailAddress.prototype.isAjxEmailAddress = true;

/**
 * Defines list of custom invalid RegEx patterns that are set in LDAP
 */
AjxEmailAddress.customInvalidEmailPats = [];

/**
 * Defines the "from" type.
 */
AjxEmailAddress.FROM		= "FROM";
/**
 * Defines the "to" type.
 */
AjxEmailAddress.TO			= "TO";
/**
 * Defines the "cc" type.
 */
AjxEmailAddress.CC			= "CC";
/**
 * Defines the "bcc" type.
 */
AjxEmailAddress.BCC			= "BCC";
AjxEmailAddress.REPLY_TO	= "REPLY_TO";
AjxEmailAddress.SENDER		= "SENDER";
AjxEmailAddress.READ_RECEIPT= "READ_RECEIPT";
AjxEmailAddress.RESENT_FROM = "RESENT_FROM";

AjxEmailAddress.TYPE_STRING = {};
AjxEmailAddress.TYPE_STRING[AjxEmailAddress.FROM]			= "from";
AjxEmailAddress.TYPE_STRING[AjxEmailAddress.TO]				= "to";
AjxEmailAddress.TYPE_STRING[AjxEmailAddress.CC]				= "cc";
AjxEmailAddress.TYPE_STRING[AjxEmailAddress.BCC]			= "bcc";
AjxEmailAddress.TYPE_STRING[AjxEmailAddress.REPLY_TO]		= "replyTo";
AjxEmailAddress.TYPE_STRING[AjxEmailAddress.SENDER]			= "sender";
AjxEmailAddress.TYPE_STRING[AjxEmailAddress.READ_RECEIPT]	= "readReceipt";
AjxEmailAddress.TYPE_STRING[AjxEmailAddress.RESENT_FROM]	= "resentFrom";

AjxEmailAddress.fromSoapType = {};
AjxEmailAddress.fromSoapType["f"]  = AjxEmailAddress.FROM;
AjxEmailAddress.fromSoapType["t"]  = AjxEmailAddress.TO;
AjxEmailAddress.fromSoapType["c"]  = AjxEmailAddress.CC;
AjxEmailAddress.fromSoapType["b"]  = AjxEmailAddress.BCC;
AjxEmailAddress.fromSoapType["r"]  = AjxEmailAddress.REPLY_TO;
AjxEmailAddress.fromSoapType["s"]  = AjxEmailAddress.SENDER;
AjxEmailAddress.fromSoapType["n"]  = AjxEmailAddress.READ_RECEIPT;
AjxEmailAddress.fromSoapType["rf"] = AjxEmailAddress.RESENT_FROM;

AjxEmailAddress.toSoapType = {};
AjxEmailAddress.toSoapType[AjxEmailAddress.FROM]		= "f";
AjxEmailAddress.toSoapType[AjxEmailAddress.TO]			= "t";
AjxEmailAddress.toSoapType[AjxEmailAddress.CC]			= "c";
AjxEmailAddress.toSoapType[AjxEmailAddress.BCC]			= "b";
AjxEmailAddress.toSoapType[AjxEmailAddress.REPLY_TO]	= "r";
AjxEmailAddress.toSoapType[AjxEmailAddress.SENDER]		= "s";
AjxEmailAddress.toSoapType[AjxEmailAddress.READ_RECEIPT]= "n";

AjxEmailAddress.SEPARATOR = "; ";				// used to join addresses
AjxEmailAddress.DELIMS = [';', ',', '\n', ' '];	// recognized as address delimiters
AjxEmailAddress.IS_DELIM = AjxUtil.arrayAsHash(AjxEmailAddress.DELIMS);

// validation patterns

AjxEmailAddress.addrAnglePat = /(\s*<(((\s*([^\x00-\x1F\x7F\u0080-\uFFFF()<>\[\]:;@\,."\s]+(\.[^\x00-\x1F\x7F\u0080-\uFFFF()<>\[\]:;@\,."\s]+)*)\s*)|(\s*"(([^\\"])|(\\([^\x0A\x0D])))+"\s*))\@((\s*([^\x00-\x1F\x7F\u0080-\uFFFF()<>\[\]:;@\,."\s]+(\.[^\x00-\x1F\x7F\u0080-\uFFFF()<>\[\]:;@\,."\s]+)*)\s*)|(\s*\[(\s*(([^\[\]\\])|(\\([^\x0A\x0D])))+)*\s*\]\s*)))>\s*)/;
AjxEmailAddress.addrOnlyPat = /^((((\s*([^\x00-\x1F\x7F\u0080-\uFFFF()<>\[\]:;@\,."\s]+(\.[^\x00-\x1F\x7F\u0080-\uFFFF()<>\[\]:;@\,."\s]+)*)\s*)|(\s*"(([^\\"])|(\\([^\x0A\x0D])))+"\s*))\@((\s*([^\x00-\x1F\x7F\u0080-\uFFFF()<>\[\]:;@\,."\s]+(\.[^\x00-\x1F\x7F\u0080-\uFFFF()<>\[\]:;@\,."\s]+)*)\s*)|(\s*\[(\s*(([^\[\]\\])|(\\([^\x0A\x0D])))+)*\s*\]\s*))))$/;

AjxEmailAddress.addrAngleQuotePat = /(\s*<'(((\s*([^\x00-\x1F\x7F\u0080-\uFFFF()<>\[\]:;@\,."\s]+(\.[^\x00-\x1F\x7F\u0080-\uFFFF()<>\[\]:;@\,."\s]+)*)\s*)|(\s*"(([^\\"])|(\\([^\x0A\x0D])))+"\s*))\@((\s*([^\x00-\x1F\x7F\u0080-\uFFFF()<>\[\]:;@\,."\s]+(\.[^\x00-\x1F\x7F\u0080-\uFFFF()<>\[\]:;@\,."\s]+)*)\s*)|(\s*\[(\s*(([^\[\]\\])|(\\([^\x0A\x0D])))+)*\s*\]\s*)))'>\s*)/;
// use addrPat to validate strings as email addresses
AjxEmailAddress.addrPat = /(((\s*([^\x00-\x1F\x7F\u0080-\uFFFF()<>\[\]:;@\,."\s]+(\.[^\x00-\x1F\x7F\u0080-\uFFFF()<>\[\]:;@\,."\s]+)*)\s*)|(\s*"(([^\\"])|(\\([^\x0A\x0D])))+"\s*))\@((\s*([^\x00-\x1F\x7F\u0080-\uFFFF()<>\[\]:;@\,."\s]+(\.[^\x00-\x1F\x7F\u0080-\uFFFF()<>\[\]:;@\,."\s]+)*)\s*)|(\s*\[(\s*(([^\[\]\\])|(\\([^\x0A\x0D])))+)*\s*\]\s*)))/;
// use addrPat1 to parse email addresses - pattern is lenient in that it will allow the following:
// 		"Joe Smith" joe@x.com
//		"Joe Smith"joe@x.com
// (RFC822 wants the address part to be in <> if preceded by name part)
AjxEmailAddress.addrPat1 = /(^|"|\s)(((\s*([^\x00-\x1F\x7F\u0080-\uFFFF()<>\[\]:;@\,."\s]+(\.[^\x00-\x1F\x7F\u0080-\uFFFF()<>\[\]:;@\,."\s]+)*)\s*)|(\s*"(([^\\"])|(\\([^\x0A\x0D])))+"\s*))\@((\s*([^\x00-\x1F\x7F\u0080-\uFFFF()<>\[\]:;@\,."\s]+(\.[^\x00-\x1F\x7F\u0080-\uFFFF()<>\[\]:;@\,."\s]+)*)\s*)|(\s*\[(\s*(([^\[\]\\])|(\\([^\x0A\x0D])))+)*\s*\]\s*)))/;
// pattern below is for account part of address (before @)
AjxEmailAddress.accountPat = /^([^\x00-\x1F\x7F\u0080-\uFFFF()<>\[\]:;@\,."\s]+(\.[^\x00-\x1F\x7F\u0080-\uFFFF()<>\[\]:;@\,."\s]+)*)$/;
// Pattern below hangs on an unclosed comment, so use simpler one if parsing for comments
//AjxEmailAddress.commentPat = /(\s*\((\s*(([^()\\])|(\\([^\x0A\x0D]))|(\s*\((\s*(([^()\\])|(\\([^\x0A\x0D]))|(\s*\((\s*(([^()\\])|(\\([^\x0A\x0D]))|(\s*\((\s*(([^()\\])|(\\([^\x0A\x0D]))|(\s*\((\s*(([^()\\])|(\\([^\x0A\x0D]))|)+)*\s*\)\s*))+)*\s*\)\s*))+)*\s*\)\s*))+)*\s*\)\s*))+)*\s*\)\s*)/;
AjxEmailAddress.commentPat = /\((.*)\)/g;
AjxEmailAddress.phrasePat = /(((\s*[^\x00-\x1F\x7F\u0080-\uFFFF()<>\[\]:;@\"\s]+\s*)|(\s*"(([^\\"])|(\\([^\x0A\x0D])))+"\s*))+)/;
AjxEmailAddress.boundAddrPat = /(\s*<?(((\s*([^\x00-\x1F\x7F\u0080-\uFFFF()<>\[\]:;@\,."\s]+(\.[^\x00-\x1F\x7F\u0080-\uFFFF()<>\[\]:;@\,."\s]+)*)\s*)|(\s*"(([^\\"])|(\\([^\x0A\x0D])))+"\s*))\@((\s*([^\x00-\x1F\x7F\u0080-\uFFFF()<>\[\]:;@\,."\s]+(\.[^\x00-\x1F\x7F\u0080-\uFFFF()<>\[\]:;@\,."\s]+)*)\s*)|(\s*\[(\s*(([^\[\]\\])|(\\([^\x0A\x0D])))+)*\s*\]\s*)))>?\s*)$/;

AjxEmailAddress.validateAddress =
function (str) {
	str = AjxStringUtil.trim(str);
	return AjxEmailAddress._prelimCheck(str) && AjxEmailAddress.addrOnlyPat.test(str);
};

/**
 * Parses an email address string into its component parts. The parsing is adapted from the perl module 
 * <a href="http://search.cpan.org/~cwest/Email-Address-1.2/lib/Email/Address.pm">Email::Address</a>. Check that out if you
 * want to know how the gory regexes that do the parsing were built. They are based on RFC2822, but don't represent a full 
 * implementation. We don't really need or want that, since we don't want to be overly restrictive or bloated. It was easier
 * to just use the resulting regexes from the Perl module, rather than go through all the rigmarole of building them up from
 * atoms.
 * <p>
 * If the address parses successfully, the current object's properties will be set.
 * </p>
 * 
 * @param	{string}	str		the string to parse
 * @return	{AjxEmailAddress}	the email address or <code>null</code>
 */
AjxEmailAddress.parse = function(str) {

	var addr, name;
	var str = AjxStringUtil.trim(str);
	var prelimOkay = AjxEmailAddress._prelimCheck(str);
	if (!(prelimOkay && str.match(AjxEmailAddress.addrPat))) {
		return null;
	}

	// Note: It would be nice if you could get back the matching parenthesized subexpressions from replace,
	// then we wouldn't have to do both a match and a replace. The parsing works by removing parts after it
	// finds them.
	
	// First find the address (and remove it)
	var parts = str.match(AjxEmailAddress.addrAngleQuotePat) || str.match(AjxEmailAddress.addrAnglePat);
	if (parts && parts.length) {
		addr = parts[2];
		str = str.replace(AjxEmailAddress.addrAnglePat, '');
	}
	else {
		parts = str.match(AjxEmailAddress.addrPat1);
		if (parts && parts.length) {
			if (parts[1] === '"') {
				return null;	// unmatched quote
			}
            // AjxEmailAddress.addrPat recognizes the email better than using parts[0] from AjxEmailAddress.addrPat1
            var parts1 = str.match(AjxEmailAddress.addrPat);
            addr = parts1 && parts1.length && parts1[0] ? AjxStringUtil.trim(parts1[0]) : parts[0];
			str = str.replace(AjxEmailAddress.addrPat, '');
		}
	}

	// double-check with validateAddress(), which uses addrOnlyPat
	if (!addr || !AjxEmailAddress.validateAddress(addr)) {
		return null;
	}

	// Validate against any customer-provided patterns
	for (var i = 0; i < AjxEmailAddress.customInvalidEmailPats.length; i++) {
		if (AjxEmailAddress.customInvalidEmailPats[i].test(addr)) {
			return null;
		}
	}

	// What remains is the name
	if (str) {
		name = AjxStringUtil.trim(str);

		// Trim off leading and trailing quotes, but leave escaped quotes and unescape them
		name = name.replace(/\\"/g,"&quot;");
		name = AjxStringUtil.trim(name, null, '"');
		name = name.replace(/&quot;/g, '"');
	}
	
	return new AjxEmailAddress(addr, null, name);
};

/**
 * Parses a string with one or more addresses and parses it. An object with lists of good addresses, bad
 * addresses, and all addresses is returned. Strict RFC822 validation (at least as far as it goes in the
 * regexes we have) is optional. If it's off, we'll retry a failed address after quoting the personal part.
 *
 * @param	{string}	emailStr	an email string with one or more addresses
 * @param	{constant}	type		address type of the string
 * @param	{boolean}	strict		if <code>true</code>, do strict checking
 * @return	{hash}		the good/bad/all addresses
 */
AjxEmailAddress.parseEmailString =
function(emailStr, type, strict) {
	var good = new AjxVector();
	var bad = new AjxVector();
	var all = new AjxVector();
	var addrList = AjxEmailAddress.split(emailStr);
	for (var i = 0; i < addrList.length; i++) {
		var addrStr = AjxStringUtil.trim(addrList[i]);
		if (addrStr) {
			var addr = AjxEmailAddress.parse(addrStr);
			if (!addr && !strict) {
				var temp = addrStr;
				var parts = temp.match(AjxEmailAddress.addrAnglePat);
				if (parts && parts.length) {
					var name = temp.replace(AjxEmailAddress.addrAnglePat, '');
					var newAddr = ['"', name, '" ', parts[0]].join("");
					addr = AjxEmailAddress.parse(newAddr);
					if (addr) {
						addr.name = name; // reset name to original unquoted form
					}
				}
			}
			if (addr) {
				addr.type = type;
				good.add(addr);
				all.add(addr);
			} else {
				bad.add(addrStr);
				all.add(new AjxEmailAddress(addrStr));
			}
		}
	}
	return {good: good, bad: bad, all: all};
};

/**
 * Returns an AjxVector with valid email addresses
 *
 * @param	{string}	emailStr	an email string with one or more addresses
 * @param	{constant}	type		address type of the string
 * @param	{boolean}	strict		if <code>true</code>, do strict checking
 * @return	{AjxVector}				valid addresses
 */
AjxEmailAddress.getValidAddresses =
function(emailStr, type, strict) {
	return AjxEmailAddress.parseEmailString(emailStr, type, strict).good;
};

/**
 * Checks if a string to see if it's a valid email string according to our mailbox pattern.
 *
 * @param {string}	str		an email string
 * @return	{boolean}	<code>true</code> if the string is valid
 */
AjxEmailAddress.isValid = function(str) {
	return AjxEmailAddress.parse(str) != null;
};

AjxEmailAddress._prelimCheck =
function(str) {
	// Do preliminary check for @ since we don't support local addresses, and as workaround for Mozilla bug
	// https://bugzilla.mozilla.org/show_bug.cgi?id=225094
	// Also check for . since we require FQDN
	var atIndex = str.indexOf('@');
	var dotIndex = str.lastIndexOf('.');
	return ((atIndex != -1) && (dotIndex != -1) && (dotIndex > atIndex) && (dotIndex != str.length - 1));
};

/**
 * Splits a string into (possible) email address strings based on delimiters. Tries to
 * be flexible about what it will accept. The following delimiters are recognized, under
 * the following conditions:
 *
 * <ul>
 * <li><i>return</i> -- always</li>
 * <li><i>semicolon</i> -- must not be inside quoted or comment text</li>
 * <li><i>comma</i> -- must not be inside quoted or comment text, and must follow an address (which may be in angle brackets)</li>
 * <li><i>space</i> -- can only separate plain addresses (no quoted or comment text)</li>
 * </ul>
 * 
 * The requirement that a comma follow an address allows us to be lenient when a mailer
 * doesn't quote the friendly part, so that a string such as the one below is split correctly:
 * <code>Smith, John &lt;jsmith@aol.com&gt;</code>
 *
 * @param {string}	str	the string to be split
 * @return	{array}	the list of {String} addresses
 */
AjxEmailAddress.split =
function(str) {
	str = AjxStringUtil.trim(str);
	// first, construct a list of ranges to ignore because they are quoted or comment text
	var ignore = [];
	var pos = 0, startPos = 0;
	var prevCh = "", startCh = "";
	var inside = false;
	while (pos < str.length) {
		var ch = str.charAt(pos);
		if ((ch == '"' || ch == '(') && prevCh != "\\") {
			inside = true;
			startCh = ch;
			startPos = pos;
			pos++;
			while (inside && pos < str.length) {
				var ch = str.charAt(pos);
				if (((startCh == '"' && ch == '"') || (startCh == '(' && ch == ')')) && (prevCh != "\\")) {
					ignore.push({start: startPos, end: pos});
					inside = false;
				}
				pos++;
				prevCh = ch;
			}
		} else {
			pos++;
		}
		prevCh = ch;
	}
	if (ignore.length) {
		AjxEmailAddress.IS_DELIM[" "] = false;
	}
	
	// Progressively scan the string for delimiters. Once an email string has been found, continue with
	// the remainder of the original string.
	startPos = 0;
	var addrList = [];
	while (startPos < str.length) {
		var sub = str.substring(startPos, str.length);
		pos = 0;
		var delimPos = sub.length;
		while ((delimPos == sub.length) && (pos < sub.length)) {
			var ch = sub.charAt(pos);
			if (AjxEmailAddress.IS_DELIM[ch]) {
				var doIgnore = false;
				if (ch != "\n") {
					for (var i = 0; i < ignore.length; i++) {
						var range = ignore[i];
						var absPos = startPos + pos;
						doIgnore = (absPos >= range.start && absPos <= range.end);
						if (doIgnore) break;
					}
				}
				if (!doIgnore) {
					var doAdd = true;
					var test = sub.substring(0, pos);
					if (ch == "," || ch == " ") {
						// comma/space allowed as non-delimeter outside quote/comment,
						// so we make sure it follows an actual address
						doAdd = test.match(AjxEmailAddress.boundAddrPat);
					}
					if (doAdd) {
						addrList.push(AjxStringUtil.trim(test));
						delimPos = pos;
						startPos += test.length + 1;
					}
				}
				// strip extra delimeters
				ch = str.charAt(startPos);
				while ((startPos < str.length) && AjxEmailAddress.IS_DELIM[ch]) {
					startPos++;
					ch = str.charAt(startPos);
				}
				pos++;
			} else {
				pos++;
			}
		}
		if (delimPos == sub.length) {
			addrList.push(AjxStringUtil.trim(sub));
			startPos += sub.length + 1;
		}
	}
	AjxEmailAddress.IS_DELIM[" "] = true;

	return addrList;
};

/**
 * Returns a string representation of this object.
 * 
 * @param {boolean}		shortForm	if true, return a brief version (name if available, otherwise email)
 * @param {boolean}		forceUnescape	if true, name will not be in quotes and any quotes inside the name will be unescaped (e.g. "John \"JD\" Doe" <jd@zimbra.com> becomes John "JD" Doe <jd@zimbra.com>
 * 
 * @return	{string}		a string representation of this object
 */
AjxEmailAddress.prototype.toString =
function(shortForm, forceUnescape) {

	if (this.name) {
		var name = this.name;
		if (!shortForm && !forceUnescape) {
			name = name.replace(/\\+"/g, '"');	// unescape double quotes (avoid double-escaping)
			name = name.replace(/"/g,'\\"');  // escape quotes
		}
		var buffer = (shortForm || forceUnescape) ? [name] : ['"', name, '"'];
		if (this.address && !shortForm) {
			buffer.push(" <", this.address, ">");
		}
		return buffer.join("");	// quote friendly part
	} else {
		return this.address;
	}
};

/**
 * Gets the address.
 * 
 * @return	{string}	the address
 */
AjxEmailAddress.prototype.getAddress =
function() {
	return this.address;
};

/**
 * Sets the address.
 * 
 * @param	{string}	addr		the address
 */
AjxEmailAddress.prototype.setAddress =
function(addr) {
	this.address = addr;
};

/**
 * Gets the type (to/from/cc/bcc).
 * 
 * @return	{constant}	the type
 */
AjxEmailAddress.prototype.getType =
function() {
	return this.type;
};

/**
 * Sets the type.
 * 
 * @param	{constant}	type		the type (to/from/cc/bcc)
 */
AjxEmailAddress.prototype.setType =
function(type) {
	this.type = type;
};

/**
 * Gets the type as a string.
 * 
 * @return	{string}	the type (to/from/cc/bcc)
 */
AjxEmailAddress.prototype.getTypeAsString =
function() {
	return AjxEmailAddress.TYPE_STRING[this.type];
};

/**
 * Gets the name.
 * 
 * @return	{string}	the name
 */
AjxEmailAddress.prototype.getName =
function() {
	return this.name;
};

/**
 * Gets the display name.
 * 
 * @return	{string}	the name
 */
AjxEmailAddress.prototype.getDispName =
function() {
	return this.dispName;
};

/*
 * We use this for displaying the actual text in the cell (or group when grouping by "from")
 */
AjxEmailAddress.prototype.getText =
function() {
	return this.getName() || this.getDispName() || this.getAddress();
};

/**
 * Clones this email address.
 * 
 * @return	{AjxEmailAddress}	a clone of this email address
 */
AjxEmailAddress.prototype.clone =
function() {
	var addr = new AjxEmailAddress(this.address, this.type, this.name, this.dispName, this.isGroup, this.canExpand);
	addr.icon = this.icon;
	return addr;
};

/**
 * Copies the email address.
 * 
 * @param	{AjxEmailAddress}	obj		the email to copy
 * @return	{AjxEmailAddress}	the newly copied email address
 */
AjxEmailAddress.copy =
function(obj){    
    var addr = new AjxEmailAddress(obj.address, obj.type, obj.name, obj.dispName, obj.isGroup, obj.canExpand);
    addr.icon = obj.icon;
    return addr;
};

AjxEmailAddress.prototype._setName =
function(name) {
	if (!name) return "";
	
	// remove wrapping single quotes from name if present
	if (name && name.charAt(0) == "'" && name.charAt(name.length - 1) == "'")
		name = name.substring(1, name.length - 1);
		
	return name;		
};

AjxEmailAddress.sortCompareByAddress =
function(a, b) {

	var addrA = a.getAddress() || "";
	var addrB = b.getAddress() || "";
	if (addrA.toLowerCase() > addrB.toLowerCase()) { return 1; }
	if (addrA.toLowerCase() < addrB.toLowerCase()) { return -1; }
	return 0;
};

/**
 * Returns the list of addresses with duplicates (based on email) removed.
 * 
 * @param {array}	addrs	list of AjxEmailAddress
 */
AjxEmailAddress.dedup =
function(addrs) {
	var list = [], used = {};
	if (addrs && addrs.length) {
		for (var i = 0; i < addrs.length; i++) {
			var addr = addrs[i];
			if (!used[addr.address]) {
				list.push(addr);
			}
			used[addr.address] = true;
		}
	}
	return list;
};
}
if (AjxPackage.define("ajax.util.AjxHistoryMgr")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only
/*
   Derived from "Really Simple History", by Brad Neuberg. Its copyright follows:

   Copyright (c) 2005, Brad Neuberg, bkn3@columbia.edu
   http://codinginparadise.org
   
   Permission is hereby granted, free of charge, to any person obtaining 
   a copy of this software and associated documentation files (the "Software"), 
   to deal in the Software without restriction, including without limitation 
   the rights to use, copy, modify, merge, publish, distribute, sublicense, 
   and/or sell copies of the Software, and to permit persons to whom the 
   Software is furnished to do so, subject to the following conditions:
   
   The above copyright notice and this permission notice shall be 
   included in all copies or substantial portions of the Software.
   
   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT 
   OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 
   THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * Initializes history support.
 * @constructor
 * @class
 * This singleton class provides support for handling history changes via the Back
 * and Forward buttons. Since an Ajax application represents a single URL, hitting
 * the Back button will ordinarily unload the app, which is usually not what the user
 * wants to do. Changing the hash value in the browser's location will affect the
 * browser history, but not the content. IE also uses a hidden iframe to track history.
 * <p>
 * The code below is a stripped-down version of Brad Neuberg's Really Simple History
 * (see copyright above). Support for history storage has been removed.</p>
 * 
 * @author Conrad Damon
 * 
 * TODO: - add enable()
 * 
 * @private
 */
AjxHistoryMgr = function() {

	this.currentLocation = null;			// Our current hash location, without the "#" symbol.
	this.listener = null;					// Our history change listener. */
	this.iframe = null;						// A hidden IFrame we use in Internet Explorer to detect history changes.
	this.ignoreLocationChange = null;		// Indicates to the browser whether to ignore location changes.

	// The amount of time in ms to wait between add requests. 
	this.WAIT_TIME = AjxEnv.isIE ? 400 : 200;

	this.currentWaitTime = 0;				// Time in ms to wait before calling setTimeout to add a location

	/** A variable to handle an important edge case in Internet
	Explorer. In IE, if a user manually types an address into
	their browser's location bar, we must intercept this by
	continuously checking the location bar with a timer 
	interval. However, if we manually change the location
	bar ourselves programmatically, when using our hidden
	iframe, we need to ignore these changes. Unfortunately,
	these changes are not atomic, so we surround them with
	the variable 'ieAtomicLocationChange', that if true,
	means we are programmatically setting the location and
	should ignore this atomic chunked change. */
	this.ieAtomicLocationChange = null;

	this._eventMgr = new AjxEventMgr();
	this._evt = new AjxEvent();

	this._initialize();
}

// Name of the file that has content for the iframe
AjxHistoryMgr.BLANK_FILE = "blankHistory.html";

// ID for the iframe
AjxHistoryMgr.IFRAME_ID = "DhtmlHistoryFrame";


/**
 * Adds a history change listener.
 */
AjxHistoryMgr.prototype.addListener =
function(listener) {
	return this._eventMgr.addListener(AjxEvent.HISTORY, listener);
};

/**
 * Removes a history change listener.
 */
AjxHistoryMgr.prototype.removeListener =
function(listener) {
	return this._eventMgr.removeListener(AjxEvent.HISTORY, listener);
};

/**
 * Most browsers require that we wait a certain amount of time before changing the
 * location, such as 200 milliseconds; rather than forcing external callers to use
 * window.setTimeout to account for this to prevent bugs, we internally handle this
 * detail by using a 'currentWaitTime' variable and have requests wait in line
 */
AjxHistoryMgr.prototype.add =
function(newLocation) {

	var self = this;
	var addImpl = function() {
		
		// indicate that the current wait time is now less
		if (self.currentWaitTime > 0) {
			self.currentWaitTime = self.currentWaitTime - self.WAIT_TIME;
		}
		
		// remove any leading hash symbols on newLocation
		newLocation = self._removeHash(newLocation);
		   
		// IE has a strange bug; if the newLocation
		// is the same as _any_ preexisting id in the
		// document, then the history action gets recorded
		// twice; throw a programmer exception if there is
		// an element with this ID
		if (AjxEnv.isIE) {
			if (document.getElementById(newLocation)) {
				throw new DwtException("AjxHistoryMgr: location has same ID as DOM element");
			}
		}

		// indicate to the browser to ignore this upcoming location change
		self.ignoreLocationChange = true;
		 
		// indicate to IE that this is an atomic location change block
		this.ieAtomicLocationChange = true;
		     
		// save this as our current location
		self.currentLocation = newLocation;
		   
		// change the browser location
		window.location.hash = newLocation;
		   
		// change the hidden iframe's location if on IE
		if (AjxEnv.isIE) {
			self.iframe.src = AjxHistoryMgr.BLANK_FILE + "?" + newLocation;
		}
		
		// end of atomic location change block for IE
		this.ieAtomicLocationChange = false;
	};		
		
	// queue up requests
	window.setTimeout(addImpl, this.currentWaitTime);
	   
	// indicate that the next request will have to wait for awhile
	this.currentWaitTime = this.currentWaitTime + self.WAIT_TIME;
};

/**
 * Returns the current hash value that is in the browser's
 * location bar, removing leading # symbols if they are present.
 */   
AjxHistoryMgr.prototype.getCurrentLocation =
function() {
	return this._removeHash(window.location.hash);
};

/**
 * Creates the DHTML history infrastructure.
 */
AjxHistoryMgr.prototype._initialize =
function() {

	// get our initial location
	var initialHash = this.getCurrentLocation();
	
	// save this as our current location
	this.currentLocation = initialHash;
	
	// write out a hidden iframe for IE and
	// set the amount of time to wait between add() requests
	if (AjxEnv.isIE) {
		DBG.println(AjxDebug.DBG2, "Creating iframe for IE: " + AjxHistoryMgr.BLANK_FILE);
		var html = [];
		var i = 0;
		html[i++] = "<iframe style='border: 0px; width: 1px; ";
		html[i++] = "height: 1px; position: absolute; bottom: 0px; ";
		html[i++] = "right: 0px; visibility: visible;' ";
		html[i++] = "id='" + AjxHistoryMgr.IFRAME_ID + "' ";
		html[i++] = "src='" + AjxHistoryMgr.BLANK_FILE + "?" + initialHash + "'>";
		html[i++] = "</iframe>";
		
		var htmlElement = document.createElement("div");
		document.body.appendChild(htmlElement);
		htmlElement.innerHTML = html.join("");
	}

	if (AjxEnv.isIE) {
		this.iframe = document.getElementById(AjxHistoryMgr.IFRAME_ID);
	}  

	// other browsers can use a location handler that checks
	// at regular intervals as their primary mechanism;
	// we use it for Internet Explorer as well to handle
	// an important edge case; see _checkLocation() for
	// details
	var self = this;
	var locationHandler = function() {
		self._checkLocation();
	};
	window.onhashchange = locationHandler;
};

/**
 * Checks if the browsers has changed location.  This is the primary history mechanism
 * for Firefox. For Internet Explorer, we use this to handle an important edge case:
 * if a user manually types in a new hash value into their Internet Explorer location
 * bar and press enter, we want to intercept this and notify any history listener.
 */
AjxHistoryMgr.prototype._checkLocation =
function() {
	// ignore any location changes that we made ourselves
	// for browsers other than Internet Explorer
	if (!AjxEnv.isIE && this.ignoreLocationChange) {
	   this.ignoreLocationChange = false;
	   return;
	}

	// if we are dealing with Internet Explorer
	// and we are in the middle of making a location
	// change from an iframe, ignore it
	if (!AjxEnv.isIE && this.ieAtomicLocationChange) {
	   return;
	}

	// get hash location
	var hash = this.getCurrentLocation();

	// see if there has been a change
	if (hash == this.currentLocation) { return; }
   
	// on Internet Explorer, we need to intercept users manually
	// entering locations into the browser; we do this by comparing
	// the browsers location against the iframes location; if they
	// differ, we are dealing with a manual event and need to
	// place it inside our history, otherwise we can return
	this.ieAtomicLocationChange = true;

	if (AjxEnv.isIE && this._getIFrameHash() != hash) {
	   this.iframe.src = AjxHistoryMgr.BLANK_FILE + "?" + hash;
	} else if (AjxEnv.isIE) {
	   // the iframe is unchanged
	   return;
	}
   
	// save this new location
	this.currentLocation = hash;
	
	this.ieAtomicLocationChange = false;
	
	// notify listeners of the change
	this._evt.data = hash;
	this._eventMgr.notifyListeners(AjxEvent.HISTORY, this._evt);
};

/**
 * Gets the current location of the hidden IFrames
 * that is stored as history. For Internet Explorer.
 */
AjxHistoryMgr.prototype._getIFrameHash =
function() {
	// get the new location
	var historyFrame = document.getElementById(AjxHistoryMgr.IFRAME_ID);
	var doc = historyFrame.contentWindow.document;
	var hash = new String(doc.location.search);
	
	if (hash.length == 1 && hash.charAt(0) == "?") {
		hash = "";
	} else if (hash.length >= 2 && hash.charAt(0) == "?") {
		hash = hash.substring(1);
	}
    
	return hash;
};
   
/**
 * Removes any leading hash that might be on a location.
 */
AjxHistoryMgr.prototype._removeHash =
function(hashValue) {
	if (hashValue == null || hashValue == undefined) {
	   return null;
	} else if (hashValue == "") {
	   return "";
	} else if (hashValue.length == 1 && hashValue.charAt(0) == "#") {
	   return "";
	} else if (hashValue.length > 1 && hashValue.charAt(0) == "#") {
	   return hashValue.substring(1);
	} else {
	   return hashValue;
	}
};
   
/**
 * For IE, says when the hidden iframe has finished loading.
 */
AjxHistoryMgr.prototype.iframeLoaded =
function(newLocation) {

	// ignore any location changes that we made ourselves
	if (this.ignoreLocationChange) {
	   this.ignoreLocationChange = false;
	   return;
	}
	
	// get the new location
	var hash = new String(newLocation.search);
	if (hash.length == 1 && hash.charAt(0) == "?") {
		hash = "";
	} else if (hash.length >= 2 && hash.charAt(0) == "?") {
		hash = hash.substring(1);
	}
	
	// move to this location in the browser location bar
	window.location.hash = hash;
	
	// notify listeners of the change
	this._evt.data = hash;
	this._eventMgr.notifyListeners(AjxEvent.HISTORY, this._evt);
};
}

// DWT files
if (AjxPackage.define("ajax.dwt.core.Dwt")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * Default constructor.
 * @constructor
 * @class
 * Dwt is a static class that defines a number of constants and helper methods that
 * support the <code>ajax.dwt.*</code> package.
 *
 * @author Ross Dargahi
 * @author Conrad Damon
 */

Dwt = function() {
};

// Constants for positioning
/**
 * Static position style.
 */
Dwt.STATIC_STYLE = "static";

/**
 * Absolute position style.
 */
Dwt.ABSOLUTE_STYLE = "absolute";

/**
 * Relative position style.
 */
Dwt.RELATIVE_STYLE = "relative";

/**
 * Fixed position style.
 */
Dwt.FIXED_STYLE = "fixed";

// Background repeat
/**
 * Do not repeat background image.
 */
Dwt.NO_REPEAT = "no-repeat";

/**
 * Repeat background image.
 */
Dwt.REPEAT = "repeat";

/**
 * Repeat background image horizontally.
 */
Dwt.REPEAT_X = "repeat-x";

/**
 * Repeat background image vertically.
 */
Dwt.REPEAT_Y = "repeat-y";


// display style
/**
 * Inline display style.
 */
Dwt.DISPLAY_INLINE = "inline";

/**
 * Block display style.
 */
Dwt.DISPLAY_BLOCK = "block";

/**
 * No display style.
 */
Dwt.DISPLAY_NONE = "none";

/**
 * Table row style.
 */
Dwt.DISPLAY_TABLE_ROW = "table-row";

/**
 * Table cell style.
 */
Dwt.DISPLAY_TABLE_CELL = "table-cell";

// Scroll constants
/**
 * Clip on overflow.
 */
Dwt.CLIP = 1;

/**
 * Allow overflow to be visible.
 */
Dwt.VISIBLE = 2;

/**
 * Automatically create scrollbars if content overflows.
 */
Dwt.SCROLL = 3;

/**
 * Always have scrollbars whether content overflows or not.
 */
Dwt.FIXED_SCROLL = 4;

/**
 * Only show scrollbars on Y when content overflows.
 */
Dwt.SCROLL_Y = 5;

/**
 * Only show scrollbars on X when content overflows.
 */
Dwt.SCROLL_X = 6;


// z-index order
/** 
 * Hidden layer. Elements at this layer will be hidden from view.
 */
Dwt.Z_HIDDEN = 100;

/**
 * The curtain layer.
 * @type int
 * @see DwtShell
 */
Dwt.Z_CURTAIN = 200;


/**
 * Visible layer. Elements at this layer will be in view.
 */
Dwt.Z_VIEW = 300;

/**
 * Popup menu layer. Used by the menu components.
 */
Dwt.Z_MENU = 500;

/**
 * Veil layer. The veil appears just behind modal dialogs render other components
 * unable to receive mouse input.
 */
Dwt.Z_VEIL = 600;

/**
 * Dialog layer. Dialogs are positioned at this layer.
 */
Dwt.Z_DIALOG = 700;

/**
 * Used by menus that are part of a dialog.
 */
Dwt.Z_DIALOG_MENU = 750;

/**
 * Tooltips layer.
 */
Dwt.Z_TOOLTIP = 775;

/**
 * Drag and Drop (DnD) icon layer. DnD icons are positioned at this layer so they
 * move across the top of other components.
 */
Dwt.Z_DND = 800;		// Drag N Drop icons

/**
 * This layer appears in front of other layers to block all user mouse input.
 */
Dwt.Z_BUSY = 900;

/**
 * The toast layer.
 */
Dwt.Z_TOAST = 950;

/**
 * Used by the splash screens.
 */
Dwt.Z_SPLASH = 1000;


/**
 * Default value. Used when setting such things as size and bounds to indicate a
 * component should not be set. For example if setting size and not wishing to set
 * the height.
 * <pre>
 * Dwt.setSize(htmlElement, 100, Dwt.DEFAULT)
 * </pre>
 * 
 */
Dwt.DEFAULT = -123456789;

/**
 * Used to clear a value.
 */
Dwt.CLEAR = -20000;

/**
 * Offscreen position. Used when setting a elements position.
 */
Dwt.LOC_NOWHERE = -10000;

// Drag N Drop action constants. These are bit fields.
/**
 * No drag and drop operation.
 */
Dwt.DND_DROP_NONE = 0;

/**
 * Copy drag and drop operation.
 */
Dwt.DND_DROP_COPY = 1;

/**
 * Move drag and drop operation.
 */
Dwt.DND_DROP_MOVE = 2;

/**
 * Ballpark figure for width of a scrollbar.
 */
Dwt.SCROLLBAR_WIDTH = 22;

// Editor formats
Dwt.HTML = "text/html";
Dwt.TEXT = "text/plain";

// Keys used for retrieving data
// TODO JSDoc
Dwt.KEY_OBJECT = "_object_";
Dwt.KEY_ID = "_id_";

/**
 * z-index increment unit. Used by components if they need to bump their z-index.
 */
Dwt._Z_INC = 1;


/**
 * @private
 */
Dwt.__nextId = {};

/**
 * This method is used to generate a unique id to be used for an HTML element's id
 * attribute.
 *
 * @return {string}	the next available element ID
 */
Dwt.getNextId =
function(prefix) {
	prefix = prefix || "DWT";
	if (!Dwt.__nextId[prefix]) {
		Dwt.__nextId[prefix] = 1;
	}
	return prefix + Dwt.__nextId[prefix]++;
};

/**
 * This method is used to query an element for its id, generating one if it
 * isn't set.
 *
 * @return {string}	the element ID
 */
Dwt.getId =
function(element, prefix) {
	return element ? element.id || (element.id = Dwt.getNextId(prefix)) : null;
};

/**
 * @deprecated
 * The association between an element and a control is now via DwtControl.ALL_BY_ID,
 * where the unique element ID is a key to the control. The association is made when
 * the control is initialized.
 * 
 * This method builds an indirect association between a DOM object and a JavaScript
 * object. This indirection is important to prevent memory leaks (particularly in IE) by
 * not directly creating a circular reference between a DOM object
 *
 * @param {DOMElement} domElement the DOM element (typically an HTML element)
 * @param {Object} jsObject the JavaScript object
 * 
 * @private
 */
Dwt.associateElementWithObject =
function(domElement, jsObject, attrName) {
	domElement[attrName||"dwtObj"] = jsObject.__internalId = AjxCore.assignId(jsObject);
};

/**
 * @deprecated
 * The association will be broken by the control when it is disposed.
 * 
 * This method breaks the indirect association between a DOM object and a JavaScript
 * object that was created by the <code>Dwt.associateElementWithObject</code>method
 *
 * @param {DOMElement} domElement the DOM element (typically an HTML element)
 * @param {Object} jsObject the JavaScript object
 * 
 * @private
 */
Dwt.disassociateElementFromObject =
function(domElement, jsObject, attrName) {
	if (domElement){
		domElement.removeAttribute(attrName||"dwtObj");
	}
	if (jsObject.__internalId){
		AjxCore.unassignId(jsObject.__internalId);
	}
};

/**
 * @deprecated		use {@link DwtControl.fromElement}
 * 
 * @private
 */
Dwt.getObjectFromElement =
function(domElement, attrName) {
	return AjxCore.objectWithId(domElement[attrName||"dwtObj"]);
};

Dwt.getElement =
function(el) {
	return (typeof(el) == "string") ? document.getElementById(el) : el;
};

/**
 * Finds an ancestor element with a non-empty value for the given attr.
 * 
 * @param	{DOMElement}	domElement	the starting DOM element
 * @param	{string}		attrName	the attribute name
 * 
 * @return	{DOMElement}	the DOM element
 */
Dwt.findAncestor =
function(domElement, attrName) {
	var attr = Dwt.getAttr(domElement, attrName);
	while (domElement && (attr == null || attr == "")) {
		domElement = domElement.parentNode;
		attr = Dwt.getAttr(domElement, attrName);
	}
	return domElement;
};

/**
 * Returns true if el1 is an ancestor (in the parent chain) of el2, or if
 * el1 and el2 are the same element.
 *
 * @param {DOMElement}	el1
 * @param {DOMElement}	el2
 */
Dwt.isAncestor =
function(el1, el2) {

	if (el1 == el2) {
		return true;
	}

	var el = el2;
	while (el) {
		el = el.parentNode;
		if (el == el1) {
			return true;
		}
	}
	return false;
};

Dwt.setHandler =
function(htmlElement, event, func) {
	if (!(htmlElement = Dwt.getElement(htmlElement))) { return; }
	if (event == DwtEvent.ONMOUSEWHEEL && AjxEnv.isGeckoBased) {
		Dwt.clearHandler(htmlElement, event);
	}
	htmlElement[event] = func;
	if (event == DwtEvent.ONMOUSEWHEEL && AjxEnv.isGeckoBased) {
		htmlElement.addEventListener("DOMMouseScroll", func, true);
	}
};

Dwt.clearHandler =
function(htmlElement, event) {
	if (!(htmlElement = Dwt.getElement(htmlElement))) { return; }
	if (event == DwtEvent.ONMOUSEWHEEL && AjxEnv.isGeckoBased) {
		if (htmlElement[event]) {
			var func = htmlElement[event];
			htmlElement.removeEventListener("DOMMouseScroll", func, true);
		}
	}
	htmlElement[event] = null;
};

Dwt.getBackgroundRepeat =
function(htmlElement) {
	if (!(htmlElement = Dwt.getElement(htmlElement))) { return; }
	return DwtCssStyle.getProperty(htmlElement, "background-repeat");
};

Dwt.setBackgroundRepeat =
function(htmlElement, style) {
	if (!(htmlElement = Dwt.getElement(htmlElement))) { return; }
	htmlElement.style.backgroundRepeat = style;
};

/**
 * Gets the bounds of an HTML element.
 *
 * @param {HTMLElement} htmlElement		the HTML element
 *
 * @return {DwtRectangle}	the elements bounds
 *
 * @see #setBounds
 * @see #getInsetBounds
 * @see #getLocation
 * @see #getSize
 */
Dwt.getBounds =
function(htmlElement, rect) {
	if (!(htmlElement = Dwt.getElement(htmlElement))) { return null; }
	var tmpPt = DwtPoint.tmp;

	Dwt.getLocation(htmlElement, tmpPt);
	var locX = tmpPt.x;
	var locY = tmpPt.y;

	Dwt.getSize(htmlElement, tmpPt);

	if (!rect) {
		return new DwtRectangle(locX, locY, tmpPt.x, tmpPt.y);
	} else {
		rect.set(locX, locY, tmpPt.x, tmpPt.y);
		return rect;
	}
};

/**
 * Sets the bounds of an HTML element. The position type of the element must
 * be absolute or else an exception is thrown. To omit setting a value set the
 * actual parameter value to <i>Dwt.DEFAULT</i>
 *
 * @param {HTMLElement} htmlElement absolutely positioned HTML element
 * @param {number|string} x the x coordinate of the element (for example: 10, "10px", {@link Dwt.DEFAULT})
 * @param {number|string} y the y coordinate of the element (for example: 10, "10px", {@link Dwt.DEFAULT})
 * @param {number} width the width of the element (for example: 100, "100px", "75%", {@link Dwt.DEFAULT})
 * @param {number} height the height of the element  (for example: 100, "100px", "75%", {@link Dwt.DEFAULT})
 *
 * @throws DwtException
 *
 * @see #getBounds
 * @see #setLocation
 * @see #setSize
 */
Dwt.setBounds =
function(htmlElement, x, y, width, height) {
	if (!(htmlElement = Dwt.getElement(htmlElement))) { return; }
	Dwt.setLocation(htmlElement, x, y);
	Dwt.setSize(htmlElement, width, height);
};

/**
 * Gets the element cursor for a given HTML element.
 *
 * @param {HTMLElement} htmlElement		the HTML element
 *
 * @return {string}	the html elements cursor
 *
 * @see #setCursor
 */
Dwt.getCursor =
function(htmlElement) {
	if (!(htmlElement = Dwt.getElement(htmlElement))) { return ""; }
	return DwtCssStyle.getProperty(htmlElement, "cursor");
};

/**
 * Sets an HTML element cursor.
 *
 * @param {HTMLElement} htmlElement the element for which to set the cursor
 * @param {string} cursorName name of the new cursor
 *
 * @see #setCursor
 */
Dwt.setCursor =
function(htmlElement, cursorName) {
	if (!(htmlElement = Dwt.getElement(htmlElement))) { return; }
	htmlElement.style.cursor = cursorName;
};

/**
 * Gets the location of an HTML element.
 *
 * @param {HTMLElement} htmlElement		the HTML element
 *
 * @return {DwtPoint}		the location of the HTML element
 *
 * @see #setLocation
 * @see #getBounds
 * @see #getSize
 */
Dwt.getLocation =
function(htmlElement, point) {
	if (!(htmlElement = Dwt.getElement(htmlElement))) { return null; }
	point = point || new DwtPoint(0, 0);

	if (htmlElement.style.position == Dwt.ABSOLUTE_STYLE) {
		// parseInt will return NaN if "top" or "left" is "auto" or not set.
		// TODO: We should test for that and just go to toWindow in that case.
		point.set(parseInt(DwtCssStyle.getProperty(htmlElement, "left")),
				parseInt(DwtCssStyle.getProperty(htmlElement, "top")));
		return point;
	}

	return Dwt.toWindow(htmlElement, 0, 0, null, null, point);
};

/**
 * Sets the location of an HTML element. The position type of the element must
 * be absolute or else an exception is thrown. To only set one of the coordinates,
 * pass in a value of {@link Dwt.DEFAULT} for the coordinate for which the value is
 * not to be set
 *
 * @param {HTMLElement} htmlElement the absolutely positioned HTML element
 * @param {number|string} x the x coordinate of the element (for example: 10, "10px", {@link Dwt.DEFAULT})
 * @param {number|string} y the y coordinate of the element (for example: 10, "10px", {@link Dwt.DEFAULT})
 *
 * @throws DwtException
 *
 * @see #getLocation
 * @see #setBounds
 * @see #setSize
 */
Dwt.setLocation =
function(htmlElement, x, y) {
	if (!(htmlElement = Dwt.getElement(htmlElement))) { return; }
	var position = DwtCssStyle.getProperty(htmlElement, 'position');
	if (position != Dwt.ABSOLUTE_STYLE && position != Dwt.RELATIVE_STYLE && position != Dwt.FIXED_STYLE) {
		DBG.println(AjxDebug.DBG1, "Cannot position static widget " + htmlElement.className);
		throw new DwtException("Static widgets may not be positioned", DwtException.INVALID_OP, "Dwt.setLocation");
	}
	if (x = Dwt.__checkPxVal(x)) {
		htmlElement.style.left = x;
	}
	if (y = Dwt.__checkPxVal(y)) {
		htmlElement.style.top = y;
	}
};

Dwt.getPosition =
function(htmlElement) {
	if (!(htmlElement = Dwt.getElement(htmlElement))) { return; }
	return htmlElement.style.position;
};

Dwt.setPosition =
function(htmlElement, posStyle) {
	if (!(htmlElement = Dwt.getElement(htmlElement))) { return; }
	htmlElement.style.position = posStyle;
};

/**
 * Returns <code>htmlElement</code>'s scroll style. The scroll style determines the element's
 * behaviour when content overflows its boundaries. Possible values are:
 * <ul>
 * <li><i>Dwt.CLIP</i> - Clip on overflow</li>
 * <li><i>Dwt.VISIBLE</i> - Allow overflow to be visible</li>
 * <li><i>Dwt.SCROLL</i> - Automatically create scrollbars if content overflows</li>
 * <li><i>Dwt.FIXED_SCROLL</i> - Always have scrollbars whether content overflows or not</li>
 * </ul>
 *
 * @param {HTMLElement} htmlElement HTML element
 *
 * @return {Dwt.CLIP|Dwt.VISIBLE|Dwt.SCROLL|Dwt.FIXED_SCROLL}	the elements scroll style
 */
Dwt.getScrollStyle =
function(htmlElement) {
	if (!(htmlElement = Dwt.getElement(htmlElement))) { return ""; }
	var overflow =  DwtCssStyle.getProperty(htmlElement, "overflow");

	if (overflow == "hidden")		{ return Dwt.CLIP; }
	if (overflow =="auto")			{ return Dwt.SCROLL; }
	if (overflow =="scroll")		{ return Dwt.FIXED_SCROLL; }

	if (overflow == '') {
		var overflowX = DwtCssStyle.getProperty(htmlElement, "overflowX");
		var overflowY = DwtCssStyle.getProperty(htmlElement, "overflowY");

		if (overflowX == 'scroll')	{ return Dwt.SCROLL_X; }
		if (overflowY == 'scroll')	{ return Dwt.SCROLL_Y; }
	}
	return Dwt.VISIBLE;
};

/**
 * Sets the <code>htmlElement</code>'s scroll style. The scroll style determines the elements's
 * behaviour when content overflows its div's boundaries. Possible values are:
 * <ul>
 * <li><i>Dwt.CLIP</i> - Clip on overflow</li>
 * <li><i>Dwt.VISIBLE</i> - Allow overflow to be visible</li>
 * <li><i>Dwt.SCROLL</i> - Automatically create scrollbars if content overflows</li>
 * <li><i>Dwt.FIXED_SCROLL</i> - Always have scrollbars whether content overflows or not</li>
 * </ul>
 *
 * @param {HTMLElement} htmlElement HTML element
 * @param {Dwt.CLIP|Dwt.VISIBLE|Dwt.SCROLL|Dwt.FIXED_SCROLL}	scrollStyle		the elements scroll style
 */
Dwt.setScrollStyle =
function(htmlElement, scrollStyle) {
	if (!(htmlElement = Dwt.getElement(htmlElement))) { return; }
	if (scrollStyle == Dwt.CLIP)
		htmlElement.style.overflow = "hidden";
	else if (scrollStyle == Dwt.SCROLL)
		htmlElement.style.overflow = "auto";
	else if (scrollStyle == Dwt.FIXED_SCROLL)
		htmlElement.style.overflow = "scroll";
	else if (scrollStyle == Dwt.SCROLL_Y) {
		htmlElement.style.overflowX = "hidden";
		htmlElement.style.overflowY = "auto";
	} else if (scrollStyle == Dwt.SCROLL_X) {
		htmlElement.style.overflowY = "hidden";
		htmlElement.style.overflowX = "auto";
	} else {
		htmlElement.style.overflow = "visible";
	}
};


/**
 * Gets the size of an HTML element. Normally, this yields the
 * calculated size of the element. However, if 'getFromStyle' is
 * true, the style is obtained directly from the CSS style.
 *
 * @param {HTMLElement} htmlElement		the HTML element
 * @param {DwtPoint} point		if given, reuse this point
 * @param {Boolean} getFromStyle		whether to use the calculated size
 *
 * @return {DwtPoint}	the elements size, margins included
 *
 * @see #getBounds
 * @see #setBounds
 * @see #getInsetBounds
 * @see #getLocation
 * @see #getOuterSize
 */
Dwt.getSize =
function(htmlElement, point, getFromStyle) {
    // Note: in FireFox, offsetHeight includes border and clientHeight does not;
    // may want to look at clientHeight for FF

	if (!(htmlElement = Dwt.getElement(htmlElement))) { return; }
	var p;
	if (!point) {
		p = new DwtPoint(0, 0);
	} else {
		p = point;
		p.set(0, 0);
	}

	if (!htmlElement) { return p; }

	if (getFromStyle) {
		if (htmlElement.style.width) { //assumption - the caller only cares about the dimension that is set via the style. So ok to keep 0 if it's not set. for simplicity.
			p.x = parseInt(htmlElement.style.width);
		}
		if (htmlElement.style.height) {
			p.y = parseInt(htmlElement.style.height);
		}

		return p;
	}

	p.x = htmlElement.offsetWidth;
	if (p.x != null) {
		p.y = htmlElement.offsetHeight;
	} else if (htmlElement.clip && htmlElement.clip.width != null) {
		p.x = parseInt(htmlElement.clip.width);
		p.y = parseInt(htmlElement.clip.height);
	} else if (htmlElement.style && htmlElement.style.pixelWidth != null) {
		p.x = parseInt(htmlElement.style.pixelWidth);
		p.y = parseInt(htmlElement.style.pixelHeight);
	}

	return p;
};


/**
 * Gets the outer size -- that is, the size including margins, padding, and borders -- of an
 * HTML element.
 *
 * @param {HTMLElement} htmlElement		the HTML element
 *
 * @return {DwtPoint}	the elements size, margins included
 *
 * @see #getSize
 * @see #getBounds
 * @see #setBounds
 * @see #getInsetBounds
 * @see #getLocation
 */
Dwt.getOuterSize =
function(htmlElement, point) {
    var p = Dwt.getSize(htmlElement, point);

    if (p && Dwt.getVisible(htmlElement)) {
        var margins = Dwt.getMargins(htmlElement);
		var insets = Dwt.getInsets(htmlElement);
        p.x += margins.left + margins.right + insets.left + insets.right;
        p.y += margins.top + margins.bottom + insets.top + insets.bottom;
    }

    return p;
};

Dwt.setSize =
function(htmlElement, width, height) {
	if (!(htmlElement = Dwt.getElement(htmlElement))) { return; }
	if (!htmlElement.style) { return; }

	if (width == Dwt.CLEAR) {
		htmlElement.style.width = null;
	} else if (width = Dwt.__checkPxVal(width, true)) {
		htmlElement.style.width = width;
	}

	if (height == Dwt.CLEAR) {
		htmlElement.style.height = null;
	} else if (height = Dwt.__checkPxVal(height, true)) {
		htmlElement.style.height = height;
	}
};

/**
 * Measure the extent in pixels of a section of html. This is not the worlds cheapest
 * method to invoke so do so judiciously
 *
 * @param {string} html 	the html content for which that extents are to be calculated
 *
 * @return {DwtPoint}	the extent of the content
 */
Dwt.getHtmlExtent =
function(html) {
	var div = AjxStringUtil.calcDIV();
	div.innerHTML = html;
	return Dwt.getSize(div);
};

Dwt.toDocumentFragment =
function(html, id) {
	var div = AjxStringUtil.calcDIV();
	div.innerHTML = html;

	var fragment = document.createDocumentFragment();
	var container = id && document.getElementById(id);
	if (container) {
		fragment.appendChild(container);
	}
	else {
		for (var child = div.firstChild; child; child = div.firstChild) {
			fragment.appendChild(child);
		}
	}
	return fragment;
};

Dwt.getAttr =
function(htmlEl, attr, recursive) {
	// test for tagName so we dont try to eval non-html elements (i.e. document)
	if (!recursive) {
		return htmlEl && htmlEl.tagName
			? (htmlEl.getAttribute(attr) || htmlEl[attr])
			: null;
	} else {
		while (htmlEl) {
			if (Dwt.getAttr(htmlEl, attr) != null) {
				return htmlEl;
			}
			htmlEl = htmlEl.parentNode;
		}
		return null;
	}
};

Dwt.getVisible =
function(htmlElement) {
	if (!(htmlElement = Dwt.getElement(htmlElement))) { return; }
	var disp = DwtCssStyle.getProperty(htmlElement, "display");
	return (disp != Dwt.DISPLAY_NONE);
};

Dwt.setVisible =
function(htmlElement, visible) {
	if (!(htmlElement = Dwt.getElement(htmlElement))) { return; }
	if (visible) {
		if (htmlElement.nodeName.match(/tr/i)) {
			htmlElement.style.display = Dwt.DISPLAY_TABLE_ROW;
		}
		else if (htmlElement.nodeName.match(/td|th/i)) {
			htmlElement.style.display = Dwt.DISPLAY_TABLE_CELL;
		}
		else {
			htmlElement.style.display = htmlElement.getAttribute("x-display") ||
										Dwt.DISPLAY_BLOCK;
		}
	} else {
		var display = DwtCssStyle.getComputedStyleObject(htmlElement).display;
		if (display != "none") {
			htmlElement.setAttribute("x-display", display);
		}
		htmlElement.style.display = Dwt.DISPLAY_NONE;
	}
};

Dwt.getVisibility =
function(htmlElement) {
	if (!(htmlElement = Dwt.getElement(htmlElement))) { return; }
	var vis = DwtCssStyle.getProperty(htmlElement, "visibility");
	return (vis == "visible");
};

Dwt.setVisibility =
function(htmlElement, visible) {
	if (!(htmlElement = Dwt.getElement(htmlElement))) { return; }
	htmlElement.style.visibility = visible ? "visible" : "hidden";
};

Dwt.__MSIE_OPACITY_RE = /alpha\(opacity=(\d+)\)/;

Dwt.getOpacity =
function(htmlElement) {
	if (!(htmlElement = Dwt.getElement(htmlElement))) { return; }
	return Number(htmlElement.style.opacity || 1) * 100;
};

Dwt.setOpacity =
function(htmlElement, opacity) {
	if (!(htmlElement = Dwt.getElement(htmlElement))) { return; }
	htmlElement.style.opacity = opacity/100;
};


/**
 * Get the z-index of an element.
 *
 * @param {boolean} getFromStyle    get the value from the style attribute of
 *                                  this element, or a parent
 *
 * @return	{number}	the z-index value
 */
Dwt.getZIndex =
function(htmlElement, getFromStyle) {
	if (!(htmlElement = Dwt.getElement(htmlElement))) { return; }

	if (getFromStyle) {
		while (htmlElement.style.zIndex === "" && htmlElement.parentNode) {
			htmlElement = htmlElement.parentNode;
		}

		return htmlElement.style.zIndex;
	}

	return DwtCssStyle.getProperty(htmlElement, "z-index");
};

Dwt.setZIndex =
function(htmlElement, idx) {
	if (!(htmlElement = Dwt.getElement(htmlElement))) { return; }
	htmlElement.style.zIndex = idx;
	if (idx < Dwt.Z_VIEW) {
		htmlElement.setAttribute('aria-hidden', true);
	} else {
		htmlElement.removeAttribute('aria-hidden');
	}
};

Dwt.getDisplay =
function(htmlElement) {
	DwtCssStyle.getProperty(htmlElement, "display");
};

Dwt.setDisplay =
function(htmlElement, value) {
	if (!(htmlElement = Dwt.getElement(htmlElement))) { return; }
	htmlElement.style.display = value;
};

/**
 * Gets the window size of the browser.
 * 
 * @param	{DwtPoint}		point		the point to hold the windows x/y size
 * @return	{DwtPoint}		the point holding the window x/y size
 */
Dwt.getWindowSize =
function(point) {
	var p = (!point) ? new DwtPoint(0, 0) : point;
	if (window.innerWidth) {
		p.x = window.innerWidth;
		p.y = window.innerHeight;
	} else if (document.body && document.body.clientWidth) {
		p.x = document.body.clientWidth;
		p.y = document.body.clientHeight;
	}
	return p;
};

Dwt.toWindow =
function(htmlElement, x, y, containerElement, dontIncScrollTop, point) {
	var p;
	if (!point) {
		p = new DwtPoint(x, y);
	} else {
		p = point;
		p.set(x, y);
	}

	htmlElement = Dwt.getElement(htmlElement);
	var offsetParent = htmlElement;
	while (offsetParent && offsetParent != containerElement) {
		p.x += offsetParent.offsetLeft - offsetParent.scrollLeft;
		p.y += offsetParent.offsetTop;
		if (!dontIncScrollTop) {
			var scrollTop = AjxEnv.isOpera ? offsetParent.pageYOffset : offsetParent.scrollTop;
			if (scrollTop) {
				p.y -= scrollTop;
			}
			var parentNode = offsetParent.parentNode;
			while (parentNode != offsetParent.offsetParent && parentNode != containerElement) {
				scrollTop = AjxEnv.isOpera ? parentNode.pageYOffset : parentNode.scrollTop;
				if (scrollTop) {
					p.y -= scrollTop;
				}
				parentNode = parentNode.parentNode;
			}
		}
		offsetParent = offsetParent.offsetParent;
	}
	return p;
};

Dwt.getInsets = function(htmlElement) {
	// return an object with the insets (border + padding size) for each side of the element, eg:
	//		{ left: 3, top:0, right:3, bottom:0 }
	// NOTE: assumes values from computedStyle are returned in pixels!!!

	if (!(htmlElement = Dwt.getElement(htmlElement))) { return; }
	var style = DwtCssStyle.getComputedStyleObject(htmlElement);

	var bl = parseInt(style.borderLeftWidth) 	|| 0;
	var bt = parseInt(style.borderTopWidth) 	|| 0;
	var br = parseInt(style.borderRightWidth)	|| 0;
	var bb = parseInt(style.borderBottomWidth)	|| 0;

	var pl = parseInt(style.paddingLeft) 	|| 0;
	var pt = parseInt(style.paddingTop) 	|| 0;
	var pr = parseInt(style.paddingRight)	|| 0;
	var pb = parseInt(style.paddingBottom)	|| 0;

	return {
			left 	: bl + pl,
			top  	: bt + pt,
			right 	: br + pr,
			bottom	: bb + pb
		};
};

Dwt.insetBounds = function(bounds, insets) {

	// given a 'bounds' object [from Dwt.getBounds()] 
	//	and an 'insets' object [from Dwt.getInsets()]
	//	munge the bounds so it takes the insets into account.
	// Useful to get the inner dimensions of an element.
	if (!bounds) {
        return null;
    }

	bounds.x += insets.left;
	bounds.y += insets.top;
	bounds.width  -= insets.left + insets.right;
	bounds.height -= insets.top + insets.bottom;

	return bounds;
};

/**
 * Gets the bounds of an HTML element, excluding borders and paddings.
 *
 * @param {HTMLElement} htmlElement		the HTML element
 *
 * @return {DwtRectangle}	the elements bounds
 *
 * @see #setBounds
 * @see #getInsetBounds
 * @see #getLocation
 * @see #getSize
 */
Dwt.getInsetBounds = function(htmlElement) {
	if (!(htmlElement = Dwt.getElement(htmlElement))) { return; }

	var bounds = Dwt.getBounds(htmlElement);
	var insets = Dwt.getInsets(htmlElement);

	return Dwt.insetBounds(bounds, insets);
};

Dwt.getMargins = function(htmlElement) {
	// return an object with the margins for each side of the element, eg:
	//		{ left: 3, top:0, right:3, bottom:0 }
	// NOTE: assumes values from computedStyle are returned in pixels!!!

	if (!(htmlElement = Dwt.getElement(htmlElement))) { return; }
	var style = DwtCssStyle.getComputedStyleObject(htmlElement);

	return {
		left 	: parseInt(style.marginLeft) 	|| 0,
		top  	: parseInt(style.marginTop) 	|| 0,
		right 	: parseInt(style.marginRight) 	|| 0,
		bottom	: parseInt(style.marginBottom)	|| 0
	};
};

/**
 * Get ancestor elements of the given node, up to and including the given
 * parent node. If no parent is given, assume the root document node. If the
 * parent node is not an ancestor of the child, return <code>null</code>.
 *
 * @param {HTMLElement} childNode		the child HTML element
 * @param {HTMLElement} parentNode		the parent HTML element
 * @param {Boolean} 	includeChild	if true, include the child itself
 *
 * @return {Array}						a list of HTML elements
 */
Dwt.getAncestors =
function(childNode, parentNode, includeChild) {
	var ancestors = [];

	// a reasonable default
	if (!parentNode) {
		parentNode = document.documentElement;
	}

	if (includeChild) {
		ancestors.push(childNode);
	}

	while (childNode && childNode != parentNode) {
		ancestors.push(childNode.parentNode);
		childNode = childNode.parentNode;
	}

	// check if the parent was an ancestor
	if (ancestors[ancestors.length - 1] != parentNode) {
		return null;
	}

	return ancestors;
};

Dwt.setStatus =
function(text) {
	window.status = text;
};

Dwt.getTitle =
function() {
	return window.document.title;
};

Dwt.setTitle =
function(text) {
	window.document.title = text;
};

Dwt.getIframeDoc =
function(iframeObj) {
	if (iframeObj) {
		return iframeObj.contentDocument;
	}
	return null;
};

Dwt.getIframeWindow =
function(iframeObj) {
	return iframeObj.contentWindow;
};

/**
 * Creates and returns an element from a string of HTML.
 *
 * @param {string} html 	the HTML text
 * @param {boolean} isRow 	if <code>true</code>, if the element is a <code>&lt;tr&gt;</code>
 *
 * @return {HTMLElement}	an HTMLElement with the <code>html</code> as its content. if <code>isRow</code>
 * 		is <code>true</code>, then the element will be a table
 */
Dwt.parseHtmlFragment =
function(html, isRow) {
	if (!Dwt._div) {
		Dwt._div = document.createElement('div');
	}
	// TR element needs to have surrounding table
	if (isRow) {
		html = "<table style='table-layout:fixed'>" + html + "</table>";
	}
	Dwt._div.innerHTML = html;

	if (isRow) {
		var fragment = document.createDocumentFragment();
		var rows = Dwt._div.firstChild.rows;
		for (var i = rows.length - 1; i >= 0; i--) {
			// NOTE: We always grab the first row because once we append it
			//       to the fragment, it will be removed from the table.
			fragment.appendChild(rows[0]);
		}
		return fragment.childNodes.length > 1 ? fragment : fragment.firstChild;
	}
	return Dwt._div.firstChild;
};

Dwt.contains =
function(parentEl, childEl) {
	var isContained = false;
	if (parentEl.compareDocumentPosition) {
		var relPos = parentEl.compareDocumentPosition(childEl);
		if ((relPos == (document.DOCUMENT_POSITION_CONTAINED_BY | document.DOCUMENT_POSITION_FOLLOWING))) {
			isContained = true;
		}
	} else if (parentEl.contains) {
		isContained = parentEl.contains(childEl);
	}
	return isContained;
};

Dwt.removeChildren =
function(htmlEl) {
	while (htmlEl.hasChildNodes()) {
		htmlEl.removeChild(htmlEl.firstChild);
	}
};

/**
 * Opera always returns zero for cellIndex property of TD element :(
 *
 * @param cell		TD object we want cell index for
 * 
 * @private
 */
Dwt.getCellIndex =
function(cell) {
	if (AjxEnv.isOpera) {
		if (cell.tagName && cell.tagName.toLowerCase() == "td") {
			// get the cells collection from the TD's parent TR
			var cells = cell.parentNode.cells;
			var len = cells.length;
			for (var i = 0; i < len; i++) {
				if (cells[i] == cell)
					return i;
			}
		}
	} else {
		return cell.cellIndex;
	}
	return -1;
};

/**
 * Remove the <code>del</code> class name from the element's CSS class names and
 * optionally add <code>add</code> class name if given provided
 *
 * @param {HTMLElement} el HTML Element to which to add/delete class names
 * @param {string} [del] the class name to delete
 * @param {string} [add] the class name to add
 */
Dwt.delClass =
function(el, del, add) {

	if (el == null) { return }
	if (!del && !add) { return; }

	if (typeof del == "string" && del.length) {
		del = Dwt._DELCLASS_CACHE[del] || (Dwt._DELCLASS_CACHE[del] = new RegExp("\\b" + del + "\\b", "ig"));
	}
	var className = el.className || "";
	className = className.replace(del, " ");
	className = AjxStringUtil.trim(className);
	el.className = add ? className + " " + add : className;
};

// cache the regexps here to avoid compiling the same regexp multiple times
Dwt._DELCLASS_CACHE = {};

/**
 * Adds the given class name to the element's CSS class names
 *
 * @param {HTMLElement} el the HTML Element to which to add the class name
 * @param {string} c the class name
 *
 * @see #delClass
 */
Dwt.addClass =
function(el, c) {
	Dwt.delClass(el, c, c);
};

/**
 * Conditionally add or remove a class name from an element
 *
 * @param {HTMLElement} el the target element
 * @param {boolean} condition 	the condition to check
 * @param {string} a the class name when condition is <code>true</code>
 * @param {string} b the class name when condition is <code>false</code>
 */
Dwt.condClass =
function(el, condition, a, b) {
	if (!!condition) {
		if (b) {
			Dwt.delClass(el, b);
		}
		Dwt.addClass(el, a);
	} else {
		Dwt.delClass(el, a);
		if (b) {
			Dwt.addClass(el, b);
		}
	}
};

/** Returns true if the specified element has the given class. */
Dwt.hasClass = function(el, className) {
    if (!el || !className) return false;
    return el.className.match(new RegExp("\\b"+className+"\\b"));
};

/**
 * Sets the selection range.
 *
 * @param {input|iframe} input input for which to find the selection start point. This
 * 		may be a text input field or an iframe in design mode
 * @param {number} start 	the starting position
 * @param {number} end 	the ending position
 *
 * @see #getSelectionStart
 * @see #getSelectionEnd
 * @see #setSelectionText
 * @see #moveCursorToEnd
 */
Dwt.setSelectionRange =
function(input, start, end) {
	if (input.setSelectionRange) {
        input.focus();
		input.setSelectionRange(start, end);
	} else if (input.createTextRange) {
		var range = input.createTextRange();
		range.collapse(true);
		range.moveStart("character", start);
		range.moveEnd("character", end - start);
		range.select();
	} else if (input.select) {
		// FIXME: find solutions for other browsers
		input.select();
	}
};

/**
 * Retrieves the start of the selection.  For a collapsed range, this is
 * equivalent to {@link #getSelectionEnd}.
 *
 * @param {input|iframe} input input for which to find the selection start point. This
 * 		may be a text input field or an iframe in design mode
 *
 * @return {number}	starting position of the selection
 *
 * @see #getSelectionEnd
 * @see #setSelectionText
 * @see #setSelectionRange
 * @see #moveCursorToEnd
 */
Dwt.getSelectionStart =
function(input) {
	if (AjxUtil.isSpecified(input.selectionStart)) {
		return input.selectionStart;
	} else if (document.selection) {
		var range = document.selection.createRange();
		var isCollapsed = range.compareEndPoints("StartToEnd", range) == 0;
		if (!isCollapsed)
			range.collapse(true);
		var b = range.getBookmark();
		var offset = input.createTextRange().getBookmark().charCodeAt(2);
		return Math.max(b.charCodeAt(2) - offset, 0);
	}

	// FIXME: find solutions for other browsers
	return input.value.length;
};

/**
 * Retrieves the end of the selection.
 *
 * @param {input|iframe} input 	the input for which to find the selection end point. This
 * 		may be a text input field or an iframe in design mode
 *
 * @return {number}	the starting position of the selection
 *
 * @see #getSelectionStart
 * @see #setSelectionText
 * @see #setSelectionRange
 * @see #moveCursorToEnd
 */
Dwt.getSelectionEnd =
function(input) {
	if (AjxUtil.isSpecified(input.selectionEnd)) {
		return input.selectionEnd;
	} else if (document.selection) {
		var range = document.selection.createRange();
		var isCollapsed = range.compareEndPoints("StartToEnd", range) == 0;
		if (!isCollapsed)
			range.collapse(false);
		var b = range.getBookmark();
		var offset = input.createTextRange().getBookmark().charCodeAt(2);
		return Math.max(b.charCodeAt(2) - offset, 0);
	}

	// FIXME: find solutions for other browsers
	return input.value.length;
};

/**
 * Sets the selection text
 *
 * @param {input|iframe} input	the input for which to set the selection text. This
 * 		may be a text input field or an iframe in design mode
 * @param {string} text 	the text to set as the selection
 *
 * @see #getSelectionStart
 * @see #getSelectionEnd
 * @see #setSelectionRange
 * @see #moveCursorToEnd
 */
Dwt.setSelectionText =
function(input, text) {
	var start = Dwt.getSelectionStart(input);
	var end = Dwt.getSelectionEnd(input);
	var str = input.value;
	var val = [
		str.substr(0, start),
		text,
		str.substr(end)
	].join("");

	if (typeof input.setValue == "function") {
		input.setValue(val);
	} else {
		input.value = val;
	}
	Dwt.setSelectionRange(input, start, start + text.length);
};

/**
 * Move cursor to the end of an input.
 *
 * @param {input} input	    text input
 *
 * @see #getSelectionStart
 * @see #getSelectionEnd
 * @see #setSelectionText
 * @see #setSelectionRange
 */
Dwt.moveCursorToEnd =
function(input) {
	Dwt.setSelectionRange(input, input.value.length, input.value.length);
};

Dwt.instanceOf =
function(objOrClassName, className) {
	if (typeof objOrClassName == "string") {
		return window[objOrClassName] &&
				(objOrClassName == className || window[objOrClassName].prototype instanceof window[className]);
	}
	return (window[className] && objOrClassName instanceof window[className]);
};

/**
 * Normalizes an argument list into a hash with the given argument names.
 * If a single hash argument is passed, it is recognized as a params hash
 * and returned. Otherwise, the argument list is exploded into a params
 * hash with the given param names.
 * 
 * @param {Object}	args			Array-like structure of arguments
 * @param {array}	paramNames		an ordered list of param names
 */
Dwt.getParams = function(args, paramNames) {

	if (!args || args.length === 0 || (args.length === 1 && !args[0])) {
		return {};
	}

	// Check for arg-list style of passing params. There will almost always
	// be more than one arg, and the first one may be the parent DwtControl.
	// Conversion is not done if there is a single argument that is a simple
	// hash, or a proxy for a simple hash (see AjxUtil.createProxy).

	if (args.length > 1 || !AjxUtil.isHash(args[0]._object_ || args[0])) {
		var params = {};
		for (var i = 0; i < args.length; i++) {
			params[paramNames[i]] = args[i];
		}
		return params;
	}
	if (args.length === 1) {
		return args[0];
	}
	return {};
};

//////////////////////////////////////////////////////////////////////////////////
// PRIVATE METHODS
//////////////////////////////////////////////////////////////////////////////////

Dwt.__REM_RE = /^(-?[0-9]+(?:\.[0-9]*)?)rem$/;

/**
 * @private
 */
Dwt.__checkPxVal =
function(val, check) {
	if (val == Dwt.DEFAULT) { return false; }
	if (isNaN(parseInt(val))) { return false; }

	if (check && val < 0 && val != Dwt.LOC_NOWHERE) {
		DBG.println(AjxDebug.DBG1, "negative pixel value: " + val);
		val = 0;
	}
	if (typeof(val) == "number") {
		val = val + "px";
	}
	if (!AjxEnv.supportsCSS3RemUnits && Dwt.__REM_RE.test(val)) {
		val = DwtCssStyle.asPixelCount(val) + "px";
	}
	return val;
};






/////////////
//	NEW STUFF FROM OWEN
/////////////
Dwt.byId =
function(id, ancestor) {
	if (!ancestor) {
		return (typeof id == "string" ? document.getElementById(id) : id);
	}

	// Find node with id that descends from ancestor (also works on DOM trees
	// that are not attached to the document object)
	if (ancestor == id || ancestor.id == id) {
		return ancestor;
	}

	for (var i = 0; i < ancestor.childNodes.length; i++) {
		if (ancestor.childNodes[i].nodeType == 1) {
			var cnode = Dwt.byId(id, ancestor.childNodes[i]);
			if (cnode) { return cnode; }
		}
	}
	return null;
};

/**
 * Get all elements of a certain tag name. Similar to
 * document.getElementsByTagName(), but returning an Array instead of
 * a NodeList.
 *
 * @param {String} tagName	the tag name, such as "A"
 * @param {HTMLElement} ancestor An optional ancestor element,
 *                      defaults to the document
 * @return	{Array}
 */
Dwt.byTag =
function(tagName, ancestor) {
	if (!ancestor) {
		ancestor = document;
	}

	return AjxUtil.toArray(ancestor.getElementsByTagName(tagName));
};

/**
 * Get all elements of the given class name. Similar to
 * document.getElementsByClassName(), but returning an Array instead
 * of a NodeList.
 *
 * @param {String} className
 * @param {HTMLElement} ancestor An optional ancestor element,
 *                      defaults to the document
 * @return	{Array}
 */
Dwt.byClassName =
function(className, ancestor) {
	if (!ancestor) {
        ancestor = document;
	}

	var nodes;

	if (ancestor.getElementsByClassName) {
		nodes = ancestor.getElementsByClassName(className);
	} else {
		nodes = ancestor.querySelectorAll('.' + className);
	}

	return AjxUtil.toArray(nodes);
};

Dwt.show =
function(it) {
	var el = Dwt.byId(it);
	if (el) {
		Dwt.setVisible(el,true);
	}
};

Dwt.hide =
function(it) {
	var el = Dwt.byId(it);
	if (el) {
		Dwt.setVisible(el,false);
	}
};

//setText Methods

Dwt.setText =
function(htmlEl,text){
	htmlEl.appendChild(document.createTextNode(text));
};

Dwt.populateText =
function(){
	if (arguments.length == 0 ) { return; }

	var node, index = 0, length = arguments.length;
	while (index < length) {
		node = document.getElementById(arguments[index]);
		if (node) {
			Dwt.setText(node,arguments[index+1]);
		}
		index += 2;
	}
};

//setHtml Methods

Dwt.setInnerHtml =
function(htmlEl,html){
	htmlEl.innerHTML = html;
};

/**
 * Sets the favicon.
 *
 * @param {string} the url to the icon to display
 * 
 * @private
 */
Dwt.setFavIcon =
function(iconURL) {

	// Look for an existing fav icon to modify.
	var favIcon = null;
	if (Dwt._favIconId) {
		favIcon = document.getElementById(Dwt._favIconId);
	} else {
		var docHead = document.getElementsByTagName("head")[0];
		var links = docHead.getElementsByTagName("link");
		for (var i = 0; i < links.length; i++) {
			var link = links[i];
			if (link.rel.toUpperCase() == "SHORTCUT ICON") {
				if (!link.id) {
					link.id = Dwt._favIconId = Dwt.getNextId();
				}
				favIcon = link;
				break;
			}
		}
	}
	// If available, change the existing favicon.
	// (Need to remove/add to dom in order to force a redraw.)
	if (favIcon) {
		favIcon.href=iconURL;
		favIcon.type = 'image/x-icon';
		var parent = favIcon.parentNode;
		parent.removeChild(favIcon);
		parent.appendChild(favIcon);
	}
	// If no favicon was found in the document, create a new one.
	else {
		var newLink = document.createElement("link");
		newLink.id = Dwt._favIconId = Dwt.getNextId()
		newLink.rel = "SHORTCUT ICON";
		newLink.href = iconURL;
		newLink.type = "image/x-icon";
		docHead = docHead || document.getElementsByTagName("head")[0];
		docHead.appendChild(newLink);
	}
};

Dwt.enableDesignMode =
function(doc, on) {
	if (!AjxEnv.isIE) {
		doc.designMode = on ? "on" : "off";
	} else {
		var editorBody = doc.body;
		if (!editorBody || editorBody.contentEditable === undefined) {
			doc.designMode = on ? "on" : "off";
		} else {
			editorBody.contentEditable = on ? true : false;
		}
	}
};

/**
 * Hack to work around FF 3.6 change in behavior with regard to mouse down/up in
 * scrollbar, which breaks this list view's scrollbar. Return true and tell DOM
 * not to call <code>preventDefault()</code>, since we want default browser behavior.
 * <p>
 * Note: Callers should set up their elements so that a click that is not within
 * a scrollbar goes to a more specific element (and not the one that scrolls).
 * That way we don't have to perform sketchy math to see if the click was in the
 * scrollbar.
 * </p>
 * <p>
 * <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=489667">https://bugzilla.mozilla.org/show_bug.cgi?id=489667</a>
 * </p>
 * <p>It looks like the FF bug will be fixed with the release of 3.6.4.</p>
 * @param {DwtMouseEvent}	ev			the event
 * @return	{boolean}	<code>true</code> if FF3.6+ scrollbar click was detected and handled
 * 
 * @private
 */
Dwt.ffScrollbarCheck =
function(ev) {
	if (AjxEnv.isFirefox3_6up || AjxEnv.isDesktop2up) {
		var t = ev.target;
		if (t && (t.clientHeight && t.scrollHeight && (t.clientHeight != t.scrollHeight)) ||
				 (t.clientWidth && t.scrollWidth && (t.clientWidth != t.scrollWidth)))
		{
			ev._dontCallPreventDefault = true;
			ev._stopPropagation = false;
			ev._returnValue = true;
			return true;
		}
	}
	return false;
};

Dwt.selectText =
function(el) {

	if (!el) {
		Dwt.deselectText();
		return;
	}

	if (document.selection) {
		// IE
		var range = el.parentTextEdit.createTextRange();
		range.moveToElementText(el);
		range.select();
	}
	else if (window.getSelection) {
		var range = document.createRange();
		range.selectNode(el);
		var sel = window.getSelection();
		sel.addRange(range);
	}
};

Dwt.deselectText =
function() {

	if (document.selection) {
		// IE
		document.selection.empty();
	}
	else if (window.getSelection) {
		window.getSelection().removeAllRanges();
	}
};

/**
 * Inserts some text into an input at the caret.
 *
 * @param {Element}     input       INPUT or TEXTAREA
 * @param {String}      text        text to insert
 */
Dwt.insertText = function(input, text) {

    if (!input || !text) {
        return;
    }

    if (document.selection) {
        // IE
        input.focus();
        var sel = document.selection.createRange();
        sel.text = text;
        input.focus();
    }
    else if (AjxUtil.isSpecified(input.selectionStart)) {
        var start = input.selectionStart,
            end = input.selectionEnd;
        input.value = input.value.substring(0, start) + text + input.value.substring(end, input.value.length);
        input.selectionStart = start + text.length;
        input.selectionEnd = end + text.length;
    }
    else {
        input.value += text;
    }
};

/**
 * Returns true if the two elements overlap.
 * 
 * @param el1
 * @param el2
 */
Dwt.doOverlap =
function(el1, el2) {

	if (!el1 || !el2) { return false; }

	var loc1 = Dwt.getLocation(el1), loc2 = Dwt.getLocation(el2);
	var size1 = Dwt.getSize(el1), size2 = Dwt.getSize(el2);
	var left1 = loc1.x, left2 = loc2.x, top1 = loc1.y, top2 = loc2.y;
	var right1 = left1 + size1.x, right2 = left2 + size2.x;
	var bottom1 = top1 + size1.y, bottom2 = top2 + size2.y;

	return !(left1 > right2 || right1 < left2 || top1 > bottom2 || bottom1 < top2);
};

/**
 * Resets the scrollTop of container (if necessary) to ensure that element is visible.
 * 
 * @param {Element}		element		the element to be made visible
 * @param {Element}		container	the containing element to possibly scroll
 * @private
 */
Dwt.scrollIntoView =
function(element, container) {
	
	if (!element || !container) { return; }
	
	var elementTop = Dwt.toWindow(element, 0, 0, null, null, DwtPoint.tmp).y;
	var containerTop = Dwt.toWindow(container, 0, 0, null, null, DwtPoint.tmp).y + container.scrollTop;

	var diff = elementTop - containerTop;
	if (diff < 0) {
		container.scrollTop += diff;
	} else {
		var containerH = Dwt.getSize(container, DwtPoint.tmp).y;
		var elementH = Dwt.getSize(element, DwtPoint.tmp).y;
		diff = (elementTop + elementH) - (containerTop + containerH);
		if (diff > 0) {
			container.scrollTop += diff;
		}
	}
};

/**
 * Sets up a hidden div for performance metrics.  Use to set the start of object rendering
 * @param id {String}
 * @param date {Date}
 */
Dwt.setLoadingTime = 
function(id, date) {
	if (!window.isPerfMetric) { return;	}
	date = date || new Date();
	id += "_loading";
	var div = document.getElementById(id);
	if (!div) {
		div = document.createElement("div");
		div.id = id;
		div.style.display = "none";
		document.body.appendChild(div);
	}
	div.innerHTML = date.getTime();
	if (window.appDevMode) {
		console.profile(id);
	}
};

/**
 * Sets up a hidden div for performance metrics.  Use to set the end of object rendering
 * @param id {String}
 * @param date {Date}
 */
Dwt.setLoadedTime = 
function(id, date) {
	if (!window.isPerfMetric) { return;	}
	date = date || new Date();
	id += "_loaded";
	var div = document.getElementById(id);
	if (!div) {
		div = document.createElement("div");
		div.id = id;
		div.style.display = "none";
		document.body.appendChild(div);
	}
	div.innerHTML = date.getTime();
	if (window.appDevMode) {
		console.profileEnd();
	}
};

/**
 * Prints the computed time from performance metrics data
 */
Dwt.printPerfMetric =
function() {
	//code to print all loading stats
	$.each($('div[id*="_loaded"]'), function(index, elem) {
		var end_id = $(elem).attr("id");
		var start_id_prefix = end_id.substring(0,end_id.indexOf("_"));
		var end_elem = $("#" + start_id_prefix+"_launched");
		if (end_elem && end_elem.length > 0) {
			var end_time = $("#" + start_id_prefix+"_launched").html();
		} else {
			end_time = $("#" + start_id_prefix+"_loading").html();
		}
		var log = "Load time for " + start_id_prefix + " is " + ($(elem).html()-end_time);
		DBG.println(AjxDebug.DBG1,log);
		if (console) {
			console.log(log);
		}
	});
}

// Css for Templates
Dwt.createLinearGradientCss =
function(startColor, endColor, direction) {
    var gradientCss = null;
    var gradient = this.createLinearGradientInfo(startColor, endColor, direction);
    if (gradient.field) {
        gradientCss = gradient.field + ":" + gradient.css + ";";
    }
    return gradientCss;
}

/**
 * -- FF 3.6+
 *    background: -moz-linear-gradient(black, white);
 * -- Safari 4+, Chrome 2+
 *    background: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #000000), color-stop(100%, #ffffff));
 * -- Safari 5.1+, Chrome 10+
 *    background: -webkit-linear-gradient(top, black, white);
 * -- Opera 11.10
 *    background: -o-linear-gradient(black, white);
 * -- IE6 & IE7
 *    filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#000000', endColorstr='#ffffff');
 * -- IE10
 *    background: -ms-linear-gradient(black, white);
 * -- the standard
 *    background: linear-gradient(black, white);
 */
Dwt.createLinearGradientInfo =
function(startColor, endColor, direction) {

    var cssDirection;
    var gradient = {};
	if (AjxEnv.isIE9) {
        var params = {
            x1: "0%",
            x2: direction == 'v' ? "0%" : "100%",
            y1: "0%",
            y2: direction == 'v' ? "100%" : "0%",
            startColor: startColor,
            endColor: endColor
        };
        var svgsrc =
            AjxTemplate.expand('dwt.Widgets#SVGGradient', params);
        gradient.field = "background";
        gradient.css   = ('url(data:image/svg+xml,' +
                          escape(svgsrc.replace(/\s+/g, ' ')) + ')');
    } else if (AjxEnv.isFirefox3_6up) {
        cssDirection = (direction == 'v') ? 'top' : 'left';
        gradient.field = "background";
        gradient.css   = "-moz-linear-gradient(" + cssDirection + "," + startColor + ", "  + endColor + ")";
    } else if ((AjxEnv.isSafari && AjxEnv.isSafari5_1up) || AjxEnv.isChrome10up) {
        cssDirection = (direction == 'v') ? 'top' : 'left';
        gradient.field = "background";
        gradient.css   = "-webkit-linear-gradient(" + cssDirection + ","+
                          startColor + ", " + endColor + ")";
    } else if ((AjxEnv.isSafari && AjxEnv.isSafari4up) || AjxEnv.isChrome2up) {
        var startPt = 'left top';
        var endPt   = (direction == 'v') ? "left bottom" : "right top";
        gradient.field = "background";
        gradient.css   = "-webkit-gradient(linear, " + startPt + ", " + endPt +
                         ", color-stop(0%, " + startColor + "), color-stop(100%, " + endColor + "))";
    } else {
        cssDirection = (direction == 'v') ? 'to bottom' : 'to right';
        gradient.field = "background";
        gradient.css   = "linear-gradient(" + cssDirection + "," + startColor + ", "  + endColor + ")";
    }
    return gradient;
}

// Used for an unattached DOM subtree.
Dwt.getDescendant =
function(htmlElement, id) {
    var descendant = null;
    for (var i = 0; i < htmlElement.childNodes.length; i++) {
        var child = htmlElement.childNodes[i];
        if (child.id == id) {
            descendant = child;
        } else {
            descendant = Dwt.getDescendant(child, id);
        }
        if (descendant != null) {
            break;
        }
    }
    return descendant;
};

Dwt.getPreviousElementSibling =
function(element) {
	var sibling = element.previousElementSibling;

	if (sibling !== undefined) {
		return sibling;
	}

	// workaround for missing previousElementSibling in MSIE 8
	for (sibling = element.previousSibling;
		 sibling && sibling.nodeType !== 1;
		 sibling = sibling.previousSibling);

	return sibling;
}

Dwt.getNextElementSibling =
function(element) {
	var sibling = element.nextElementSibling;

	if (sibling !== undefined) {
		return sibling;
	}

	// workaround for missing nextElementSibling in MSIE 8
	for (sibling = element.nextSibling;
		 sibling && sibling.nodeType !== 1;
		 sibling = sibling.nextSibling);

	return sibling;
}

Dwt.getScrollbarSizes = function(node) {
    var insets = Dwt.getInsets(node);
    var style = DwtCssStyle.getComputedStyleObject(node);

    var bl = parseInt(style.borderLeftWidth)    || 0;
    var bt = parseInt(style.borderTopWidth)     || 0;
    var br = parseInt(style.borderRightWidth)   || 0;
    var bb = parseInt(style.borderBottomWidth)  || 0;

    var width = node.offsetWidth - node.clientWidth - bl - br;
    var height = node.offsetHeight - node.clientHeight - bt - bb;

    return new DwtPoint(width, height);
};
}
if (AjxPackage.define("ajax.dwt.core.DwtId")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * @class
 * This class is responsible for providing unique, predictable IDs for HTML elements.
 * That way, code outside the client can locate particular elements.
 * <p>
 * Not every element that has an associated JS object will have a known ID. Those are
 * allocated only for elements it would be useful to locate: major components of the UI,
 * toolbars, buttons, views, menus, some menu items, and some selects.
 * <p>
 * There is a simple naming scheme for the IDs themselves. Each ID starts with a "z" followed
 * by one to a few letters that indicate the type of object (widget) represented by the element.
 * 
 * @author Conrad Damon
 */
 
DwtId = function() {}

// separator for parts used in constructing IDs - need to pick one that
// doesn't show up in any of the parts
DwtId.SEP = "__";

// widget types (used to prefix IDs)
/**
 * Defines the widget "list view".
 */
DwtId.WIDGET_LIST_VIEW		= "zl";			// list view
/**
 * Defines the widget "list view header".
 */
DwtId.WIDGET_HDR			= "zlh";		// list view header
/**
 * Defines the widget "list view header table".
 */
DwtId.WIDGET_HDR_TABLE		= "zlht";		// list view header table
/**
 * Defines the widget "list view header icon image".
 */
DwtId.WIDGET_HDR_ICON		= "zlhi";		// list view header image
/**
 * Defines the widget "list view header text".
 */
DwtId.WIDGET_HDR_LABEL		= "zlhl";		// list view header text
/**
 * Defines the widget "list view header dropdown arrow".
 */
DwtId.WIDGET_HDR_ARROW		= "zlha";		// list view header dropdown arrow
/**
 * Defines the widget "sash between list view headers".
 */
DwtId.WIDGET_HDR_SASH		= "zlhs";		// sash between list view headers
/**
 * Defines the widget "list view item".
 */
DwtId.WIDGET_ITEM			= "zli";		// list view item
/**
 * Defines the widget "list view item row".
 */
DwtId.WIDGET_ITEM_ROW		= "zlir";		// list view item row
/**
 * Defines the widget "list view item cell".
 */
DwtId.WIDGET_ITEM_CELL		= "zlic";		// list view item cell
/**
 * Defines the widget "list view item field".
 */
DwtId.WIDGET_ITEM_FIELD		= "zlif";		// list view item field

// list view modifiers
/**
 * Defines the list view "headers" modifier.
 */
DwtId.LIST_VIEW_HEADERS	= "headers";
/**
 * Defines the list view "rows" modifier.
 */
DwtId.LIST_VIEW_ROWS	= "rows";

DwtId.IFRAME = "iframe";

DwtId.DND_PLUS_ID		= "z__roundPlus";

/**
 * Joins the given arguments into an ID, excluding empty ones.
 * 
 * @private
 */
DwtId.makeId =
function() {
	var list = [];
	for (var i = 0; i < arguments.length; i++) {
		var arg = arguments[i];
		if (arg != null && arg != "") {
			list.push(arg);
		}
	}
	return list.join(DwtId.SEP);
};
DwtId._makeId = DwtId.makeId;	// back-compatibility

/**
 * Gets an ID for a list view.
 * 
 * @param {constant}	context		the owning view identifier
 * @param {DwtId.LIST_VIEW_HEADERS|DwtId.LIST_VIEW_ROWS}	modifier	indicates element within list view (see <code>DwtId.LIST_VIEW*</code> constants)	
 * @return	{string}	the ID
 */
DwtId.getListViewId =
function(context, modifier) {
	return DwtId.makeId(DwtId.WIDGET_LIST_VIEW, context, modifier);
};

/**
 * Gets an ID for an element within a list view header.
 * 
 * @param {constant}	type		the type of hdr element (see <code>DwtId.WIDGET_HDR*</code> constants)
 * @param {constant}	context	the the ID of owning view
 * @param {constant}	hdr		the header ID
 * @return	{string}	the ID
 */
DwtId.getListViewHdrId =
function(type, context, hdr) {
	return DwtId.makeId(type, context, hdr);
};

/**
 * Gets an ID for an element associated with the display of an item in a list view.
 * 
 * @param {constant}	type		the type of item element (see <code>DwtId.WIDGET_ITEM*</code> constants)
 * @param {constant}	context		the ID of owning view
 * @param {string}	itemId	the item ID (typically numeric)
 * @param {constant}	field		the field identifier (for example, "su" for subject)
 * @return	{string}	the ID
 */
DwtId.getListViewItemId =
function(type, context, itemId, field) {
	return DwtId.makeId(type, context, itemId, field);
};

/**
 * Gets an ID for an IFRAME.
 * 
 * @param {constant}	context	the ID of owning {@link DwtIframe}
 * @return	{string}	the ID
 */
DwtId.getIframeId =
function(context) {
	return DwtId.makeId(context, DwtId.IFRAME);
};
}
if (AjxPackage.define("ajax.dwt.core.DwtException")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * Creates an exception.
 * @constructor
 * @class
 * This is the base class for all exceptions in the Ajax toolkit.
 * 
 * @author Ross Dargahi
 * 
 * @param {string} [msg] 		the human readable message
 * @param {string|number} [code]	 any error or fault code
 * @param {string} [method] 	the name of the method throwing the exception
 * @param {string} [detail] 	any additional detail
 * 
 * @extends		AjxException
 */
DwtException = function(msg, code, method, detail) {
	if (arguments.length === 0) {return;}
	AjxException.call(this, msg, code, method, detail);
}

DwtException.prototype = new AjxException();
DwtException.prototype.constructor = DwtException;

DwtException.prototype.toString = 
function() {
	return "DwtException";
};

/**
 * Invalid parent exception code.
 */
DwtException.INVALIDPARENT = -1;

/**
 * Invalid operation exception code.
 */
DwtException.INVALID_OP = -2;

/**
 * Internal error exception code.
 */
DwtException.INTERNAL_ERROR = -3;

/**
 * Invalid parameter exception code.
 */
DwtException.INVALID_PARAM = -4;
}
if (AjxPackage.define("ajax.dwt.core.DwtDraggable")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
* @class
* This static class enables entities (for example, {@link DwtDialog}s) to be dragged around within
* an application window. The code is basically the same as in dom-drag.js from www.youngpup.net
*
* @author Ross Dargahi
* 
* @private
*/
DwtDraggable = function() {
}

DwtDraggable.dragEl = null;

/**
 * Initializes dragging for <code>dragEl</code>
 * 
 * @param {HTMLElement} dragEl 	the element being dragged, can also be a handle e.g. the
 * 		title bar in a dialog
 * @param {HTMLElement} [rootEl]	the actual element that will be moved. This will be a
 * 		parent element of <i>dragEl</i>
 * @param {number} [minX] 	the minimum x coord to which we can drag
 * @param {number} [maxX] 	the maximum x coord to which we can drag
 * @param {number} [minY] 	the minimum y coord to which we can drag
 * @param {number} [maxY] 	the maximum x coord to which we can drag
 * @param {AjxCallback} dragStartCB	the callback that is called when dragging is started
 * @param {AjxCallback}dragCB		the callback that is called when dragging
 * @param {AjxCallback}dragEndCB	the callback that is called when dragging is ended
 * @param {boolean} [swapHorizRef]	if <code>true</code>, then mouse motion to the right will move element left
 * @param {boolean} [swapVertRef]		if <code>true</code>, then mouse motion to the bottom will move element up
 * @param {function} [fXMapper] 		the function that overrides this classes x coordinate transformations
 * @param {function} [fYMapper] 		the function that overrides this classes y coordinate transformations
 *
 */
DwtDraggable.init = 
function(dragEl, rootEl, minX, maxX, minY, maxY, dragStartCB, dragCB, dragEndCB, 
		 swapHorizRef, swapVertRef, fXMapper, fYMapper) {
	dragEl.onmousedown = DwtDraggable.__start;

	dragEl.__hMode = swapHorizRef ? false : true;
	dragEl.__vMode = swapVertRef ? false : true;

	dragEl.__root = (rootEl && rootEl != null) ? rootEl : dragEl ;

	if (dragEl.__hMode && isNaN(parseInt(dragEl.__root.style.left))) 
		dragEl.__root.style.left = "0px";
	if (dragEl.__vMode && isNaN(parseInt(dragEl.__root.style.top))) 
		dragEl.__root.style.top = "0px";
		
	if (!dragEl.__hMode && isNaN(parseInt(dragEl.__root.style.right))) 
		dragEl.__root.style.right = "0px";
	if (!dragEl.__vMode && isNaN(parseInt(dragEl.__root.style.bottom))) 
		dragEl.__root.style.bottom = "0px";

	dragEl.__minX = (typeof minX != 'undefined') ? minX : null;
	dragEl.__minY = (typeof minY != 'undefined') ? minY : null;
	dragEl.__maxX = (typeof maxX != 'undefined') ? maxX : null;
	dragEl.__maxY = (typeof maxY != 'undefined') ? maxY : null;

	dragEl.__xMapper = fXMapper ? fXMapper : null;
	dragEl.__yMapper = fYMapper ? fYMapper : null;

	dragEl.__root.onDragStart = dragStartCB
	dragEl.__root.onDragEnd = dragEndCB
	dragEl.__root.onDrag = dragCB;
};

/**
 * Sets the minimum and maximum drag boundries
 * 
 * @param {HTMLElement} dragEl Element being dragged, can also be a handle e.g. the
 * 		title bar in a dialog
 * @param {number} minX 	the minimum x coordinate
 * @param {number} maxX 	the maximum x coordinate
 * @param {number} minY 	the minimum y coordinate
 * @param {number} maxY 	the maximum y coordinate
 */
DwtDraggable.setDragBoundaries =
function (dragEl ,minX, maxX, minY, maxY) {
	if (dragEl != null) {
		if (minX != null) dragEl.__minX = minX;
		if (maxX != null) dragEl.__maxX = maxX;
		if (minY != null) dragEl.__minY = minY;
		if (maxY != null) dragEl.__maxY = maxY;
	}
};

/** @private */
DwtDraggable.__start =
function(e)	{
	var dragEl = DwtDraggable.dragEl = this;
	e = DwtDraggable.__fixE(e);
	var x = parseInt(dragEl.__hMode ? dragEl.__root.style.left : dragEl.__root.style.right );
	var y = parseInt(dragEl.__vMode ? dragEl.__root.style.top  : dragEl.__root.style.bottom);
	if (dragEl.__root.onDragStart)
		dragEl.__root.onDragStart.run([x, y]);

	dragEl.__lastMouseX = e.clientX;
	dragEl.__lastMouseY = e.clientY;

	if (dragEl.__hMode) {
		if (dragEl.__minX != null)	
			dragEl.__minMouseX = e.clientX - x + dragEl.__minX;
		if (dragEl.__maxX != null)
			dragEl.__maxMouseX = dragEl.__minMouseX + dragEl.__maxX - dragEl.__minX;
	} else {
		if (dragEl.__minX != null)
			dragEl.__maxMouseX = -dragEl.__minX + e.clientX + x;
		if (dragEl.__maxX != null)
			dragEl.__minMouseX = -dragEl.__maxX + e.clientX + x;
	}

	if (dragEl.__vMode) {
		if (dragEl.__minY != null)
			dragEl.__minMouseY = e.clientY - y + dragEl.__minY;
		if (dragEl.__maxY != null)
			dragEl.__maxMouseY = dragEl.__minMouseY + dragEl.__maxY - dragEl.__minY;
	} else {
		if (dragEl.__minY != null)
			dragEl.__maxMouseY = -dragEl.__minY + e.clientY + y;
		if (dragEl.__maxY != null)
			dragEl.__minMouseY = -dragEl.__maxY + e.clientY + y;
	}

	document.onmousemove = DwtDraggable.__drag;
	document.onmouseup = DwtDraggable.__end;

	return false;
};

/** @private */
DwtDraggable.__drag =
function(e)	{
	e = DwtDraggable.__fixE(e);
	var dragEl = DwtDraggable.dragEl;

	var ey	= e.clientY;
	var ex	= e.clientX;
	var x = parseInt(dragEl.__hMode ? dragEl.__root.style.left : dragEl.__root.style.right );
	var y = parseInt(dragEl.__vMode ? dragEl.__root.style.top  : dragEl.__root.style.bottom);
	var nx, ny;

	if (!dragEl.__xMapper) {
		if (dragEl.__minX != null)
			ex = dragEl.__hMode ? Math.max(ex, dragEl.__minMouseX) : Math.min(ex, dragEl.__maxMouseX);
		if (dragEl.__maxX != null)
			ex = dragEl.__hMode ? Math.min(ex, dragEl.__maxMouseX) : Math.max(ex, dragEl.__minMouseX);
		nx = x + ((ex - dragEl.__lastMouseX) * (dragEl.__hMode ? 1 : -1));
	} else {
		nx = dragEl.__xMapper(x, ex);
	}

	if (!dragEl.__yMapper) {
		if (dragEl.__minY != null)
			ey = dragEl.__vMode ? Math.max(ey, dragEl.__minMouseY) : Math.min(ey, dragEl.__maxMouseY);
		if (dragEl.__maxY != null)
			ey = dragEl.__vMode ? Math.min(ey, dragEl.__maxMouseY) : Math.max(ey, dragEl.__minMouseY);
		ny = y + ((ey - dragEl.__lastMouseY) * (dragEl.__vMode ? 1 : -1));
	} else {
		ny = dragEl.__yMapper(y, ey);
	}

	DwtDraggable.dragEl.__root.style[dragEl.__hMode ? "left" : "right"] = nx + "px";
	DwtDraggable.dragEl.__root.style[dragEl.__vMode ? "top" : "bottom"] = ny + "px";
	DwtDraggable.dragEl.__lastMouseX = ex;
	DwtDraggable.dragEl.__lastMouseY = ey;

	if (DwtDraggable.dragEl.__root.onDrag)
		DwtDraggable.dragEl.__root.onDrag.run([nx, ny]);
		
	return false;
};

/** @private */
DwtDraggable.__end =
function() {
	document.onmousemove = null;
	document.onmouseup   = null;
	if (DwtDraggable.dragEl.__root.onDragEnd)
		DwtDraggable.dragEl.__root.onDragEnd.run([parseInt(DwtDraggable.dragEl.__root.style[DwtDraggable.dragEl.__hMode ? "left" : "right"]), 
											 	  parseInt(DwtDraggable.dragEl.__root.style[DwtDraggable.dragEl.__vMode ? "top" : "bottom"])]);
	DwtDraggable.dragEl = null;
};

/** @private */
DwtDraggable.__fixE =
function(e) {
	if (typeof e == 'undefined')
		e = window.event;
	if (!AjxEnv.isWebKitBased) {
		if (typeof e.layerX == 'undefined')
			e.layerX = e.offsetX;
		if (typeof e.layerY == 'undefined')
			e.layerY = e.offsetY;
	}
	return e;
};
}
if (AjxPackage.define("ajax.dwt.core.DwtDragTracker")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * 
 * @private
 */
DwtDragTracker = function() {}

/**
 * Initializes the tracker.
 * 
 * @param {DwtControl}	control        the control that can be moved/dragged
 * @param {number}	[threshX=1]        the minimum number of X pixels before we move
 * @param {number}	[threshY=1]        the minimum number of Y pixels before we move
 * @param {function}	callbackFunc   callback function
 * @param callbackObj    object for callback
 * @param	userData		the user data
 * 
 */
DwtDragTracker.init = 
function(control, style, threshX, threshY, callbackFunc, callbackObj, userData) {

    var ctxt = control._dragTrackerContext = {};
    var htmlElement = control.getHtmlElement();
    
    if (style) htmlElement.style.cursor = style;
    
   	ctxt.style = style;
	ctxt.threshX = (threshX > 0) ? threshX : 1;
	ctxt.threshY = (threshY > 0) ? threshY : 1;
	ctxt.data = { delta: {}, userData: userData};

	ctxt.captureObj = new DwtMouseEventCapture({
		targetObj:control,
		mouseOverHdlr:DwtDragTracker._mouseOverHdlr,
		mouseDownHdlr:DwtDragTracker._mouseDownHdlr,
		mouseMoveHdlr:DwtDragTracker._mouseMoveHdlr,
		mouseUpHdlr:DwtDragTracker._mouseUpHdlr,
		mouseOutHdlr:DwtDragTracker._mouseOutHdlr
	});

	control.setHandler(DwtEvent.ONMOUSEDOWN, DwtDragTracker._mouseDownHdlr);
	control.setHandler(DwtEvent.ONMOUSEOVER, DwtDragTracker._mouseOverHdlr);
	control.setHandler(DwtEvent.ONMOUSEOUT, DwtDragTracker._mouseOutHdlr);
	ctxt.callbackFunc = callbackFunc;
	ctxt.callbackObj = callbackObj;	
}

DwtDragTracker.STYLE_NONE = "auto";
DwtDragTracker.STYLE_MOVE = "move";
DwtDragTracker.STYLE_RESIZE_NORTHWEST = "nw-resize";
DwtDragTracker.STYLE_RESIZE_NORTH = "n-resize";
DwtDragTracker.STYLE_RESIZE_NORTHEAST = "ne-resize";
DwtDragTracker.STYLE_RESIZE_WEST = "w-resize";
DwtDragTracker.STYLE_RESIZE_EAST = "e-resize";
DwtDragTracker.STYLE_RESIZE_SOUTHWEST = "sw-resize";
DwtDragTracker.STYLE_RESIZE_SOUTH = "s-resize";
DwtDragTracker.STYLE_RESIZE_SOUTHEAST = "se-resize";

DwtDragTracker.STATE_START = 1;
DwtDragTracker.STATE_DRAGGING = 2;
DwtDragTracker.STATE_END = 3;

DwtDragTracker._mouseOverHdlr =
function(ev) {
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev);
	mouseEv._stopPropagation = true;
	mouseEv._returnValue = false;
	mouseEv.setToDhtmlEvent(ev);
	return false;	
}

DwtDragTracker._mouseDownHdlr =
function(ev) {
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev, true);	
	if (mouseEv.button != DwtMouseEvent.LEFT) {
		DwtUiEvent.setBehaviour(ev, true, false);
		return false;
	}
	var control = mouseEv.dwtObj;
	if (control && control._dragTrackerContext) {
        var ctxt = control._dragTrackerContext;
        	if (ctxt.callbackFunc != null) {
				ctxt.oldCapture = DwtMouseEventCapture.getCaptureObj();
				if (ctxt.oldCapture) {
					ctxt.oldCapture.release();
				}
        		ctxt.captureObj.capture();
        		ctxt.data.startDoc = {x: mouseEv.docX, y: mouseEv.docY};
        		ctxt.data.state = DwtDragTracker.STATE_START;
             DwtDragTracker._doCallback(ctxt, mouseEv);
        	}
   	}
	mouseEv._stopPropagation = true;
	mouseEv._returnValue = false;
	mouseEv.setToDhtmlEvent(ev);
	return false;	
}

DwtDragTracker._doCallback =
function(ctxt, mouseEv) {
	ctxt.data.mouseEv = mouseEv;
	if (ctxt.callbackObj != null)
		ctxt.callbackFunc.call(ctxt.callbackObj, ctxt.data);
	else 
		ctxt.callbackFunc(ctxt.data);
	ctxt.data.mouseEv = null;
}

DwtDragTracker._mouseMoveHdlr =
function(ev) {
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev);	
	
	var control = DwtMouseEventCapture.getTargetObj();
    var ctxt = control._dragTrackerContext;
    var data = ctxt.data;
	    
	data.delta.x = mouseEv.docX - data.startDoc.x;
	data.delta.y = mouseEv.docY - data.startDoc.y;
	
	if (Math.abs(data.delta.x) >= ctxt.threshX || Math.abs(data.delta.y) >= ctxt.threshY) {
        data.prevState = data.state;
        data.state = DwtDragTracker.STATE_DRAGGING;
	    DwtDragTracker._doCallback(ctxt, mouseEv);
	}
	mouseEv._stopPropagation = true;
	mouseEv._returnValue = false;
	mouseEv.setToDhtmlEvent(ev);
	return false;	
}

DwtDragTracker._mouseUpHdlr =
function(ev) {
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev);	
	if (mouseEv.button != DwtMouseEvent.LEFT) {
		DwtUiEvent.setBehaviour(ev, true, false);
		return false;
	}
	
	var ctxt = DwtMouseEventCapture.getTargetObj()._dragTrackerContext;
	if (ctxt) {
        	if (ctxt.callbackFunc != null)
        		DwtMouseEventCapture.getCaptureObj().release();
			if (ctxt.oldCapture) {
				ctxt.oldCapture.capture();
				ctxt.oldCapture = null;
			}
        	ctxt.data.state = DwtDragTracker.STATE_END;
        DwtDragTracker._doCallback(ctxt, mouseEv);
	}
	mouseEv._stopPropagation = true;
	mouseEv._returnValue = false;
	mouseEv.setToDhtmlEvent(ev);
	return false;	
}

DwtDragTracker._mouseOutHdlr =
function(ev) {
	var mouseEv = DwtShell.mouseEvent;
	
	mouseEv.setFromDhtmlEvent(ev);
	mouseEv._stopPropagation = true;
	mouseEv._returnValue = false;
	mouseEv.setToDhtmlEvent(ev);
	return false;	
}
}

if (AjxPackage.define("ajax.dwt.graphics.DwtCssStyle")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * Default constructor.
 * @constructor
 * @class
 * This is a static class that defines a number of constants and helper methods that
 * support the working with CSS.
 * 
 * @author Ross Dargahi
 * 
 * @private
 */
DwtCssStyle = function() {
}

// Common class name constants used in Dwt

/**
 * "mouseOver": transitory state while mouse is over the item.
 */
DwtCssStyle.HOVER = "hover";

/**
 * "mouseDown": transitory state while left mouse button is being pressed on the item.
 */
DwtCssStyle.ACTIVE = "active";

/**
 * item is "on", (for example: selected tab, select item(s) in list, or button that stays depressed).
 */
DwtCssStyle.SELECTED = "selected";

/**
 * Currently used for item that is currently viewed, but not selected (other checkboxes are checked, or a right click action is on a different item).
 */
DwtCssStyle.ALT_SELECTED = "altSelected";

/**
 * "disabled": item is not actionable (for example: because not appropriate or some other condition needs to be true).
 */
DwtCssStyle.DISABLED = "disabled";

/**
 * "focused": item has keyboard focus.
 */
DwtCssStyle.FOCUSED = "focused";

/**
 * UI component is target of some external action, for example:
 * <ul>
 * <li>item is the target of right-click (for example: show menu)</li>
 * <li>item is the thing being dragged</li>
 * </ul>
 */
DwtCssStyle.ACTIONED = "actioned";

/**
 * Matched item in a list (for example: in conv list view, items that match the search. NOT used if *all* items match the search).
 */
DwtCssStyle.MATCHED	 = "matched";

/**
 * UI component is the current, valid drop target.
 */
DwtCssStyle.DRAG_OVER = "dragOver";

/**
 * Item being dragged is over a valid drop target.
 */
DwtCssStyle.DROPPABLE = "droppable";

/**
 * Item being dragged is NOT over a valid drop target.
 */
DwtCssStyle.NOT_DROPPABLE = "notDroppable";

/**
 * Represents of an item *as it is being dragged* (for example: thing moving around the screen).
 */
DwtCssStyle.DRAG_PROXY = "dragProxy";

/**
 * Class applies only to linux browsers.
 */
DwtCssStyle.LINUX = "linux";


DwtCssStyle.getProperty = 
function(htmlElement, cssPropName) {
	var doc = htmlElement.ownerDocument;

	if (window.getComputedStyle) {
		var cssDecl = window.getComputedStyle(htmlElement, null);
		if (cssDecl && cssDecl.length > 0) { //on Chrome/Safari it returns cssDecl with length 0 for some elements for some reason. (a wild guess could be invisible items, as it happens with invite toolbar when it's invisible) So in that case fall back on the other ways.
			return cssDecl.getPropertyValue(cssPropName);
		}
	}
	
	// Convert CSS -> DOM name for IE etc
	var tokens = cssPropName.split("-");
	// Shift one word off the array and capitalize the rest
	var propName = tokens.shift() + AjxUtil.map(tokens, AjxStringUtil.capitalize).join("");

	if (htmlElement.currentStyle) {
		return htmlElement.currentStyle[propName];
	} else if (htmlElement.style) {
		return htmlElement.style[propName];
	}
};

DwtCssStyle.getComputedStyleObject = 
function(htmlElement) {
	var doc = htmlElement.ownerDocument;
	
	if (window.getComputedStyle) {
		var style = window.getComputedStyle(htmlElement, null);
		if (!style && htmlElement.style) {
// TODO: destructive ?
			htmlElement.style.display = "";
			style = window.getComputedStyle(htmlElement, null);
		}
		return style || {};
	} else if (htmlElement.currentStyle)
		return htmlElement.currentStyle;
	else if (htmlElement.style)
		return htmlElement.style;
};

DwtCssStyle.removeProperty = function(el, prop) {
	if (prop instanceof Array) {
		for (var i = prop.length; --i >= 0;)
			DwtCssStyle.removeProperty(el, prop[i]);
	} else {
		if (AjxEnv.isIE) {
			el.style.removeAttribute(prop, true);
		} else {
			prop = prop.replace(/([A-Z])/g, "-$1");
			el.style.removeProperty(prop);
		}
	}
};

/**
 * Adds a rule to a stylesheet.
 * 
 * @param {StyleSheet}	stylesheet		a CSS stylesheet
 * @param {string}		selector		rule selector
 * @param {string}		declaration		styles
 * @param {string}		index			insertion index (optional)
 * 
 * @return	index at which rule was inserted (for later removal)
 */
DwtCssStyle.addRule =
function(stylesheet, selector, declaration, index) {
	if (stylesheet.addRule) {	// IE
		//if index is not specified insert at the end so that new rule takes precedence
		index = index || (stylesheet.rules.length);
		stylesheet.addRule(selector, declaration, index);
	}
	else {
		//if index is not specified insert at the end so that new rule takes precedence
		index = index || (stylesheet.cssRules.length);
		stylesheet.insertRule(selector + "{" + declaration + "}", index);
	}
	return index;
};

/**
 * Removes the rule at the given index.
 * 
 * @param {StyleSheet}	stylesheet		a CSS stylesheet
 * @param {string}		index			insertion index (optional)
 */
DwtCssStyle.removeRule =
function(stylesheet, index) {
	if (stylesheet.removeRule) {	// IE
		stylesheet.removeRule(index);
	}
	else {
		stylesheet.deleteRule(index);
	}
};

DwtCssStyle.__PIXEL_RE = /^(-?[0-9]+(?:\.[0-9]*)?)px$/;
DwtCssStyle.__DIMENSION_RE = /^(-?[0-9]+(?:\.[0-9]*)?)([a-z]*|%)$/;
DwtCssStyle.__NUMBER_RE = /^(-?[0-9]+(?:\.[0-9]*)?)+$/

/**
 * Obtain the font size of the root element in pixels.
 */
DwtCssStyle.__getRootFontSize = function() {

	var fontsize = DwtCssStyle.getProperty(document.documentElement, 'font-size');

	if (!DwtCssStyle.__PIXEL_RE.test(fontsize)) {
		DBG.println(AjxDebug.DBG1, 'font size of root element is not in pixels!');
		return -1;
	}

	return parseInt(fontsize);
};

/**
 * Convert a CSS value to a pixel count; unhandled units raise an error.
 *
 * @param   {String}    val     a font size value in some form
 *
 * @return  {Number}    the size in pixels, or -1 if there is an error
 */
DwtCssStyle.asPixelCount = function(val) {

	if (!val) {
		DBG.println(AjxDebug.DBG1, 'DwtCssStyle.asPixelCount: missing argument');
		return -1;
	}

	var dimension, unit, match;

	// assume pixels if no unit is specified
	if (typeof val === 'number' || DwtCssStyle.__NUMBER_RE.test(val)) {
		dimension = Number(val);
		unit = 'px';
	} else if ((match = DwtCssStyle.__DIMENSION_RE.exec(val))) {
		dimension = Number(match[1]);
		unit = match[2];
	} else {
		DBG.println(AjxDebug.DBG1, 'DwtCssStyle.asPixelCount: unsupported argument: ' + val);
		return -1;
	}

	switch (unit) {
		case 'rem': {
			var rootFontSize = DwtCssStyle.__getRootFontSize();
			return rootFontSize !== -1 ? dimension * rootFontSize : -1;
		}

		// see http://www.w3.org/TR/css3-values/#absolute-lengths
		case 'mm': {
			dimension /= 10;
		}

		case 'cm': {
			dimension /= 2.54;
		}

		case 'in': {
			dimension *= 6;
		}

		case 'pc': {
			dimension *= 12;
		}

		case 'pt': {
			dimension /= 0.75;
		}

		case 'px': {
			return dimension;
		}

		case 'ch':
		case 'em':
		case 'ex': {
			DBG.println(AjxDebug.DBG1, 'DwtCssStyle.asPixelCount: cannot convert context-dependent CSS unit ' + unit);
			return -1;
		}

		default: {
			DBG.println(AjxDebug.DBG1, 'DwtCssStyle.asPixelCount: unrecognized CSS unit ' + unit);
			return -1;
		}
	}
};
}
if (AjxPackage.define("ajax.dwt.graphics.DwtPoint")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * Creates a point.
 * @constructor
 * @class
 * This class represents a point. A point has an x-coordinate and y-coordinate.
 * 
 * @author Ross Dargahi
 * 
 * @param {number} x 	the x coordinate
 * @param {number} y 	the y coordinate
 * 
 */
DwtPoint = function(x, y) {
	/**
	 * The x-coordinate.
	 * @type	number
	 */
	this.x = x || 0;
	/**
	 * The y-coordinate.
	 * @type	number
	 */
	this.y = y || 0;
}

DwtPoint.tmp = new DwtPoint(0, 0);

/**
 * Returns a string representation of the object.
 * 
 * @return		{string}		a string representation of the object
 */
DwtPoint.prototype.toString = 
function() {
	return "DwtPoint";
}

/**
 * Sets the values of a point
 * 
 * @param {number} x 	the x coordinate
 * @param {number} y 	the y coordinate
 */
 DwtPoint.prototype.set =
 function(x, y) {
 	this.x = x;
 	this.y = y;
 }
 
}
if (AjxPackage.define("ajax.dwt.graphics.DwtRectangle")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * Creates a rectangle.
 * @constructor
 * @class
 * This class represents a rectangle. A point has an x-coordinate, y-coordinate, height and width.
 * 
 * @author Ross Dargahi
 * 
 * @param {number} x 	the x coordinate
 * @param {number} y 	the y coordinate
 * @param {number} width 	the width
 * @param {number} height 	the height
 */
DwtRectangle = function(x, y, width, height) {

	/**
	 * The x-coordinate.
	 * @type	number
	 */
	this.x = x;
	/**
	 * The y-coordinate.
	 * @type	number
	 */
	this.y = y;
	/**
	 * The width.
	 * @type	number
	 */
	this.width = width;
	/**
	 * The height.
	 * @type	number
	 */
	this.height = height;
}

/**
 * Returns a string representation of the object.
 * 
 * @return		{string}		a string representation of the object
 */
DwtRectangle.prototype.toString = 
function() {
	return "DwtRectangle";
}

/**
 * Sets the values of the rectangle.
 * 
 * @param {number} x 	the x coordinate
 * @param {number} y 	the y coordinate
 * @param {number} width 	the width
 * @param {number} height 	the height
 */
 DwtRectangle.prototype.set =
 function(x, y, width, height) {
 	this.x = x;
 	this.y = y;
 }
}

if (AjxPackage.define("ajax.dwt.events.DwtEvent")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * @class
 * This class is the base class of all DWT events.
 * 
 * @param {boolean} 	__init 	a dummy parameter used for class initialization
 * 
 * @author Ross Dargahi
 * @author Conrad Damon
 * 
 */
DwtEvent = function(__init) {
	if (arguments.length == 0) return;
	/**
	 * The Dwt object that generated the event
	 * @type DwtControl
	 */
	this.dwtObj = null;
}

/**
 * Returns a string representation of the object.
 * 
 * @return		{string}		a string representation of the object
 */
DwtEvent.prototype.toString = 
function() {
	return "DwtEvent";
}

// native browser events - value is the associated DOM property
/**
 * Browser "onchange" event.
 */
DwtEvent.ONCHANGE = "onchange";

/**
 * Browser "onclick" event.
 */
DwtEvent.ONCLICK = "onclick";

/**
 * Browser "oncontextmenu" event.
 */
DwtEvent.ONCONTEXTMENU = "oncontextmenu";

/**
 * Browser double-click event "ondblclick" event.
 */
DwtEvent.ONDBLCLICK = "ondblclick";

/**
 * Browser "onfocus" event.
 */
DwtEvent.ONFOCUS = "onfocus";

/**
 * Browser "onblur" event.
 */
DwtEvent.ONBLUR = "onblur";

/**
 * Browser "onkeydown" event.
 */
DwtEvent.ONKEYDOWN = "onkeydown";

/**
 * Browser "onkeypress" event.
 */
DwtEvent.ONKEYPRESS = "onkeypress";

/**
 * Browser "onkeyup" event.
 */
DwtEvent.ONKEYUP = "onkeyup";

/**
 * Browser "onmousedown" event.
 */
DwtEvent.ONMOUSEDOWN = "onmousedown";

/**
 * Browser "onmouseenter" event (IE Only) - reported only for the element.
 */
DwtEvent.ONMOUSEENTER = "onmouseenter";

/**
 * Browser "onmouseleave" event (IE Only) - reported only for the element.
 */
DwtEvent.ONMOUSELEAVE = "onmouseleave";

/**
 * Browser "onmousemove" event.
 */
DwtEvent.ONMOUSEMOVE = "onmousemove";

/**
 * Browser "onmouseout" event - reported for element and children.
 */
DwtEvent.ONMOUSEOUT = "onmouseout";

/**
 * Browser "onmouseover" event - reported for element and children.
 */
DwtEvent.ONMOUSEOVER = "onmouseover";

/**
 * Browser "onmouseup" event
 */
DwtEvent.ONMOUSEUP = "onmouseup";

/**
 * Browser "onmousewheel" event.
 */
DwtEvent.ONMOUSEWHEEL = "onmousewheel";

/**
 * Browser "onselectstart" event.
 */
DwtEvent.ONSELECTSTART = "onselectstart";

/**
 * Browser "onscroll" event.
 */
DwtEvent.ONSCROLL = "onscroll";

/**
 * Browser "onpaste" event.
 */
DwtEvent.ONPASTE = "onpaste";

/**
 * Browser "oncut" event.
 */
DwtEvent.ONCUT = "oncut";

/**
 * Browser "oninput" event is fired synchronously when the value of an <input> or <textarea> element is changed.
 */
DwtEvent.ONINPUT = "oninput";

// semantic events

/**
 * Action event. An example is right-clicking on a list item or tree item
 * generally brings up a context menu.
 */
DwtEvent.ACTION	= "ACTION";

/**
 * Control event. Control events are fired by resizing or repositioning {@link DwtControl}s.
 */
DwtEvent.CONTROL = "CONTROL";		// resize

/**
 * Date Range events are fired by the {@link DwtCalendar} widget. This event is
 * fired when the date range of the calendar widget changes.
 */
DwtEvent.DATE_RANGE	= "DATE_RANGE";

/**
 * The dispose event is fired when the {@link DwtControl#dispose} method of a control is called.
 */
DwtEvent.DISPOSE = "DISPOSE";

/**
 * The enter event is fired when the enter key is pressed.
 * @private
 */
DwtEvent.ENTER = "ENTER";			// enter/return key

/**
 * This event is fired when the mouse hovers over a control for a certain period of time.
 */
DwtEvent.HOVEROVER = "HOVEROVER";

/**
 * This event is fired when the mouse stops hovering over a control.
 */
DwtEvent.HOVEROUT = "HOVEROUT";

/**
 * The popdown event is fired when a item (such as a {@link DwtMenu}) is popped down.
 */
DwtEvent.POPDOWN = "POPDOWN";

/**
 * The popup event is fired when a item (such as a {@link DwtMenu}) is popped up.
 */
DwtEvent.POPUP = "POPUP";

/**
 * The selection event is fired when controls are selected. This generally means
 * that there has been a "left mouse button click" in the control (for example: a button, or
 * list item, or tree node).
 */
DwtEvent.SELECTION = "SELECTION";		// left-click

/**
 * A tree event is fired when a {@link DwtTree} node is expanded or collapsed.
 */
DwtEvent.TREE = "TREE";

/**
 * State change events are fired when some intrinsic state of a widget changes. For
 * example it may be that an item was added to a {@link DwtListView}
 */
DwtEvent.STATE_CHANGE	= "STATE_CHANGE";

/**
 * The tab event is fired when the tab key is pressed.
 * @private
 */
DwtEvent.TAB = "TAB";

// XForms
DwtEvent.XFORMS_READY				= "xforms-ready";
DwtEvent.XFORMS_DISPLAY_UPDATED		= "xforms-display-updated";
DwtEvent.XFORMS_VALUE_CHANGED		= "xforms-value-changed";
DwtEvent.XFORMS_FORM_DIRTY_CHANGE	= "xforms-form-dirty-change";
DwtEvent.XFORMS_CHOICES_CHANGED		= "xforms-choices-changed";
DwtEvent.XFORMS_VALUE_ERROR			= "xforms-value-error";
DwtEvent.XFORMS_INSTANCE_CHANGED 	= "xforms-instance-cahnged"; //fires when a new instance is applied to the form

// Convenience lists
/**
 * An array of key event types.
 */
DwtEvent.KEY_EVENTS = [DwtEvent.ONKEYDOWN, DwtEvent.ONKEYPRESS, DwtEvent.ONKEYUP];

/**
 * An array of mouse event types.
 */
DwtEvent.MOUSE_EVENTS = [
	DwtEvent.ONCONTEXTMENU, DwtEvent.ONCLICK, DwtEvent.ONDBLCLICK,
	DwtEvent.ONMOUSEDOWN, DwtEvent.ONMOUSEMOVE, DwtEvent.ONMOUSEUP,
	DwtEvent.ONSELECTSTART, DwtEvent.ONMOUSEOVER, DwtEvent.ONMOUSEOUT
];
}
if (AjxPackage.define("ajax.dwt.events.DwtEventManager")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * static class that wraps around AjxEventManager
 * 
 * @private
 */
DwtEventManager = function() {
};

DwtEventManager._instance = new AjxEventMgr();

DwtEventManager._domEventToDwtMap = {
	'ondblclick': DwtEvent.ONDBLCLICK,
	'onmousedown': DwtEvent.ONMOUSEDOWN ,
	'onmouseup': DwtEvent.ONMOUSEUP,
	'onmousemove': DwtEvent.ONMOUSEMOVE,
	'onmouseout': DwtEvent.ONMOUSEOUT,
	'onmouseover': DwtEvent.ONMOUSEOVER,
	'onselectstart': DwtEvent.ONSELECTSTART,
	'onchange': DwtEvent.ONCHANGE
};

DwtEventManager.addListener = 
function(eventType, listener) {
	DwtEventManager._instance.addListener(eventType, listener);
};

DwtEventManager.notifyListeners = 
function(eventType, event) {
	DwtEventManager._instance.notifyListeners(eventType, event);
};

DwtEventManager.removeListener = 
function(eventType, listener) {
	DwtEventManager._instance.removeListener(eventType, listener);
};
}
if (AjxPackage.define("ajax.dwt.events.DwtDateRangeEvent")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * 
 * @private
 */
DwtDateRangeEvent = function(init) {
	if (arguments.length == 0) return;
	DwtEvent.call(this, true);
	this.reset();
}

DwtDateRangeEvent.prototype = new DwtEvent;
DwtDateRangeEvent.prototype.constructor = DwtDateRangeEvent;

DwtDateRangeEvent.prototype.toString = 
function() {
	return "DwtDateRangeEvent";
}

DwtDateRangeEvent.prototype.reset =
function() {
	this.start = null;
	this.end = null;
}
}
if (AjxPackage.define("ajax.dwt.events.DwtDisposeEvent")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * 
 * @private
 */
DwtDisposeEvent = function(init) {
	if (arguments.length == 0) return;
	DwtEvent.call(this, true);
}

DwtDisposeEvent.prototype = new DwtEvent;
DwtDisposeEvent.prototype.constructor = DwtDisposeEvent;

DwtDisposeEvent.prototype.toString = 
function() {
	return "DwtDisposeEvent";
}
}
if (AjxPackage.define("ajax.dwt.events.DwtUiEvent")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * 
 * 
 * @private
 */
DwtUiEvent = function(init) {
	if (arguments.length == 0) return;
	DwtEvent.call(this, true);
	this.reset();
}

DwtUiEvent.prototype = new DwtEvent;
DwtUiEvent.prototype.constructor = DwtUiEvent;

DwtUiEvent.prototype.isDwtUiEvent = true;
DwtUiEvent.prototype.toString = function() { return "DwtUiEvent"; }

DwtUiEvent.prototype.reset =
function() {
	this.dwtObj = null
	this.altKey = false;
	this.ctrlKey = false;
	this.metaKey = false;
	this.shiftKey = false;
	this.target = null;
	this.type = null;
	this.docX = -1;
	this.docY = -1;
	this.elementX = -1;
	this.elementY = -1;
	this.ersatz = false; // True means this event was manufactured
	this._stopPropagation = false;
	this._returnValue = true;
	this._dontCallPreventDefault = false; // True means to allow the the (unusual) situation in Firefox where we
	                                      // want the event handler to return false without calling preventDefault().
}

/**
 * Pass caller's "this" as 'target' if using IE and the ev may have come from another window. The target
 * will be used to get to the window that generated the event, so the event can be found.
 */
DwtUiEvent.getEvent =
function(ev, target) {
	ev = ev || window.event;
	if (ev) { return ev; }

	// get event from iframe in IE; see http://www.outofhanwell.com/blog/index.php?cat=25
	if (target) {
		DBG.println(AjxDebug.DBG3, "getEvent: Checking other window for event");
		var pw = (target.ownerDocument || target.document || target).parentWindow;
		return pw ? pw.event : null;
	}
}

/**
 * Returns the target element of the event.
 * 
 * @param ev				[Event]		DHTML event
 * @param useRelatedTarget	[boolean]*	if true, return element that was related to this event;
 * 										for a MOUSEOVER or MOUSEOUT event, that's the element
 * 										moved from/to.
 */
DwtUiEvent.getTarget =
function(ev, useRelatedTarget)  {
	ev = DwtUiEvent.getEvent(ev);
	if (!ev) { return null; }
	if (!useRelatedTarget) {
		if (ev.target) {
			// if text node (like on Safari) return parent
			return (ev.target.nodeType == 3) ? ev.target.parentNode : ev.target;
		} else if (ev.srcElement) {		// IE
			return ev.srcElement;
		}
	} else {
		if (ev.relatedTarget) {
			return ev.relatedTarget;
		} else if (ev.toElement) {		// IE
			return ev.toElement;
		} else if (ev.fromElement) {	// IE
			return ev.fromElement;
		}
	}
	return null;
}

/**
 * Returns the first element with a value for the given property, working its way up the element chain.
 *
 * @param ev				[Event]		DHTML event
 * @param prop				[string]	the name of a property
 * @param useRelatedTarget	[boolean]*	if true, return element that was related to this event;
 * @param value				[string]*	expected value of given property
 */
DwtUiEvent.getTargetWithProp =
function(ev, prop, useRelatedTarget, value)  {
	var htmlEl = DwtUiEvent.getTarget(ev, useRelatedTarget);
	while (htmlEl) {
		var elValue = Dwt.getAttr(htmlEl, prop);
		if (elValue != null && elValue !== "" && (!value || (elValue == value))) {
			return htmlEl;
		}
		htmlEl = htmlEl.parentNode;
	}
	return null;
}

/**
 * Returns the first element with the given class name, working its way up the element chain.
 *
 * @param ev				[Event]		DHTML event
 * @param className			[string]	the requested class name
 * @param useRelatedTarget	[boolean]*	if true, return element that was related to this event;
 */
DwtUiEvent.getTargetWithClass =
function(ev, className, useRelatedTarget)  {
	var htmlEl = DwtUiEvent.getTarget(ev, useRelatedTarget);
	while (htmlEl && htmlEl.nodeType === 1) {
		if (Dwt.hasClass(htmlEl, className)) {
			return htmlEl;
		}
		htmlEl = htmlEl.parentNode;
	}
	return null;
}

/**
 * Returns the first element with values for all of the given properties, working its way up the element chain.
 *
 * @param ev				[Event]		DHTML event
 * @param props				[array]		a list of property names (strings)
 */
DwtUiEvent.getTargetWithProps =
function(ev, props)  {
	var htmlEl = DwtUiEvent.getTarget(ev);
	while (htmlEl) {
		var okay = true;
		for (var i in props) {
			var val = Dwt.getAttr(htmlEl, props[i]);
			if (val == null || val === "") {
				htmlEl = htmlEl.parentNode;
				okay = false;
				break;
			}
		}
		if (okay)
			return htmlEl;
	}
	return null;
}

DwtUiEvent.copy = 
function(dest, src) {
	dest.altKey = src.altKey;
	dest.ctrlKey = src.ctrlKey;
	dest.metaKey = src.metaKey;
	dest.shiftKey = src.shiftKey;
	dest.target = src.target;
	dest.type = src.type;
	dest.dwtObj = src.dwtObj;
	dest.docX = src.docX;
	dest.docY = src.docY;
	dest.elementX = src.elementX;
	dest.elementY = src.elementY;
	dest.ersatz = src.ersatz;
	dest._stopPropagation = src._stopPropagation;
	dest._returnValue = src._returnValue;
}

/**
 * Copies properties from the native DHTML event to this DWT event object. The target
 * control can be optionally fetched by providing true as the second argument.
 * 
 * @param ev	[Event]				DHTML event
 * @param obj	[DwtControl|true]	if true, the target object will be fetched; otherwise
 * 									used to set target object if present
 */
DwtUiEvent.prototype.setFromDhtmlEvent =
function(ev, obj) {
	ev = DwtUiEvent.getEvent(ev);
	if (!ev) { return; }
	this.altKey = ev.altKey;
	this.ctrlKey = ev.ctrlKey;
	this.metaKey = ev.metaKey;
	this.shiftKey = ev.shiftKey;
	this.type = ev.type;
	this.target = DwtUiEvent.getTarget(ev);
	this.dwtObj = (obj === true) ? DwtControl.getTargetControl(ev) : obj;

	// Compute document coordinates
	if (ev.pageX != null) {
		this.docX = ev.pageX;
		this.docY = ev.pageY;
	} else if (ev.clientX != null) {
		this.docX = ev.clientX + document.body.scrollLeft - document.body.clientLeft;
		this.docY = ev.clientY + document.body.scrollTop - document.body.clientTop;
		if (document.body.parentElement) {
				var bodParent = document.body.parentElement;
				this.docX += bodParent.scrollLeft - bodParent.clientLeft;
				this.docY += bodParent.scrollTop - bodParent.clientTop;
		}
	}
	// Compute Element coordinates
	if (ev.offsetX != null) {
		this.elementX = ev.offsetX;
		this.elementY = ev.offsetY;
	} else if (!AjxEnv.isWebKitBased && ev.layerX != null) {
		this.elementX = ev.layerX;
		this.elementY = ev.layerY;
	} else { // fail hard for others
		this.elementX = Dwt.DEFAULT;
		this.elementY = Dwt.DEFAULT;
	}
	
	this.ersatz = false;
	return ev;
}

DwtUiEvent.prototype.setToDhtmlEvent =
function(ev) {
	DwtUiEvent.setBehaviour(ev, this._stopPropagation, this._returnValue, this._dontCallPreventDefault);
}

DwtUiEvent.setBehaviour =
function(ev, stopPropagation, allowDefault, dontCallPreventDefault) {
	var dhtmlEv = DwtUiEvent.getEvent(ev);
	DwtUiEvent.setDhtmlBehaviour(dhtmlEv, stopPropagation, allowDefault, dontCallPreventDefault);
};

DwtUiEvent.setDhtmlBehaviour =
function(dhtmlEv, stopPropagation, allowDefault, dontCallPreventDefault) {

	dhtmlEv = DwtUiEvent.getEvent(dhtmlEv);
	if (!dhtmlEv) { return; }

	// stopPropagation is referring to the function found in Mozilla's event object
	if (dhtmlEv.stopPropagation != null) {
		if (stopPropagation)
			dhtmlEv.stopPropagation();
		if (!allowDefault && !dontCallPreventDefault)
			dhtmlEv.preventDefault();
	} else {
		// IE only..
		dhtmlEv.returnValue = allowDefault;
		dhtmlEv.cancelBubble = stopPropagation;
	}
};

/**
 * @deprecated
 * Use DwtControl.getTargetControl() instead.
 * 
 * Returns a control (DWT object) based on the event, by finding the event target and using
 * its reference to a DWT object in the element's "dwtObj" expando property.
 * 
 * @param ev				[Event]		DHTML event
 * @param useRelatedTarget	[boolean]*	if true, return element that was related to this event;
 */
DwtUiEvent.getDwtObjFromEvent =
function(ev, useRelatedTarget) {
	var htmlEl = DwtUiEvent.getTargetWithProp(ev, "dwtObj", useRelatedTarget);
	return htmlEl ? Dwt.getObjectFromElement(htmlEl) : null;
};

/**
 * @deprecated
 * Instead, do something like this:
 * 		var htmlEl = DwtUiEvent.getTargetWithProp(ev, "myProp");
 * 		var obj = DwtControl.findControl(htmlEl);
 * 
 * Returns a control (DWT object) based on the event, by finding the event target with the
 * given property and using its reference to a DWT object.
 * 
 * @param ev				[Event]		DHTML event
 * @param useRelatedTarget	[boolean]*	if true, return element that was related to this event;
 */
DwtUiEvent.getDwtObjWithProp =
function(ev, prop) {
	var htmlEl = DwtUiEvent.getTargetWithProps(ev, ["dwtObj", prop]);
	return htmlEl ? Dwt.getObjectFromElement(htmlEl) : null;
};
}
if (AjxPackage.define("ajax.dwt.events.DwtControlEvent")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * 
 * @private
 */
DwtControlEvent = function() {
	this.reset();
}
DwtControlEvent.prototype = new DwtEvent;
DwtControlEvent.prototype.constructor = DwtControlEvent;

// type of control event
//      RESIZE	       -- for setSize
//      MOVE	       -- for setLocation
//      RESIZE | MOVE  -- for setBounts (bitwise or)
//      STATE	       -- for setDisplayState (bitwise or)

DwtControlEvent.RESIZE = 1;
DwtControlEvent.MOVE = 2;
DwtControlEvent.STATE = 4;

DwtControlEvent.prototype.toString = 
function() {
	return "DwtControlEvent";
}

DwtControlEvent.prototype.reset = 
function(type) {
	this.oldX = Dwt.DEFAULT;
	this.oldY = Dwt.DEFAULT;
	this.oldWidth = Dwt.DEFAULT;
	this.oldHeight = Dwt.DEFAULT;
	this.oldState = null;
	this.newX = Dwt.DEFAULT;
	this.newY = Dwt.DEFAULT;
	this.newWidth = Dwt.DEFAULT;
	this.newHeight = Dwt.DEFAULT;
	this.newState = null;
	this.type = type || null;
}
}
if (AjxPackage.define("ajax.dwt.events.DwtFocusEvent")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * 
 * @private
 */
DwtFocusEvent = function(init) {
	if (arguments.length == 0) return;
	DwtEvent.call(this, true);
	this.reset();
}
DwtFocusEvent.prototype = new DwtEvent;
DwtFocusEvent.prototype.constructor = DwtFocusEvent;

DwtFocusEvent.FOCUS = 1;
DwtFocusEvent.BLUR = 2;

DwtFocusEvent.prototype.toString = 
function() {
	return "DwtFocusEvent";
}

DwtFocusEvent.prototype.reset = 
function() {
	this.dwtObj = null;
	this.state = DwtFocusEvent.FOCUS;
}
}
if (AjxPackage.define("ajax.dwt.events.DwtKeyEvent")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * 
 * @private
 */
DwtKeyEvent = function() {
	DwtUiEvent.call(this, true);
	this.reset(true);
};

DwtKeyEvent.prototype.toString = function() { return "DwtKeyEvent"; }
DwtKeyEvent.prototype.isDwtKeyEvent = true;

// Constants for key codes
DwtKeyEvent.KEY_END_OF_TEXT     = 3;      // Enter key on Mac
DwtKeyEvent.KEY_BACKSPACE       = 8;
DwtKeyEvent.KEY_TAB             = 9;
DwtKeyEvent.KEY_RETURN          = 13;
DwtKeyEvent.KEY_ENTER           = DwtKeyEvent.KEY_RETURN;
DwtKeyEvent.KEY_ESCAPE          = 27;
DwtKeyEvent.KEY_SPACE           = 32;
DwtKeyEvent.KEY_ARROW_LEFT      = 37;
DwtKeyEvent.KEY_ARROW_UP        = 38;
DwtKeyEvent.KEY_ARROW_RIGHT     = 39;
DwtKeyEvent.KEY_ARROW_DOWN      = 40;
DwtKeyEvent.KEY_DELETE          = 46;
DwtKeyEvent.KEY_SEMICOLON       = 59;
DwtKeyEvent.KEY_SEMICOLON_1     = 186;
DwtKeyEvent.KEY_COMMA           = 188;
DwtKeyEvent.KEY_COMMAND         = 224;  // Mac FF

// Easy way to check for 3 or 13
DwtKeyEvent.IS_RETURN = {};
DwtKeyEvent.IS_RETURN[ DwtKeyEvent.KEY_END_OF_TEXT ]    = true;
DwtKeyEvent.IS_RETURN[ DwtKeyEvent.KEY_RETURN ]         = true;

// FF on Mac reports keyCode of 0 for many shifted keys
DwtKeyEvent.MAC_FF_CODE = {};
DwtKeyEvent.MAC_FF_CODE["~"] = 192;
DwtKeyEvent.MAC_FF_CODE["!"] = 49;
DwtKeyEvent.MAC_FF_CODE["@"] = 50;
DwtKeyEvent.MAC_FF_CODE["#"] = 51;
DwtKeyEvent.MAC_FF_CODE["$"] = 52;
DwtKeyEvent.MAC_FF_CODE["%"] = 53;
DwtKeyEvent.MAC_FF_CODE["^"] = 54;
DwtKeyEvent.MAC_FF_CODE["&"] = 55;
DwtKeyEvent.MAC_FF_CODE["*"] = 56;
DwtKeyEvent.MAC_FF_CODE["("] = 57;
DwtKeyEvent.MAC_FF_CODE[")"] = 48;
DwtKeyEvent.MAC_FF_CODE["-"] = 189;
DwtKeyEvent.MAC_FF_CODE["_"] = 189;
DwtKeyEvent.MAC_FF_CODE["+"] = 187;
DwtKeyEvent.MAC_FF_CODE["|"] = 220;
DwtKeyEvent.MAC_FF_CODE[":"] = 186;
DwtKeyEvent.MAC_FF_CODE["<"] = 188;
DwtKeyEvent.MAC_FF_CODE[">"] = 190;
DwtKeyEvent.MAC_FF_CODE["?"] = 191;

DwtKeyEvent.prototype = new DwtUiEvent;
DwtKeyEvent.prototype.constructor = DwtKeyEvent;


DwtKeyEvent.isKeyEvent =
function(ev) {
	return ev.type && ev.type.search(/^key/i) != -1;
}

DwtKeyEvent.isKeyPressEvent =
function(ev) {
	return (AjxEnv.isIE && ev.type == "keydown") || (ev.type == "keypress");
}

DwtKeyEvent.prototype.reset =
function(dontCallParent) {
	if (!dontCallParent)
		DwtUiEvent.prototype.reset.call(this);
	this.keyCode = 0;
	this.charCode = 0;
}

DwtKeyEvent.prototype.isCommand =
function(ev) {
	return AjxEnv.isMac && this.metaKey || this.ctrlKey;
}

DwtKeyEvent.prototype.setFromDhtmlEvent =
function(ev, obj) {
	ev = DwtUiEvent.prototype.setFromDhtmlEvent.apply(this, arguments);
	if (!ev) { return; }
	this.charCode = ev.charCode || ev.keyCode;
	this.keyCode = ev.keyCode;
}

/**
 * Simple function to return key code from a key event. The code is in keyCode for keydown/keyup.
 * Gecko puts it in charCode for keypress.
 */
DwtKeyEvent.getCharCode =
function(ev) {
	ev = DwtUiEvent.getEvent(ev);
	var key = AjxEnv.isSafari ? ev.keyCode : (ev.charCode || ev.keyCode);
	if (key == 0 && AjxEnv.isMac && AjxEnv.isGeckoBased && ev.type == "keyup" && DwtKeyEvent._geckoCode) {
		// if Mac Gecko, return keyCode saved from keypress event
		key = DwtKeyEvent._geckoCode;
		DwtKeyEvent._geckoCode = null;
	}
	return key;
}

DwtKeyEvent.copy =
function(dest, src) {
	DwtUiEvent.copy(dest, src);
	dest.charCode = src.charCode;
	dest.keyCode = src.keyCode;
}

/**
 * Workaround for the bug where Mac Gecko returns a keycode of 0 for many shifted chars for
 * keydown and keyup. Since it returns a char code for keypress, we save it so that the
 * ensuing keyup can pick it up.
 *
 * FF2 returns keycode 0 for: ~ ! @ # $ % ^ & * ( ) - _ + | : < > ? Alt-anything
 * FF3 returns keycode 0 for: ~ _ | : < > ?
 *
 * FF2 returns incorrect keycode for Ctrl plus any of: 1 2 3 4 5 6 7 8 9 0 ; ' , . /
 *
 * https://bugzilla.mozilla.org/show_bug.cgi?id=448434
 *
 * @param ev
 */
DwtKeyEvent.geckoCheck =
function(ev) {

	ev = DwtUiEvent.getEvent(ev);
	if (ev.type == "keypress") {
		DwtKeyEvent._geckoCode = null;
		if (AjxEnv.isMac && AjxEnv.isGeckoBased) {
			var ch = String.fromCharCode(ev.charCode);
			DwtKeyEvent._geckoCode = DwtKeyEvent.MAC_FF_CODE[ch];
		}
	}
};
}
if (AjxPackage.define("ajax.dwt.events.DwtMouseEvent")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * 
 * @private
 */
DwtMouseEvent = function() {
	DwtUiEvent.call(this, true);
	this.reset(true);
};

DwtMouseEvent.prototype = new DwtUiEvent;
DwtMouseEvent.prototype.constructor = DwtMouseEvent;

DwtMouseEvent.prototype.toString = 
function() {
	return "DwtMouseEvent";
};

DwtMouseEvent.NONE		= 0;
DwtMouseEvent.LEFT 		= 1;
DwtMouseEvent.MIDDLE	= 2;
DwtMouseEvent.RIGHT		= 3;

DwtMouseEvent.prototype.reset =
function(dontCallParent) {
	if (!dontCallParent) {
		DwtUiEvent.prototype.reset.call(this);
	}
	this.button = 0;
};

DwtMouseEvent.prototype.setFromDhtmlEvent =
function(ev, obj) {
	ev = DwtUiEvent.prototype.setFromDhtmlEvent.apply(this, arguments);
	if (!ev) { return; }

	if (ev.which) { // Mozilla or Safari3
		switch (ev.which) {
			case 1:  this.button = DwtMouseEvent.LEFT; break;
			case 2:  this.button = DwtMouseEvent.MIDDLE; break;
			case 3:  this.button = DwtMouseEvent.RIGHT; break;
			default: this.button = DwtMouseEvent.NONE;
		}
	} else if (ev.button) { // IE
		if ((ev.button & 1) != 0) {
			this.button = DwtMouseEvent.LEFT;
		} else if ((ev.button & 2) != 0) {
			this.button = DwtMouseEvent.RIGHT;
		} else if ((ev.button & 4) != 0) {
			this.button = DwtMouseEvent.MIDDLE;
		} else {
			this.button = DwtMouseEvent.NONE;
		}
	}

	if (AjxEnv.isMac && this.button) {
		// Mac only comes with one button, but can take a USB multibutton mouse. Single-button will translate
		// CTRL-LEFT into RIGHT, but leave ctrlKey set to true. Convert that into vanilla RIGHT click. That
		// means we can't distinguish a CTRL-RIGHT, but oh well.
		if (this.ctrlKey && (this.button == DwtMouseEvent.LEFT || this.button == DwtMouseEvent.RIGHT)) {
			this.button = DwtMouseEvent.RIGHT;
			this.ctrlKey = false;
		}
		// allow alt-key to be used for ctrl-select
		if (this.altKey) {
			this.ctrlKey = true;
			this.altKey = false;
		}
	}
};
}
if (AjxPackage.define("ajax.dwt.events.DwtMouseEventCapture")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * Creates a helper class for mouse event capturing.
 * @constructor
 * @class
 *
 * @author Ross Dargahi
 *
 * @param {hash}		params					a hash of parameters:
 * @param {Element}		params.targetObj		the target element
 * @param {string}		params.id				the ID for this capture instance.
 * @param {function}	params.mouseOverHdlr	the browser event handler
 * @param {function}	params.mouseDownHdlr	the browser event handler
 * @param {function}	params.mouseMoveHdlr	the browser event handler
 * @param {function}	params.mouseUpHdlr		the browser event handler
 * @param {function}	params.mouseOutHdlr		the browser event handler
 * @param {function}	params.mouseWheelHdlr	the browser event handler
 * @param {boolean}		params.hardCapture		if <code>true</code>, event propagation is halted at this element (IE only)
 *
 * @private
 */
DwtMouseEventCapture = function(params) {

	params = Dwt.getParams(arguments, DwtMouseEventCapture.PARAMS);

	this.targetObj = params.targetObj;
	this._id = params.id;
	this._mouseOverHdlr = params.mouseOverHdlr || DwtMouseEventCapture.emptyHdlr;
	this._mouseDownHdlr = params.mouseDownHdlr || DwtMouseEventCapture.emptyHdlr;
	this._mouseMoveHdlr = params.mouseMoveHdlr || DwtMouseEventCapture.emptyHdlr;
	this._mouseUpHdlr = params.mouseUpHdlr || DwtMouseEventCapture.emptyHdlr;
	this._mouseOutHdlr = params.mouseOutHdlr || DwtMouseEventCapture.emptyHdlr;
	this._mouseWheelHdlr = params.mouseWheelHdlr || DwtMouseEventCapture.emptyHdlr;
	this._hardCapture = (params.hardCapture !== false)
}

DwtMouseEventCapture.PARAMS = ["targetObj", "id", "mouseOverHdlr", "mouseDownHdlr", "mouseMoveHdlr",
							   "mouseUpHdlr", "mouseOutHdlr", "mouseWheelHdlr", "hardCapture"];

DwtMouseEventCapture._capturing = false;

DwtMouseEventCapture.getCaptureObj =
function() {
	return window._mouseEventCaptureObj;
}

DwtMouseEventCapture.getTargetObj =
function() {
	return window._mouseEventCaptureObj ? window._mouseEventCaptureObj.targetObj : null;
}

DwtMouseEventCapture.getId =
function() {
	return window._mouseEventCaptureObj ? window._mouseEventCaptureObj._id : null;
}

DwtMouseEventCapture.prototype.toString = 
function() {
	return "DwtMouseEventCapture";
}

DwtMouseEventCapture.prototype.capturing =
function() {
	return DwtMouseEventCapture._capturing;
}

DwtMouseEventCapture.prototype.capture =
function() {

	if (window._mouseEventCaptureObj) {
		window._mouseEventCaptureObj.release();
	}

	if (document.body != null && document.body.addEventListener != null) {
		document.body.addEventListener("mouseover", this._mouseOverHdlr, true);
		document.body.addEventListener("mousedown", this._mouseDownHdlr, true);
		document.body.addEventListener("mousemove", this._mouseMoveHdlr, true);
		document.body.addEventListener("mouseup", this._mouseUpHdlr, true);
		document.body.addEventListener("mouseout", this._mouseOutHdlr, true);
		document.body.addEventListener("DOMMouseScroll", this._mouseWheelHdlr, true);
	} else {
		this._savedMouseOverHdlr = document.onmouseover;
		this._savedMouseDownHdlr = document.onmousedown;
		this._savedMouseMoveHdlr = document.onmousemove;
		this._savedMouseUpHdlr = document.onmouseup;
		this._savedMouseOutHdlr = document.onmouseout;
		this._savedMouseWheelHdlr = document.onmousewheel;
		document.onmouseover = this._mouseOverHdlr;
		document.onmousedown = this._mouseDownHdlr;
		document.onmousemove = this._mouseMoveHdlr;
		document.onmouseup = this._mouseUpHdlr;
		document.onmouseout = this._mouseOutHdlr;
		document.onmousewheel = this._mouseWheelHdlr;
	}
	window._mouseEventCaptureObj = this;
	DwtMouseEventCapture._capturing = true;
}


DwtMouseEventCapture.prototype.release = 
function() {

	if (window._mouseEventCaptureObj == null) { return; }

	var obj = window._shellCaptureObj;
	if (document.body && document.body.addEventListener) {
		document.body.removeEventListener("mouseover", this._mouseOverHdlr, true);
		document.body.removeEventListener("mousedown", this._mouseDownHdlr, true);
		document.body.removeEventListener("mousemove", this._mouseMoveHdlr, true);
		document.body.removeEventListener("mouseup", this._mouseUpHdlr, true);
		document.body.removeEventListener("mouseout", this._mouseOutHdlr, true);
		document.body.removeEventListener("DOMMouseScroll", this._mouseWheelHdlr, true);
	} else {
		document.onmouseover = this._savedMouseOverHdlr
		document.onmousedown = this._savedMouseDownHdlr;
		document.onmousemove = this._savedMouseMoveHdlr;
		document.onmouseup = this._savedMouseUpHdlr;
		document.onmouseout = this._savedMouseOutHdlr;
		document.onmousewheel = this._savedMouseWheelHdlr;
	}
	window._mouseEventCaptureObj = null;
	DwtMouseEventCapture._capturing = false;
}

DwtMouseEventCapture.emptyHdlr =
function(ev) {
	var capObj = DwtMouseEventCapture.getCaptureObj();
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev);	
	if (capObj._hardCapture) {
		mouseEv._stopPropagation = true;
		mouseEv._returnValue = false;
		mouseEv.setToDhtmlEvent(ev);
		return false;	
	} else {
		mouseEv._stopPropagation = false;
		mouseEv._returnValue = true;
		mouseEv.setToDhtmlEvent(ev);
		return true;
	}	
}
}
if (AjxPackage.define("ajax.dwt.events.DwtListViewActionEvent")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * 
 * @private
 */
DwtListViewActionEvent = function() {
	DwtMouseEvent.call(this);
	this.reset(true);
}

DwtListViewActionEvent.prototype = new DwtMouseEvent;
DwtListViewActionEvent.prototype.constructor = DwtListViewActionEvent;

DwtListViewActionEvent.prototype.toString = 
function() {
	return "DwtListViewActionEvent";
}

DwtListViewActionEvent.prototype.reset =
function(dontCallParent) {
	if (!dontCallParent)
		DwtMouseEvent.prototype.reset.call(this);
	this.field = null;
	this.item = null;
	this.detail = null;
}
}
if (AjxPackage.define("ajax.dwt.events.DwtSelectionEvent")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * 
 * 
 * @private
 */
DwtSelectionEvent = function(init) {
	if (arguments.length == 0) return;
	DwtUiEvent.call(this, true);
	this.reset(true);
}

DwtSelectionEvent.prototype = new DwtUiEvent;
DwtSelectionEvent.prototype.constructor = DwtSelectionEvent;

DwtSelectionEvent.prototype.toString = 
function() {
	return "DwtSelectionEvent";
}

DwtSelectionEvent.prototype.reset =
function(dontCallParent) {
	if (!dontCallParent)
		DwtUiEvent.prototype.reset.call(this);
	this.button = 0;
	this.detail = null;
	this.item = null;
}

}
if (AjxPackage.define("ajax.dwt.events.DwtTreeEvent")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * 
 * 
 * @private
 */
DwtTreeEvent = function() {
	DwtSelectionEvent.call(this, true);
}

DwtTreeEvent.prototype = new DwtSelectionEvent;
DwtTreeEvent.prototype.constructor = DwtTreeEvent;

DwtTreeEvent.prototype.toString = 
function() {
	return "DwtTreeEvent";
}

DwtTreeEvent.prototype.setFromDhtmlEvent =
function(ev, obj) {
	ev = DwtSelectionEvent.prototype.setFromDhtmlEvent.apply(this, arguments);
}
}
if (AjxPackage.define("ajax.dwt.events.DwtHoverEvent")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * 
 * @private
 */
DwtHoverEvent = function(type, delay, object, x, y) {
	if (arguments.length == 0) return;
	DwtEvent.call(this, true);
	this.type = type;
	this.delay = delay;
	this.object = object;
	this.x = x || -1;
	this.y = y || -1;
}

DwtHoverEvent.prototype = new DwtEvent;
DwtHoverEvent.prototype.constructor = DwtHoverEvent;

DwtHoverEvent.prototype.toString = function() { return "DwtHoverEvent"; };

DwtHoverEvent.prototype.reset =
function() {
	this.type = 0;
	this.delay = 0;
	this.object = null;
	this.x = -1;
	this.y = -1;
};
}
if (AjxPackage.define("ajax.dwt.events.DwtOutsideMouseEventMgr")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * Creates a singleton that manages outside mouse clicks for a given widget.
 * @constructor
 * @class
 * This class is designed to make it easy for a widget to detect mouse events
 * that happen somewhere outside its HTML structure. The typical use case is
 * so that a menu can pop down when a user clicks outside of it, but there are
 * others. For the most part, we care about mousedown events.
 *
 * There are several ways to detecting outside mouse events:
 *
 * 1. Set the body element to capture all mouse events, using DwtMouseEventCapture.
 *    That is all that's needed for non-IE browsers.
 * 2. Any control that receives an event calls the global listener through
 *    DwtEventManager.
 * 3. The shell listens for mouse events.
 * 4. Listen for window blur events.
 *
 * 2 and 3 are used by IE only. Note that the controls and the shell must be handling
 * those events in order to trigger the listeners.
 *
 * 4 is not used by IE, since window.onblur does not work correctly on IE. It's possible to
 * use document.onfocusout, but that is triggered even on clicks within the document, so
 * you need to check activeElement and cross your fingers. It's not worth the risk.
 *
 * We also have classes that create elements in another document (IFRAME) forward
 * their mouse events to us so that we can notify a client object if appropriate.
 * The one class that does that is DwtIframe.
 *
 * The framework can support multiple simultaneous clients. For example, a context
 * menu and toast could both be listening for outside mouse clicks at the same time.
 * Each will be notified as appropriate. If the toast is clicked, the context menu
 * will be notified of an outside click.
 *
 * A client may also add an element to its defined "inside" area by calling
 * startListening() with the same ID. One use case is a menu that pops up a submenu.
 * The two are considered together when determining if a mouse click was "outside".
 * If the submenu pops down, its element is removed from the area to check.
 */
DwtOutsideMouseEventMgr = function() {

	this._reset();
	this._mouseEventListener = DwtOutsideMouseEventMgr._mouseEventHdlr.bind();
	DwtOutsideMouseEventMgr.INSTANCE = this;
	this.id = "DwtOutsideMouseEventMgr";
};

DwtOutsideMouseEventMgr.prototype.isDwtOutsideMouseEventMgr = true;
DwtOutsideMouseEventMgr.prototype.toString = function() { return "DwtOutsideMouseEventMgr"; };

DwtOutsideMouseEventMgr.EVENTS = [DwtEvent.ONMOUSEDOWN];
DwtOutsideMouseEventMgr.EVENTS_HASH = AjxUtil.arrayAsHash(DwtOutsideMouseEventMgr.EVENTS);

/**
 * Start listening for outside mouse events on behalf of the given object.
 *
 * @param {hash}		params					hash of params:
 * @param {string}		params.id				unique ID for this listening session
 * @param {DwtControl}	params.obj				control on behalf of whom we're listening
 * @param {string}		params.elementId		ID of reference element, if other than control's HTML element
 * @param {AjxListener}	params.outsideListener	listener to call when we get an outside mouse event
 * @param {boolean}		params.noWindowBlur		if true, don't listen for window blur events; useful for dev
 */
DwtOutsideMouseEventMgr.prototype.startListening =
function(params) {

	DBG.println("out", "start listening: " + params.id);

	if (!(params && params.outsideListener)) { return; }
	var id = params.id;

	if (!this._menuCapObj) {
		// we only need a single menu capture object, create it lazily
		var mecParams = {
			id:				this.id,
			hardCapture:	false,
			mouseDownHdlr:	DwtOutsideMouseEventMgr._mouseEventHdlr
		}
		this._menuCapObj = new DwtMouseEventCapture(mecParams);
	}

	var elementId = params.elementId || (params.obj && params.obj.getHTMLElId && params.obj.getHTMLElId());
	DBG.println("out", "add element ID " + elementId + " for ID " + id);

	var context = this._byId[id];
	if (context) {
		// second and subsequent calls with same ID will just add element IDs; typical case is submenu
		if (elementId) {
			context.elementIds.push(elementId);
		}
		DBG.println("out", "element IDs: " + context.elementIds);
		return;
	}
	else {
		context = this._byId[id] = {
			id:					id,
			obj:				params.obj,
			elementIds:			[elementId],
			outsideListener:	params.outsideListener
		}
	}

	// add various event listeners when we get our first client
	if (this._numIds == 0) {
		if (AjxEnv.isIE) {
			var shell = DwtShell.getShell(window);
			var events = DwtOutsideMouseEventMgr.EVENTS;
			shell._setEventHdlrs(events);
			for (var i = 0; i < events.length; i++) {
				var ev = events[i];
				shell.addListener(ev, this._mouseEventListener);
				DwtEventManager.addListener(ev, this._mouseEventListener);
			}
		}

		if (!AjxEnv.isIE && !params.noWindowBlur) {
			this._savedWindowBlurHandler = window.onblur;
			window.onblur = DwtOutsideMouseEventMgr._mouseEventHdlr;
		}

		// start a new capture session
		DBG.println("out", "capture");
		this._menuCapObj.capture();
		this._capturing = true;
	}

	this._numIds++;
};

/**
 * Stop listening for outside mouse events. Listening is stopped for the element
 * provided, if any, or for the element indicated by the context ID. Outside
 * listeners are removed once there are no more elements in the context.
 *
 * @param {string|hash}	params				ID, if string, otherwise hash of params:
 * @param {string}		params.id			unique ID for this listening session
 * @param {DwtControl}	params.obj			control on behalf of whom we're listening
 * @param {string}		params.elementId	ID of element to remove from listening context
 * @param {boolean}		params.noWindowBlur	if true, don't listen for window blur events; useful for dev
 */
DwtOutsideMouseEventMgr.prototype.stopListening =
function(params) {

	if (typeof params == "string") {
		params = {id:params};
	}
	var id = params.id;
	var context = this._byId[id];
	if (!context) { return; }
	DBG.println("out", "stop listening: " + id);

	var elIds = context.elementIds;
	var elementId = params.elementId || (params.obj && params.obj.getHTMLElId());
	if (elementId) {
		AjxUtil.arrayRemove(elIds, elementId);
		if (elIds.length > 0) {
			// still at least one element to check against
			return;
		}
	}

	// no more elements in this context, remove listeners
	delete this._byId[id];
	this._numIds--;

	if (this._numIds == 0) {
		if (AjxEnv.isIE) {
			var shell = DwtShell.getShell(window);
			var events = DwtOutsideMouseEventMgr.EVENTS;
			shell._setEventHdlrs(events, true);
			for (var i = 0; i < events.length; i++) {
				var ev = events[i];
				shell.removeListener(ev, this._mouseEventListener);
				DwtEventManager.removeListener(ev, this._mouseEventListener);
			}
		}

		if (!AjxEnv.isIE && !params.noWindowBlur) {
			window.onblur = this._savedWindowBlurHandler;
		}

		this._reset();
	}
};

DwtOutsideMouseEventMgr.prototype._reset =
function() {

	if (this._capturing && (DwtMouseEventCapture.getId() == this.id)) {
		DBG.println("out", "release");
		this._menuCapObj.release();
		this._capturing = false;
	}
	this._byId		= {};
	this._numIds	= 0;
};

/**
 * If the event is one we're listening for, check its target to see if
 * we should pass it along.
 *
 * @param {Event}	ev
 */
DwtOutsideMouseEventMgr.forwardEvent =
function(ev) {

	if (!ev) { return; }
	var omem = DwtOutsideMouseEventMgr.INSTANCE;
	if (!omem._numIds) { return; }

	var type = "on" + ev.type;
	if (DwtOutsideMouseEventMgr.EVENTS_HASH[type]) {
		DwtOutsideMouseEventMgr._mouseEventHdlr(ev);
	}
};

/**
 * Call the client's outside listener if the event happened outside of the elements
 * defined by the client's context. Note that the event that gets passed in might be
 * a DOM event, or a DwtMouseEvent. That's okay, since both have a "target" property.
 *
 * @param {Event|DwtMouseEvent}	ev		event
 */
DwtOutsideMouseEventMgr._mouseEventHdlr =
function(ev) {

    ev = DwtUiEvent.getEvent(ev);
    if (!ev)
        return;

    var omem = DwtOutsideMouseEventMgr.INSTANCE;
	var targetEl = DwtUiEvent.getTarget(ev);
	DBG.println("out", "event type: " + ev.type);
	DBG.println("out", "target: " + targetEl.id);
	// bug 59782 - FF issues mysterious window.blur event that we should ignore
	if (AjxEnv.isGeckoBased && ev && (ev.type == "blur") && ev.target && ev.explicitOriginalTarget &&
		(ev.target != ev.explicitOriginalTarget)) {
		
		DwtUiEvent.setBehaviour(ev, false, true);
		return true;
	}
	
	for (var id in omem._byId) {
		var runListener = true;
		var context = omem._byId[id];
		var elementIds = context.elementIds;
		DBG.println("out", "element IDs for " + id + ": " + context.elementIds);
		for (var i = 0; i < elementIds.length; i++) {
			DBG.println("out", "check: " + elementIds[i]);
			var el = document.getElementById(elementIds[i]);
			if (el && targetEl && Dwt.isAncestor(el, targetEl)) {
				runListener = false;
				break;
			}
		}
		if (runListener) {
			DBG.println("out", "run listener for: " + context.id);
			context.outsideListener.run(ev, context);
		}
	}

	DwtUiEvent.setBehaviour(ev, false, true);
	return true;
};

// create our singleton instance
new DwtOutsideMouseEventMgr();
}

if (AjxPackage.define("ajax.dwt.keyboard.DwtTabGroupEvent")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * @constructor
 * @class
 * This class represents a the tab event. This event is used to indicate changes in
 * the state of {@link DwtTabGroup} objects (e.g. member addition and deletion). 
 * 
 * @author Ross Dargahi
 * 
 * @private
 */
DwtTabGroupEvent = function() {
	/**
	 * Tab group for which the event is being generated
	 * @type DwtTabGroup
	 */
	this.tabGroup = null;
	
	/**
	 * New focus member
	 * @type DwtControl|HTMLElement
	 */
	this.newFocusMember = null;
}

/**
 * Returns a string representation of this object.
 * 
 * @return {string}	a string representation of this object
 */
DwtTabGroupEvent.prototype.toString = 
function() {
	return "DwtTabGroupEvent";
}

/**
 * Resets the members of the event.
 * 
 */
DwtTabGroupEvent.prototype.reset =
function() {
	this.tabGroup = null;
	this.newFocusMember = null;
}
}
if (AjxPackage.define("ajax.dwt.keyboard.DwtKeyMap")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * Creates and loads a key map.
 * @constructor
 * @class
 * This class provides the basic keyboard mappings for {@link Dwt} components. The
 * key bindings are taken from the class AjxKeys, which is populated from a
 * properties file. The identifiers used in the properties file must match
 * those used here.
 * 
 * @author Ross Dargahi
 * 
 * @param	{boolean}		subclassInit		if <code>true</code>, the sub-class will initialize
 * 
 */
DwtKeyMap = function(subclassInit) {
	if (subclassInit) {	return };

	this._map			= {};
	this._args			= {};
	this._checkedMap	= {};	// cache results of _checkMap()

	this._load(this._map, AjxKeys);

	DwtKeyMap.MOD_ORDER[DwtKeyMap.ALT]		= 1;
	DwtKeyMap.MOD_ORDER[DwtKeyMap.CTRL]		= 2;
	DwtKeyMap.MOD_ORDER[DwtKeyMap.META]		= 3;
	DwtKeyMap.MOD_ORDER[DwtKeyMap.SHIFT]	= 4;
};

DwtKeyMap.prototype.isDwtKeyMap = true;
DwtKeyMap.prototype.toString = function() { return "DwtKeyMap"; };

// This is how modifiers need to appear in *.keycode values
DwtKeyMap.ALT   = 'Alt';
DwtKeyMap.CTRL  = 'Ctrl';
DwtKeyMap.META  = 'Meta';
DwtKeyMap.SHIFT = 'Shift';

DwtKeyMap.deserialize =
function(keymap) {
	alert("DwtKeyMap.deserialize: NOT IMPLEMENTED");
};

DwtKeyMap.serialize =
function(keymap) {
	alert("DwtKeyMap.serialize: NOT IMPLEMENTED");
};

DwtKeyMap.MAP_DIALOG		= "dialog";
DwtKeyMap.MAP_OPTION_DIALOG	= "optionDialog";
DwtKeyMap.MAP_BUTTON		= "button";
DwtKeyMap.MAP_LIST			= "list";
DwtKeyMap.MAP_MENU			= "menu";
DwtKeyMap.MAP_EDITOR		= "editor";
DwtKeyMap.MAP_TOOLBAR_HORIZ	= "toolbarHorizontal";
DwtKeyMap.MAP_TOOLBAR_VERT	= "toolbarVertical";
DwtKeyMap.MAP_TAB_VIEW		= "tabView";
DwtKeyMap.MAP_TREE			= "tree";


// Returns true if the given key is a modifier. The list of modifier keys is
// taken from the AjxKeys properties file.
DwtKeyMap.IS_MODIFIER = {};

// Order filled in by DwtKeyMapMgr._processKeyDefs()
DwtKeyMap.MOD_ORDER		= {};

// Key names
DwtKeyMap.ARROW_DOWN		= "ArrowDown";
DwtKeyMap.ARROW_LEFT		= "ArrowLeft";
DwtKeyMap.ARROW_RIGHT		= "ArrowRight";
DwtKeyMap.ARROW_UP			= "ArrowUp";
DwtKeyMap.BACKSLASH			= "Backslash";
DwtKeyMap.BACKSPACE			= "Backspace";
DwtKeyMap.COMMA				= "Comma";
DwtKeyMap.DELETE			= "Del";
DwtKeyMap.END				= "End";
DwtKeyMap.ENTER				= "Enter";
DwtKeyMap.ESC				= "Esc";
DwtKeyMap.HOME				= "Home";
DwtKeyMap.PGDOWN			= "PgDown";
DwtKeyMap.PGUP			    = "PgUp";
DwtKeyMap.SEMICOLON			= "Semicolon";
DwtKeyMap.SPACE				= "Space";
DwtKeyMap.TAB				= "Tab";

// Action codes
DwtKeyMap.ADD_SELECT_NEXT	= "AddNext";
DwtKeyMap.ADD_SELECT_PREV	= "AddPrevious";
DwtKeyMap.CANCEL			= "Cancel";
DwtKeyMap.COLLAPSE			= "Collapse";
DwtKeyMap.DBLCLICK			= "DoubleClick";
DwtKeyMap.DELETE			= "Delete";
DwtKeyMap.EXPAND			= "Expand";
DwtKeyMap.GOTO_TAB			= "GoToTab";
DwtKeyMap.HEADER1			= "Header1";
DwtKeyMap.HEADER2			= "Header2";
DwtKeyMap.HEADER3			= "Header3";
DwtKeyMap.HEADER4			= "Header4";
DwtKeyMap.HEADER5			= "Header5";
DwtKeyMap.HEADER6			= "Header6";
DwtKeyMap.INSERT_LINK	    = "InsertLink";
DwtKeyMap.JUSTIFY_CENTER	= "CenterJustify";
DwtKeyMap.JUSTIFY_LEFT		= "LeftJustify";
DwtKeyMap.JUSTIFY_RIGHT		= "RightJustify";
DwtKeyMap.NEXT				= "Next";
DwtKeyMap.NEXT_TAB			= "NextTab";
DwtKeyMap.NO				= "No";
DwtKeyMap.PAGE_UP			= "PageUp";
DwtKeyMap.PAGE_DOWN			= "PageDown";
DwtKeyMap.PARENTMENU		= "ParentMenu";
DwtKeyMap.PREV				= "Previous";
DwtKeyMap.PREV_TAB			= "PreviousTab";
DwtKeyMap.SELECT_ALL		= "SelectAll";
DwtKeyMap.SELECT			= "Select";
DwtKeyMap.SELECT_CURRENT	= "SelectCurrent";
DwtKeyMap.SELECT_FIRST		= "SelectFirst";
DwtKeyMap.SELECT_LAST		= "SelectLast";
DwtKeyMap.SELECT_NEXT		= "SelectNext";
DwtKeyMap.SELECT_PREV		= "SelectPrevious";
DwtKeyMap.SUBMENU			= "SubMenu";
DwtKeyMap.SWITCH_MODE		= "SwitchMode";
DwtKeyMap.TEXT_BOLD			= "Bold";
DwtKeyMap.TEXT_ITALIC		= "Italic";
DwtKeyMap.TEXT_UNDERLINE	= "Underline";
DwtKeyMap.TEXT_STRIKETHRU	= "Strikethru";
DwtKeyMap.YES				= "Yes";

DwtKeyMap.GOTO_TAB_RE = new RegExp(DwtKeyMap.GOTO_TAB + "(\\d+)");

DwtKeyMap.JOIN		= "+";			// Modifier join character
DwtKeyMap.SEP		= ",";			// Key separator
DwtKeyMap.INHERIT	= "INHERIT";	// Inherit keyword.

DwtKeyMap.prototype.getMap =
function() {
	return this._map;
};

/**
 * Converts a properties representation of shortcuts into a hash. The
 * properties version is actually a reverse map of what we want, so we
 * have to swap keys and values. Handles platform-specific shortcuts,
 * and inheritance. The properties version is made available via a
 * servlet.
 * 
 * @param {hash}	map			the hash to populate with shortcuts
 * @param {hash}	keys			the properties version of shortcuts
 * 
 * @private
 */
DwtKeyMap.prototype._load =
function(map, keys) {

	// preprocess for platform-specific bindings, and sanitize for misuse of {modifier} in keycode
	var curPlatform = AjxEnv.platform.toLowerCase();
	for (var propName in keys) {
		var parts = propName.split(".");
		var last = parts[parts.length - 1];
        // if we find the right platform-specific binding, promote it to be the main one
		if (last === "win" || last === "mac" || last === "linux") {
			if (last === curPlatform) {
				var baseKey = parts.slice(0, parts.length - 1).join(".");
				keys[baseKey] = keys[propName];
			}
			keys[propName] = null;
		}
        // clean up in case someone put something like {ctrl} in keycode rather than display
        var propValue = AjxStringUtil.trim(keys[propName]);
        if (parts[2] && parts[2] === 'keycode' && propValue && propValue.indexOf('{') !== -1) {
            keys[propName] = propValue.replace(/\{(\w)(\w+)\}/g, function(m, first, rest) {
                return first.toUpperCase() + rest;
            });
        }
	}
	
	for (var propName in keys) {
		var propValue = AjxStringUtil.trim(keys[propName]);
		if (!propValue || (typeof keys[propName] != "string")) { continue; }
		var parts = propName.split(".");
		var field = parts[parts.length - 1];
		var isMap = (parts.length == 2);
		var action = isMap ? null : parts[1];
		if (parts[0] == "keys") {
			this._processKeyDef(action, field, propValue);
			continue;
		}
		if (field != DwtKeyMap.INHERIT && field != "keycode") { continue; }
		var mapName = parts[0];
		if ((this._checkedMap[mapName] === false) ||
			(!this._checkedMap[mapName] && !this._checkMap(mapName))) { continue; }
		if (!map[mapName]) {
			map[mapName] = {};
		}
		if (!this._checkAction(mapName, action)) { continue; }
		var keySequences = propValue.split(/\s*;\s*/);
		for (var i = 0; i < keySequences.length; i++) {
			var ks = this._canonicalize(keySequences[i]);
			if (field == DwtKeyMap.INHERIT) {
				var parents = ks.split(/\s*,\s*/);
				var parents1 = [];
				for (var p = 0; p < parents.length; p++) {
					parents1[p] = parents[p];
				}
				map[mapName][parts[1]] = parents1.join(",");
			} else if (field == "keycode") {
				map[mapName][ks] = action;
			}
		}
	}
};

/**
 * Returns true if this map is valid. This class always returns true,
 * but subclasses may override to do more checking.
 *
 * @param {string}	mapName		the name of map
 * 
 * @private
 */
DwtKeyMap.prototype._checkMap =
function(mapName) {
	var result = true;
	this._checkedMap[mapName] = result;
	return result;
};

/**
 * Checks if this action is valid. This class always returns <code>true</code>,
 * but subclasses may override to do more checking.
 *
 * @param {string}	mapName	the name of map
 * @param {string}	action	the action to check
 * @param	{boolean}	<code>true</code> if this action is valid. 
 * @private
 */
DwtKeyMap.prototype._checkAction =
function(mapName, action) {
	return true;
};

/**
 * Sets up constants for a modifier key as described in a properties file.
 * 
 * @param {string}	key		the ctrl, alt, shift, or meta
 * @param {string}	field	the display or keycode
 * @param {string|number}	value	the property value
 * 
 * @private
 */
DwtKeyMap.prototype._processKeyDef = 
function(key, field, value) {
	if (!key || !field || !value) { return; }
	if (field == "keycode") {
		DwtKeyMap.IS_MODIFIER[value] = true;
	}
};

/**
 * Ensures a predictable order for the modifiers in a key sequence:
 * <pre>
 * Alt Ctrl Meta Shift
 * </pre>
 * 
 * Example: "Shift+Ctrl+U" will be transformed into "Ctrl+Shift+U"
 * 
 * @param {String}	ks	the key sequence
 * 
 * @private
 */
DwtKeyMap.prototype._canonicalize =
function(ks) {
	var keys = ks.split(DwtKeyMap.SEP);
	var result = [];
	for (var i = 0; i < keys.length; i++) {
		var key = keys[i];
		var parts = key.split(DwtKeyMap.JOIN);
		if (parts.length > 2) {
			var mods = parts.slice(0, parts.length - 1);
			mods.sort(function(a, b) {
				var sortA = DwtKeyMap.MOD_ORDER[a] || 0;
				var sortB = DwtKeyMap.MOD_ORDER[b] || 0;
				return Number(sortA - sortB);
			});
			mods.push(parts[parts.length - 1]);
			result.push(mods.join(DwtKeyMap.JOIN));
		} else {
			result.push(key);
		}
	}
	return result.join(",");
};
}
if (AjxPackage.define("ajax.dwt.keyboard.DwtKeyMapMgr")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * Creates and initializes a manager for the given keymap.
 * @constructor
 * @class
 * A keymap manager parses the keymap into a form that is easily used for 
 * translating key codes into actions. It also provides some static methods
 * that map the available keyboard to key codes, and which qualify certain
 * keys as punctuation, etc.
 * 
 * @author Ross Dargahi
 *
 * @param {DwtKeyMap}	keyMap the keymap
 *
 * @private
 */
DwtKeyMapMgr = function(keyMap) {

	var map = this._map = keyMap.getMap();
	this._args = keyMap._args;
	
	// build FSA for each mapping
	this._fsas = {};
	for (var key in map) {
		DBG.println(AjxDebug.DBG3, "building FSA for key: " + key);
		this._fsas[key] = DwtKeyMapMgr.__buildFSA({}, map[key], key);
	}
	DBG.dumpObj(AjxDebug.DBG3, this._fsas);
};

DwtKeyMapMgr.prototype.toString = function() { return "DwtKeyMapMgr"; };
DwtKeyMapMgr.prototype.isDwtKeyMapMgr = true;

DwtKeyMapMgr.NOT_A_TERMINAL = -999;
DwtKeyMapMgr.TAB_KEYCODE = DwtKeyEvent.KEY_TAB;


/**
 * This method will attempt to look up the action code for a given key sequence in
 * a given key map. 
 * 
 * @param {string}		keySeq				key sequence to lookup
 * @param {string}		mappingName			keymap name in which to search
 * @param {boolean}		forceActionCode		if <code>true</code>, then if the key sequence contains both
 * 											a submap and an action code, then return the action code.
 * 											If this parameter is false or omitted, then
 * 											{@link DwtKeyMapMgr.NOT_A_TERMINAL} will be returned for
 * 											a key sequence that contains both a submap and an action code.
 * 
 * @return {string|number}	the action code for the provided key map name, null if there is no action code
 * 		or {@link DwtKeyMapMgr.NOT_A_TERMINAL} if the key sequence is an intermediate
 * 		node in the key map (i.e. has a submap)
 * 
 */
DwtKeyMapMgr.prototype.getActionCode =
function(keySeq, mappingName, forceActionCode) {
	//DBG.println(AjxDebug.DBG3, "Getting action code for: " + keySeq + " in map: " + mappingName);
	var mapping =  this._fsas[mappingName];

	if (!mapping) {
		DBG.println(AjxDebug.DBG3, "No keymap for: " + mappingName);
		return null;
	}

	var keySeqLen = keySeq.length;
	var tmpFsa = mapping;
	var key;
	for (var j = 0; j < keySeqLen && tmpFsa; j++) {
		key = keySeq[j];

		if (!tmpFsa || !tmpFsa[key]) break;

		if (j < keySeqLen - 1) {
			tmpFsa = tmpFsa[key].subMap;
		}
	}

	if (tmpFsa && tmpFsa[key]) {
		var binding = tmpFsa[key];
		/* If the binding does not have a submap, then it must have an action code
		 * so return it. Else if the binding does not have an action code (i.e. it
		 * has a submap only) or if forceActionCode is false, then return DwtKeyMapMgr.NOT_A_TERMINAL
		 * since we are to behave like an intermediate node. Else return the action code. */
		if (!binding.subMap || forceActionCode) {
			var inherited = this.__getInheritedActionCode(keySeq, mapping, forceActionCode);
            //if keyMap not available then return the inherited keyMap.
            return inherited == DwtKeyMapMgr.NOT_A_TERMINAL ? DwtKeyMapMgr.NOT_A_TERMINAL : ( binding.actionCode || inherited );
		} else {
			return DwtKeyMapMgr.NOT_A_TERMINAL;
		}
	} else {
		return this.__getInheritedActionCode(keySeq, mapping, forceActionCode);
	}
};

/**
 * Returns the action for the given map and key sequence.
 * 
 */
DwtKeyMapMgr.prototype.getAction =
function(mapName, keySeq) {
	return this._map[mapName][keySeq];
};

/**
 * Returns the key sequences associated with the given map and action.
 */
DwtKeyMapMgr.prototype.getKeySequences =
function(mapName, action) {
	var keySeqs = [];
	for (var ks in this._map[mapName]) {
		if (this._map[mapName][ks] == action) {
			keySeqs.push(ks);
		}
	}
	return keySeqs;
};

/**
 * Allow the programmatic setting of a key sequence mapping for a given map
 * 
 * @param {string} 			mapName map name to affect
 * @param {string} 			keySeq the key sequence to set
 * @param {string|number} action the action code for the key sequence
 */
DwtKeyMapMgr.prototype.setMapping =
function(mapName, keySeq, action) {
	this._map[mapName][keySeq] = action;
};

/**
 * Allow the programatting removal of a key sequence mapping for a given map
 * 
 * @param {string} mapName map name to affect
 * @param {string} keySeq the key sequence to remove
 */
DwtKeyMapMgr.prototype.removeMapping =
function(mapName, keySeq) {
	delete this._map[mapName][keySeq];
};

/**
 * Replace the key sequence for a given action in a keymap 
 * 
 * @param {string} mapName map name to affect
 * @param {string} oldKeySeq the key sequence to replace
 * @param {string} newKeySeq the new key sequence
 */
DwtKeyMapMgr.prototype.replaceMapping =
function(mapName, oldKeySeq, newKeySeq) {
	var action = this._map[mapName][oldKeySeq];
	if (!action) return;
	this.removeMapping(mapName, oldKeySeq);
	this.setMapping(mapName, newKeySeq, action);
};

DwtKeyMapMgr.prototype.setArg =
function(mapName, action, arg) {
	if (!this._args[mapName]) {
		this._args[mapName] = {};
	}
	this._args[mapName][action] = arg;
};

DwtKeyMapMgr.prototype.removeArg =
function(mapName, action) {
	delete this._args[mapName][action];
};

DwtKeyMapMgr.prototype.getArg =
function(mapName, action) {
	return this._args[mapName] ? this._args[mapName][action] : null;
};

/**
 * Reloads a given keymap
 * 
 * @param {string} mapName Name of the keymap to reload
 */
DwtKeyMapMgr.prototype.reloadMap =
function(mapName) {
	this._fsas[mapName] = DwtKeyMapMgr.__buildFSA({}, this._map[mapName], mapName);
};

/**
 * Returns a list of maps that the given map inherits from.
 *
 * @param {string} mapName Name of the keymap to reload
 */
DwtKeyMapMgr.prototype.getAncestors =
function(mapName, list) {
    list = list || [];
    var subMap = this._fsas[mapName];
    var parents = subMap && subMap.inherit;
    if (parents && parents.length) {
        for (var i = 0; i < parents.length; i++) {
            list.push(parents[i]);
            list = this.getAncestors(parents[i], list);
        }
    }
    return list;
};

/**
 * Returns true if the given element accepts text input.
 * 
 * @param element	[Element]		DOM element
 */
DwtKeyMapMgr.isInputElement =
function(element) {
	if (!element) { return false; }
	// Check designMode in case we're in an HTML editor iframe
	var dm = element.ownerDocument ? element.ownerDocument.designMode : null;
	if (dm && (dm.toLowerCase() == "on")) { return true; }

	var tag = element.tagName.toUpperCase();
	return (tag == "INPUT" || tag == "TEXTAREA");
};

DwtKeyMapMgr.__buildFSA =
function(fsa, mapping, mapName) {
	for (var i in mapping) {
		// check for inheritance from other maps (in CSV list)
		if (i == DwtKeyMap.INHERIT) {
			fsa.inherit = mapping[i].split(/\s*,\s*/);
			continue;
		}
		 
		var keySeq = i.split(DwtKeyMap.SEP);
		var keySeqLen = keySeq.length;
		var tmpFsa = fsa;
		for (var j = 0; j < keySeqLen; j++) {
			var key = keySeq[j];
			//DBG.println(AjxDebug.DBG3, "Processing: " + key);
			
			if (!tmpFsa[key]) {
				tmpFsa[key] = {};	// first time visiting this key
			}

			if (j == keySeqLen - 1) {
				/* We are at the last key in the sequence so we can bind the
				 * action code to it */
				//DBG.println(AjxDebug.DBG3, "BINDING: " + mapping[i]);
				tmpFsa[key].actionCode = mapping[i];
			} else {
				/* We have more keys in the sequence. If our subMap is null,
				 * then we need to create it to hold the new key sequences */
				if (!tmpFsa[key].subMap) {
					tmpFsa[key].subMap = {};
					//DBG.println(AjxDebug.DBG3, "NEW SUBMAP");
				}
					
				tmpFsa = tmpFsa[key].subMap;
			}			
		}
	}
	return fsa;
};

DwtKeyMapMgr.prototype.__getInheritedActionCode =
function(keySeq, mapping, forceActionCode) {
	if (mapping.inherit && mapping.inherit.length) {
		var actionCode = null;
		var len = mapping.inherit.length;
		for (var i = 0; i < len; i++) {
			DBG.println(AjxDebug.DBG3, "checking inherited map: " + mapping.inherit[i]);
			actionCode = this.getActionCode(keySeq, mapping.inherit[i], forceActionCode);
			if (actionCode != null) {
				return actionCode;
			}
		}
	}
	return null;
};

/**
 * Returns true if the given key event has a modifier which makes it nonprintable.
 * 
 * @param ev	[Event]		key event
 */
DwtKeyMapMgr.hasModifier =
function(ev) {
	return (ev.altKey || ev.ctrlKey || ev.metaKey);
};
}
if (AjxPackage.define("ajax.dwt.keyboard.DwtKeyboardMgr")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * Creates an empty keyboard manager. Intended for use as a singleton.
 * @constructor
 * @class
 * This class is responsible for managing focus and shortcuts via the keyboard. That includes dispatching
 * keyboard events (shortcuts), as well as managing tab groups. It is at the heart of the
 * Dwt keyboard navigation framework.
 * <p>
 * {@link DwtKeyboardMgr} intercepts key strokes and translates
 * them into actions which it then dispatches to the component with focus. If the key
 * stroke is a TAB (or Shift-TAB), then focus is moved based on the current tab group.
 * </p><p>
 * A {@link DwtShell} instantiates its own <i>DwtKeyboardMgr</i> at construction.
 * The keyboard manager may then be retrieved via the shell's <code>getKeyboardMgr()</code>
 * function. Once a handle to the shell's keyboard manager is retrieved, then the user is free
 * to add tab groups, and to register keymaps and handlers with the keyboard manager.
 * </p><p>
 * Focus is managed among a stack of tab groups. The TAB button will move the focus within the
 * current tab group. When a non-TAB is received, we first check if the control can handle it.
 * In general, control key events simulate something the user could do with the mouse, and change
 * the state/appearance of the control. For example, ENTER on a DwtButton simulates a button
 * press. If the control does not handle the key event, the event is handed to the application,
 * which handles it based on its current state. The application key event handler is in a sense
 * global, since it does not matter which control received the event.
 * </p><p>
 * At any given time there is a default handler, which is responsible for determining what
 * action is associated with a particular key sequence, and then taking it. A handler should support
 * the following methods:
 * 
 * <ul>
 * <li><i>getKeyMapName()</i> -- returns the name of the map that defines shortcuts for this handler</li>
 * <li><i>handleKeyAction()</i> -- performs the action associated with a shortcut</li>
 * <li><i>handleKeyEvent()</i>	-- optional override; handler solely responsible for handling event</li>
 * </ul>
 * </p>
 *
 * @author Ross Dargahi
 *
 * @param	{DwtShell}	shell		the shell
 * @see DwtShell
 * @see DwtTabGroup
 * @see DwtKeyMap
 * @see DwtKeyMapMgr
 * 
 * @private
 */
DwtKeyboardMgr = function(shell) {

	DwtKeyboardMgr.__shell = shell;

    this.__kbEventStatus = DwtKeyboardMgr.__KEYSEQ_NOT_HANDLED;
    this.__keyTimeout = DwtKeyboardMgr.SHORTCUT_TIMEOUT;

    // focus
    this.__tabGrpStack = [];
    this.__currTabGroup = null;
    this.__tabGroupChangeListenerObj = this.__tabGrpChangeListener.bind(this);

    // shortcuts
    this.__shortcutsEnabled = false;
	this.__defaultHandlerStack = [];
	this.__currDefaultHandler = null;
    this.__killKeySeqTimedAction = new AjxTimedAction(this, this.__killKeySequenceAction);
    this.__killKeySeqTimedActionId = -1;
    this.__keySequence = [];
    this._evtMgr = new AjxEventMgr();

    Dwt.setHandler(document, DwtEvent.ONKEYDOWN, DwtKeyboardMgr.__keyDownHdlr);
    Dwt.setHandler(document, DwtEvent.ONKEYUP, DwtKeyboardMgr.__keyUpHdlr);
    Dwt.setHandler(document, DwtEvent.ONKEYPRESS, DwtKeyboardMgr.__keyPressHdlr);
};

DwtKeyboardMgr.prototype.isDwtKeyboardMgr = true;
DwtKeyboardMgr.prototype.toString = function() { return "DwtKeyboardMgr"; };

DwtKeyboardMgr.SHORTCUT_TIMEOUT = 750;

DwtKeyboardMgr.__KEYSEQ_NOT_HANDLED	= "NOT HANDLED";
DwtKeyboardMgr.__KEYSEQ_HANDLED		= "HANDLED";
DwtKeyboardMgr.__KEYSEQ_PENDING		= "PENDING";

/**
 * Checks if the event may be a shortcut from within an input (text input or
 * textarea). Since printable characters are echoed, the shortcut must be non-printable:
 * 
 * <ul>
 * <li>Alt or Ctrl or Meta plus another key</li>
 * <li>Esc</li>
 * </ul>
 * 
 * @param {DwtKeyEvent}	ev	the key event
 * @return	{boolean}	<code>true</code> if the event may be a shortcut
 */

// Enter and all four arrows can be used as shortcuts in an INPUT
DwtKeyboardMgr.IS_INPUT_SHORTCUT_KEY = AjxUtil.arrayAsHash([
    DwtKeyEvent.KEY_END_OF_TEXT,
    DwtKeyEvent.KEY_RETURN,
    DwtKeyEvent.KEY_ARROW_LEFT,
    DwtKeyEvent.KEY_ARROW_UP,
    DwtKeyEvent.KEY_ARROW_RIGHT,
    DwtKeyEvent.KEY_ARROW_DOWN
]);

// Returns true if the key event has a keycode that could be used in an input (INPUT or TEXTAREA) as a shortcut. That
// excludes printable characters.
DwtKeyboardMgr.isPossibleInputShortcut = function(ev) {

	var target = DwtUiEvent.getTarget(ev);
    return !DwtKeyMap.IS_MODIFIER[ev.keyCode] && (ev.keyCode === DwtKeyEvent.KEY_ESCAPE || DwtKeyMapMgr.hasModifier(ev) ||
			(target && target.nodeName.toLowerCase() == "input" && DwtKeyboardMgr.IS_INPUT_SHORTCUT_KEY[ev.keyCode]));
};

/**
 * Pushes the tab group onto the stack and makes it the active tab group.
 * 
 * @param 	{DwtTabGroup}	tabGroup	the tab group to push onto the stack
 * 
 * @see		#popTabGroup
 */
DwtKeyboardMgr.prototype.pushTabGroup = function(tabGroup, preventFocus) {

    if (!(tabGroup && tabGroup.isDwtTabGroup)) {
        DBG.println(AjxDebug.DBG1, "pushTabGroup() called without a tab group: " + tabGroup);
        return;
    }

	DBG.println(AjxDebug.FOCUS, "PUSH tab group " + tabGroup.getName());
	this.__tabGrpStack.push(tabGroup);
	this.__currTabGroup = tabGroup;
	var focusMember = tabGroup.getFocusMember();
	if (!focusMember) {
		focusMember = tabGroup.resetFocusMember(true);
	}
	if (!focusMember) {
		DBG.println(AjxDebug.FOCUS, "DwtKeyboardMgr.pushTabGroup: tab group " + tabGroup.__name + " has no members!");
		return;
	}
	tabGroup.addFocusChangeListener(this.__tabGroupChangeListenerObj);
	if (!preventFocus) {
		this.grabFocus(focusMember);
	}
};

/**
 * Pops the current tab group off the top of the tab group stack. The previous 
 * tab group (if there is one) then becomes the current tab group.
 * 
 * @param {DwtTabGroup} [tabGroup]		the tab group to pop. If supplied, then the tab group
 * 		stack is searched for the tab group and it is removed. If <code>null</code>, then the
 * 		top tab group is popped.
 * 
 * @return {DwtTabGroup}	the popped tab group or <code>null</code> if there is one or less tab groups
 */
DwtKeyboardMgr.prototype.popTabGroup = function(tabGroup) {

    if (!(tabGroup && tabGroup.isDwtTabGroup)) {
        DBG.println(AjxDebug.DBG1, "popTabGroup() called without a tab group: " + tabGroup);
        return null;
    }

    DBG.println(AjxDebug.FOCUS, "POP tab group " + tabGroup.getName());
	
	// we never want an empty stack
	if (this.__tabGrpStack.length <= 1) {
		return null;
	}
	
	// If we are popping a tab group that is not on the top of the stack then
	// we need to find it and remove it.
	if (tabGroup && this.__tabGrpStack[this.__tabGrpStack.length - 1] != tabGroup) {
		var a = this.__tabGrpStack;
		var len = a.length;
		for (var i = len - 1; i >= 0; i--) {
			if (tabGroup == a[i]) {
				a[i].dump(AjxDebug.DBG1);
				break;
			}
		}
		
		/* If there is no match in the stack for tabGroup, then simply return null,
		 * else if the match is not the top item on the stack, then remove it from 
		 * the stack. Else we are dealing with the topmost item on the stack so handle it 
		 * as a simple pop. */
		if (i < 0) { // No match
			return null;
		} else if (i != len - 1) { // item is not on top
			// Remove tabGroup
			a.splice(i, 1);
			return tabGroup;
		}
	} 

	var tabGroup = this.__tabGrpStack.pop();
	tabGroup.removeFocusChangeListener(this.__tabGroupChangeListenerObj);
	
	var currTg = null;
	if (this.__tabGrpStack.length > 0) {
		currTg = this.__tabGrpStack[this.__tabGrpStack.length - 1];
		var focusMember = currTg.getFocusMember();
		if (!focusMember) {
			focusMember = currTg.resetFocusMember(true);
		}
		if (focusMember) {
			this.grabFocus(focusMember);
		}
	}
	this.__currTabGroup = currTg;

	return tabGroup;
};

/**
 * Replaces the current tab group with the given tab group.
 * 
 * @param {DwtTabGroup} tabGroup 	the tab group to use
 * @return {DwtTabGroup}	the old tab group
 */
DwtKeyboardMgr.prototype.setTabGroup = function(tabGroup) {

	var otg = this.popTabGroup();
	this.pushTabGroup(tabGroup);

	return otg;
};

/**
 * Gets the current tab group
 *
 * @return {DwtTabGroup}	current tab group
 */
DwtKeyboardMgr.prototype.getCurrentTabGroup = function() {

    return this.__currTabGroup;
};

/**
 * Adds a default handler to the stack. A handler should define a 'handleKeyAction' method.
 *
 * @param {Object}  handler     default handler
 */
DwtKeyboardMgr.prototype.pushDefaultHandler = function(handler) {

	if (!this.isEnabled() || !handler) {
        return;
    }
	DBG.println(AjxDebug.FOCUS, "PUSH default handler: " + handler);
		
	this.__defaultHandlerStack.push(handler);
	this.__currDefaultHandler = handler;
};

/**
 * Removes a default handler from the stack.
 *
 * @return {Object}  handler     a default handler
 */
DwtKeyboardMgr.prototype.popDefaultHandler = function() {

	DBG.println(AjxDebug.FOCUS, "POP default handler");
	// we never want an empty stack
	if (this.__defaultHandlerStack.length <= 1) {
        return null;
    }

	DBG.println(AjxDebug.FOCUS, "Default handler stack length: " + this.__defaultHandlerStack.length);
	var handler = this.__defaultHandlerStack.pop();
	this.__currDefaultHandler = this.__defaultHandlerStack[this.__defaultHandlerStack.length - 1];
	DBG.println(AjxDebug.FOCUS, "Default handler is now: " + this.__currDefaultHandler);

	return handler;
};

/**
 * Sets the focus to the given object.
 * 
 * @param {HTMLInputElement|DwtControl|string} focusObj		the object to which to set focus, or its ID
 */ 
DwtKeyboardMgr.prototype.grabFocus = function(focusObj) {

	if (typeof focusObj === "string") {
		focusObj = document.getElementById(focusObj);
	}
    else if (focusObj && focusObj.isDwtTabGroup) {
        focusObj = focusObj.getFocusMember() || focusObj.getFirstMember();
    }

    if (!focusObj) {
        return;
    }

	// Make sure tab group knows what's currently focused
	if (this.__currTabGroup) {
		this.__currTabGroup.setFocusMember(focusObj, false, true);
	}
		
	this.__doGrabFocus(focusObj);
};

/**
 * Tells the keyboard manager that the given control now has focus. That control will handle shortcuts and become
 * the reference point for tabbing.
 *
 * @param {DwtControl|Element}  focusObj    control (or element) that has focus
 */
DwtKeyboardMgr.prototype.updateFocus = function(focusObj, ev) {

    if (!focusObj) {
        return;
    }

    var ctg = this.__currTabGroup;
    if (ctg) {
        this.__currTabGroup.__showFocusedItem(focusObj, "updateFocus");
    }
    var control = focusObj.isDwtControl ? focusObj : DwtControl.findControl(focusObj);

    // Set the keyboard mgr's focus obj, which will be handed shortcuts. It must be a DwtControl.
    if (control) {
        this.__focusObj = control;
        DBG.println(AjxDebug.FOCUS, "DwtKeyboardMgr UPDATEFOCUS kbMgr focus obj: " + control);
    }

    // Update the current (usually root) tab group's focus member to whichever of these it contains: the focus obj,
    // its tab group member, or its control.
    var tgm = this._findTabGroupMember(ev || focusObj);
    if (tgm && ctg) {
        ctg.setFocusMember(tgm, false, true);
    }
};

// Goes up the DOM looking for something (element or control) that is in the current tab group.
DwtKeyboardMgr.prototype._findTabGroupMember = function(obj) {

    var ctg = this.__currTabGroup;
    if (!obj || !ctg) {
        return;
    }

    var htmlEl = (obj.isDwtControl && obj.getHtmlElement()) || DwtUiEvent.getTarget(obj, false) || obj;

    try {
        while (htmlEl) {
            if (ctg.contains(htmlEl)) {
                return htmlEl;
            }
            else {
                var control = DwtControl.ALL_BY_ID[htmlEl.id];
                if (control && ctg.contains(control)) {
                    return control;
                }
                else {
                    var tgm = control && control.getTabGroupMember && control.getTabGroupMember();
                    if (tgm && ctg.contains(tgm)) {
                        return tgm;
                    }
                }
            }
            htmlEl = htmlEl.parentNode;
        }
    } catch(e) {
    }

    return null;
};

/**
 * Gets the object that has focus.
 *
 * @return {HTMLInputElement|DwtControl} focusObj		the object with focus
 */
DwtKeyboardMgr.prototype.getFocusObj = function(focusObj) {

	return this.__focusObj;
};

/**
 * This method is used to register an application key handler. If registered, this
 * handler must support the following methods:
 * <ul>
 * <li><i>getKeyMapName</i>: This method returns a string representing the key map 
 * to be used for looking up actions
 * <li><i>handleKeyAction</i>: This method should handle the key action and return
 * true if it handled it else false. <i>handleKeyAction</i> has two formal parameters
 *    <ul>
 *    <li><i>actionCode</i>: The action code to be handled</li>
 *    <li><i>ev</i>: the {@link DwtKeyEvent} corresponding to the last key event in the sequence</li>
 *    </ul>
 * </ul>
 * 
 * @param 	{function}	hdlr	the handler function. This method should have the following
 * 									signature <code>Boolean hdlr(Int actionCode DwtKeyEvent event);</code>
 * 
 * @see DwtKeyEvent
 */
DwtKeyboardMgr.prototype.registerDefaultKeyActionHandler = function(hdlr) {

	if (this.isEnabled()) {
        this.__defaultKeyActionHdlr = hdlr;
    }
};

/**
 * Registers a keymap with the shell. A keymap typically
 * is a subclass of {@link DwtKeyMap} and defines the mappings from key sequences to
 * actions.
 *
 * @param {DwtKeyMap} keyMap		the key map to register
 * 
 */
DwtKeyboardMgr.prototype.registerKeyMap = function(keyMap) {

	if (this.isEnabled()) {
	    this.__keyMapMgr = new DwtKeyMapMgr(keyMap);
    }
};

/**
 * Sets the timeout (in milliseconds) between key presses for handling multi-keypress sequences.
 * 
 * @param 	{number}	timeout		the timeout (in milliseconds)
 */
DwtKeyboardMgr.prototype.setKeyTimeout = function(timeout) {
	this.__keyTimeout = timeout;
};

/**
 * Clears the key sequence. The next key event will begin a new one.
 * 
 */
DwtKeyboardMgr.prototype.clearKeySeq = function() {

	this.__killKeySeqTimedActionId = -1;
	this.__keySequence = [];
};

/**
 * Enables/disables keyboard nav (shortcuts).
 * 
 * @param 	{boolean}	enabled		if <code>true</code>, enable keyboard nav
 */
DwtKeyboardMgr.prototype.enable = function(enabled) {

	DBG.println(AjxDebug.DBG2, "keyboard shortcuts enabled: " + enabled);
	this.__shortcutsEnabled = enabled;
};

DwtKeyboardMgr.prototype.isEnabled = function() {
	return this.__shortcutsEnabled;
};

/**
 * Adds a global key event listener.
 *
 * @param {constant}	ev			key event type
 * @param {AjxListener}	listener	listener to notify
 */
DwtKeyboardMgr.prototype.addListener = function(ev, listener) {
	this._evtMgr.addListener(ev, listener);
};

/**
 * Removes a global key event listener.
 *
 * @param {constant}	ev			key event type
 * @param {AjxListener}	listener	listener to remove
 */
DwtKeyboardMgr.prototype.removeListener = function(ev, listener) {
	this._evtMgr.removeListener(ev, listener);
};

DwtKeyboardMgr.prototype.__doGrabFocus = function(focusObj) {

	if (!focusObj) {
        return;
    }

    var curFocusObj = this.getFocusObj();
    if (curFocusObj && curFocusObj.blur) {
        DBG.println(AjxDebug.FOCUS, "DwtKeyboardMgr DOGRABFOCUS cur focus obj: " + [curFocusObj, curFocusObj._htmlElId || curFocusObj.id].join(' / '));
        curFocusObj.blur();
    }

    DBG.println(AjxDebug.FOCUS, "DwtKeyboardMgr DOGRABFOCUS new focus obj: " + [focusObj, focusObj._htmlElId || focusObj.id].join(' / '));
    if (focusObj.focus) {
        // focus handler should lead to focus update, but just in case ...
        this.updateFocus(focusObj.focus() || focusObj);
    }
};

/**
 * @private
 */
DwtKeyboardMgr.__keyUpHdlr = function(ev) {

	ev = DwtUiEvent.getEvent(ev);
	DBG.println(AjxDebug.KEYBOARD, "keyup: " + ev.keyCode);

	var kbMgr = DwtKeyboardMgr.__shell.getKeyboardMgr();
	if (kbMgr._evtMgr.notifyListeners(DwtEvent.ONKEYUP, ev) === false) {
		return false;
	}

	// clear saved Gecko key
	if (AjxEnv.isMac && AjxEnv.isGeckoBased && ev.keyCode === 0) {
		return DwtKeyboardMgr.__keyDownHdlr(ev);
	}
    else {
		return DwtKeyboardMgr.__handleKeyEvent(ev);
	}
};

/**
 * @private
 */
DwtKeyboardMgr.__keyPressHdlr = function(ev) {

	ev = DwtUiEvent.getEvent(ev);
	DBG.println(AjxDebug.KEYBOARD, "keypress: " + (ev.keyCode || ev.charCode));

	var kbMgr = DwtKeyboardMgr.__shell.getKeyboardMgr();
	if (kbMgr._evtMgr.notifyListeners(DwtEvent.ONKEYPRESS, ev) === false) {
		return false;
	}

	DwtKeyEvent.geckoCheck(ev);

	return DwtKeyboardMgr.__handleKeyEvent(ev);
};

/**
 * @private
 */
DwtKeyboardMgr.__handleKeyEvent =
function(ev) {

	if (DwtKeyboardMgr.__shell._blockInput) {
        return false;
    }

	ev = DwtUiEvent.getEvent(ev, this);
	DBG.println(AjxDebug.KEYBOARD, [ev.type, ev.keyCode, ev.charCode, ev.which].join(" / "));
	var kbMgr = DwtKeyboardMgr.__shell.getKeyboardMgr();
	var kev = DwtShell.keyEvent;
	kev.setFromDhtmlEvent(ev);

	if (kbMgr.__kbEventStatus != DwtKeyboardMgr.__KEYSEQ_NOT_HANDLED) {
		return kbMgr.__processKeyEvent(ev, kev, false);
	}
};

/**
 * @private
 */
DwtKeyboardMgr.__keyDownHdlr = function(ev) {

	try {

	ev = DwtUiEvent.getEvent(ev, this);
	var kbMgr = DwtKeyboardMgr.__shell.getKeyboardMgr();
	ev.focusObj = null;
	if (kbMgr._evtMgr.notifyListeners(DwtEvent.ONKEYDOWN, ev) === false) {
		return false;
	}

	if (DwtKeyboardMgr.__shell._blockInput) {
        return false;
    }
	DBG.println(AjxDebug.KEYBOARD, [ev.type, ev.keyCode, ev.charCode, ev.which].join(" / "));

	var kev = DwtShell.keyEvent;
	kev.setFromDhtmlEvent(ev);
	var keyCode = DwtKeyEvent.getCharCode(ev);
	DBG.println(AjxDebug.KEYBOARD, "keydown: " + keyCode + " -------- " + ev.target);

	// Popdown any tooltip
	DwtKeyboardMgr.__shell.getToolTip().popdown();

    /********* FOCUS MANAGEMENT *********/

	/* The first thing we care about is the tab key since we want to manage
	 * focus based on the tab groups. 
	 * 
	 * If the tab hit happens in the currently
	 * focused obj, the go to the next/prev element in the tab group. 
	 * 
	 * If the tab happens in an element that is in the tab group hierarchy, but that 
	 * element is not the currently focus element in the tab hierarchy (e.g. the user
	 * clicked in it and we didnt detect it) then sync the tab group's current focus 
	 * element and handle the tab
	 * 
	 * If the tab happens in an object not under the tab group hierarchy, then set
	 * focus to the current focus object in the tab hierarchy i.e. grab back control
	 */
    var ctg = kbMgr.__currTabGroup,
        member;

	if (keyCode == DwtKeyEvent.KEY_TAB) {
	    if (ctg && !DwtKeyMapMgr.hasModifier(kev)) {
			DBG.println(AjxDebug.FOCUS, "Tab");
			// If the tab hit is in an element or if the current tab group has a focus member
			if (ctg.getFocusMember()) {
                member = kev.shiftKey ? ctg.getPrevFocusMember(true) : ctg.getNextFocusMember(true);
			}
            else {
			 	DBG.println(AjxDebug.FOCUS, "DwtKeyboardMgr.__keyDownHdlr: no current focus member, resetting to first in tab group");
			 	// If there is no current focus member, then reset
                member = ctg.resetFocusMember(true);
			}
	    }
        // If we did not handle the Tab, let the browser handle it
        return kbMgr.__processKeyEvent(ev, kev, !member, member ? DwtKeyboardMgr.__KEYSEQ_HANDLED : DwtKeyboardMgr.__KEYSEQ_NOT_HANDLED);
	}
    else if (ctg && AjxEnv.isGecko && kev.target instanceof HTMLHtmlElement) {
	 	/* With FF we focus get set to the <html> element when tabbing in
	 	 * from the address or search fields. What we want to do is capture
	 	 * this here and reset the focus to the first element in the tabgroup
	 	 * 
	 	 * TODO Verify this trick is needed/works with IE/Safari
	 	 */
        member = ctg.resetFocusMember(true);
	}
	 
    // Allow key events to propagate when keyboard manager is disabled (to avoid taking over browser shortcuts). Bugzilla #45469.
    if (!kbMgr.isEnabled()) {
        return true;
    }


    /********* SHORTCUTS *********/

	// Filter out modifier keys. If we're in an input field, filter out legitimate input.
	// (A shortcut from an input field must use a modifier key.)
	if (DwtKeyMap.IS_MODIFIER[keyCode] || (kbMgr.__killKeySeqTimedActionId === -1 &&
		kev.target && DwtKeyMapMgr.isInputElement(kev.target) && !kev.target["data-hidden"] && !DwtKeyboardMgr.isPossibleInputShortcut(kev))) {

	 	return kbMgr.__processKeyEvent(ev, kev, true, DwtKeyboardMgr.__KEYSEQ_NOT_HANDLED);
	}
	 
	/* Cancel any pending time action to kill the keysequence */
	if (kbMgr.__killKeySeqTimedActionId != -1) {
		AjxTimedAction.cancelAction(kbMgr.__killKeySeqTimedActionId);
		kbMgr.__killKeySeqTimedActionId = -1;
	}
		
 	var parts = [];
	if (kev.altKey) 	{ parts.push(DwtKeyMap.ALT); }
	if (kev.ctrlKey) 	{ parts.push(DwtKeyMap.CTRL); }
 	if (kev.metaKey) 	{ parts.push(DwtKeyMap.META); }
	if (kev.shiftKey) 	{ parts.push(DwtKeyMap.SHIFT); }
	parts.push(keyCode);
	kbMgr.__keySequence[kbMgr.__keySequence.length] = parts.join(DwtKeyMap.JOIN);

	DBG.println(AjxDebug.KEYBOARD, "KEYCODE: " + keyCode + " - KEY SEQ: " + kbMgr.__keySequence.join(""));
	
	var handled = DwtKeyboardMgr.__KEYSEQ_NOT_HANDLED;

	// First see if the control that currently has focus can handle the key event
	var obj = ev.focusObj || kbMgr.__focusObj;
    var hasFocus = obj && obj.hasFocus && obj.hasFocus();
    DBG.println(AjxDebug.KEYBOARD, "DwtKeyboardMgr::__keyDownHdlr - focus object " + obj + " has focus: " + hasFocus);
	if (hasFocus && obj.handleKeyAction) {
		handled = kbMgr.__dispatchKeyEvent(obj, kev);
		while ((handled === DwtKeyboardMgr.__KEYSEQ_NOT_HANDLED) && obj.parent) {
			obj = obj.parent;
            if (obj.getKeyMapName) {
			    handled = kbMgr.__dispatchKeyEvent(obj, kev);
            }
		}
	}

	// If the currently focused control didn't handle the event, hand it to the default key event handler
	if (handled === DwtKeyboardMgr.__KEYSEQ_NOT_HANDLED && kbMgr.__currDefaultHandler) {
		handled = kbMgr.__dispatchKeyEvent(kbMgr.__currDefaultHandler, kev);
	}

	// see if we should let browser handle the event as well; note that we need to set the 'handled' var rather than
	// just the 'propagate' one below, since the keyboard mgr isn't built for both it and the browser to handle the event.
	if (kev.forcePropagate) {
		handled = DwtKeyboardMgr.__KEYSEQ_NOT_HANDLED;
		kev.forcePropagate = false;
	}
	
	kbMgr.__kbEventStatus = handled;
	var propagate = (handled == DwtKeyboardMgr.__KEYSEQ_NOT_HANDLED);

	if (handled != DwtKeyboardMgr.__KEYSEQ_PENDING) {
		kbMgr.clearKeySeq();
	}

	return kbMgr.__processKeyEvent(ev, kev, propagate);

	} catch (ex) {
		AjxException.reportScriptError(ex);
	}
};

/**
 * Handles event dispatching
 * 
 * @private
 */
DwtKeyboardMgr.prototype.__dispatchKeyEvent = function(hdlr, ev, forceActionCode) {

	if (hdlr && hdlr.handleKeyEvent) {
		var handled = hdlr.handleKeyEvent(ev);
		return handled ? DwtKeyboardMgr.__KEYSEQ_HANDLED : DwtKeyboardMgr.__KEYSEQ_NOT_HANDLED;
	}

	var mapName = (hdlr && hdlr.getKeyMapName) ? hdlr.getKeyMapName() : null;
	if (!mapName) {
		return DwtKeyboardMgr.__KEYSEQ_NOT_HANDLED;
	}

	DBG.println(AjxDebug.KEYBOARD, "DwtKeyboardMgr.__dispatchKeyEvent: handler " + hdlr.toString() + " handling " + this.__keySequence + " for map: " + mapName);
	var actionCode = this.__keyMapMgr.getActionCode(this.__keySequence, mapName, forceActionCode);
	if (actionCode === DwtKeyMapMgr.NOT_A_TERMINAL) {
		DBG.println(AjxDebug.KEYBOARD, "scheduling action to kill key sequence");
		/* setup a timed action to redispatch/kill the key sequence in the event
		 * the user does not press another key in the allotted time */
		this.__hdlr = hdlr;
		this.__mapName = mapName;
		this.__ev = ev;
		this.__killKeySeqTimedActionId = AjxTimedAction.scheduleAction(this.__killKeySeqTimedAction, this.__keyTimeout);
		return DwtKeyboardMgr.__KEYSEQ_PENDING;	
	}
    else if (actionCode != null) {
		/* It is possible that the component may not handle a valid action
		 * particulary actions defined in the default map */
		DBG.println(AjxDebug.KEYBOARD, "DwtKeyboardMgr.__dispatchKeyEvent: handling action: " + actionCode);
		if (!hdlr.handleKeyAction) {
			return DwtKeyboardMgr.__KEYSEQ_NOT_HANDLED;
		}
		var result = hdlr.handleKeyAction(actionCode, ev);
		return result ? DwtKeyboardMgr.__KEYSEQ_HANDLED : DwtKeyboardMgr.__KEYSEQ_NOT_HANDLED;
	}
    else {
		DBG.println(AjxDebug.KEYBOARD, "DwtKeyboardMgr.__dispatchKeyEvent: no action code for " + this.__keySequence);
		return DwtKeyboardMgr.__KEYSEQ_NOT_HANDLED;
	}
};

/**
 * This method will reattempt to handle the event in the case that the intermediate
 * node in the keymap may have an action code associated with it.
 * 
 * @private
 */
DwtKeyboardMgr.prototype.__killKeySequenceAction = function() {

	DBG.println(AjxDebug.KEYBOARD, "DwtKeyboardMgr.__killKeySequenceAction: " + this.__mapName);
	this.__dispatchKeyEvent(this.__hdlr, this.__ev, true);
	this.clearKeySeq();
};

/**
 * @private
 */
DwtKeyboardMgr.prototype.__tabGrpChangeListener = function(ev) {
	this.__doGrabFocus(ev.newFocusMember);
};

/**
 * @private
 */
DwtKeyboardMgr.prototype.__processKeyEvent = function(ev, kev, propagate, status) {

	if (status) {
		this.__kbEventStatus = status;
	}
	kev._stopPropagation = !propagate;
	kev._returnValue = propagate;
	kev.setToDhtmlEvent(ev);
	DBG.println(AjxDebug.KEYBOARD, "key event returning: " + propagate);
	return propagate;
};
}
if (AjxPackage.define("ajax.dwt.keyboard.DwtTabGroup")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * Creates an empty tab group.
 * @constructor
 * @class
 * A tab group is used to manage keyboard focus among a group of related visual 
 * elements. It is a tree structure consisting of elements and other tab groups.
 * <p>
 * The root tab group is the only one without a parent tab group, and is the one
 * that the application interacts with. Focus listeners register with the root
 * tab group. The root tab group tracks where focus is.
 * 
 * @param {string}	name					the name of this tab group
 *
 * @author Ross Dargahi
 */
DwtTabGroup = function(name) {

	this.__members = new AjxVector();
	this.__parent = null;
	this.__name = name;
	this.__currFocusMember = null;
	this.__evtMgr = new AjxEventMgr();

    DwtTabGroup.BY_NAME[name] = this;
};

DwtTabGroup.prototype.isDwtTabGroup = true;
DwtTabGroup.prototype.toString = function() { return "DwtTabGroup"; };



/** 
 * Exception string that is thrown when an operation is attempted
 * on a non-root tab group.
 */
DwtTabGroup.NOT_ROOT_TABGROUP = "NOT ROOT TAB GROUP";

DwtTabGroup.__changeEvt = new DwtTabGroupEvent();

// Allow static access to any tab group by its name
DwtTabGroup.getByName = function(name) {
    return DwtTabGroup.BY_NAME[name];
};
DwtTabGroup.BY_NAME = {};

/**
 * Gets the name of this tab group.
 * 
 * @return	{string}	the tab group name
 */
DwtTabGroup.prototype.getName = function() {
	return this.__name;
};

/**
 * Adds a focus change listener to the root tab group. The listener is called
 * when the focus member changes. Note that the focus member hasn't actually
 * been focused yet - only its status within the tab group has changed. It is
 * up to the listener to implement the appropriate focus action.
 * 
 * @param {AjxListener} listener	a listener
 * 
 * @throws DwtTabGroup.NOT_ROOT_TABGROUP
 */
DwtTabGroup.prototype.addFocusChangeListener = function(listener) {

	this.__checkRoot();		
	this.__evtMgr.addListener(DwtEvent.STATE_CHANGE, listener);
};

/**
 * Removes a focus change listener from the root tab group.
 * 
 * @param {AjxListener} listener	a listener
 * 
 * @throws DwtTabGroup.NOT_ROOT_TABGROUP
 */
DwtTabGroup.prototype.removeFocusChangeListener = function(listener) {

	this.__checkRoot();		
	this.__evtMgr.removeListener(DwtEvent.STATE_CHANGE, listener);
};

/**
 * Adds a member to the tab group.
 * 
 * @param {Array|DwtControl|DwtTabGroup|HTMLElement} member	the member(s) to be added
 * @param {number} [index] 		the index at which to add the member. If omitted, the member
 * 		will be added to the end of the tab group
 */
DwtTabGroup.prototype.addMember = function(member, index) {

    index = (index != null) ? index : this.__members.size();
    var members = AjxUtil.collapseList(AjxUtil.toArray(member));

	for (var i = 0, len = members.length; i < len; i++) {
        var member = members[i];
        this.__members.add(member, index + i);
        // If adding a tab group, register me as its parent
        if (member.isDwtTabGroup) {
            member.newParent(this);
        }
	}
};

/**
 * Resets all members of the tab group to the given arguments.
 * 
 * @param {Array|DwtControl|DwtTabGroup|HTMLElement} members	the member(s) for the tab group
 */
DwtTabGroup.prototype.setMembers = function(members) {
	this.removeAllMembers();
	this.addMember(members);
};

/**
 * Adds a member to the tab group, positioned after another member.
 * 
 * @param {DwtControl|DwtTabGroup|HTMLElement} member 		the member to be added
 * @param {DwtControl|DwtTabGroup|HTMLElement} afterMember 	the member after which to add <code>member</code>
 */
DwtTabGroup.prototype.addMemberAfter = function(newMember, afterMember) {

	this.addMember(newMember, this.__indexOfMember(afterMember) + 1);
};

/**
 * Adds a member to the tab group, positioned before another member.
 * 
 * @param {DwtControl|DwtTabGroup|HTMLElement} member 		the member to be added
 * @param {DwtControl|DwtTabGroup|HTMLElement} beforeMember 	the member before which to add <code>member</code>
 */
DwtTabGroup.prototype.addMemberBefore = function(newMember, beforeMember) {

	this.addMember(newMember, this.__indexOfMember(beforeMember));
};

/**
 * This method removes a member from the tab group. If the member being removed
 * is currently the focus member, then we will try to set focus to the
 * previous member. If that fails, we will try the next member.
 * 
 * @param {DwtControl|DwtTabGroup|HTMLElement} member 	the member to be removed
 * @param {boolean} [checkEnabled] 		if <code>true</code>, then make sure that if we have a newly focused member it is enabled
 * @param {boolean} [skipNotify] 		if <code>true</code>, notification is not fired. This flag typically set by Dwt tab management framework when it is calling into this method
 * @return {DwtControl|DwtTabGroup|HTMLElement}	the removed member or <code>null</code> if <code>oldMember</code> is not in the tab groups hierarchy
 */
DwtTabGroup.prototype.removeMember = function(member, checkEnabled, skipNotify) {

	return this.replaceMember(member, null, checkEnabled, skipNotify);
};

/**
 * Removes all members.
 * 
 */
DwtTabGroup.prototype.removeAllMembers = function() {

	this.__members.removeAll();
};

/**
 * This method replaces a member in the tab group with a new member. If the member being
 * replaced is currently the focus member, then we will try to set focus to the
 * previous member. If that fails, we will try the next member.
 * 
 * @param {DwtControl|DwtTabGroup|HTMLElement} oldMember 	the member to be replaced
 * @param {DwtControl|DwtTabGroup|HTMLElement} newMember 	the replacing member
 * 		If this parameter is <code>null</code>, then this method effectively removes <code>oldMember</code>
 * @param {boolean} [checkEnabled] 	if <code>true</code>, then make sure that if we have a newly focused
 * 		member it is enabled
 * @param {boolean} [skipNotify] if <code>true</code>, notification is not fired. This flag is
 * 		typically set by the tab management framework when it is calling into this method
 * @return {DwtControl|DwtTabGroup|HTMLElement}	replaced member or <code>null></code> if <code>oldMember</code> is not in the tab group
 */
DwtTabGroup.prototype.replaceMember = function(oldMember, newMember, checkEnabled, skipNotify, focusItem, noFocus) {

	var tg = this.__getTabGroupForMember(oldMember);
	if (!tg) {
		this.addMember(newMember);
		return null;
	}

	/* If we are removing the current focus member, then we need to adjust the focus
	 * member index. If the tab group is empty as a result of the removal
	 */
	var root = this.__getRootTabGroup();
	var newFocusMember;
	if (focusItem) {
		newFocusMember = focusItem;
	}
    else if (root.__currFocusMember === oldMember || (oldMember && oldMember.isDwtTabGroup && oldMember.contains(root.__currFocusMember))) {
		if (newMember) {
			newFocusMember = (newMember.isDwtTabGroup) ? newMember.getFirstMember() : newMember;
		}
        else {
			newFocusMember = this.__getPrevMember(oldMember, checkEnabled);
			if (!newFocusMember) {
				newFocusMember =  this.__getNextMember(oldMember, checkEnabled);
			}
		}
	}

	if (newFocusMember && !noFocus) {
		root.__currFocusMember = newFocusMember;
		this.__showFocusedItem(this.__currFocusMember, "replaceMember");
		if (!skipNotify) {
			this.__notifyListeners(newFocusMember);
		}
	}

	if (newMember && newMember.isDwtTabGroup) {
		newMember.newParent(this);
	}
		
	return newMember ? this.__members.replaceObject(oldMember, newMember) : this.__members.remove(oldMember);
};

/**
 * Returns true if this tab group contains <code>member</code>.
 * 
 * @param {DwtControl|DwtTabGroup|HTMLElement} member	the member for which to search
 * 
 * @return {boolean}	<code>true</code> if the tab group contains member
 */
DwtTabGroup.prototype.contains = function(member) {

	return !!this.__getTabGroupForMember(member);
};

/**
 * Sets a new parent for this tab group.
 * 
 * @param {DwtTabGroup} newParent 	the new parent. If the parent is <code>null</code>, then this tabGroup is the root tab group.
 */
DwtTabGroup.prototype.newParent = function(newParent) {

	this.__parent = newParent;
};

/**
 * Gets the first member of the tab group.
 * 
 * @param {boolean} [checkEnabled]		if <code>true</code>, then return first enabled member
 *
 * @return {DwtControl|HTMLElement}	the first member of the tab group
 */
DwtTabGroup.prototype.getFirstMember = function(checkEnabled) {

	return this.__getLeftMostMember(checkEnabled);
};

/**
 * Gets the last member of the tab group.
 * 
 * @param {boolean} [checkEnabled]		if <code>true</code>, then return last enabled member
 *
 * @return {DwtControl|HTMLElement}	the last member of the tab group
 */
DwtTabGroup.prototype.getLastMember = function(checkEnabled) {

	return this.__getRightMostMember(checkEnabled);
};
 
/**
 * Returns the current focus member.
 * 
 * @return {DwtControl|HTMLElement}	current focus member
 * 
 * @throws DwtTabGroup.NOT_ROOT_TABGROUP
 */
DwtTabGroup.prototype.getFocusMember = function(){

	this.__checkRoot();
	return this.__currFocusMember;
};

/**
 * Sets the current focus member. 
 * 
 * @param {DwtControl|HTMLElement} member 		the member to which to set focus
 * @param {boolean} [checkEnabled] 	if <code>true</code>, then make sure the member is enabled
 * @param {boolean} [skipNotify] if <code>true</code>, notification is not fired. This flag
 * 		typically set by Dwt tab management framework when it is calling into this method
 * 
 * @return {boolean}	<code>true</code> if member was part of the tab group hierarchy, else false
 *
 * @throws DwtTabGroup.NOT_ROOT_TABGROUP
 */
DwtTabGroup.prototype.setFocusMember = function(member, checkEnabled, skipNotify) {

    if (!member) {
        return false;
    }

    if (member.isDwtTabGroup) {
        DBG.println(AjxDebug.FOCUS, "DwtTabGroup SETFOCUSMEMBER to a DwtTabGroup: " + member + " / " + member.getName());
        member = member.getFocusMember() || member.getFirstMember();
    }
	this.__checkRoot();	
	if (!this.__checkEnabled(member, checkEnabled)) {
		return false;
	}

	if (this.contains(member)) {
		this.__currFocusMember = member;
		this.__showFocusedItem(this.__currFocusMember, "setFocusMember");
		if (!skipNotify) {
			this.__notifyListeners(this.__currFocusMember);
		}
		return true;	
	}

	return false;
};

/**
 * This method sets and returns the next focus member in this tab group. If there is no next
 * member, sets and returns the first member in the tab group.
 * 
 * @param {boolean} [checkEnabled] 	if <code>true</code>, get the next enabled member
 * @param {boolean} [skipNotify] if <code>true</code>, notification is not fired. This flag
 * 		typically set by {@link Dwt} tab management framework when it is calling into this method
 * 
 * @return {DwtControl|HTMLElement}	new focus member or <code>null</code> if there is no focus member or if the focus
 * 		member has not changed (i.e. only one member in the tabgroup)
 *
 * @throws DwtTabGroup.NOT_ROOT_TABGROUP
 */
DwtTabGroup.prototype.getNextFocusMember = function(checkEnabled, skipNotify) {

	this.__checkRoot();		
	return this.__setFocusMember(true, checkEnabled, skipNotify);
};

/**
 * This method sets and returns the previous focus member in this tab group. If there is no
 * previous member, sets and returns the last member in the tab group.
 * 
 * @param {boolean} [checkEnabled] 	if <code>true</code>, get the previously enabled member
 * @param {boolean} [skipNotify] if <code>true</code>, notification is not fired. This flag
 * 		typically set by Dwt tab management framework when it is calling into this method
 * 
 * @return {DwtControl|HTMLElement}	new focus member or <code>null</code> if there is no focus member or if the focus
 * 		member has not changed (i.e. only one member in the tabgroup)
 *
 * @throws DwtTabGroup.NOT_ROOT_TABGROUP
 */
DwtTabGroup.prototype.getPrevFocusMember = function(checkEnabled, skipNotify) {

	this.__checkRoot();		
	return this.__setFocusMember(false, checkEnabled, skipNotify);
};

/**
 * Resets the the focus member to the first element in the tab group.
 * 
 * @param {boolean} [checkEnabled] 	if <code>true</code>, then pick a enabled member to which to set focus
 * @param {boolean} [skipNotify] if <code>true</code>, notification is not fired. This flag
 * 		typically set by Dwt tab management framework when it is calling into this method
 * 
 * @return {DwtControl|HTMLElement}	the new focus member
 *
 * @throws DwtTabGroup.NOT_ROOT_TABGROUP
 */
DwtTabGroup.prototype.resetFocusMember = function(checkEnabled, skipNotify) {

	this.__checkRoot();
	var focusMember = this.__getLeftMostMember(checkEnabled);
	if ((focusMember != this.__currFocusMember) && !skipNotify) {
		this.__notifyListeners(this.__currFocusMember);
	}
	this.__showFocusedItem(this.__currFocusMember, "resetFocusMember");
    DBG.println(AjxDebug.FOCUS, "DwtTabGroup RESETFOCUSMEMBER: " + focusMember);
	this.__currFocusMember = focusMember;
	
	return this.__currFocusMember;
};

/**
 * Pretty-prints the contents of the tab group to the browser console or the
 * debug window.
 *
 * @param {number} [debugLevel]     if specified, dump to the debug window
 *                                  at the given level.
 */
DwtTabGroup.prototype.dump = function(debugLevel) {

	if (debugLevel) {
		if (!window.AjxDebug || !window.DBG) {
			return;
		}

		var logger = function(s) {
			var s = AjxStringUtil.convertToHtml(s);
			DBG.println(debugLevel, s);
		}

		DwtTabGroup.__dump(this, logger, 0);
	} else if (window.console && window.console.log) {
		var r = [];
		DwtTabGroup.__dump(this, r.push.bind(r), 0);
		console.log(r.join('\n'));
	}
};

/**
 * Gets the size of the group.
 * 
 * @return	{number}	the size
 */
DwtTabGroup.prototype.size = function() {

	return this.__members.size();
};

/**
 * Returns the previous member in the tag group.
 * 
 * @private
 */
DwtTabGroup.prototype.__getPrevMember = function(member, checkEnabled) {

	var a = this.__members.getArray();

	// Start working from the member to the immediate left, then keep going left
	for (var i = this.__lastIndexOfMember(member) - 1; i > -1; i--) {
		var prevMember = a[i];
		/* if sibling is not a tab group, then it is the previous child. If the
		 * sibling is a tab group, get its rightmost member.*/
		if (!prevMember.isDwtTabGroup) {
			if (this.__checkEnabled(prevMember, checkEnabled)) {
				return prevMember;
			}
		} else {
			prevMember = prevMember.__getRightMostMember(checkEnabled);
			if (this.__checkEnabled(prevMember, checkEnabled)) {
				return prevMember;
			}
		}
	}

	/* If we have fallen through to here it is because the tab group only has 
	 * one member. So we roll up to the parent, unless we are at the root in 
	 * which case we return null. */
	return this.__parent ? this.__parent.__getPrevMember(this, checkEnabled) : null;
};

/**
 * Returns true if the given member can accept focus, or if there is no need to check.
 * If we are checking, the member must be enabled and visible if it is a control, and
 * enabled otherwise. A member may also set the "noTab" flag to take itself out of the
 * tab hierarchy.
 * 
 * @private
 */
DwtTabGroup.prototype.__checkEnabled = function(member, checkEnabled) {

	if (!checkEnabled) {
		return true;
	}

	if (!member || member.noTab) {
		return false;
	}

	if (member.isDwtControl ? !member.getEnabled() : member.disabled) {
		return false;
	}

	if (member.isDwtControl) {
		member = member.getHtmlElement();
	}

	var loc = Dwt.getLocation(member);
	if (loc.x === null || loc.y === null || loc.x === Dwt.LOC_NOWHERE || loc.y === Dwt.LOC_NOWHERE) {
		return false;
	}

	var size = Dwt.getSize(member);
	if (!size || size.x === 0 || size.y === 0) {
		return false;
	}

	if (member.nodeName && member.nodeName.toLowerCase() === "body") {
		return true;
	}
	return (Dwt.getZIndex(member, true) > Dwt.Z_HIDDEN &&
	        Dwt.getVisible(member) && Dwt.getVisibility(member));
};

DwtTabGroup.prototype.__indexOfMember = function(member) {

    return this.__members.indexOf(member);
};

DwtTabGroup.prototype.__lastIndexOfMember = function(member) {

    return this.__members.lastIndexOf(member);
};

/**
 * Sets and returns the next member in the tag group.
 * 
 * @private
 */
DwtTabGroup.prototype.__getNextMember = function(member, checkEnabled) {

	var a = this.__members.getArray();
	var sz = this.__members.size();

	// Start working from the member rightwards
	for (var i = this.__indexOfMember(member) + 1; i < sz; i++) {
		var nextMember = a[i];
		/* if sibling is not a tab group, then it is the next child. If the
		 * sibling is a tab group, get its leftmost member.*/
		if (!nextMember.isDwtTabGroup) {
			if (this.__checkEnabled(nextMember, checkEnabled)) {
				return nextMember;
			}
		}
        else {
			nextMember = nextMember.__getLeftMostMember(checkEnabled);
			if (this.__checkEnabled(nextMember, checkEnabled)) {
				return nextMember;
			}
		}
	}

	/* If we have fallen through to here it is because the tab group only has 
	 * one member or we are at the end of the list. So we roll up to the parent, 
	 * unless we are at the root in which case we return null. */
	return this.__parent ? this.__parent.__getNextMember(this, checkEnabled) : null;
};

/**
 * Finds the rightmost member of the tab group. Will recurse down
 * into contained tab groups if necessary.
 * @private
 */
DwtTabGroup.prototype.__getRightMostMember = function(checkEnabled) {

	var a = this.__members.getArray();
	var member = null;
	
	/* Work backwards from the rightmost member. If the member is a tab group, then
	 * recurse into it. If member is not a tab group, return it as it is the 
	 * rightmost element. */
	for (var i = this.__members.size() - 1; i >= 0; i--) {
		member = a[i]
		if (!member.isDwtTabGroup) {
			if (this.__checkEnabled(member, checkEnabled)) {
                break;
            }
		}
        else {
			member = member.__getRightMostMember(checkEnabled);
			if (this.__checkEnabled(member, checkEnabled)) {
                break;
            }
		}
	}

	return this.__checkEnabled(member, checkEnabled) ? member : null;
};

/**
 *  Finds the leftmost member of the tab group. Will recurse down
 * into contained tab groups if necessary.
 * @private
 */
DwtTabGroup.prototype.__getLeftMostMember = function(checkEnabled) {

	var sz = this.__members.size();
	var a = this.__members.getArray();
	var member = null;

	/* Work forwards from the leftmost member. If the member is a tabgroup, then
	 * recurse into it. If member is not a tabgroup, return it as it is the 
	 * rightmost element */
	for (var i = 0; i < sz; i++) {
		member = a[i]
		if (!member.isDwtTabGroup) {
			if  (this.__checkEnabled(member, checkEnabled)) {
                break;
            }
		}
        else {
			member = member.__getLeftMostMember(checkEnabled);
			if (this.__checkEnabled(member, checkEnabled)) {
                break;
            }
		}
	}

	return this.__checkEnabled(member, checkEnabled) ? member : null;
};

/**
 * Notifies focus change listeners.
 * @private
 */
DwtTabGroup.prototype.__notifyListeners = function(newFocusMember) {

	// Only the root tab group will issue notifications
	var rootTg = this.__getRootTabGroup();
	if (rootTg.__evtMgr) {
		var evt = DwtTabGroup.__changeEvt;
		evt.reset();
		evt.tabGroup = this;
		evt.newFocusMember = newFocusMember;
		rootTg.__evtMgr.notifyListeners(DwtEvent.STATE_CHANGE, evt);
	}
};

/**
 * @private
 */
DwtTabGroup.prototype.__getRootTabGroup = function() {

	var root = this;
	while (root.__parent) {
		root = root.__parent;
	}
	
	return root;
}

DwtTabGroup.DUMP_INDENT = '|\t';

/**
 * @private
 */
DwtTabGroup.__dump = function(tg, logger, level) {

	var myIndent = AjxStringUtil.repeat(DwtTabGroup.DUMP_INDENT, level);

	logger(myIndent + "TABGROUP: " + tg.__name);

	myIndent += DwtTabGroup.DUMP_INDENT;

	var sz = tg.__members.size();
	var a = tg.__members.getArray();
	for (var i = 0; i < sz; i++) {
        var m = a[i];
		if (m.isDwtTabGroup) {
			DwtTabGroup.__dump(m, logger, level + 1);
		}
        else {
			var desc = m.nodeName ? [ m.nodeName, m.id, m.className ].join(' ') : [ String(m), m._htmlElId ].join(' ');
			if (m.noTab) {
				desc += ' - no tab!';
			}
			logger(myIndent + desc);
		}
	}
};

/**
 * Sets the next or previous focus member.
 * @private
 */
DwtTabGroup.prototype.__setFocusMember = function(next, checkEnabled, skipNotify) {

	// If there is currently no focus member, then reset to the first member and return
	if (!this.__currFocusMember) {
		return this.resetFocusMember(checkEnabled, skipNotify);
	}
	
	var tabGroup = this.__getTabGroupForMember(this.__currFocusMember);
	if (!tabGroup) {
		DBG.println(AjxDebug.DBG1, "tab group not found for focus member: " + this.__currFocusMember);
		return null;
	}
	var m = next ? tabGroup.__getNextMember(this.__currFocusMember, checkEnabled)
				 : tabGroup.__getPrevMember(this.__currFocusMember, checkEnabled);

	if (!m) {
        // wrap around
		m = next ? this.__getLeftMostMember(checkEnabled)
				 : this.__getRightMostMember(checkEnabled);

		// Test for the case where there is only one member in the tabgroup
		if (m == this.__currFocusMember) {
			return null;
		}
	}

	this.__currFocusMember = m;
	
	this.__showFocusedItem(this.__currFocusMember, "__setFocusMember");
	if (!skipNotify) {
		this.__notifyListeners(this.__currFocusMember);
	}
	
	return this.__currFocusMember;
};

/**
 * Returns the tab group from within this tab group's hierarchy that contains the given member. Traverses the tree top-down.
 *
 * @private
 */
DwtTabGroup.prototype.__getTabGroupForMember = function(member) {

	if (!member) {
        return null;
    }

    var a = this.__members.getArray(),
        ln = a.length, i, m;

	for (i = 0; i < ln; i++) {
		m = a[i];
		if (m === member) {
			return this;
		}
        else if (m.isDwtTabGroup && (m = m.__getTabGroupForMember(member))) {
			return m;
		}
	}
	return null;
};

/**
 * Throws an exception if this is not the root tab group.
 * 
 * @private
 */
DwtTabGroup.prototype.__checkRoot = function() {

	if (this.__parent) {
        DBG.println(AjxDebug.DBG1, "DwtTabGroup NOT_ROOT_TABGROUP: " + this.getName());
//		throw DwtTabGroup.NOT_ROOT_TABGROUP;
	}
};

// Prints out a debug line describing the currently focused member
DwtTabGroup.prototype.__showFocusedItem = function(item, caller) {

	if (item && window.AjxDebug && window.DBG) {
		var callerText = caller ? "DwtTabGroup." + caller + ": " : "",
			idText = " [" + (item.isDwtControl ? item._htmlElId : item.id) + "] ",
            itemText = (item.nodeName || item) + " " + idText,
			otherText = (item.getTitle && item.getTitle()) || (item.getText && item.getText()) || "",
			fullText = itemText + otherText;

		DBG.println(AjxDebug.FOCUS, callerText + "current focus member is now " + itemText);
		DBG.println(AjxDebug.FOCUS1, "Focus: " + fullText);
	}
};
}

if (AjxPackage.define("ajax.dwt.dnd.DwtDragEvent")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * @constructor
 * @class
 * DwtDragEvent is generated by the Drag and Drop framework when a drag operation is
 * in process. The drag event is dispatched to the registered {@link DwtDragSource} instance.
 * 
 * @author Ross Dargahi
 * 
 * @see DwtDragSource
 */
DwtDragEvent = function() {
	/**
	 * Type of drag operation. One of:
	 * <ul>
	 * <li>{@link DwtDragEvent.DRAG_START}</li>
	 * <li>{@link DwtDragEvent.SET_DATA}</li>
	 * <li>{@link DwtDragEvent.DRAG_END}</li>
	 * </ul>
	 */
	this.operation = null;
	
	/**
	 * Drag source control
	 * @type DwtControl
	 */
	this.srcControl = null;
	
	/**
	 * Action being performed. One of:
	 * <ul>
	 * <li>{@link Dwt.DND_DROP_NONE}</li>
	 * <li>{@link Dwt.DND_DROP_COPY}</li>
	 * <li>{@link Dwt.DND_DROP_MOVE}</li>
	 * </ul>
	 */
	this.action = null;
	
	/**
	 * Whether the DnD framework should perform the operation. The application is
	 * responsible for setting this value based on whatever business logic it is
	 * implementing
	 * @type boolean
	 */
	this.doIt = false;
	
	/**
	 * Drag source data. This is the application data associated with the item being dragged.
	 */
	this.srcData = null;
};

/**
 * Drag initialization.
 */
DwtDragEvent.DRAG_INIT = "INIT";

/**
 * Drag is starting.
 */
DwtDragEvent.DRAG_START = "START";

/**
 * Set the <code>srcData</code> field of the event.
 */
DwtDragEvent.SET_DATA = "SET_DATA";

/**
 * Drag movement has occurred.
 */
DwtDragEvent.DRAG_MOVE = "MOVE";

/**
 * Drag has ended.
 */
DwtDragEvent.DRAG_END = "END";

/**
 * Drag canceled (i.e. dropped on invalid target).
 */
DwtDragEvent.DRAG_CANCEL = "CANCEL";
}
if (AjxPackage.define("ajax.dwt.dnd.DwtDragSource")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * @constructor
 * @class
 * A drag source is registered with a control to indicate that the control is 
 * draggable. The drag source is the mechanism by which the DnD framework provides 
 * the binding between the UI components and the application.
 * <p>
 * Application developers instantiate {@link DwtDragSource} and register it with the control
 * which is to be draggable (via {@link DwtControl.setDragSource}). The
 * application should then register a listener with the {@link DwtDragSource}. This way
 * when drag events occur the application will be notified and may act on them 
 * accordingly
 * </p>
 * 
 * @author Ross Dargahi
 * 
 * @param {number} supportedOps 	the supported operations. This is an arithmetic OR'ing of
 * 		the operations supported by the drag source. Supported values are:
 * 		<ul>
 * 			<li>{@link Dwt.DND_DROP_NONE}</li>
 * 			<li>{@link Dwt.DND_DROP_COPY}</li>
 * 			<li>{@link Dwt.DND_DROP_MOVE}</li>
 * 		</ul> 
 * 
 * @see DwtDragEvent
 * @see DwtControl
 * @see DwtControl#setDragSource
 */
DwtDragSource = function(supportedOps) {
	this.__supportedOps = supportedOps
	this.__evtMgr = new AjxEventMgr();
};

/** @private */
DwtDragSource.__DRAG_LISTENER = "DwtDragSource.__DRAG_LISTENER";

/** @private */
DwtDragSource.__dragEvent = new DwtDragEvent();

/**
 * Returns a string representation of this object.
 * 
 * @return {string}	a string representation of this object
 */
DwtDragSource.prototype.toString = 
function() {
	return "DwtDragSource";
};


/**
 * Registers a listener for <i>DwtDragEvent</i> events.
 *
 * @param {AjxListener} dragSourceListener Listener to be registered 
 * 
 * @see DwtDragEvent
 * @see AjxListener
 * @see #removeDragListener
 */
DwtDragSource.prototype.addDragListener =
function(dragSourceListener) {
	this.__evtMgr.addListener(DwtDragSource.__DRAG_LISTENER, dragSourceListener);
};

/**
 * Removes a registered event listener.
 * 
 * @param {AjxListener} dragSourceListener Listener to be removed
 * 
 * @see AjxListener
 * @see #addDragListener
 */
DwtDragSource.prototype.removeDragListener =
function(dragSourceListener) {
	this.__evtMgr.removeListener(DwtDragSource.__DRAG_LISTENER, dragSourceListener);
};

// The following methods are called by DwtControl during the drag lifecycle 

/** @private */
DwtDragSource.prototype._beginDrag =
function(operation, srcControl) {
	if (!(this.__supportedOps & operation))
		return Dwt.DND_DROP_NONE;
		
	DwtDragSource.__dragEvent.operation = operation;
	DwtDragSource.__dragEvent.srcControl = srcControl;
	DwtDragSource.__dragEvent.action = DwtDragEvent.DRAG_START;
	DwtDragSource.__dragEvent.srcData = null;
	DwtDragSource.__dragEvent.doit = true;
	this.__evtMgr.notifyListeners(DwtDragSource.__DRAG_LISTENER, DwtDragSource.__dragEvent);
	return DwtDragSource.__dragEvent.operation;
};

/** @private */
DwtDragSource.prototype._getData =
function() {
	DwtDragSource.__dragEvent.action = DwtDragEvent.SET_DATA;
	this.__evtMgr.notifyListeners(DwtDragSource.__DRAG_LISTENER, DwtDragSource.__dragEvent);
	return DwtDragSource.__dragEvent.srcData;
};

/** @private */
DwtDragSource.prototype._endDrag =
function() {
	DwtDragSource.__dragEvent.action = DwtDragEvent.DRAG_END;
	DwtDragSource.__dragEvent.doit = false;
	this.__evtMgr.notifyListeners(DwtDragSource.__DRAG_LISTENER, DwtDragSource.__dragEvent);
	return DwtDragSource.__dragEvent.doit;
};

/** @private */
DwtDragSource.prototype._cancelDrag =
function() {
	DwtDragSource.__dragEvent.action = DwtDragEvent.DRAG_CANCEL;
	DwtDragSource.__dragEvent.doit = false;
	this.__evtMgr.notifyListeners(DwtDragSource.__DRAG_LISTENER, DwtDragSource.__dragEvent);
	return DwtDragSource.__dragEvent.doit;
};
}
if (AjxPackage.define("ajax.dwt.dnd.DwtDropEvent")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * @constructor
 * @class
 * DwtDropEvent is generated by the Drag and Drop framework when a drag n drop operation is
 * in process. The drop event is dispatched to the registered {@link DwtDropTarget} instance.
 * 
 * @author Ross Dargahi
 * 
 * @see DwtDropTarget
 */
DwtDropEvent = function() {
	/**
	 * Type of drag operation. One of:
	 * <ul>
	 * <li>{@link DwtDragEvent.DRAG_START}</li>
	 * <li>{@link DwtDragEvent.SET_DATA}</li>
	 * <li>{@link DwtDragEvent.DRAG_END}</li>
	 * </ul>
	 */
	this.operation = null;
	
	/**
	 * Drop target control.
	 * @type DwtControl
	 * */	
	this.targetControl = null;
	
	/**
	 * Action being performed. One of:
	 * <ul>
	 * <li>{@link Dwt.DND_DROP_NONE}</li>
	 * <li>{@link Dwt.DND_DROP_COPY}</li>
	 * <li>{@link Dwt.DND_DROP_MOVE}</li>
	 * </ul>
	 */
	this.action = null;
	
	/**
	 * Drag source data. This is the application data associated with the item being dragged.
	 */
	this.srcData = null;

	/**
	 * Whether the DnD framework should perform the operation. The application is
	 * responsible for setting this value based on whatever business logic it is
	 * implementing.
	 * @type boolean
	 */
	this.doIt = false;
}

/**
 * A draggable object has entered the drop target.
 */
DwtDropEvent.DRAG_ENTER = 1;

/**
 * A draggable object has left the drop target.
 */
DwtDropEvent.DRAG_LEAVE = 2;

/**
 * Drag operation has changed e.g. from move to copy.
 */
DwtDropEvent.DRAG_OP_CHANGED = 3;

/**
 * A draggable object has been dropped on the drag target.
 */
DwtDropEvent.DRAG_DROP = 4;
}
if (AjxPackage.define("ajax.dwt.dnd.DwtDropTarget")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * @constructor
 * @class
 * A drop target is registered with a control to indicate that the control is 
 * a drop target. The drop target is the mechanism by which the DnD framework provides 
 * the binding between the UI components and the application.
 * <p>
 * Application developers instantiate {@link DwtDropTarget} and register it with the control
 * which is to be a drop target (via {@link DwtControl.setDropTarget}). The
 * application should then register a listener with the {@link DwtDropTarget}. This way
 * when drop events occur the application will be notified and may act on them 
 * accordingly
 * </p>
 * 
 * @author Ross Dargahi
 * 
 * @param {array} transferType	a list of supported object types that may be dropped onto
 * 		this drop target. Typically the items represent classes (i.e. functions) whose 
 * 		instances may be dropped on this drop target e.g. 
 * 		<code>new DwtDropTarget(MailItem, AppointmentItme)</code>
 * 
 * @see DwtDropEvent
 * @see DwtControl
 * @see DwtControl#setDropTarget
 */
DwtDropTarget = function(types) {
	/** @private */
	this._evtMgr = new AjxEventMgr();

	/** @private */
	this.__hasMultiple = false;
	
	this._types = {};
	if (typeof types == "string") {
		types = [types];
	}
	if (types && types.length) {
		for (var i = 0; i < types.length; i++) {
			this.addTransferType(types[i]);
		}
	}
}

/** @private */
DwtDropTarget.__DROP_LISTENER = "DwtDropTarget.__DROP_LISTENER";

/** @private */
DwtDropTarget.__dropEvent = new DwtDropEvent();

/**
 * Returns a string representation of this object.
 * 
 * @return {string}	a string representation of this object
 */
DwtDropTarget.prototype.toString = 
function() {
	return "DwtDropTarget";
}

/**
 * Registers a listener for {@link DwtDragEvent} events.
 *
 * @param {AjxListener} dropTargetListener Listener to be registered 
 * 
 * @see DwtDropEvent
 * @see AjxListener
 * @see #removeDropListener
 */
DwtDropTarget.prototype.addDropListener =
function(dropTargetListener) {
	this._evtMgr.addListener(DwtDropTarget.__DROP_LISTENER, dropTargetListener);
}

/**
 * Removes a registered event listener.
 * 
 * @param {AjxListener} dropTargetListener Listener to be removed
 * 
 * @see AjxListener
 * @see #addDropListener
 */
DwtDropTarget.prototype.removeDropListener =
function(dropTargetListener) {
	this._evtMgr.removeListener(DwtDropTarget.__DROP_LISTENER, dropTargetListener);
}

/**
 *  Check to see if the types in <code>items</code> can be dropped on this drop target
 *
 * @param {object|array} items an array of objects or single object whose types are
 * 		to be checked against the set of transfer types supported by this drop target
 * 
 * @return true if all of the objects in <code>items</code> may legally be dropped on 
 * 		this drop target
 * @type boolean
 */
DwtDropTarget.prototype.isValidTarget =
function(items) {
	if (items instanceof Array) {
		var len = items.length;
		for (var i = 0; i < len; i++) {
			if (!this.__checkTarget(items[i])) {
				return false;
			}
		}
		return true;
	} else {
		return this.__checkTarget(items);
	}
}

/**
 * Calling this method indicates that the UI component backing this drop target has multiple 
 * sub-components
 */
DwtDropTarget.prototype.markAsMultiple = 
function() {
	this.__hasMultiple = true;
};

/**
 * Checks if the UI component backing this drop target has multiple sub-components.
 * 
 * @return	{boolean}		<code>true</code> if the UI component has multiple sub-components
 */
DwtDropTarget.prototype.hasMultipleTargets = 
function () {
	return this.__hasMultiple;
};

/**
 * Gets the transfer types.
 * 
 * @return {array}	the list of transfer types supported by this drop target
 * 
 * @see #setTransferTypes
 */
DwtDropTarget.prototype.getTransferTypes =
function() {
	return this._types;
}

/**
 * Declares a type of object as valid for being dropped onto this target. The type is provided
 * as a string, since the corresponding class may not yet be defined. The type is eval'ed before
 * it is used for any validation, since the check is done with <code>instanceof</code>.
 * 
 * @param {string}	type		the name of class
 */
DwtDropTarget.prototype.addTransferType =
function(type) {
	this._types[type] = null;
};

// The following methods are called by DwtControl during the Drag lifecycle 

/** @private */
DwtDropTarget.prototype._dragEnter =
function(operation, targetControl, srcData, ev, dndProxy) {
	DwtDropTarget.__dropEvent.operation = operation;
	DwtDropTarget.__dropEvent.targetControl = targetControl;
	DwtDropTarget.__dropEvent.action = DwtDropEvent.DRAG_ENTER;
	DwtDropTarget.__dropEvent.srcData = srcData;
	DwtDropTarget.__dropEvent.uiEvent = ev;
	DwtDropTarget.__dropEvent.doIt = true;
	DwtDropTarget.__dropEvent.dndProxy = dndProxy;
	this._evtMgr.notifyListeners(DwtDropTarget.__DROP_LISTENER, DwtDropTarget.__dropEvent);
	return DwtDropTarget.__dropEvent.doIt;
}

/** @private */
DwtDropTarget.prototype._dragLeave =
function() {
	DwtDropTarget.__dropEvent.action = DwtDropEvent.DRAG_LEAVE;
	this._evtMgr.notifyListeners(DwtDropTarget.__DROP_LISTENER, DwtDropTarget.__dropEvent);
}

/** @private */
DwtDropTarget.prototype._dragOpChanged =
function(newOperation) {
	DwtDropTarget.__dropEvent.operation = newOperation;
	DwtDropTarget.__dropEvent.action = DwtDropEvent.DRAG_OP_CHANGED;
	this._evtMgr.notifyListeners(DwtDropTarget.__DROP_LISTENER, DwtDropTarget.__dropEvent);
	return DwtDropTarget.__dropEvent.doIt;
};

/** @private */
DwtDropTarget.prototype._drop =
function(srcData, ev) {
	DwtDropTarget.__dropEvent.action = DwtDropEvent.DRAG_DROP;
	DwtDropTarget.__dropEvent.srcData = srcData;
	DwtDropTarget.__dropEvent.uiEvent = ev;
	this._evtMgr.notifyListeners(DwtDropTarget.__DROP_LISTENER, DwtDropTarget.__dropEvent);
	return DwtDropTarget.__dropEvent.doIt;
};


// Private methods

/**@private*/
DwtDropTarget.prototype.__checkTarget =
function(item) {
	if (this._types) {
		for (var i in this._types) {
			var ctor;
			if (this._types[i]) {
				ctor = this._types[i];
			} else {
				ctor = this._types[i] = eval(i);
			}
			if (ctor && (typeof ctor == "function") && (item instanceof ctor)) {
				return true;
			}
		}
		return false;
	}
};
}
if (AjxPackage.define("ajax.dwt.dnd.DwtDragBox")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * @constructor
 * @class
 * A drag box is registered with a control to indicate that the control supports the
 * presence of an elastic box created by clicking and dragging, and typically used to
 * select visual objects within a space.
 * <p>
 * Application developers instantiate {@link DwtDragBox} and register it with the control
 * which is to be draggable (via {@link DwtControl.setDragBox}). The
 * application should then register a listener with the {@link DwtDragBox}. This way
 * when drag events occur the application will be notified and may act on them 
 * accordingly.
 * </p>
 * 
 * @author Conrad Damon
 * 
 * @see DwtDragEvent
 * @see DwtControl
 * @see DwtControl#setDragBox
 */
DwtDragBox = function() {
	this.__evtMgr = new AjxEventMgr();
};

/** @private */
DwtDragBox.__DRAG_LISTENER = "DwtDragBox.__DRAG_LISTENER";

/** @private */
DwtDragBox.__dragEvent = new DwtDragEvent();

/**
 * Returns a string representation of this object.
 * 
 * @return {string}	a string representation of this object
 */
DwtDragBox.prototype.toString = 
function() {
	return "DwtDragBox";
};


/**
 * Registers a listener for <i>DwtDragEvent</i> events.
 *
 * @param {AjxListener} dragBoxListener Listener to be registered
 * 
 * @see DwtDragEvent
 * @see AjxListener
 * @see #removeDragListener
 */
DwtDragBox.prototype.addDragListener =
function(dragBoxListener) {
	this.__evtMgr.addListener(DwtDragBox.__DRAG_LISTENER, dragBoxListener);
};

/**
 * Removes a registered event listener.
 * 
 * @param {AjxListener} dragBoxListener Listener to be removed
 * 
 * @see AjxListener
 * @see #addDragListener
 */
DwtDragBox.prototype.removeDragListener =
function(dragBoxListener) {
	this.__evtMgr.removeListener(DwtDragBox.__DRAG_LISTENER, dragBoxListener);
};

// The following methods are called by DwtControl during the drag lifecycle 

DwtDragBox.prototype._setStart =
function(mouseEv, srcControl) {

	this._startX = mouseEv.docX;
	this._startY = mouseEv.docY;
	this._dragObj = DwtDragBox.__dragEvent.srcControl = srcControl;
	DwtDragBox.__dragEvent.action = DwtDragEvent.DRAG_INIT;
	DwtDragBox.__dragEvent.target = mouseEv.target;
	return (this.__evtMgr.notifyListeners(DwtDragBox.__DRAG_LISTENER, DwtDragBox.__dragEvent) !== false);
};

DwtDragBox.prototype._beginDrag =
function(srcControl) {

	srcControl._dragging = DwtControl._DRAGGING;
	DwtDragBox.__dragEvent.srcControl = srcControl;
	DwtDragBox.__dragEvent.action = DwtDragEvent.DRAG_START;
	this.__evtMgr.notifyListeners(DwtDragBox.__DRAG_LISTENER, DwtDragBox.__dragEvent);
};

DwtDragBox.prototype._dragMove =
function(mouseEv, srcControl) {

	var deltaX = mouseEv.docX - this._startX;
	var deltaY = mouseEv.docY - this._startY;
	var locX = (deltaX > 0) ? this._startX : mouseEv.docX;
	var locY = (deltaY > 0) ? this._startY : mouseEv.docY;

	var box = srcControl.getDragSelectionBox();
	Dwt.setLocation(box, locX, locY);
	Dwt.setSize(box, Math.abs(deltaX), Math.abs(deltaY));

	DwtDragBox.__dragEvent.srcControl = srcControl;
	DwtDragBox.__dragEvent.action = DwtDragEvent.DRAG_MOVE;
	this.__evtMgr.notifyListeners(DwtDragBox.__DRAG_LISTENER, DwtDragBox.__dragEvent);
};

DwtDragBox.prototype._endDrag =
function(srcControl) {

	srcControl._dragging = DwtControl._NO_DRAG;
	DwtDragBox.__dragEvent.action = DwtDragEvent.DRAG_END;
	if (!this.__evtMgr.notifyListeners(DwtDragBox.__DRAG_LISTENER, DwtDragBox.__dragEvent)) {
		srcControl.destroyDragSelectionBox();
	}
	this._dragObj = null;
};

/*
 *  return starting X position
 *  @return {int} starting X position
 */
DwtDragBox.prototype.getStartX =
function() {
    return this._startX;
};

/*  return starting Y position
 *  @return {int} starting Y position
 */
DwtDragBox.prototype.getStartY =
function() {
    return this._startY;
};
}

if (AjxPackage.define("ajax.dwt.widgets.DwtHoverMgr")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * 
 * @private
 */
DwtHoverMgr = function() {
	this._hoverOverAction = new AjxTimedAction(this, this._notifyHoverOver);
	this._hoverOutAction = new AjxTimedAction(this, this._notifyHoverOut);
	this._ignoreHoverOverOnClickAction = new AjxTimedAction(this, this._resetIgnoreHoverOverOnClick);
};

DwtHoverMgr.prototype.isDwtHoverMgr = true;
DwtHoverMgr.prototype.toString = function() { return "DwtHoverMgr"; };

// Data


DwtHoverMgr.prototype._hoverOverDelay = 750;
DwtHoverMgr.prototype._hoverOverActionId = -1;

DwtHoverMgr.prototype._hoverOutDelay = 50;
DwtHoverMgr.prototype._ignoreHoverOverOnClickDelay = 750;
DwtHoverMgr.prototype._hoverOutActionId = -1;

DwtHoverMgr.prototype._isHovering = false;

// Public methods

DwtHoverMgr.prototype.setHoverObject =
function(object) {
	this._hoverObject = object;
};

DwtHoverMgr.prototype.getHoverObject =
function() {
	return this._hoverObject;
};

DwtHoverMgr.prototype.reset =
function() {
	this._hoverObject = null;
	this._hoverOverDelay = DwtHoverMgr.prototype._hoverOverDelay;
	this._hoverOverData = null;
	if (this._hoverOverActionId != -1) {
		AjxTimedAction.cancelAction(this._hoverOverActionId);
	}
	this._hoverOverActionId = -1;
	this._hoverOverListener = null;

	this._hoverOutDelay = DwtHoverMgr.prototype._hoverOutDelay;
	this._hoverOutData = null;
	if (this._hoverOutActionId != -1) {
		AjxTimedAction.cancelAction(this._hoverOutActionId);
		this._notifyHoverOut();
	}
	this._hoverOutActionId = -1;
	this._hoverOutListener = null;
};

DwtHoverMgr.prototype.isHovering =
function() {
	return this._isHovering;
};

DwtHoverMgr.prototype.setHoverOverDelay =
function(delay) {
	this._hoverOverDelay = delay;
};

DwtHoverMgr.prototype.setHoverOverData =
function(data) {
	this._hoverOverData = data;
};

DwtHoverMgr.prototype.setHoverOverListener =
function(listener) {
	this._hoverOverListener = listener;
};

DwtHoverMgr.prototype.setHoverOutDelay =
function(delay) {
	this._hoverOutDelay = delay;
};

DwtHoverMgr.prototype.setHoverOutData =
function(data) {
	this._hoverOutData = data;
};

DwtHoverMgr.prototype.setHoverOutListener =
function(listener) {
	this._hoverOutListener = listener;
};


DwtHoverMgr.prototype.ignoreHoverOverOnClick =
function() {
	this._ignoreHoverOverOnClick = true;
	AjxTimedAction.scheduleAction(this._ignoreHoverOverOnClickAction, this._ignoreHoverOverOnClickDelay);
};

DwtHoverMgr.prototype._resetIgnoreHoverOverOnClick =
function() {
	this._ignoreHoverOverOnClick = false;
};

DwtHoverMgr.prototype.hoverOver =
function(x, y) {

	if (this._ignoreHoverOverOnClick) { return; }
	
	this._isHovering = true;
	if (this._hoverOverActionId != -1) {
		AjxTimedAction.cancelAction(this._hoverOverActionId);
	}
	this._hoverOverAction.args = [x, y];
	this._hoverOverActionId = AjxTimedAction.scheduleAction(this._hoverOverAction, this._hoverOverDelay);
};

DwtHoverMgr.prototype.hoverOut =
function() {
	this._isHovering = false;
	if (this._hoverOverActionId != -1) {
		AjxTimedAction.cancelAction(this._hoverOverActionId);
	}
	if (this._hoverOutActionId == -1) {
		if (this._hoverOutDelay > 0) {
			this._hoverOutActionId = AjxTimedAction.scheduleAction(this._hoverOutAction, this._hoverOutDelay);
		}
		else {
			this._notifyHoverOut();
		}
	}
};

// Protected methods

DwtHoverMgr.prototype._notifyHoverOver =
function() {
	this._hoverOverActionId = -1;
	if (this._hoverOverListener != null) {
		var x = this._hoverOverAction.args[0];
		var y = this._hoverOverAction.args[1];
		var event = new DwtHoverEvent(DwtEvent.HOVEROVER, this._hoverOverDelay, this._hoverOverData, x, y);
		this._hoverOverListener.handleEvent(event);
	}
};

DwtHoverMgr.prototype._notifyHoverOut =
function() {
	this._hoverOutActionId = -1;
		if (this._hoverOutListener != null) {
		var event = new DwtHoverEvent(DwtEvent.HOVEROUT, this._hoverOutDelay, this._hoverOutData);
		this._hoverOutListener.handleEvent(event);
	}
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtControl")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * @overview
 * This file contains a Dwt control.
 */

/**
 * Creates a control.
 * @class
 * This class is the root class of the Dwt component hierarchy. All
 * Dwt components either directly or indirectly inherit from this class.
 * <p>
 * A {@link DwtControl} may also be directly instantiated. In this case it is essentially
 * a div into which any content may be "drawn"
 * <p>
 * A control may be created in "deferred" mode, meaning that the UI portion of the control
 * will be created "Just In Time". This is useful for widgets which may want to defer construction
 * of elements (e.g. {@link DwtTreeItem}) until such time as is needed, in the interest of efficiency.
 * Note that if the control is a child of the shell, it won't become visible until its z-index is set.
 *
 * <h4>Events</h4><ul>
 * <li><i>DwtEvent.CONTROL</i></li>
 * <li><i>DwtEvent.DISPOSE</i></li>
 * <li><i>DwtEvent.HOVEROVER</i></li>
 * <li><i>DwtEvent.HOVEROUT</i></li>
 * <li><i>DwtEvent.ONCONTEXTMENU</i></li>
 * <li><i>DwtEvent.ONCLICK</i></li>
 * <li><i>DwtEvent.ONDBLCLICK</i></li>
 * <li><i>DwtEvent.ONFOCUS</i></li>
 * <li><i>DwtEvent.ONBLUR</i></li>
 * <li><i>DwtEvent.ONMOUSEDOWN</i></li>
 * <li><i>DwtEvent.ONMOUSEENTER</i></li>
 * <li><i>DwtEvent.ONMOUSELEAVE</i></li>
 * <li><i>DwtEvent.ONMOUSEMOVE</i></li>
 * <li><i>DwtEvent.ONMOUSEOUT</i></li>
 * <li><i>DwtEvent.ONMOUSEOVER</i></li>
 * <li><i>DwtEvent.ONMOUSEUP</i></li>
 * <li><i>DwtEvent.ONMOUSEWHEEL</i></li>
 * <li><i>DwtEvent.ONSELECTSTART</i></li>
 * </ul>
 *
 * @author Ross Dargahi
 * 
 * @param {hash}		params			a hash of parameters
 * @param	{DwtComposite}	parent		the parent widget, except in the case of {@link DwtShell}, the parent will be a control that is a subclass of {@link DwtComposite}
 * @param	{string}	className		the CSS class
 * @param	{constant}	posStyle		the positioning style (absolute, static, or relative). Defaults to {@link DwtControl.STATIC_STYLE}.
 * @param	{boolean}	deferred		if <code>true</code>, postpone initialization until needed
 * @param	{string}	id			    an explicit ID to use for the control's HTML element. If not provided, defaults to an auto-generated ID.
 * @param	{string|HTMLElement}	parentElement   the parent element
 * @param	{number}	index 		    the index at which to add this control among parent's children
 * @param   {boolean}   isFocusable     if false, this control does not take browser focus (its element will not have a tabindex); defaults to true
 * @param   {string}    role            ARIA role for this control
 *
 */
DwtControl = function(params) {

	if (arguments.length == 0) { return; }
	params = Dwt.getParams(arguments, DwtControl.PARAMS);

	/**
	 * parent component. Read-Only
	 * 
	 * @private
	 */
	var parent = this.parent = params.parent;
	if (parent && !(parent.isDwtComposite)) {
		throw new DwtException("Parent must be a subclass of Composite", DwtException.INVALIDPARENT, "DwtControl");
	}

	/**
	 * the control's <i>DwtShell</i>
	 * @private
	 */
	this.shell = null;

	/**
	 * Data object used to store "client data" on the widget via the
	 * <code>setData</code> and <code>getData</code> methods
	 * 
	 * @type hash
	 * @private
	 */
	this._data = {};

	/**
	 * The event manager controls the mapping between event types and the registered listeners.
	 * @type AjxEventMgr
	 * @private
	 */
	this._eventMgr = new AjxEventMgr();

	/** true if the control is disposed, else false. The public api to this
	 * member is <code>isDisposed</code>.
	 * 
	 * @type boolean
	 * @private
	 */
	this._disposed = false;

	// set to true for an event type to override default behavior of swallowing the event
	this._propagateEvent = {};

	// don't swallow mouse wheel events; we often want to react to them, while
	// letting the browser continue to scroll
	this._propagateEvent[DwtEvent.ONMOUSEWHEEL] = true;

 	if (!parent) { return; }

	/** CSS class name
	 * @type string
	 * @private
	 */
	this._className = params.className || "DwtControl";

	/**
	 * @private
	 */
	this.__posStyle = params.posStyle;

	/**
	 * id of the control's HTML element
	 * @type string
	 * @private
	 */
	if (params.id) {
		this._htmlElId = params.id;
	}

	this.isFocusable = (params.isFocusable !== false);

	if (params.role != null) {
		this.role = params.role;
	}

	/**
	 * @private
	 */
	this.__index = params.index;

	this.__parentElement = params.parentElement;

	/**
	 * enabled state of this control. Public APIs to this member are
	 * <code>getEnabled</code> and <code>setEnabled</code>.
	 * 
	 * @type boolean
	 * @private
	 */
	this._enabled = false;

	/**
	 * Indicates the drag state of the control. Valid values are:
	 * <ul>
	 * <li>DwtControl._NO_DRAG<li>
	 * <li>DwtControl._DRAGGING<li>
	 * <li>DwtControl._DRAG_REJECTED<li>
	 * </ul>
	 * 
	 * @type number
	 * @private
	 */
	this._dragging = null;

	/**
	 * Drag n drop icon. Valid when a drag and drop operation is occurring.
	 * 
	 * @type HTMLElement
	 * @private
	 */
	this._dndProxy = null;

	/**
	 * Flag indicating whether the control has keyboard focus or not.
	 * 
	 * @type boolean
	 * @private
	 */
	this._hasFocus = false;

	if (!params.deferred) {
		this.__initCtrl();
	}

	/**
	 * Hover over listener.
	 * 
	 * @type AjxListener
	 * @private
	 */
	this._hoverOverListener = new AjxListener(this, this.__handleHoverOver);

	/**
	 * Hover out listener.
	 * 
	 * @type AjxListener
	 * @private
	 */
	this._hoverOutListener = new AjxListener(this, this.__handleHoverOut);

	// turn this on to receive only the dblclick event (rather than click,
	// click, dblclick); penalty is that single click's timer must expire
	// before it is processed; useful if control has both single and double
	// click actions, and single click action is heavy
	this._dblClickIsolation = false;

	// set to true to ignore OVER and OUT mouse events between elements in the same control
	this._ignoreInternalOverOut = false;
	
	// override this control's default template
	this.TEMPLATE = params.template || this.TEMPLATE;
};

DwtControl.prototype.isDwtControl = true;
DwtControl.prototype.toString = function() { return "DwtControl"; };

DwtControl.prototype.isFocusable = null;

DwtControl.PARAMS = ["parent", "className", "posStyle", "deferred", "id", "index", "template"];

DwtControl.ALL_BY_ID = {};


//
// Constants
//

// Display states
/**
 * Defines the "normal" display state.
 */
DwtControl.NORMAL = "";
/**
 * Defines the "active" display state.
 */
DwtControl.ACTIVE = "ZActive";
/**
 * Defines the "focused" display state.
 */
DwtControl.FOCUSED = "ZFocused";
/**
 * Defines the "disabled" display state.
 */
DwtControl.DISABLED = "ZDisabled";
/**
 * Defines the "hover" display state.
 */
DwtControl.HOVER = "ZHover";
/**
 * Defines the "selected" display state.
 */
DwtControl.SELECTED = "ZSelected";
/**
 * Defines the "default" display state.
 */
DwtControl.DEFAULT = "ZDefault";
/**
 * Defines the "error" display state.
 */
DwtControl.ERROR = "ZError";

DwtControl._STATES = [
	DwtControl.ACTIVE,  DwtControl.FOCUSED,     DwtControl.DISABLED,
	DwtControl.HOVER,   DwtControl.SELECTED,    DwtControl.DEFAULT,
	DwtControl.ERROR
];

DwtControl._RE_STATES = new RegExp(
    "\\b(" + DwtControl._STATES.join("|") + ")\\b", "g"
);

DwtControl._RE_STATE = AjxUtil.arrayAsHash(
	DwtControl._STATES,
	function(state) {
		return new RegExp("\\b" + state + "\\b", "g");
	});

DwtControl._ARIA_STATES = {};
DwtControl._ARIA_STATES[DwtControl.DISABLED] = 'aria-disabled';
DwtControl._ARIA_STATES[DwtControl.SELECTED] = 'aria-selected';
DwtControl._ARIA_STATES[DwtControl.ERROR] = 'aria-invalid';

// Try to use browser tooltips (setting 'title' attribute) if possible
DwtControl.useBrowserTooltips = false;


/*
 * Position styles
 * 
 */

/**
 * Defines the static position style.
 * 
 * @see  Dwt.STATIC_STYLE
 */
DwtControl.STATIC_STYLE = Dwt.STATIC_STYLE;

/**
 * Defines the absolute position style.
 * 
 * @see Dwt.ABSOLUTE_STYLE
 */
DwtControl.ABSOLUTE_STYLE = Dwt.ABSOLUTE_STYLE;

/**
 * Defines the relative position style.
 * 
 * @see Dwt.RELATIVE_STYLE
 */
DwtControl.RELATIVE_STYLE = Dwt.RELATIVE_STYLE;

/**
 * Defines the fixed position style.
 * 
 * @see Dwt.FIXED_STYLE
 */
DwtControl.FIXED_STYLE = Dwt.FIXED_STYLE;


/*
 * 
 * Overflow style
 * 
 */

/**
 * 
 * Defines clip on overflow.
 * 
 * @see Dwt.CLIP
 */
DwtControl.CLIP = Dwt.CLIP;

/**
 * Defines allow overflow to be visible.
 * 
 * @see Dwt.VISIBLE
 */
DwtControl.VISIBLE = Dwt.VISIBLE;

/**
 * Defines automatically create scrollbars if content overflows.
 * 
 * @see Dwt.SCROLL
 */
DwtControl.SCROLL = Dwt.SCROLL;

/**
 * Defines always have scrollbars whether content overflows or not.
 * 
 * @see Dwt.FIXED_SCROLL
 */
DwtControl.FIXED_SCROLL = Dwt.FIXED_SCROLL;


// DnD states
/**
 * Defines "no drag" in progress.
 * 
 * @private
 */
DwtControl._NO_DRAG = "NO_DRAG";

/**
 * Defines "drag" in progress.
 *
 * @private
 */
DwtControl._DRAGGING = "DRAGGING";

/**
 * Defines "drag rejected".
 * 
 * @private
 */
DwtControl._DRAG_REJECTED = "DRAG_REJECTED";

/**
 * Defines "drag threshold".
 * 
 * @private
 */
DwtControl.__DRAG_THRESHOLD = 3;

/**
 * Defines "tooltip threshold".
 *
 * @private
 */
DwtControl.__TOOLTIP_THRESHOLD = 5;

/**
 * @private
 */
DwtControl.__DND_HOVER_DELAY = 750;

/**
 * @private
 */
DwtControl.__controlEvent = new DwtControlEvent();

/**
 * Applies only if control has turned on _doubleClickIsolation (see above)
 * want to hit sweet spot where value is more than actual dbl click speed,
 * but as low as possible since it also the length of single click pause.
 * 
 * @private
 */
DwtControl.__DBL_CLICK_TIMEOUT = 300;

//
// Data
//

/**
 * @private
 */
DwtControl.prototype._displayState = "";

//
// Public methods
//

/**
 * Adds a control event listener for control events. Control events are essentially
 * resize and coordinate change events.
 *
 * @param {AjxListener} listener		the listener to be registered (may not be <code>null</code>)
 *
 * @see DwtControlEvent
 * @see #removeControlListener
 * @see #removeAllListeners
 */
DwtControl.prototype.addControlListener =
function(listener) {
	this.addListener(DwtEvent.CONTROL, listener);
};

/**
 * Removes a control event listener for control events. Control events are essentially
 * resize and coordinate change events.
 *
 * @param {AjxListener} listener		the listener to remove
 *
 * @see DwtControlEvent
 * @see #addControlListener
 * @see #removeAllListeners
 */
DwtControl.prototype.removeControlListener =
function(listener) {
	this.removeListener(DwtEvent.CONTROL, listener);
};

/**
 * Registers a dispose listener for control events. Dispose events are fired when
 * a control is "destroyed" via the {@link #dispose} call.
 *
 * @param {AjxListener} listener		the listener to be registered (may not be <code>null</code>)
 *
 * @see DwtDisposeEvent
 * @see #removeDisposeListener
 * @see #removeAllListeners
 * @see #dispose
 * @see #isDisposed
 */
DwtControl.prototype.addDisposeListener =
function(listener) {
	this.addListener(DwtEvent.DISPOSE, listener);
};

/**
 * Removes a dispose event listener for control events. Dispose events are fired when
 * a control is "destroyed" via the {@link #dispose} method call.
 *
 * @param {AjxListener} listener		the listener to remove
 *
 * @see DwtDisposeEvent
 * @see #addDisposeListener
 * @see #removeAllListeners
 * @see #dispose
 * @see #isDisposed
 */
DwtControl.prototype.removeDisposeListener =
function(listener) {
	this.removeListener(DwtEvent.DISPOSE, listener);
};

/**
 * Adds a listener to the control. The listener will be call when events
 * of type <code>eventType</code> fire.
 *
 * @param {string} eventType		the event type for which to listen (may not be <code>null</code>)
 * @param {AjxListener} listener	the listener to register (may not be <code>null</code>)
 * @param {number}		index		the index at which to add listener
 *
 * @see DwtEvent
 * @see #removeListener
 * @see #removeAllListeners
 * @see #notifyListeners
 */
DwtControl.prototype.addListener =
function(eventType, listener, index) {
	return this._eventMgr.addListener(eventType, listener, index);
};

/**
 * Removes a listener from the control.
 *
 * @param {string} eventType		the event type for which to listen (may not be <code>null</code>)
 * @param {AjxListener} listener	the listener to remove (may not be <code>null</code>)
 *
 * @see DwtEvent
 * @see #addListener
 * @see #removeAllListeners
 */
DwtControl.prototype.removeListener =
function(eventType, listener) {
	return this._eventMgr.removeListener(eventType, listener);
};

/**
 * Removes all listeners for a particular event type.
 *
 * @param {string} eventType		the event type (may not be <code>null</code>)
 * @return	{boolean}	<code>true</code> if all listeners are removed
 * 
 * @see DwtEvent
 * @see #addListener
 * @see #removeListener
 */
DwtControl.prototype.removeAllListeners =
function(eventType) {
	return this._eventMgr.removeAll(eventType);
};

/**
 * Checks if there are any listeners registered for a particular event type.
 *
 * @param {string} eventType		the event type (may not be <code>null</code>)
 *
 * @return {boolean}	<code>true</code> if there is an listener registered for the specified event type
 * @see DwtEvent
 */
DwtControl.prototype.isListenerRegistered =
function(eventType) {
	return this._eventMgr.isListenerRegistered(eventType);
};

/**
 * Notifies all listeners of type <code>eventType</code> with <code>event</code>.
 *
 * @param {string} eventType		the event type (may not be <code>null</code>)
 * @param {DwtEvent} event		the event
 */
DwtControl.prototype.notifyListeners =
function(eventType, event) {
	return this._eventMgr.notifyListeners(eventType, event);
};

/**
 * Disposes of the control. This method will remove the control from under the
 * control of its parent and release any resources associate with the component
 * it will also notify any event listeners on registered {@link DwtEvent.DISPOSE} event type.
 *
 * <p>
 * Subclasses may override this method to perform their own dispose functionality but
 * should generally call up to the parent method.
 *
 * @see #isDisposed
 * @see #addDisposeListener
 * @see #removeDisposeListener
 */
DwtControl.prototype.dispose =
function() {
	if (this._disposed) { return; }

	if (this.parent && this.parent.isDwtComposite) {
		this.parent.removeChild(this);
	}
	this._elRef = null;
	
    DwtControl.ALL_BY_ID[this._htmlElId] = null;
    delete DwtControl.ALL_BY_ID[this._htmlElId];

	this._disposed = true;
	var ev = new DwtDisposeEvent();
	ev.dwtObj = this;
	this.notifyListeners(DwtEvent.DISPOSE, ev);
    this._eventMgr.clearAllEvents();
};

/**
 * This method is deprecated. Please use "document" directly.
 * @deprecated
 * @private
 */
DwtControl.prototype.getDocument =
function() {
	return document;
};

/**
 * Gets the tab group member for this control. Tab group members can
 * be a native HTML form element, a {@link DwtControl}, or a {@link DwtTabGroup} (for more
 * complex or explicit tab-ordering.
 * 
 * @return	{DwtControl}	by default, returns this object
 */
DwtControl.prototype.getTabGroupMember = function() {

    return this.tabGroupMember || this;
};

/**
 * Gets the data associated with the specified key.
 *
 * @param {string} key		the key
 * @return {Object}		the associated data
 * 
 * @see #setData
 */
DwtControl.prototype.getData =
function(key) {
	return this._data[key];
};

/**
 * Sets the data for a given key. This method is useful for associating client data with a control.
 *
 * @param {string} key		the key
 * @param {Object} value	the data
 * 
 * @see #getData
 */
DwtControl.prototype.setData =
function(key, value) {
  this._data[key] = value;
};

/**
 * Checks if the control is disposed.
 * 
 * @return {boolean}	<code>true</code> if the control is in a disposed state; <code>false</code> otherwise
 *
 * @see #dispose
 * @see #addDisposeListener
 * @see #removeDisposeListener
 */
DwtControl.prototype.isDisposed =
function() {
	return this._disposed;
};

/**
 * Checks if the control is initialized. In general, a control will not be
 * initialized if it has been created in deferred mode and has not yet been initialized.
 * 
 * @return {boolean}	<code>true</code> if the control is in a initialized; <code>false</code> otherwise
 */
DwtControl.prototype.isInitialized =
function() {
	return this.__ctrlInited;
};

/**
 * Sets browser and keyboard focus to this control.
 *
 *  @return  {DwtControl|Element}   control or element that actually got focused
 */
DwtControl.prototype.focus = function() {

    DBG.println(AjxDebug.FOCUS, "DwtControl FOCUS: " + [this, this._htmlElId].join(' / '));
    if (!this._checkState()) {
        return;
    }

    var el = this.getFocusElement();
    if (el && el.focus) {
        AjxTimedAction.scheduleAction(this._focusAction);

        // retain the scroll position if the user scrolled, since setting focus will cause browser to scroll this control into view
        var scrollContainer = this.getScrollContainer(),
            scrollTop = scrollContainer && scrollContainer.scrollTop;

        el.focus();

        if (scrollTop > 0) {
            DBG.println(AjxDebug.DBG1, "Resetting scroll after focus to: " + scrollTop);
            scrollContainer.scrollTop = scrollTop;
        }
    }

    return this;
};

/**
 * Takes browser and keyboard focus away from this control.
 *
 *  @return   {DwtControl|Element}  control or element that actually got blurred
 */
DwtControl.prototype.blur = function() {

    DBG.println(AjxDebug.FOCUS, "DwtControl BLUR: " + [this, this._htmlElId].join(' / '));
    if (!this._checkState()) {
        return;
    }
    var el = this.getFocusElement();
    if (el && el.blur) {
        AjxTimedAction.scheduleAction(this._blurAction);
        el.blur();
    }

    return this;
};

/**
 * Checks if this control has focus.
 * 
 * @return {boolean}	<code>true</code> if this control has keyboard focus; <code>false</code> otherwise
 */
DwtControl.prototype.hasFocus =
function() {
	return this._hasFocus;
};

/**
 * Handles key actions and is called by the keyboard navigation framework. Subclasses
 * should override this method to provide behavior for supported key actions.
 * 
 * @param	{DwtKeyMap}	actionCode	the key action code
 * @param	{DwtKeyEvent}	ev		the key event
 * @return	{boolean}	<code>true</code> if the event is handled; <code>false</code> otherwise
 * 
 * @private
 *
 */
DwtControl.prototype.handleKeyAction =
function(actionCode, ev) {
	return false;
};

/**
 * Re-parents the control within the component hierarchy. Unlike <i>reparentHtmlElement</i>
 * which re-parents the controls <i>div</i> within the DOM hierarchy, this method re-parents
 * the whole control.
 *
 * @param {DwtComposite} newParent 	the control's new parent
 * @param	{number}	index	the index
 * 
 * @see #reparentHtmlElement
 */
DwtControl.prototype.reparent =
function(newParent, index) {
	if (!this._checkState()) { return; }

	var htmlEl = this.getHtmlElement();
	this.parent.removeChild(this, true);
	DwtComposite._pendingElements[this._htmlElId] = htmlEl;
	newParent.addChild(this, index);
	this.parent = newParent;
	// TODO do we need a reparent event?
};

/**
 * Re-parents the HTML element of the control to the html element supplied as the
 * parameter to this method. Note this method only re-parents the control's <i>div</i>
 * element and does not affect the component hierarchy. To re-parent the control within
 * the component hierarchy, use the <i>reparent</i> method.
 *
 * @param {string|HTMLElement} htmlEl a string representing an element ID or an HTML element
 * @param {number} position 	the position to insert the element
 *
 * @see #reparent
 */
DwtControl.prototype.reparentHtmlElement =
function(htmlEl, position) {

	// If htmlEl is a string, then it is an ID so lookup the html element that
	// has the corresponding ID
	if (typeof htmlEl == "string") {
		htmlEl = document.getElementById(htmlEl);
	}
	if (!htmlEl) { return; }

	var el = this.getHtmlElement();
	if (position == null) {
		htmlEl.appendChild(el);
	} else if (typeof position == "object") {
		htmlEl.insertBefore(el, position);
	} else {
		if (htmlEl.childNodes[position]) {
			htmlEl.insertBefore(el, htmlEl.childNodes[position]);
		} else {
			htmlEl.appendChild(el);
		}
	}
};

/**
 * Sets the event handling function for a given event type. This method
 * should be used judiciously as it can lead to unexpected results (for example if
 * overriding the control's mouse handlers). This method calls through to <i>Dwt.setHandler</i>
 *
 * @param {string} eventType 	the event type (defined in {@see DwtEvent}) to override 
 * @param {function} hdlrFunc Event handler function
 *
 * @see DwtEvent
 */
DwtControl.prototype.setHandler =
function(eventType, hdlrFunc) {
	if (!this._checkState()) { return; }

	var htmlElement = this.getHtmlElement();
	Dwt.setHandler(htmlElement, eventType, hdlrFunc);
};

/**
 * Clears the event handling function for a given event type. This method
 * should be used judiciously as it can lead to unexpected results (for example if
 * overriding the control's mouse handlers)
 *
 * @param {string} eventType 	the event type (defined in {@see DwtEvent}) to override 
 *
 * @see DwtEvent
 */
DwtControl.prototype.clearHandler =
function(eventType) {
	if (!this._checkState()) { return; }

	var htmlElement = this.getHtmlElement();
	Dwt.clearHandler(htmlElement, eventType);
};

/**
 * Set the default behavior for whether an event will propagate (bubble up).
 * 
 * @param {boolean}		propagate		if true, event will propagate
 * @param {array}		events			one or more events
 */
DwtControl.prototype.setEventPropagation =
function(propagate, events) {
	events = AjxUtil.toArray(events);
	for (var i = 0; i < events.length; i++) {
		this._propagateEvent[events[i]] = propagate;
	}
};

/**
 * Gets the bounds of the component. Bounds includes the location (not relevant for
 * statically position elements) and dimensions of the control (i.e. the <code>&lt;div&gt;</code> element).
 *
 * @return {DwtRectangle}		the control bounds
 *
 * @see DwtRectangle
 * @see #getInsetBounds
 * @see #getInsets
 * @see #getSize
 * @see #getLocation
 * @see #getH
 * @see #getW
 * @see #getX
 * @see #getXW
 * @see #getY
 * @see #getYH
 * @see #setBounds
 * @see #setSize
 * @see #setLocation
 */
DwtControl.prototype.getBounds =
function() {
	if (!this._checkState()) { return; }

	return Dwt.getBounds(this.getHtmlElement());
};

/**
 * Gets the inset bounds of the component. Similar to the bounds, but excluding borders and paddings.
 *
 * @return {DwtRectangle}		the control inset bounds
 *
 * @see DwtRectangle
 * @see #getBounds
 * @see #getInsets
 * @see #getSize
 * @see #getLocation
 * @see #getH
 * @see #getW
 * @see #getX
 * @see #getXW
 * @see #getY
 * @see #getYH
 * @see #setBounds
 * @see #setSize
 * @see #setLocation
 */
DwtControl.prototype.getInsetBounds =
function() {
	if (!this._checkState()) { return; }

	return Dwt.getInsetBounds(this.getHtmlElement());
};

/**
 * Gets the insets of the component, i.e. the width of borders and paddings.
 *
 * @return {DwtRectangle}		the control insets
 *
 * @see DwtRectangle
 * @see #getBounds
 * @see #getInsetBounds
 * @see #getMargins
 * @see #getSize
 * @see #getLocation
 * @see #getH
 * @see #getW
 * @see #getX
 * @see #getXW
 * @see #getY
 * @see #getYH
 * @see #setBounds
 * @see #setSize
 * @see #setLocation
 */
DwtControl.prototype.getInsets =
function() {
	if (!this._checkState()) { return; }

	return Dwt.getInsets(this.getHtmlElement());
};

/**
 * Gets the margins of the component.
 *
 * @return {DwtRectangle}		the control margins
 *
 * @see DwtRectangle
 * @see #getBounds
 * @see #getInsetBounds
 * @see #getInsets
 * @see #getSize
 * @see #getLocation
 * @see #getH
 * @see #getW
 * @see #getX
 * @see #getXW
 * @see #getY
 * @see #getYH
 * @see #setBounds
 * @see #setSize
 * @see #setLocation
 */
DwtControl.prototype.getMargins =
function() {
	if (!this._checkState()) {
		return;
	}

	return Dwt.getMargins(this.getHtmlElement());
};

/**
 * Sets the bounds of a control. The position type of the control must
 * be absolute or else an exception is thrown. To omit setting a value set the
 * actual parameter value to <i>Dwt.DEFAULT</i>
 *
 * @param {number|string} x		the x coordinate of the element (for example: 10, "10px", Dwt.DEFAULT)
 * @param {number|string} y		the y coordinate of the element (for example: 10, "10px", Dwt.DEFAULT)
 * @param {number|string} width	the width of the element (for example: 100, "100px", "75%", Dwt.DEFAULT)
 * @param {number|string} height	the height of the element (for example: 100, "100px", "75%", Dwt.DEFAULT)
 *
 * @return {DwtControl}		this control
 *
 * @see DwtRectangle
 * @see #getBounds
 * @see #getInsetBounds
 * @see #getInsets
 * @see #setSize
 * @see #setLocation
 * @see #getSize
 * @see #getLocation
 * @see #getH
 * @see #getW
 * @see #getX
 * @see #getXW
 * @see #getY
 * @see #getYH
 */
DwtControl.prototype.setBounds =
function(x, y, width, height) {
	if (!this._checkState()) { return; }

	var htmlElement = this.getHtmlElement();
	if (this.isListenerRegistered(DwtEvent.CONTROL)) {
		this.__controlEvent.reset(DwtControlEvent.RESIZE | DwtControlEvent.MOVE);
		var bds = Dwt.getBounds(htmlElement);
		this.__controlEvent.oldX = bds.x;
		this.__controlEvent.oldY = bds.y;
		this.__controlEvent.oldWidth = bds.width;
		this.__controlEvent.oldHeight = bds.height;
        //TODO: notifyListeners() called atleast 3 times. Should minimize the calls.
		this.setLocation(x, y);
		this.setSize(width, height);
		bds = Dwt.getBounds(htmlElement);
		this.__controlEvent.newX = bds.x;
		this.__controlEvent.newY = bds.y;
		this.__controlEvent.newWidth = (AjxUtil.isNumber(width)) ? width : bds.width; //if it's exact number, no need to use the bounds, especially since they are not accurate, wrong in about 2 pixels at least in the case I'm testing.
		this.__controlEvent.newHeight = (AjxUtil.isNumber(height)) ? height : bds.height;
		this.__controlEvent.requestedWidth = width;
		this.__controlEvent.requestedHeight = height;
		this.notifyListeners(DwtEvent.CONTROL, this.__controlEvent);
	} else {
		this.setLocation(x, y);
		this.setSize(width, height);
	}

	return this;
}

/**
 * Gets the class name of this control. The class name may be set
 * when constructing the control. If it is not passed into the constructor, it
 * defaults to the control's class name. The class name is generally used as the
 * CSS class name for the control, although control's that change visual behaviour
 * based on state may append (or even use different) class names. See the documentation
 * of the specific component for details.
 *
 * @return {string}		the control class name
 *
 * @see #setClassName
 */
DwtControl.prototype.getClassName =
function() {
	return this._className;
};

/**
 * Sets the control class name. This also automatically sets the control CSS
 * class name (i.e. the control htmlElement class name). Subclasses of <i>DwtControl</i>
 * may override this method to perform a different behavior.
 *
 * @param {string} className		the new class name for the control
 *
 * @see #getClassName
 */
DwtControl.prototype.setClassName =
function(className) {
	if (!this._checkState()) { return; }

	this._className = className;
    var el = this.getHtmlElement();
    el.className = className;
    Dwt.addClass(el, this._displayState);
};

/**
 * Adds a class name to this control HTML element.
 *
 * @param {string} className		the class name to add
 */
DwtControl.prototype.addClassName =
function(className) {
	Dwt.addClass(this.getHtmlElement(), className);
};

/**
 * Removes a class name from this control's HTML element. Optionally adds a new class name, if specified.
 *
 * @param {string} delClass		the class to remove
 * @param {string} addClass		the class to add (may be <code>null</code>)
 */
DwtControl.prototype.delClassName =
function(delClass, addClass) {
	Dwt.delClass(this.getHtmlElement(), delClass, addClass);
};

/**
 * Conditionally adds or removes a class name to this control HTML element.
 * The class names are used exclusively, that is: when condition is true,
 * <code>classWhenTrue</code> is added and <code>classWhenFalse</code> is removed (if present and
 * specified).  When condition is false, <code>classWhenTrue</code> is removed and
 * <code>classWhenFalse</code> is added (again, if present and specified).
 *
 * @param {string} condition	the condition
 * @param {string} classWhenTrue	the class name to add when condition is <code>true</code>
 * @param {string} classWhenFalse	the class name to add when contition is <code>false</code> (may be <code>null</code>)
 */
DwtControl.prototype.condClassName = function(condition, classWhenTrue, classWhenFalse) {
	Dwt.condClass(this.getHtmlElement(), condition, classWhenTrue, classWhenFalse);
};

/**
 * Sets the display state.
 * 
 * @param	{Object}		state		the state
 */
DwtControl.prototype.setDisplayState =
function(state) {
    if (!this._enabled) {
		state = DwtControl.DISABLED;
	}

    if (arguments.length > 1) {
        var a = [];
        for (var i = 0; i < arguments.length; i++) {
            a.push(arguments[i]);
        }
        state = a.join(" ");
    }

    if (this._displayState == state) {
        return;
    }

	var oldState = this._displayState;

    this._displayState = state;
    Dwt.delClass(this.getHtmlElement(), DwtControl._RE_STATES, state);

    AjxUtil.foreach(DwtControl._ARIA_STATES, (function(attribute, state) {
        if (DwtControl._RE_STATE[state].test(this._displayState)) {
            this.setAttribute(attribute, true);
        } else {
            this.removeAttribute(attribute);
        }
    }).bind(this));

	if (this.isListenerRegistered(DwtEvent.STATE_CHANGE)) {
		this.__controlEvent.reset(DwtControlEvent.STATE);
		this.__controlEvent.oldState = oldState;
		this.__controlEvent.newState = state;
		this.__controlEvent.dwtObj = this;
		this.notifyListeners(DwtEvent.STATE_CHANGE, this.__controlEvent);
	}
};

/**
* Shows an alert in the control. For example, to indicate that a new message has arrived.
*
* @param	{string}	alert		the alert
*/
DwtControl.prototype.showAlert =
function(alert) {
	if (alert && !this._alert) {
		this.delClassName(null, "ZAlert");
	} else if (!alert && this._alert) {
		this.delClassName("ZAlert", null);
	}
	this._alert = alert;
};

/**
* Checks if the control is showing an alert.
* 
* @return	{boolean}	<code>true</code> if showing an altert; <code>false</code> otherwise
*/
DwtControl.prototype.isAlertShown =
function() {
	return this._alert;
};

/**
 * @private
 */
DwtControl.prototype._createHtmlFromTemplate =
function(templateId, data) {
    // set html content
    this.getHtmlElement().innerHTML = AjxTemplate.expand(templateId, data);

    // set container class name, if needed
    var params = AjxTemplate.getParams(templateId);
    var className = params && params["class"];
    if (className) {
        className = [ this._className, className ].join(" ");
        this.setClassName(className);
    }
};

/**
 * Gets the control cursor.
 * 
 * @return {string}		the control cursor
 *
 * @see #setCursor
 */
DwtControl.prototype.getCursor =
function() {
	if (!this._checkState()) { return; }

	return Dwt.getCursor(this.getHtmlElement());
};

/**
 * Sets the control cursor.
 *
 * @param {string} cursorName		the name of the new cursor
 *
 * @see #getCursor
 */
DwtControl.prototype.setCursor =
function(cursorName) {
	if (!this._checkState()) { return; }

	Dwt.setCursor(this.getHtmlElement(), cursorName);
};

/**
 * Gets the control drag source.
 * 
 * @return {DwtDragSource}		the control drag source or <code>null</code> for none
 *
 * @see #setDragSource
 */
DwtControl.prototype.getDragSource =
function() {
	return this._dragSource;
};

/**
 * Set the control drag source. The drag source binds the drag-and-drop system with
 * an application. Setting a control drag source makes the control "draggable".
 *
 * @param {DwtDragSource} dragSource		the control drag source
 *
 * @see #getDragSource
 */
DwtControl.prototype.setDragSource =
function(dragSource) {
	this._dragSource = dragSource;
	if (dragSource && !this._ctrlCaptureObj) {
		this.__initCapture();
		this._dndHoverAction = new AjxTimedAction(null, this.__dndDoHover);
	}
};

/**
 * Gets the control drop target.
 * 
 * @return	{DwtDropTarget}		the control drop target or <code>null</code> for none
 *
 * @see #setDropTarget
 */
DwtControl.prototype.getDropTarget =
function() {
	return this._dropTarget;
};

/**
 * Sets the drop target for the control. The drop target binds the drag-and-drop system with
 * an application. Setting a control drop target makes the control a potential drop
 * target within an application.
 *
 * @param {DwtDropTarget} dropTarget		the control drop target
 *
 * @see #getDropTarget
 */
DwtControl.prototype.setDropTarget =
function(dropTarget) {
	this._dropTarget = dropTarget;
};

/**
 * Gets the control drag box.
 *
 * @return {DwtDragBox}		the control drag box or <code>null</code> for none
 *
 * @see #setDragBox
 */
DwtControl.prototype.getDragBox =
function() {
	return this._dragBox;
};

/**
 * Set the control drag box. The drag box handles the display of a dotted rectangle
 * that is typically used to select items.
 *
 * @param {DwtDragBox} dragBox		the control drag box
 *
 * @see #getDragBox
 */
DwtControl.prototype.setDragBox =
function(dragBox) {
	this._dragBox = dragBox;
	if (dragBox && !this._ctrlCaptureObj) {
		this.__initCapture();
	}
};

DwtControl.prototype.__initCapture =
function(dragBox) {
	this._ctrlCaptureObj = new DwtMouseEventCapture({
		targetObj:		this,
		id:				"DwtControl",
		mouseOverHdlr:	DwtControl.__mouseOverHdlr,
		mouseDownHdlr:	DwtControl.__mouseDownHdlr,
		mouseMoveHdlr:	DwtControl.__mouseMoveHdlr,
		mouseUpHdlr:	DwtControl.__mouseUpHdlr,
		mouseOutHdlr:	DwtControl.__mouseOutHdlr
	});
};

/**
 * Gets the enabled state.
 * 
 * @return {boolean}		<code>true</code> if the control is enabled; <code>false</code> otherwise
 *
 * @see #setEnabled
 */
DwtControl.prototype.getEnabled =
function() {
	if (!this._checkState()) { return; }

	return this._enabled;
};

/**
 * Sets the control enabled state. If <code>setHtmlElement</code> is true, then
 * this method will also set the control HTML element disabled attribute.
 *
 * @param {boolean} enabled		<code>true</code> if the control is enabled
 * @param {boolean} setHtmlElement	<code>true</code> to set the control HTML element disabled attribute
 */
DwtControl.prototype.setEnabled =
function(enabled, setHtmlElement) {
	if (!this._checkState()) { return; }

	if (enabled != this._enabled) {
		this._enabled = enabled;
        this.setDisplayState(enabled ? DwtControl.NORMAL : DwtControl.DISABLED);
        if (setHtmlElement)
			this.getHtmlElement().disabled = !enabled;
	}
};

/**
 * Gets the ID of the control containing HTML element.
 *
 * @return {string} 	the ID of the control containing HTML element
 */
DwtControl.prototype.getHTMLElId =
function () {
	return this._htmlElId;
};

/**
 * Gets the control containing HTML element. By default this is a <code>div</code> element
 *
 * @return {HTMLElement}		the control containing HTML element
 */
DwtControl.prototype.getHtmlElement =
function() {
	if (!this._checkState()) { return; }

	var htmlEl = this._elRef || document.getElementById(this._htmlElId);
	if (htmlEl == null) {
		htmlEl = DwtComposite._pendingElements[this._htmlElId];
	} else if (!htmlEl._rendered) {
		delete DwtComposite._pendingElements[this._htmlElId];
		htmlEl._rendered = true;
	}
	return this._elRef = htmlEl;
};

/**
 * Returns the element that should get browser focus when this control is focused.
 *
 * @returns {HTMLElement}
 */
DwtControl.prototype.getFocusElement = function() {

    return this.isFocusable ? this._focusElement : null;
};

/**
 * Sets the "focus element" if this control is focusable. Adds focus/blur event handlers and a tabIndex to the focus element.
 * If no element is provided, defaults to the control's input element or its container (DIV).
 *
 * @param {HTMLElement} el      (optional) new focus element
 */
DwtControl.prototype.setFocusElement = function(el) {

    if (!this.isFocusable) {
        return;
    }

    var hadFocus = (document.activeElement === this._focusElement),
        focusEl = el || (this.getInputElement && this.getInputElement()) || this.getHtmlElement();

    if (this._focusElement && this._focusElement !== focusEl) {
        this._makeFocusable(this._focusElement, false);
    }

    this._focusElement = focusEl;

    if (focusEl) {
        this._makeFocusable(this._focusElement, true);
        if (hadFocus) {
            focusEl.focus();
        }
    }
};

/**
 * Returns the control associated with the given element, if any.
 * 
 * @param {Element}		htmlEl	an HTML element
 * @return	{DwtControl}		the control element or <code>null</code> for none
 */
DwtControl.fromElement = function(htmlEl)  {

	return DwtControl.ALL_BY_ID[htmlEl.id];
};

/**
 * Returns the control associated with the given element ID, if any.
 * 
 * @param {string}		htmlElId	an HTML element Id
 * @return	{DwtControl}		the control element or <code>null</code> for none
 */
DwtControl.fromElementId = function(htmlElId)  {

	return DwtControl.ALL_BY_ID[htmlElId];
};

/**
 * Finds a control and starts the search at the given element and works
 * up the element chain until it finds one with an ID that maps to a {@link DwtControl}.
 * 
 * @param {Element}		htmlEl	an HTML element
 * @return	{DwtControl}	the control or <code>null</code> for none
 */
DwtControl.findControl =
function(htmlEl)  {

	// FF 3.5 throws protection error if we dereference a chrome element, so bail
	if (AjxEnv.isFirefox3_5up && !AjxEnv.isFirefox3_6up) {
		var s = HTMLElement.prototype.toString.call(htmlEl);
		if (s == '[xpconnect wrapped native prototype]' || s == '[object XULElement]') { return null; }
	}

	try{
		while (htmlEl) {
			if (htmlEl.id && DwtControl.ALL_BY_ID[htmlEl.id]) {
				return DwtControl.ALL_BY_ID[htmlEl.id];
			}
			htmlEl = htmlEl.parentNode;
		}
	} catch(e) {
		//In some FF, we might get permission denied error. Ignore it.
	}
	return null;
};

/**
 * Returns the control associated with the given event. Starts with the
 * event target and works its way up the element chain until it finds one
 * with an ID that maps to a {@link DwtControl}.
 * 
 * @param {Event}		ev				the DHTML event
 * @param {boolean}		useRelatedTarget	if <code>true</code>, use element that was related to this event
 * @return {DwtControl}	the control or <code>null</code> for none
 */
DwtControl.getTargetControl =
function(ev, useRelatedTarget)  {
	var htmlEl = DwtUiEvent.getTarget(ev, useRelatedTarget);
	return htmlEl ? DwtControl.findControl(htmlEl) : null;
};

/**
 * Sets the control HTML element id attribute.
 *
 * @param {string} id 		the new element Id
 */
DwtControl.prototype.setHtmlElementId =
function(id) {
	if (this._disposed) { return; }

	if (this.__ctrlInited) {
		var htmlEl = this.getHtmlElement();
		if (!htmlEl._rendered) {
			delete DwtComposite._pendingElements[this._htmlElId];
			DwtComposite._pendingElements[id] = htmlEl;
		}
		else {
			delete DwtControl.ALL_BY_ID[this._htmlElId];
			DwtControl.ALL_BY_ID[id] = this;
		}
		htmlEl.id = id;
	}
	this._htmlElId = id;
};

/**
 * Gets the X coordinate of the control (if absolutely positioned).
 * 
 * @return {number}		the X coordinate of the control 
 *
 * @see #getBounds
 * @see #getInsetBounds
 * @see #getInsets
 * @see #getSize
 * @see #getLocation
 * @see #getH
 * @see #getW
 * @see #getXW
 * @see #getY
 * @see #getYH
 * @see #setBounds
 * @see #setSize
 * @see #setLocation
 */
DwtControl.prototype.getX =
function() {
	if (!this._checkState()) { return; }

	return Dwt.getLocation(this.getHtmlElement()).x;
};

/**
 * Gets the horizontal extent of the control (if absolutely positioned).
 * 
 * @return {number} 	the horizontal extent of the control
 *
 * @see #getBounds
 * @see #getInsetBounds
 * @see #getInsets
 * @see #getSize
 * @see #getLocation
 * @see #getH
 * @see #getW
 * @see #getX
 * @see #getY
 * @see #getYH
 * @see #setBounds
 * @see #setSize
 * @see #setLocation
 */
DwtControl.prototype.getXW =
function() {
	if (!this._checkState()) { return; }

    var bounds = this.getBounds();
	return bounds.x+bounds.width;
};

/**
 * Gets the Y coordinate of the control (if it is absolutely positioned).
 * 
 * @return {number}		the Y coordinate of the control 
 *
 * @see #getBounds
 * @see #getInsetBounds
 * @see #getInsets
 * @see #getSize
 * @see #getLocation
 * @see #getH
 * @see #getW
 * @see #getX
 * @see #getXW
 * @see #getYH
 * @see #setBounds
 * @see #setSize
 * @see #setLocation
 */
DwtControl.prototype.getY =
function() {
	if (!this._checkState()) { return; }

	return Dwt.getLocation(this.getHtmlElement()).y;
};

/**
 * Gets the vertical extent of the control (if it is absolutely positioned).
 * 
 * @return {number}		the vertical extent of the control
 *
 * @see #getBounds
 * @see #getInsetBounds
 * @see #getInsets
 * @see #getSize
 * @see #getLocation
 * @see #getH
 * @see #getW
 * @see #getX
 * @see #getXW
 * @see #getY
 * @see #setBounds
 * @see #setSize
 * @see #setLocation
 */
DwtControl.prototype.getYH =
function() {
	if (!this._checkState()) { return; }

    var bounds = this.getBounds();
	return bounds.y+bounds.height;
};

/**
 * Returns the positioning style
 */
DwtControl.prototype.getPosition =
function() {
	if (!this._checkState()) { return; }

	return Dwt.getPosition(this.getHtmlElement());
};

/**
 * Sets the positioning style
 * 
 * @param 	{constant}	posStyle	positioning style (Dwt.*_STYLE)
 */
DwtControl.prototype.setPosition =
function(posStyle) {
	if (!this._checkState()) { return; }

	return Dwt.setPosition(this.getHtmlElement(), posStyle);
};

/**
 * Gets the location of the control.
 *
 * @return {DwtPoint}		the location of the control
 *
 * @see #getBounds
 * @see #getInsetBounds
 * @see #getInsets
 * @see #getSize
 * @see #setLocation
 * @see #getH
 * @see #getW
 * @see #getX
 * @see #getXW
 * @see #getY
 * @see #setBounds
 * @see #setSize
 * @see Dwt
 */
DwtControl.prototype.getLocation =
function() {
	if (!this._checkState()) { return; }

	return Dwt.getLocation(this.getHtmlElement());
};

/**
 * Sets the location of the control. The position style of the control must
 * be absolute or else an exception is thrown. To only set one of the coordinates,
 * pass in a value of <i>Dwt.DEFAULT</i> for the coordinate for which the value is
 * not to be set. Any <i>DwtEvent.CONTROL</i> listeners registered on the control
 * will be called.
 *
 * @param {number|string} x	the x coordinate of the element (for example: 10, "10px", Dwt.DEFAULT)
 * @param {number|string} y	the y coordinate of the element (for example: 10, "10px", Dwt.DEFAULT)
 *
 * @return {DwtControl}		this control
 *
 * @see #getBounds
 * @see #getInsetBounds
 * @see #getInsets
 * @see #getSize
 * @see #getLocation
 * @see #getH
 * @see #getW
 * @see #getX
 * @see #getXW
 * @see #getY
 * @see #setBounds
 * @see #setSize
 * @see Dwt
 */
DwtControl.prototype.setLocation =
function(x, y) {
	if (!this._checkState()) { return; }

	if (this.isListenerRegistered(DwtEvent.CONTROL)) {
		var htmlElement = this.getHtmlElement();
		this.__controlEvent.reset(DwtControlEvent.MOVE);
		var loc = Dwt.getLocation(htmlElement);
		this.__controlEvent.oldX = loc.x;
		this.__controlEvent.oldY = loc.y;
		Dwt.setLocation(htmlElement, x, y);
		loc = Dwt.getLocation(htmlElement);
		this.__controlEvent.newX = loc.x;
		this.__controlEvent.newY = loc.y;
		this.notifyListeners(DwtEvent.CONTROL, this.__controlEvent);
	} else {
		Dwt.setLocation(this.getHtmlElement(), x, y);
	}
	return this;
};

/**
 * Gets the control scroll style. The scroll style determines the control
 * behavior when content overflows its div's boundaries. Possible values are:
 * <ul>
 * <li>{@link Dwt.CLIP} - Clip on overflow</li>
 * <li>{@link Dwt.VISIBLE} - Allow overflow to be visible</li>
 * <li>{@link Dwt.SCROLL} - Automatically create scrollbars if content overflows</li>
 * <li>{@link Dwt.FIXED_SCROLL} - Always have scrollbars whether content overflows or not</li>
 * </ul>
 *
 * @return {number}		the control scroll style
 */
DwtControl.prototype.getScrollStyle =
function() {
	if (!this._checkState()) { return; }

	return Dwt.getScrollStyle(this.getHtmlElement());
};

/**
 * Sets the control scroll style. The scroll style determines the control's
 * behavior when content overflows its div's boundaries. Possible values are:
 * <ul>
 * <li>{@link Dwt.CLIP} - Clip on overflow</li>
 * <li>{@link Dwt.VISIBLE} - Allow overflow to be visible</li>
 * <li>{@link Dwt.SCROLL} - Automatically create scrollbars if content overflows</li>
 * <li>{@link Dwt.FIXED_SCROLL} - Always have scrollbars whether content overflows or not</li>
 * </ul>
 *
 * @param {int} scrollStyle		the control new scroll style
 */
DwtControl.prototype.setScrollStyle =
function(scrollStyle) {
	if (!this._checkState()) { return; }

	Dwt.setScrollStyle(this.getHtmlElement(), scrollStyle);
};

/**
 * Returns the element that this control scrolls within.
 *
 * @returns {HTMLElement}
 */
DwtControl.prototype.getScrollContainer = function() {

    return this.parent && this.parent.getHtmlElement();
};

/**
 * Sets the control position. The position determines the control's
 * location within the context of which it was created. Possible values are:
 * <ul>
 * <li>{@link DwtControl.STATIC_STYLE} - Allow browser to control content flow</li>
 * <li>{@link DwtControl.ABSOLUTE_STYLE} - Allow content to be positioned relative to parent or body</li>
 * <li>{@link DwtControl.RELATIVE_STYLE} - Allow browser to control content flow but relative to parent</li>
 * </ul>
 *
 * @param {number} position		the control new position
 */
DwtControl.prototype.setPosition =
function(position) {
	if (!this._checkState()) { return; }

	if (position == DwtControl.STATIC_STYLE ||
		position == DwtControl.ABSOLUTE_STYLE ||
		position == DwtControl.RELATIVE_STYLE)
	{
		this.__posStyle = position;
		Dwt.setPosition(this.getHtmlElement(), position);
	}
};

/**
 * Gets the width of the control.
 * 
 * @return	{number}		the width of the control
 *
 * @see #getBounds
 * @see #getInsetBounds
 * @see #getInsets
 * @see #getSize
 * @see #getLocation
 * @see #getH
 * @see #getX
 * @see #getXW
 * @see #getY
 * @see #getYH
 * @see #setBounds
 * @see #setSize
 * @see #setLocation
 */
DwtControl.prototype.getW =
function() {
	if (!this._checkState()) { return; }

	return Dwt.getSize(this.getHtmlElement()).x;
};

/**
 * Gets the height of the control.
 * 
 * @return {number}	the height of the control
 *
 * @see #getBounds
 * @see #getInsetBounds
 * @see #getInsets
 * @see #getSize
 * @see #getLocation
 * @see #getW
 * @see #getX
 * @see #getXW
 * @see #getY
 * @see #getYH
 * @see #setBounds
 * @see #setLocation
 * @see #setSize
 */
DwtControl.prototype.getH =
function() {
	if (!this._checkState()) { return; }

	return Dwt.getSize(this.getHtmlElement()).y;
};

/**
 * Gets the size of the control. The x value of the returned point is the width
 * and the y is the height.
 * 
 * @return {DwtPoint}		the control size
 *
 * @see #getBounds
 * @see #getInsetBounds
 * @see #getInsets
 * @see #getLocation
 * @see #getH
 * @see #getW
 * @see #getX
 * @see #getXW
 * @see #getY
 * @see #getYH
 * @see #setBounds
 * @see #setSize
 * @see #setLocation
 */
DwtControl.prototype.getSize =
function(getFromStyle) {
	if (!this._checkState()) { return; }

	return Dwt.getSize(this.getHtmlElement(), null, getFromStyle);
};

/**
 * Gets the outer size -- that is, the size including margins, padding, and borders -- of an
 * HTML element.
 *
 * @return {DwtPoint}	the elements size, margins, padding, and borders included
 */
DwtControl.prototype.getOuterSize =
function() {
	if (!this._checkState()) { return; }

	return Dwt.getOuterSize(this.getHtmlElement(), null);
};

/**
 * Sets the size of the control
 *
 * @param {number|string} width	the width of the control (for example: 100, "100px", "75%", Dwt.DEFAULT)
 * @param {number|string} height	the height of the control (for example: 100, "100px", "75%", Dwt.DEFAULT)
 *
 * @return {DwtControl}	this control
 *
 * @see #getBounds
 * @see #getInsetBounds
 * @see #getInsets
 * @see #getSize
 * @see #setLocation
 * @see #getH
 * @see #getW
 * @see #getX
 * @see #getXW
 * @see #getY
 * @see #getYH
 * @see #setBounds
 */
DwtControl.prototype.setSize =
function(width, height) {
	if (!this._checkState()) { return; }

	if (this.isListenerRegistered(DwtEvent.CONTROL)) {
		var htmlElement = this.getHtmlElement();
		this.__controlEvent.reset(DwtControlEvent.RESIZE);
		var sz = Dwt.getSize(htmlElement);
		this.__controlEvent.oldWidth = sz.x;
		this.__controlEvent.oldHeight = sz.y;
		Dwt.setSize(htmlElement, width, height);
		sz = Dwt.getSize(htmlElement);
		this.__controlEvent.newWidth = sz.x;
		this.__controlEvent.newHeight = sz.y;
		this.notifyListeners(DwtEvent.CONTROL, this.__controlEvent);
	} else {
		Dwt.setSize(this.getHtmlElement(), width, height);
	}
	return this;
};

/**
 * Gets the tooltip content (typically set using {@link #setToolTipContent}). Controls
 * that want to return dynamic tooltip content should override this method.
 *
 * @param {DwtEvent}	ev	the mouseover event
 * @return {string}		the tooltip content set for the control
 */
DwtControl.prototype.getToolTipContent =
function(ev) {
	if (this._disposed) { return null; }

	return this.__toolTipContent;
};

/**
 * Sets tooltip content for the control. The toolTip passed in may be plain text,
 * HTML or an object containing a callback function.
 * If DwtControl.useBrowserTooltips is set to true, and the tooltip does not have
 * HTML, returns, or tabs, use a browser tooltip by setting the 'title' attribute
 * on the element.
 *
 * @param {string/object} 	toolTip		the tooltip content
 */
DwtControl.prototype.setToolTipContent =
function(toolTip, useBrowser) {
	if (this._disposed) { return; }
	if (toolTip && (typeof(toolTip) == "string")  && DwtControl.useBrowserTooltips) {
		// browser tooltip can't have return, tab, or HTML
		if (!toolTip || (!toolTip.match(/[\n\r\t]/) && !toolTip.match(/<[a-zA-Z]+/))) {
			var el = this.getHtmlElement();
			if (el) {
				el.title = toolTip;
				this._browserToolTip = true;
				return;
			}
		}
	}

	this._browserToolTip = false;
	this.__toolTipContent = toolTip;
};

/**
 * Gets the visible state of the control. For example, the control HTML elements display style attribute is not "none".
 * 
 * @return {boolean}	if <code>true</code>, the control is visible
 *
 * @see Dwt#getVisibile
 */
DwtControl.prototype.getVisible =
function() {
	if (!this._checkState()) { return; }

	return Dwt.getVisible(this.getHtmlElement());
};

/**
 * Sets the the visible state of the control HTML element. <i>Note: Gets style
 * "display: none", don't confuse with {@link setVisibility}).</i>
 *
 * @param {boolean} visible 	if <code>true</code>, the control should be displayed; if <code>false</code>, the control should not be displayed
 *
 * @see Dwt#setVisible
 */
DwtControl.prototype.setVisible =
function(visible) {
	if (!this._checkState()) { return; }

	Dwt.setVisible(this.getHtmlElement(), visible);
};

/**
 * Sets the visibility of the control HTML element.
 *
 * @param {boolean} visible		if <code>true</code> then the control is visible
 *
 * @see Dwt#setVisibility
 */
DwtControl.prototype.setVisibility =
function(visible) {
	if (!this._checkState()) { return; }

	Dwt.setVisibility(this.getHtmlElement(), visible);
};

/**
 * Gets the visibility of the control HTML element.
 * 
 * @return {boolean}	if <code>true</code>, the control is visible (i.e. the HTML elements visibility play style attribute is not "hidden")
 *
 * @see Dwt#getVisibility
 */
DwtControl.prototype.getVisibility =
function() {
	if (!this._checkState()) { return; }

	return Dwt.getVisibility(this.getHtmlElement());
};


/**
 * Gets the control z-index value.
 *
 * @param {boolean} getFromStyle    get the value from the style attribute of
 *                                  the control element, or a parent
 *
 * @return	{number}	the z-index value
 */
DwtControl.prototype.getZIndex =
function(getFromStyle) {
	if (!this._checkState()) { return; }

	return Dwt.getZIndex(this.getHtmlElement(), getFromStyle);
};

/**
 * Sets the z-index for the control HTML element. Since z-index is only relevant among peer
 * elements, we make sure that all elements that are being displayed via z-index hang off the
 * main shell.
 *
 * @param {number} idx		the new z-index for this element
 */
DwtControl.prototype.setZIndex =
function(idx) {
	if (!this._checkState()) { return; }

	Dwt.setZIndex(this.getHtmlElement(), idx);
};

/**
 * Convenience function to toggle visibility using z-index. It uses the two lowest level
 * z-indexes ({@link Dwt.Z_VIEW} and {@link Dwt.Z_HIDDEN} respectively). Any further
 * stacking will have to use {@link #setZIndex} directly.
 *
 * @param {boolean} show		if <code>true</code>, show the element; <code>false</code> to hide the element
 *
 * @see #setZIndex
 */
DwtControl.prototype.zShow =
function(show) {
	this.setZIndex(show ? Dwt.Z_VIEW : Dwt.Z_HIDDEN);
};

/**
 * Sets the display.
 * 
 * @param	{string}	value		the display value
 */
DwtControl.prototype.setDisplay =
function(value) {
	if (!this._checkState()) { return; }

	Dwt.setDisplay(this.getHtmlElement(), value);
};

/**
 * Sets the opacity of the control HTML element.
 *
 * @param {Number} opacity		opacity, as a percentage between 0 and 100
 *
 * @see Dwt#setOpacity
 */
DwtControl.prototype.setOpacity =
function(opacity) {
	if (!this._checkState()) { return; }

	Dwt.setOpacity(this.getHtmlElement(), opacity);
};

/**
 * Gets the opacity of the control HTML element.
 *
 * @return {Number}	opacity, as a percentage between 0 and 100
 *
 * @see Dwt#getOpacity
 */
DwtControl.prototype.getOpacity =
function() {
	if (!this._checkState()) { return; }

	return Dwt.getOpacity(this.getHtmlElement());
};

/**
 * Prevents selection on the specified element.
 *
 * @param	{Element}	targetEl	the element
 */
DwtControl.prototype.preventSelection =
function(targetEl) {
	return !this.__isInputEl(targetEl);
};

/**
 * Prevents a context menu on the specified element.
 * 
 * @param	{Element}	targetEl	the element
 */
DwtControl.prototype.preventContextMenu =
function(targetEl) {
	return targetEl ? (!this.__isInputEl(targetEl)) : true;
};

/**
 * Returns the content of the control HTML element.
 * 
 * @return {string}		HTML content
 */
DwtControl.prototype.getContent =
function() {
	return this.getHtmlElement().innerHTML;
};

/**
 * Sets the content of the control HTML element to the provided
 * content. Care should be taken when using this method as it can blow away all
 * the content of the control which can be particularly bad if the control is
 * a <i>DwtComposite</i> with children. Generally this method should be used
 * controls which are being directly instantiated and used as a canvas
 *
 * @param {string} content		the HTML content
 */
DwtControl.prototype.setContent =
function(content) {
	if (content) {
		this.getHtmlElement().innerHTML = content;
	}
};

/**
 * Clears the content of the control HTML element.
 * Care should be taken when using this method as it can blow away all
 * the content of the control which can be particularly bad if the control is
 * a {@link DwtComposite} with children. Generally this method should be used
 * controls which are being directly instantiated and used as a canvas.
 */
DwtControl.prototype.clearContent =
function() {
	this.getHtmlElement().innerHTML = "";
};

/**
 * Appends this control element to the specified element.
 *
 * @param {Element|string}	elemOrId  the DOM element or an element id
 */
DwtControl.prototype.appendElement =
function(elemOrId) {
    var el = AjxUtil.isString(elemOrId) ? document.getElementById(elemOrId) : elemOrId;
    if (el) {
        el.appendChild(this.getHtmlElement(), el);
    }
};

/**
 * Replaces the specified element with this control element.
 *
 * @param {Element|string}	elemOrId  the DOM element or an element id
 */
DwtControl.prototype.replaceElement =
function(elemOrId, inheritClass, inheritStyle) {
    var oel = AjxUtil.isString(elemOrId) ? document.getElementById(elemOrId) : elemOrId;
    if (oel) {
        var nel = this.getHtmlElement();
        oel.parentNode.replaceChild(nel, oel);
        this._replaceElementHook(oel, nel, inheritClass, inheritStyle);
    }
};

/**
 * This method is a hook for sub-classes that want to intercept the
 * inheriting of class and style when an element is replaced. By
 * default, the new will will inherit the class and style. In order
 * to prevent this behavior, you must pass in a <code>true</code>
 * or <code>false</code> value.
 * 
 * @private
 */
DwtControl.prototype._replaceElementHook =
function(oel, nel, inheritClass, inheritStyle) {
    if ((inheritClass == null || inheritClass) && oel.className) {
        Dwt.addClass(nel, oel.className);
    }
    if (inheritStyle == null || inheritStyle) {
        var style = oel.getAttribute("style") || oel.style;
        if (style) {
            if (AjxUtil.isString(style)) { // All non-IE browsers
                nel.setAttribute("style", [nel.getAttribute("style"),style].join(";"));
            } else if (AjxUtil.isString(style.cssText)) {
				if (style.cssText) {
					nel.setAttribute("style", [nel.getAttribute("style"),style.cssText].join(";"));
				}
			} else {
				for (var attribute in style) {
					if (style[attribute]) {
						try {
							nel.style[attribute] = style[attribute];
						} catch (e) {}
					}
				}
			}
        }
    }
};

/**
 * This protected method is called by the keyboard navigate infrastructure when a control
 * gains focus. This method should be overridden by derived classes to provide
 * the visual behavior for the component losing focus
 *
 * @see #_focus
 * @see #_focusByMouseUpEvent
 * @see #focus
 * 
 * @private
 */
DwtControl.prototype._blur =
function() {
};

/**
 * This protected method should be overridden by derived classes to provide
 * behavior for the component gaining focus e.g. providing a border or
 * highlighting etc...
 *
 * @see #_blur
 * @see #_focusByMouseUpEvent
 * @see #focus
 * 
 * @private
 */
DwtControl.prototype._focus =
function() {
};

/**
 * This protected method is called from mouseUpHdl. Subclasses may override this method
 * if they have their own specialized focus management code.
 *
 * @see #_blur
 * @see #_focus
 * @see #focus
 * 
 * @private
 */
DwtControl.prototype._focusByMouseUpEvent =
function(ev)  {
    DBG.println(AjxDebug.FOCUS, "DwtControl FOCUSONMOUSEUP: " + [this, this._htmlElId].join(' / '));
 	if (this.getEnabled()) {
        this.shell.getKeyboardMgr().grabFocus(this);
    }
};

/**
 * This is for bug 11827.
 * 
 * TODO: we should remove _focusByMouseUpEvent and update all classes
 * that define it to use _focusByMouseDownEvent instead.
 * 
 * @private
 */
DwtControl.prototype._focusByMouseDownEvent =
function(ev) {
    DBG.println(AjxDebug.FOCUS, "DwtControl FOCUSONMOUSEDOWN: " + [this, this._htmlElId].join(' / '));
	this._duringFocusByMouseDown = true;
	this._focusByMouseUpEvent(ev);
	this._duringFocusByMouseDown = false;
};

/**
 * Returns the type of drag operation we are performing.
 *
 * @param mouseEv
 */
DwtControl.prototype._getDragOp =
function(mouseEv) {
	return mouseEv.ctrlKey ? Dwt.DND_DROP_COPY : Dwt.DND_DROP_MOVE;
};

/**
 * Subclasses may override this protected method to return an HTML element that will represent
 * the dragging icon. The icon must be created on the DwtShell widget. This means that the
 * icon must be a child of the shells HTML component If this method returns
 * null, it indicates that the drag failed. This method is called when a control is
 * being dragged and it has a valid drag source
 *
 * @return {HTMLElement}	the DnD dragging icon. This is typically a div element
 *
 * @see #_setDragProxyState
 * @see #_destroyDragProxy
 * @see #_isValidDragObject
 * @see #_dragEnter
 * @see #_dragOver
 * @see #_dragHover
 * @see #_dragLeave
 * @see #_drop
 * @see #setDragSource
 * @see DwtDropTarget
 * @see DwtDragSource
 * 
 * @private
 */
DwtControl.prototype._getDragProxy =
function(dragOp) {
	DBG.println(AjxDebug.DBG2, "DwtControl.prototype._getDragProxy");
	return null;
};

DwtControl.prototype.getDragSelectionBox =
function(dragOp) {

	if (!this._dragSelectionBox) {
		var box = this._dragSelectionBox = document.createElement("div");
		box.className = "dndSelectionBox";
		Dwt.setPosition(box, Dwt.ABSOLUTE_STYLE);
		this.shell.getHtmlElement().appendChild(box);
		Dwt.setZIndex(box, Dwt.Z_DND);
	}
	return this._dragSelectionBox;
};

/**
 * Subclasses may override this method to set the DnD icon properties based on whether drops are
 * allowed. The default implementation sets the class on the HTML element obtained
 * from <code>_getDragProxy</code> to DwtCssStyle.DROPPABLE if <code>dropAllowed</code> is true and
 * to DwtCssStyle.NOT_DROPPABLE if false
 *
 * @param {boolean} dropAllowed		if <code>true</code>, then dropping is allowed on the drop zone so set
 * 		DnD icon to the visually reflect this
 *
 * @see #_getDragProxy
 * @see #_destroyDragProxy
 * @see #_isValidDragObject
 * @see #_dragEnter
 * @see #_dragOver
 * @see #_dragHover
 * @see #_dragLeave
 * @see #_drop
 * @see #setDragSource
 * @see DwtDropTarget
 * @see DwtDragSource
 * 
 * @private
 */
DwtControl.prototype._setDragProxyState =
function(dropAllowed) {
	if (this._dndProxy) {
		Dwt.condClass(this._dndProxy, dropAllowed, DwtCssStyle.DROPPABLE, DwtCssStyle.NOT_DROPPABLE);
	}
};


/**
 * @private
 */
DwtControl.__junkIconId = 0;

/**
 * Subclasses may override this method to destroy the DnD icon HTML element
 *
 * @see #_getDragProxy
 * @see #_setDragProxyState
 * @see #_isValidDragObject
 * @see #_dragEnter
 * @see #_dragOver
 * @see #_dragHover
 * @see #_dragLeave
 * @see #_drop
 * @see #setDragSource
 * @see DwtDropTarget
 * @see DwtDragSource
 * 
 * @private
 */
DwtControl.prototype._destroyDragProxy =
function(icon) {
	if (icon) {
		// not sure why there is no parent node, but if there isn't one,
		// let's try and do our best to get rid of the icon
		if (icon.parentNode) {
			icon.parentNode.removeChild(icon);
		} else {
			// at least hide the icon, and change the id so we can't get it back later
			icon.style.zIndex = -100;
			icon.id = "DwtJunkIcon" + DwtControl.__junkIconId++;
			icon = null;
		}
	}
};

DwtControl.prototype.destroyDragSelectionBox =
function() {

	var box = this._dragSelectionBox;
	if (box && box.parentNode) {
		box.parentNode.removeChild(box);
	}
	this._dragSelectionBox = null;
};

/**
 * Subclasses may override this method to provide feedback as to whether a possibly
 * valid capture is taking place. For example, there are instances such as when a mouse
 * down happens on a scroll bar in a DwtListView that are reported in the context of
 * the DwtListView, but which are not really a valid mouse down i.e. on a list item. In
 * such cases this function would return false.
 *
 * @return {boolean}	<code>true</code> if the object is a valid drag object
 *
 * @see #_getDragProxy
 * @see #_setDragProxyState
 * @see #_destroyDragProxy
 * @see #_dragEnter
 * @see #_dragOver
 * @see #_dragHover
 * @see #_dragLeave
 * @see #_drop
 * @see #setDragSource
 * @see DwtDropTarget
 * @see DwtDragSource
 * 
 * @private
 */
 DwtControl.prototype._isValidDragObject =
 function(ev) {
 	return true;
 };

/**
 * _dragHover is called multiple times as the user hovers over
 * the control. _dragLeave is called when the drag operation exits the control.
 * _drop is called when the item is dropped on the target.
 */

 /**
  * This protected method is called when a drag operation enters a control. Subclasses
  * supporting drop targets should implement this method to visual indicate that they are a
  * drop target. This could be by changing the background etc. Note that it is the
  * responsibility of the drag source (the control being dragged) to change its icon state
  * to reflect whether the drop target is valid for the drag source
  *
  * @param {DwtMouseEvent} ev	the mouse event that is associated with the drag operation
  *
  * @see #_getDragProxy
  * @see #_setDragProxyState
  * @see #_destroyDragProxy
  * @see #_isValidDragObject
  * @see #_dragOver
  * @see #_dragHover
  * @see #_dragLeave
  * @see #_drop
  * @see #setDragSource
  * @see DwtDropTarget
  * @see DwtDragSource
  * 
  * @private
  */
DwtControl.prototype._dragEnter =
function(ev) {
};

 /**
  * This protected method is called multiple times as a dragged control crosses over this control
  * Subclasses supporting drop targets may implement this method for additional visual
  * indication, such as indicating "landing zones" in the control for drop operations
  *
  * @param {DwtMouseEvent} ev	the mouse event that is associated with the drag operation
  *
  * @see #_getDragProxy
  * @see #_setDragProxyState
  * @see #_destroyDragProxy
  * @see #_isValidDragObject
  * @see #_dragEnter
  * @see #_dragHover
  * @see #_dragLeave
  * @see #_drop
  * @see #setDragSource
  * @see DwtDropTarget
  * @see DwtDragSource
  * @private
  */
DwtControl.prototype._dragOver =
function(ev) {
};

 /**
  * This protected method is called every 750ms as an item hovers over this control
  * Subclasses supporting drop targets may implement this method for additional visual
  * indication or actions, such as expanding a collapsed tree node if the user hovers
  * over the node for a period of time.
  *
  * @param {DwtMouseEvent} ev	the mouse event that is associated with the drag operation
  *
  * @see #_getDragProxy
  * @see #_setDragProxyState
  * @see #_destroyDragProxy
  * @see #_isValidDragObject
  * @see #_dragEnter
  * @see #_dragHover
  * @see #_dragLeave
  * @see #_drop
  * @see #setDragSource
  * @see DwtDropTarget
  * @see DwtDragSource
  * @private
  */
DwtControl.prototype._dragHover =
function(ev) {
};

 /**
  * This protected method is called when the drag operation exits the control
  * Subclasses supporting drop targets should implement this method to reset the
  * visual to the default (i.e. reset the actions performed as part of the
  * <code>_dragEnter</code> method.
  *
  * @param {DwtMouseEvent} ev	the mouse event that is associated with the drag operation
  *
  * @see #_getDragProxy
  * @see #_setDragProxyState
  * @see #_destroyDragProxy
  * @see #_isValidDragObject
  * @see #_dragEnter
  * @see #_dragHover
  * @see #_drop
  * @see #setDragSource
  * @see DwtDropTarget
  * @see DwtDragSource
  * @private
  */
DwtControl.prototype._dragLeave =
function(ev) {
};


/**
  * This protected method is called when the a drop occurs on the control
  * Subclasses supporting drop targets may implement this method to provide a
  * visual indication that the drop succeeded (e.g. an animation such as flashing
  * the drop target).
  *
  * @param {DwtMouseEvent} ev	the mouse event that is associated with the drag operation
  *
  * @see #_getDragProxy
  * @see #_setDragProxyState
  * @see #_destroyDragProxy
  * @see #_isValidDragObject
  * @see #_dragEnter
  * @see #_dragHover
  * @see #_dragLeave
  * @see #setDragSource
  * @see DwtDropTarget
  * @see DwtDragSource
  * @private
  */
DwtControl.prototype._drop =
function(ev) {
};

/**
  * Makes an element focusable or unfocusable by the browser. It manages the "tabIndex" attribute,
  * and sets or unsets the element's onfocus and onblur handlers.
  *
  * @param {HTMLElement}    element	    element to make (not) focusable
  * @param {boolean}        focusable   if true (default), make element focusable by the browser
  *
  * @private
  */
DwtControl.prototype._makeFocusable = function(element, focusable) {

    focusable = (focusable !== false);
    DBG.println(AjxDebug.FOCUS, "MAKE " + (focusable ? '' : 'NOT ') + "FOCUSABLE: " + this + ', ' + (element || ''));

    this._setEventHdlrs([ DwtEvent.ONFOCUS, DwtEvent.ONBLUR ], true, element);
    if (focusable) {
        this._setEventHdlrs([ DwtEvent.ONFOCUS, DwtEvent.ONBLUR ], false, element);
        element.tabIndex = 0;
    }
    else {
        element.removeAttribute('tabIndex');
    }
};

/**
 * This convenience methods sets or clears the control's event handler for key
 * press events as defined by {@link DwtEvent.ONKEYPRESS}.
 *
 * @param {boolean} clear	if <code>true</code>, clear the keypress events handler
 * @param {HTMLElement} element	if specified, assign event handlers to this element (optional)
 *
 * @private
 */
DwtControl.prototype._setKeyPressEventHdlr =
function(clear, element) {
	this._setEventHdlrs([DwtEvent.ONKEYPRESS], clear, element);
};

/**
 * This convenience methods sets or clears the control's event handlers for mouse
 * events as defined by <i>DwtEvent.MOUSE_EVENTS</i>
 *
 * @param {boolean} clear	if <code>true</code>, clear the mouse events handlers
 * @param {HTMLElement} element	if specified, assign event handlers to this element (optional)
 *
 * @private
 */
DwtControl.prototype._setMouseEventHdlrs =
function(clear, element) {
	this._setEventHdlrs(DwtEvent.MOUSE_EVENTS, clear, element);
};

/**
 * This convenience methods sets or clears the control's event handlers for keyboard
 * events as defined by <i>DwtEvent.KEY_EVENTS</i>
 *
 * @param {boolean} clear	if <code>true</code>, clear the mouse events handlers
 * @param {HTMLElement} element	if specified, assign event handlers to this element (optional)
 *
 * @private
 */
DwtControl.prototype._setKeyEventHdlrs =
function(clear, element) {
	this._setEventHdlrs(DwtEvent.KEY_EVENTS, clear, element);
};

/**
 * This protected method will set or clear the event handlers for the provided array
 * of events.
 *
 * @param {array} events		an array of events for which to set or clear the
 * 		control's event handlers. The set of events supported by the control are:
 * 		<ul>
 * 		<li><i>DwtEvent.ONCONTEXTMENU</i></li>
 * 		<li><i>DwtEvent.ONCLICK</i></li>
 * 		<li><i>DwtEvent.ONDBLCLICK</i></li>
 * 		<li><i>DwtEvent.ONMOUSEDOWN</i></li>
 * 		<li><i>DwtEvent.ONMOUSEENTER</i></li>
 * 		<li><i>DwtEvent.ONMOUSELEAVE</i></li>
 * 		<li><i>DwtEvent.ONMOUSEMOVE</i></li>
 * 		<li><i>DwtEvent.ONMOUSEOUT</i></li>
 * 		<li><i>DwtEvent.ONMOUSEOVER</i></li>
 * 		<li><i>DwtEvent.ONMOUSEUP</i></li>
 * 		<li><i>DwtEvent.ONMOUSEWHEEL</i></li>
 * 		<li><i>DwtEvent.ONSELECTSTART</i></li>
 * 		<li><i>DwtEvent.ONKEYPRESS</i></li>
 * 		</ul>
 * @param {boolean} clear	if <code>true</code>, the event handlers are cleared for the set of events
 * @param {HTMLElement} element	if specified, assign event handlers to this element (optional)
 *
 * @see Dwt#setHandler
 * @see Dwt#clearHandler
 * @private
 */
DwtControl.prototype._setEventHdlrs =
function(events, clear, element) {
	if (!this._checkState()) { return; }

	var htmlElement = element || this.getHtmlElement();
	for (var i = 0; i < events.length; i++) {
		if (clear !== true) {
			Dwt.setHandler(htmlElement, events[i], DwtControl.__HANDLER[events[i]]);
		} else {
			Dwt.clearHandler(htmlElement, events[i]);
		}
	}
};

/**
 * @private
 */
DwtControl.prototype._setMouseEvents =
function() {
	// add custom mouse handlers to standard ones
	var mouseEvents = [DwtEvent.ONCONTEXTMENU, DwtEvent.ONCLICK, DwtEvent.ONDBLCLICK, DwtEvent.ONMOUSEDOWN,
					   DwtEvent.ONMOUSEMOVE, DwtEvent.ONMOUSEUP, DwtEvent.ONSELECTSTART];
	if (AjxEnv.isIE) {
		mouseEvents.push(DwtEvent.ONMOUSEENTER, DwtEvent.ONMOUSELEAVE);
	} else {
		mouseEvents.push(DwtEvent.ONMOUSEOVER, DwtEvent.ONMOUSEOUT);
	}
	this._setEventHdlrs(mouseEvents);
};

/**
 * Populates a fake mouse event in preparation for the direct call of a listener (rather
 * than via an event handler).
 * 
 * @param {DwtMouseEvent}	mev		the mouse event
 * @param {hash}	params		the hash of event properties
 * 
 * @see DwtUiEvent.copy
 * @private
 */
DwtControl.prototype._setMouseEvent =
function(mev, params) {
	mev.reset();
	params.ersatz = true;
	DwtUiEvent.copy(mev, params);
	mev.button = params.button;
};

/**
 * TODO
 * @private
 */
DwtControl.prototype._getStopPropagationValForMouseEv =
function(ev) {
	// overload me for dealing w/ browsers w/ weird quirks
	return true;
};

/**
 * TODO
 * @private
 */
DwtControl.prototype._getEventReturnValForMouseEv =
function(ev) {
	// overload me for dealing w/ browsers w/ weird quirks
	return false;
};


/**
 * Check the state of the control, if it is not disposed and is not initialized, then
 * as a side-effect it will initialize it (meaning it will create the HTML element
 * for the control and insert it into the DOM. This is pertinent for controls that
 * were created <i>deferred</i> (see the constructor documentation)
 *
 * @return {boolean}	<code>true</code> if the control is not disposed; <code>false</code> otherwise
 * @private
 */
DwtControl.prototype._checkState =
function() {
	if (this._disposed) { return false; }
	if (!this.__ctrlInited) {
		this.__initCtrl();
	}
	return true;
};

/**
 * Positions this control at the given point. If no location is provided, centers it
 * within the shell.
 *
 * @param {DwtPoint}	loc		the point at which to position this control
 * @private
 */
DwtControl.prototype._position =
function(loc) {
	this._checkState();

	var sizeShell = this.shell.getSize();
	var sizeThis = this.getSize();
	var x, y;

	if (sizeThis) {
		if (!loc) {
			// if no location, go for the middle
			x = Math.round((sizeShell.x - sizeThis.x) / 2);
			y = Math.round((sizeShell.y - sizeThis.y) / 2);
		} else {
			x = loc.x;
			y = loc.y;
		}
		// try to stay within shell boundaries
		if ((x + sizeThis.x) > sizeShell.x) {
			x = sizeShell.x - sizeThis.x;
		}
		if ((y + sizeThis.y) > sizeShell.y) {
			y = sizeShell.y - sizeThis.y;
		}
		this.setLocation(x, y);
	}
};

/**
 * Handles scrolling of a drop area for an object being dragged. The scrolling is based on proximity to
 * the top or bottom edge of the area (only vertical scrolling is done). The scrolling is done via a
 * looping timer, so that the scrolling is smooth and does not depend on additional mouse movement.
 *
 * @param {hash}	params		a hash of parameters
 * @param {Element}      params.container		the DOM element that may need to be scrolled
 * @param {number}      params.threshold		if mouse is within this many pixels of top or bottom of container,
 * 										check if scrolling is needed
 * @param {number}      params.amount		the number of pixels to scroll at each interval
 * @param {number}      params.interval		the number of milliseconds to wait before continuing to scroll
 * @param {string}      params.id			the ID for determining if we have moved out of container
 * @param {DwtEvent}	ev		the event
 * 
 * @private
 */
DwtControl._dndScrollCallback =
function(params, ev) {

	var container = params.container;
	if (!container) { return; }

	// stop scrolling if mouse has moved out of the scrolling area, or dnd object has been released;
	// a bit tricky because this callback is run as the mouse moves among objects within the scroll area,
	// so we need to see if mouse has moved from within to outside of scroll area
	var dwtObjId = ev.dwtObj && ev.dwtObj._dndScrollId;
	if (ev.type == "mouseup" || !dwtObjId || (params.id && dwtObjId != params.id)) {
		if (container._dndScrollActionId != -1) {
			AjxTimedAction.cancelAction(container._dndScrollActionId);
			container._dndScrollActionId = -1;
		}
		return;
	}

	container._scrollAmt = 0;
	if (container.clientHeight < container.scrollHeight) {
		var containerTop = Dwt.toWindow(container, 0, 0, null, null, DwtPoint.tmp).y;
		var realTop = containerTop + container.scrollTop;
		var scroll = container.scrollTop;
		var diff = ev.docY - realTop; // do we need to scroll up?
		// account for horizontal scrollbar
		var threshold = (container.clientWidth < container.scrollWidth) ? params.threshold + Dwt.SCROLLBAR_WIDTH :
																		  params.threshold;
		var scrollAmt = (diff <= threshold) ? -1 * params.amount : 0;
		if (scrollAmt == 0) {
			var containerH = Dwt.getSize(container, DwtPoint.tmp).y;
			var containerBottom = realTop + containerH;
			diff = containerBottom - ev.docY; // do we need to scroll down?
			scrollAmt = (diff <= threshold) ? params.amount : 0;
		}
		container._scrollAmt = scrollAmt;
		if (scrollAmt) {
			if (!container._dndScrollAction) {
				container._dndScrollAction = new AjxTimedAction(null, DwtControl._dndScroll, [params]);
				container._dndScrollActionId = -1;
			}
			// launch scrolling loop
			if (container._dndScrollActionId == -1) {
				container._dndScrollActionId = AjxTimedAction.scheduleAction(container._dndScrollAction, 0);
			}
		} else {
			// stop scrolling
			if (container._dndScrollActionId != -1) {
				AjxTimedAction.cancelAction(container._dndScrollActionId);
				container._dndScrollActionId = -1;
			}
		}
	}
};

/**
 * @private
 */
DwtControl._dndScroll =
function(params) {
	var container = params.container;
	var containerTop = Dwt.toWindow(container, 0, 0, null, null, DwtPoint.tmp).y;
	var containerH = Dwt.getSize(container, DwtPoint.tmp).y;
	var scroll = container.scrollTop;
	// if we are to scroll, make sure there is more scrolling to be done
	if ((container._scrollAmt < 0 && scroll > 0) || (container._scrollAmt > 0 && (scroll + containerH < container.scrollHeight))) {
		container.scrollTop += container._scrollAmt;
		container._dndScrollActionId = AjxTimedAction.scheduleAction(container._dndScrollAction, params.interval);
	}
};

/**
 * @private
 */
DwtControl.__keyPressHdlr =
function(ev) {
	var obj = obj ? obj : DwtControl.getTargetControl(ev);
	if (!obj) return false;

	if (obj.__hasToolTipContent()) {
		var shell = DwtShell.getShell(window);
		var manager = shell.getHoverMgr();
		manager.setHoverOutListener(obj._hoverOutListener);
		manager.hoverOut();
		obj.__tooltipClosed = false;
	}
};


/**
 * @private
 */
DwtControl.__keyUpHdlr = function(ev) {

	return DwtKeyboardMgr.__keyUpHdlr.apply(this, arguments);
};

/**
 * @private
 */
DwtControl.__keyDownHdlr = function(ev) {

	return DwtKeyboardMgr.__keyDownHdlr.apply(this, arguments);
};

/**
 * @private
 */
DwtControl.__focusHdlr = function(ev, evType, obj) {

	obj = obj || DwtControl.getTargetControl(ev);
	if (!obj) {
        return false;
    }

    obj._cancelFocusBlurActions();

    return obj.__doFocus(ev);
};

/**
 * @private
 */
DwtControl.__blurHdlr = function(ev, evType, obj) {

    obj = obj || DwtControl.getTargetControl(ev);
    if (!obj) {
        return false;
    }

    obj._cancelFocusBlurActions();

	return obj.__doBlur(ev);
};

DwtControl.prototype._cancelFocusBlurActions = function() {

    if (this._focusAction._id !== -1) {
        AjxTimedAction.cancelAction(this._focusAction._id);
    }
    if (this._blurAction._id !== -1) {
        AjxTimedAction.cancelAction(this._blurAction._id);
    }
};

/**
 * Returns true if the control has static tooltip content, or if it has overridden
 * getToolTipContent() to return dynamic content. Essentially, it means that this
 * control provides tooltips and will need to use the hover mgr.
 *
 * @private
 */
DwtControl.prototype.__hasToolTipContent =
function() {
	if (this._disposed) { return false; }
	return Boolean(!this._browserToolTip && (this.__toolTipContent || (this.getToolTipContent != DwtControl.prototype.getToolTipContent)));
};

/**
 * This control has gotten focus, so do some housekeeping: tell the keyboard mgr, notify listeners, and update our UI and state.
 * @private
 */
DwtControl.prototype.__doFocus = function(ev) {

    DBG.println(AjxDebug.FOCUS, "DwtControl.__doFocus for " + this.toString() + ", id: " + this._htmlElId);

    if (!this._checkState()) {
        return false;
    }

    this._hasFocus = true;

    this.shell.getKeyboardMgr().updateFocus(this, ev);

    if (this.isListenerRegistered(DwtEvent.ONFOCUS)) {
        ev = ev || DwtShell.focusEvent;
        ev.dwtObj = this;
        ev.state = DwtFocusEvent.FOCUS;
        this.notifyListeners(DwtEvent.ONFOCUS, ev);
    }

    this._focus();

    return true;
};

/**
 * This control has lost focus, so do some housekeeping: notify listeners, and update our UI and state.
 * @private
 */
DwtControl.prototype.__doBlur = function(ev) {

	DBG.println(AjxDebug.FOCUS, "DwtControl.__doBlur for " + this.toString() + ", id: " + this._htmlElId);

    if (!this._checkState()) {
        return false;
    }

	this._hasFocus = false;
	if (this.isListenerRegistered(DwtEvent.ONBLUR)) {
        ev = ev || DwtShell.focusEvent;
		ev.dwtObj = this;
		ev.state = DwtFocusEvent.BLUR;
		this.notifyListeners(DwtEvent.ONBLUR, ev);
	}

	this._blur();

    return true;
};

/**
 * @private
 */
DwtControl.__clickHdlr =
function(ev) {
	var obj = DwtControl.getTargetControl(ev);
	if (obj && obj._clickPending) {
		return;
	}

	try {

	return DwtControl.__mouseEvent(ev, DwtEvent.ONCLICK);

	} catch (ex) {
		AjxException.reportScriptError(ex);
	}
};

/**
 * @private
 */
DwtControl.__dblClickHdlr =
function(ev) {

	try {

	var obj = DwtControl.getTargetControl(ev);
	if (obj && obj._dblClickIsolation) {
		obj._clickPending = false;
		AjxTimedAction.cancelAction(obj._dblClickActionId);
	}
	return DwtControl.__mouseEvent(ev, DwtEvent.ONDBLCLICK);

	} catch (ex) {
		AjxException.reportScriptError(ex);
	}
};

/**
 * @private
 */
DwtControl.__mouseOverHdlr =
function(ev, evType) {

	try {

	// Check to see if a drag is occurring. If so, don't process the mouse
	// over events.
	var captureObj = (DwtMouseEventCapture.getId() == "DwtControl") ? DwtMouseEventCapture.getCaptureObj() : null;
	if (captureObj != null) {
		ev = DwtUiEvent.getEvent(ev);
		ev._stopPropagation = true;
		return false;
	}
	var obj = DwtControl.getTargetControl(ev);
	if (!obj) { return false; }
	evType = evType || DwtEvent.ONMOUSEOVER;
	if ((evType == DwtEvent.ONMOUSEOVER) && obj._ignoreInternalOverOut) {
		var otherObj = DwtControl.getTargetControl(ev, true);
		if (obj == otherObj) {
			return false;
		}
	}

	var mouseEv = DwtShell.mouseEvent;
	if (obj._dragging == DwtControl._NO_DRAG) {
		mouseEv.setFromDhtmlEvent(ev, obj);
		mouseEv.hoverStarted = false;	// don't handle hover if it has already begun
		if (obj.isListenerRegistered(evType)) {
			obj.notifyListeners(evType, mouseEv);
		}
		// Call the tooltip after the listeners to give them a
		// chance to change the tooltip text.
		if (obj.__hasToolTipContent(mouseEv) && !mouseEv.hoverStarted) {
			var shell = DwtShell.getShell(window);
			var manager = shell.getHoverMgr();
			if ((!manager.isHovering() || manager.getHoverObject() != obj) && !DwtMenu.menuShowing()) {
				manager.reset();
				manager.setHoverObject(obj);
				manager.setHoverOverData(mouseEv);
				manager.setHoverOverDelay(DwtToolTip.TOOLTIP_DELAY);
				manager.setHoverOverListener(obj._hoverOverListener);
				manager.hoverOver(mouseEv.docX, mouseEv.docY);
			}
		}
	}
	mouseEv._stopPropagation = true;
	mouseEv._returnValue = false;
	mouseEv.setToDhtmlEvent(ev);
	return false;

	} catch (ex) {
		AjxException.reportScriptError(ex);
	}
};

/**
 * @private
 */
DwtControl.__mouseEnterHdlr =
function(ev) {
	return DwtControl.__mouseOverHdlr(ev, DwtEvent.ONMOUSEENTER);
};

/**
 * @private
 */
DwtControl.__mouseDownHdlr =
function(ev) {

	try {

	var obj = DwtControl.getTargetControl(ev);
	if (!obj) { return false; }

	ev = DwtUiEvent.getEvent(ev);
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev, obj);
	if (mouseEv.button == DwtMouseEvent.LEFT) {
		obj._focusByMouseDownEvent(ev);
		// reset our event - above call can set type to "blur" (at least in FF)
		mouseEv.setFromDhtmlEvent(ev, obj);
	}

	if (obj.__hasToolTipContent()) {
		var shell = DwtShell.getShell(window);
		var manager = shell.getHoverMgr();
		manager.setHoverOutListener(obj._hoverOutListener);
		manager.hoverOut();
	}

	// If we have a dragSource, then we need to start capturing mouse events
	if (obj._dragSource && (mouseEv.button == DwtMouseEvent.LEFT) && obj._isValidDragObject(mouseEv))	{
		try {
			obj._ctrlCaptureObj.capture();
		} catch (ex) {
			DBG.dumpObj(ex);
		}
		obj._dragOp = obj._getDragOp(mouseEv);
		obj.__dragStartX = mouseEv.docX;
		obj.__dragStartY = mouseEv.docY;
	}
	else if (obj._dragBox) {
		// We do mouse capture for drag boxes mostly because the mouseup can come from anywhere, and we
		// want to handle it, usually by destroying the box.
		if (obj._dragBox._setStart(mouseEv, obj)) {
			try {
				obj._ctrlCaptureObj.capture();
			} catch (ex) {
				DBG.dumpObj(ex);
			}
		}
	}

	return DwtControl.__mouseEvent(ev, DwtEvent.ONMOUSEDOWN, obj, mouseEv);

	} catch (ex) {
		AjxException.reportScriptError(ex);
	}
};

/**
 * @private
 */
DwtControl.__mouseMoveHdlr =
function(ev) {

	try {

	// Find the target control. If we're doing capture (DnD), we get it from the capture object.
	var captureObj = (DwtMouseEventCapture.getId() == "DwtControl") ? DwtMouseEventCapture.getCaptureObj() : null;
	var obj = captureObj ? captureObj.targetObj : DwtControl.getTargetControl(ev);
 	if (!obj) { return false; }

	// DnD hover cancel point
	if (obj.__dndHoverActionId != -1) {
		AjxTimedAction.cancelAction(obj.__dndHoverActionId);
		obj.__dndHoverActionId = -1;
	}

	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev, captureObj ? true : obj);

	// This following can happen during a DnD operation if the mouse moves
	// out the window. This seems to happen on IE only.
	if (mouseEv.docX < 0 || mouseEv.docY < 0) {
		mouseEv._stopPropagation = true;
		mouseEv._returnValue = false;
		mouseEv.setToDhtmlEvent(ev);
		return false;
	}

	// If we are not draggable or if we have not started dragging and are
	// within the Drag threshold then handle it as a move.
	var doingDnD = (obj._dragSource && captureObj &&
			(Math.abs(obj.__dragStartX - mouseEv.docX) >= DwtControl.__DRAG_THRESHOLD ||
			 Math.abs(obj.__dragStartY - mouseEv.docY) >= DwtControl.__DRAG_THRESHOLD));
	var doingDragBox = (captureObj && obj._dragBox && obj._dragBox._dragObj == obj);

	if (!doingDnD && !doingDragBox) {
		if (obj.__hasToolTipContent()) {
			var shell = DwtShell.getShell(window);
			var manager = shell.getHoverMgr();
			if (!obj.__tooltipClosed && !DwtMenu.menuShowing()) {
				// NOTE: mouseOver already init'd other hover settings
				// We do hoverOver() here since the mouse may have moved during
				// the delay, and we want to use latest x,y
				manager.hoverOver(mouseEv.docX, mouseEv.docY);
			} else {
				var deltaX = obj.__lastTooltipX ? Math.abs(mouseEv.docX - obj.__lastTooltipX) : null;
				var deltaY = obj.__lastTooltipY ? Math.abs(mouseEv.docY - obj.__lastTooltipY) : null;
				if ((deltaX != null && deltaX > DwtControl.__TOOLTIP_THRESHOLD) ||
					(deltaY != null && deltaY > DwtControl.__TOOLTIP_THRESHOLD)) {
					manager.setHoverOutListener(obj._hoverOutListener);
					manager.hoverOut();
					obj.__tooltipClosed = true; // prevent tooltip popup during moves in this object
				}
			}
		}
		return DwtControl.__mouseEvent(ev, DwtEvent.ONMOUSEMOVE, obj, mouseEv);
	} else {
		// If we are not dragging, try to begin a drag operation, which may be either DnD or drawing a box.
		if (obj._dragging == DwtControl._NO_DRAG) {
			if (obj._dragSource) {
				obj._dragOp = obj._dragSource._beginDrag(obj._dragOp, obj);
				if (obj._dragOp != Dwt.DND_DROP_NONE) {
					obj._dragging = DwtControl._DRAGGING;
					obj._dndProxy = obj._getDragProxy(obj._dragOp);
					Dwt.addClass(obj._dndProxy, "DwtDragProxy");
					if (!obj._dndProxy) {
						obj._dragging = DwtControl._DRAG_REJECTED;
					}
				} else {
					obj._dragging = DwtControl._DRAG_REJECTED;
				}
			}
			else if (obj._dragBox) {
				obj._dragging = DwtControl._DRAGGING;
				obj._dragBox._beginDrag(obj);
			}
		}

		if (obj._dragging != DwtControl._DRAG_REJECTED) {
			var targetObj = mouseEv.dwtObj;
			if (obj._dragSource) {
				var dropTarget = targetObj && targetObj._dropTarget;
				var lastTargetObj = obj.__lastTargetObj;
				if (targetObj) {
					// Set up the drag hover event. we will even let this item hover over itself as there may be
					// scenarios where that will hold true
					obj._dndHoverAction.args = [ targetObj ];
					obj.__dndHoverActionId = AjxTimedAction.scheduleAction(obj._dndHoverAction, DwtControl.__DND_HOVER_DELAY);
				}

				// See if the target will allow us to be dropped on it. We have to be an allowable type, and the
				// target's drop listener may perform additional checks. The DnD icon will typically turn green or
				// red to indicate whether a drop is allowed.
				if (targetObj && dropTarget && ((targetObj != obj) || dropTarget.hasMultipleTargets())) {
					if (targetObj != lastTargetObj || dropTarget.hasMultipleTargets()) {
						var data = obj._dragSource._getData();
						if (dropTarget._dragEnter(obj._dragOp, targetObj, data, mouseEv, obj._dndProxy)) {
							obj._setDragProxyState(true);
							obj.__dropAllowed = true;
							targetObj._dragEnter(mouseEv);
						} else {
							obj._setDragProxyState(false);
							obj.__dropAllowed = false;
						}
					} else if (obj.__dropAllowed) {
						targetObj._dragOver(mouseEv);
					}
				} else {
					obj._setDragProxyState(false);
				}

				// Tell the previous target that we're no longer being dragged over it.
				if (lastTargetObj && lastTargetObj != targetObj && lastTargetObj._dropTarget && lastTargetObj != obj) {
					// check if obj dragged out of scrollable container
					if (targetObj && !targetObj._dndScrollCallback && lastTargetObj._dndScrollCallback) {
						lastTargetObj._dndScrollCallback.run(mouseEv);
					}

					lastTargetObj._dragLeave(mouseEv);
					lastTargetObj._dropTarget._dragLeave();
				}

				obj.__lastTargetObj = targetObj;

				if ((targetObj != obj) && targetObj && targetObj._dndScrollCallback) {
					targetObj._dndScrollCallback.run(mouseEv);
				}

				// Move the DnD icon. We offset the location slightly so the icon doesn't receive the mousemove events.
				Dwt.setLocation(obj._dndProxy, mouseEv.docX + 2, mouseEv.docY + 2);
			}

			// We keep drawing a drag box as long as we're still over the owning object. We need to check its child
			// objects, and whether we're over the box itself (in case the user reverses direction).
			else if (obj._dragBox) {
				var evTarget = DwtUiEvent.getTarget(ev);
				if (targetObj && (Dwt.isAncestor(obj.getHtmlElement(), evTarget) || evTarget == obj._dragSelectionBox)) {
					obj._dragBox._dragMove(mouseEv, obj);
				}
			}

		} else {
			DwtControl.__mouseEvent(ev, DwtEvent.ONMOUSEMOVE, obj, mouseEv);
		}
		mouseEv._stopPropagation = true;
		mouseEv._returnValue = false;
		mouseEv.setToDhtmlEvent(ev);
		return false;
	}

	} catch (ex) {
		AjxException.reportScriptError(ex);
	}
};

/**
 * @private
 */
DwtControl.__mouseUpHdlr =
function(ev) {

	try {

	// Find the target control. If we're doing capture (DnD), we get it from the capture object.
	var captureObj = (DwtMouseEventCapture.getId() == "DwtControl") ? DwtMouseEventCapture.getCaptureObj() : null;
	var obj = captureObj ? captureObj.targetObj : DwtControl.getTargetControl(ev);
	if (!obj) { return false; }

	// DnD hover cancel point
	if (obj.__dndHoverActionId != -1) {
		AjxTimedAction.cancelAction(obj.__dndHoverActionId);
		obj.__dndHoverActionId = -1;
	}

	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev, captureObj ? true : obj);
	if (!(captureObj && (obj._dragSource || obj._dragBox))) {
		return DwtControl.__processMouseUpEvent(ev, obj, mouseEv);
	} else {
		captureObj.release();
		if (obj._dragging != DwtControl._DRAGGING) {
			obj._dragging = DwtControl._NO_DRAG;
			return DwtControl.__processMouseUpEvent(ev, obj, mouseEv);
		}
		if (obj._dragSource) {
			obj.__lastTargetObj = null;
			var targetObj = mouseEv.dwtObj;
			var dropTarget = targetObj && targetObj._dropTarget;
			// Perform the drop if the target has allowed it
			if (targetObj && dropTarget && obj.__dropAllowed && ((targetObj != obj) || dropTarget.hasMultipleTargets())) {
				targetObj._drop(mouseEv);
				dropTarget._drop(obj._dragSource._getData(), mouseEv);
				obj._dragSource._endDrag();
				obj._destroyDragProxy(obj._dndProxy);
				obj._dragging = DwtControl._NO_DRAG;
			} else {
				DwtControl.__badDrop(obj, mouseEv);
			}
			if (targetObj && targetObj._dndScrollCallback) {
				targetObj._dndScrollCallback.run(mouseEv);
			}
		}
		else if (obj._dragBox) {
			obj._dragBox._endDrag(obj);
		}
		mouseEv._stopPropagation = true;
		mouseEv._returnValue = false;
		mouseEv.setToDhtmlEvent(ev);
		return false;
	}

	} catch (ex) {
		AjxException.reportScriptError(ex);
	}
};

/**
 * Handles a bad DND drop operation by showing an animation of the icon flying
 * back to its origin.
 *
 * @param obj		[DwtControl]	control that underlies drag operation
 * @param mouseEv	[DwtMouseEvent]	mouse event
 * @private
 */
DwtControl.__badDrop =
function(obj, mouseEv) {
	if (obj._dragSource) {
		obj._dragSource._cancelDrag();
	}
    var targetObj = mouseEv.dwtObj;
    if (targetObj) {
       targetObj._drop(mouseEv);
    }
	// The following code sets up the drop effect for when an
	// item is dropped onto an invalid target. Basically the
	// drag icon will spring back to its starting location.
	obj.__dragEndX = mouseEv.docX;
	obj.__dragEndY = mouseEv.docY;
	if (obj.__badDropAction == null) {
		obj.__badDropAction = new AjxTimedAction(obj, obj.__badDropEffect);
	}

	// Line equation is y = mx + c. Solve for c, and set up d (direction)
	var m = (obj.__dragEndY - obj.__dragStartY) / (obj.__dragEndX - obj.__dragStartX);
	obj.__badDropAction.args = [m, obj.__dragStartY - (m * obj.__dragStartX), (obj.__dragStartX - obj.__dragEndX < 0) ? -1 : 1];
	AjxTimedAction.scheduleAction(obj.__badDropAction, 0);
};

/**
 * Handle double clicks in isolation, if requested (if not, events are handled
 * normally). On the first click, we set a 'click pending' flag and start a timer.
 * If the timer expires before another click arrives, we process the single click.
 * If a double-click event arrives before the timer expires, then we process the
 * double-click event.
 * @private
 */
DwtControl.__processMouseUpEvent =
function(ev, obj, mouseEv) {
	var shell = DwtShell.getShell(window);
	var hoverMgr = shell.getHoverMgr();
	hoverMgr.ignoreHoverOverOnClick();

	if (obj._dblClickIsolation && mouseEv && (mouseEv.button == DwtMouseEvent.LEFT)) {
		if (obj._clickPending) {
			// wait for real dblclick event
			return false;
		} else {
			obj._clickPending = true;
			var ta = new AjxTimedAction(null, DwtControl.__timedClick, [ev, obj, mouseEv]);
			obj._dblClickActionId = AjxTimedAction.scheduleAction(ta, DwtControl.__DBL_CLICK_TIMEOUT);
			DwtUiEvent.setBehaviour(ev, true, false);
			obj._st = new Date();
			return false;
		}
	} else {
		obj._clickPending = false;
		return DwtControl.__mouseEvent(ev, DwtEvent.ONMOUSEUP, obj, mouseEv);
	}
};

DwtControl.__timedClick =
function(ev, obj, mouseEv) {
	obj._clickPending = false;
	DwtControl.__mouseEvent(ev, DwtEvent.ONMOUSEUP, obj, mouseEv);
};

/**
 * @private
 */
DwtControl.__mouseOutHdlr =
function(ev, evType) {

	try {

	var obj = DwtControl.getTargetControl(ev);
	if (!obj) { return false; }
	evType = evType || DwtEvent.ONMOUSEOUT;
	if ((evType == DwtEvent.ONMOUSEOUT) && obj._ignoreInternalOverOut) {
		var otherObj = DwtControl.getTargetControl(ev, true);
		if (obj == otherObj) {
			return false;
		}
	}

	if (obj.__hasToolTipContent()) {
		var shell = DwtShell.getShell(window);
		var manager = shell.getHoverMgr();
			manager.setHoverOutListener(obj._hoverOutListener);
			manager.hoverOut();
			obj.__tooltipClosed = false;
	}
	return DwtControl.__mouseEvent(ev, evType || DwtEvent.ONMOUSEOUT, obj);

	} catch (ex) {
		AjxException.reportScriptError(ex);
	}
};

/**
 * @private
 */
DwtControl.__mouseLeaveHdlr =
function(ev) {
	return DwtControl.__mouseOutHdlr(ev, DwtEvent.ONMOUSELEAVE);
};

/**
 * @private
 */
DwtControl.__mouseWheelHdlr =
function(ev) {

	try {

	return DwtControl.__mouseEvent(ev, DwtEvent.ONMOUSEWHEEL);

	} catch (ex) {
		AjxException.reportScriptError(ex);
	}
};

/**
 * @private
 */
DwtControl.__selectStartHdlr =
function(ev) {

	try {

	return DwtControl.__mouseEvent(ev, DwtEvent.ONSELECTSTART);

	} catch (ex) {
		AjxException.reportScriptError(ex);
	}
};

/**
 * Note: if there is also a mousedown handler, oncontextmenu is no longer sent, so be careful.
 *
 * @private
 */
DwtControl.__contextMenuHdlr =
function(ev) {

	try {

	// for Safari, we have to fake a right click
	if (AjxEnv.isSafari) {
		var obj = DwtControl.getTargetControl(ev);
		var prevent = obj ? obj.preventContextMenu() : true;
		if (prevent) {
			DwtControl.__mouseEvent(ev, DwtEvent.ONMOUSEDOWN);
			return DwtControl.__mouseEvent(ev, DwtEvent.ONMOUSEUP);
		}
	}
	return DwtControl.__mouseEvent(ev, DwtEvent.ONCONTEXTMENU);

	} catch (ex) {
		AjxException.reportScriptError(ex);
	}
};

/**
 * @private
 */
DwtControl.__mouseEvent =
function(ev, eventType, obj, mouseEv) {

	var obj = obj ? obj : DwtControl.getTargetControl(ev);
	if (!obj) { return false; }

	if (!mouseEv) {
		mouseEv = DwtShell.mouseEvent;
		mouseEv.setFromDhtmlEvent(ev, obj);
	}

	// By default, we halt event processing. The default can be overridden here through
	// the use of setEventPropagation(). A listener may also change the event props when called.
	var tn = mouseEv.target.tagName && mouseEv.target.tagName.toLowerCase();
	var propagate = obj._propagateEvent[eventType] || (tn === "input" || tn === "textarea" || tn === "a" || tn === "label" || tn === "select");
	//todo - not sure if _stopPropagation and _dontCallPreventDefault should not the the SAME. Since if you stop propagation and dontCallPreventDefault,
	//it DOES allow selection (or context menu, etc, any default browser stuff). But if you allow to propagate, this might be overriden by a DOM element
	//higher up, which might not be what we want. Very confusing.
	mouseEv._stopPropagation = !propagate;
	mouseEv._dontCallPreventDefault = propagate;
	mouseEv._returnValue = propagate;

	// notify global listeners
	DwtEventManager.notifyListeners(eventType, mouseEv);

	// notify widget listeners
	if (obj.isListenerRegistered && obj.isListenerRegistered(eventType)) {
		obj.notifyListeners(eventType, mouseEv);
	}

	// publish our settings to the DOM
	mouseEv.setToDhtmlEvent(ev);

	// Some screen readers exclusively trigger ONCLICK events, but
	// Zimbra relies on ONMOUSEDOWN/ONMOUSEUP sequences for buttons
	// and some other controls, so we detect non-mouse clicks and
	// introduce the ability to 'fake' ONMOUSEDOWN/ONMOUSEUP sequences
	// for them. This triggers when the control element has a listener
	// for ONCLICK, but the DwtControl doesn't.
	if (eventType == DwtEvent.ONMOUSELEAVE ||
		eventType == DwtEvent.ONMOUSEOUT) {
		// we're 'switching' elements, so the browser won't
		// trigger a click event
		obj.__ignoreNextClick = false;

	} else if (eventType == DwtEvent.ONMOUSEUP) {
		// yes, ignore the next click -- ZCS' built-in click-ish
		// thing will work just fine
		obj.__ignoreNextClick = true;

	} else if (eventType == DwtEvent.ONCLICK) {
		if (obj.__ignoreNextClick) {
			DBG.println(AjxDebug.ACCESSIBILITY,
			            "DwtControl: ignoring a click!");
			obj.__ignoreNextClick = false;
			return true;
		}

		// check whether the target control listens for clicks,
		// and if not, fake a mouseup/mousedown event pair
		if (obj.isListenerRegistered && !obj.isListenerRegistered(DwtEvent.ONCLICK)) {
			DBG.println(AjxDebug.ACCESSIBILITY,
			            "DwtControl: faking a click!");

			eventType = DwtEvent.ONMOUSEDOWN;
			if (ev) {
				ev.type = eventType;
			}

			DwtControl.__mouseEvent(ev, eventType, obj, DwtShell.mouseEvent);

			eventType = DwtEvent.ONMOUSEUP;
			if (ev) {
				ev.type = eventType;
			}

			DwtControl.__mouseEvent(ev, eventType, obj, DwtShell.mouseEvent);

			return DwtShell.mouseEvent._returnValue;
		} else {
			DBG.println(AjxDebug.ACCESSIBILITY,
			            "DwtControl: skipping a click!");
			window.console && console.warn('skipping a click!');
		}
	}

	return mouseEv._returnValue;
};

// need to populate this hash after methods are defined
/**
 * @private
 */
DwtControl.__HANDLER = {};
DwtControl.__HANDLER[DwtEvent.ONCONTEXTMENU] = DwtControl.__contextMenuHdlr;
DwtControl.__HANDLER[DwtEvent.ONCLICK] = DwtControl.__clickHdlr;
DwtControl.__HANDLER[DwtEvent.ONDBLCLICK] = DwtControl.__dblClickHdlr;
DwtControl.__HANDLER[DwtEvent.ONMOUSEDOWN] = DwtControl.__mouseDownHdlr;
DwtControl.__HANDLER[DwtEvent.ONMOUSEENTER] = DwtControl.__mouseEnterHdlr;
DwtControl.__HANDLER[DwtEvent.ONMOUSELEAVE] = DwtControl.__mouseLeaveHdlr;
DwtControl.__HANDLER[DwtEvent.ONMOUSEMOVE] = DwtControl.__mouseMoveHdlr;
DwtControl.__HANDLER[DwtEvent.ONMOUSEOUT] = DwtControl.__mouseOutHdlr;
DwtControl.__HANDLER[DwtEvent.ONMOUSEOVER] = DwtControl.__mouseOverHdlr;
DwtControl.__HANDLER[DwtEvent.ONMOUSEUP] = DwtControl.__mouseUpHdlr;
DwtControl.__HANDLER[DwtEvent.ONMOUSEWHEEL] = DwtControl.__mouseWheelHdlr;
DwtControl.__HANDLER[DwtEvent.ONSELECTSTART] = DwtControl.__selectStartHdlr;
DwtControl.__HANDLER[DwtEvent.ONKEYPRESS] = DwtControl.__keyPressHdlr;
DwtControl.__HANDLER[DwtEvent.ONKEYUP] = DwtControl.__keyUpHdlr;
DwtControl.__HANDLER[DwtEvent.ONKEYDOWN] = DwtControl.__keyDownHdlr;
DwtControl.__HANDLER[DwtEvent.ONFOCUS] = DwtControl.__focusHdlr;
DwtControl.__HANDLER[DwtEvent.ONBLUR] = DwtControl.__blurHdlr;

/**
 * @private
 */
DwtControl.prototype.__initCtrl =
function() {
	this.shell = this.parent.shell || this.parent;
	// __internalId is for back-compatibility (was side effect of Dwt.associateElementWithObject)
	this._htmlElId = this.__internalId = this._htmlElId || Dwt.getNextId();
	var htmlElement = this._elRef = this._createElement(this._htmlElId);
	htmlElement.id = this._htmlElId;
    if (DwtControl.ALL_BY_ID[this._htmlElId]) {
        DBG.println(AjxDebug.DBG1, "Duplicate ID for " + this.toString() + ": " + this._htmlElId);
        this._htmlElId = htmlElement.id = this.__internalId = DwtId.makeId(this._htmlElId, Dwt.getNextId());
    }
    DwtControl.ALL_BY_ID[this._htmlElId] = this;
	DwtComposite._pendingElements[this._htmlElId] = htmlElement;
	htmlElement.style.position = this.__posStyle || DwtControl.STATIC_STYLE;
	htmlElement.className = this._className;
	htmlElement.style.overflow = "visible";
	if (this.role) {
		htmlElement.setAttribute('role', this.role);
	}
	this._enabled = true;
	this.__controlEvent = DwtControl.__controlEvent;
	this._dragging = DwtControl._NO_DRAG;
	this.__ctrlInited = true;

    this.setFocusElement();

    // timed actions in case we don't get focus/blur events when we programmatically focus/blur
    this._focusAction = new AjxTimedAction(null, DwtControl.__focusHdlr, [ DwtShell.focusEvent, DwtEvent.ONFOCUS, this ]);
    this._blurAction = new AjxTimedAction(null, DwtControl.__blurHdlr, [ DwtShell.focusEvent, DwtEvent.ONBLUR, this ]);

	// Make sure this is the last thing we do
	this.parent.addChild(this, this.__index);
};

/**
 * Returns the container element to be used for this control.
 * <p>
 * <strong>Note:</strong>
 * The caller will overwrite the id of the returned element with the
 * specified id.
 *
 * @param id [string] The id of the container element.
 * @private
 */
DwtControl.prototype._createElement = function(id) {
	return document.createElement("DIV")
};

/**
 * @private
 */
DwtControl.prototype.__dndDoHover =
function(control) {
	//TODO Add allow hover?
	control._dragHover();
};

/**
 * This method is called when a drop happens on an invalid target. The code will
 * animate the Drag icon back to its source before destroying it via <code>_destroyDragProxy</code>
 * @private
 */
DwtControl.prototype.__badDropEffect =
function(m, c, d) {
	var usingX = (Math.abs(m) <= 1);
	// Use the bigger delta to control the snap effect
	var delta = usingX ? this.__dragStartX - this.__dragEndX : this.__dragStartY - this.__dragEndY;
    if (delta * d > 0 && !(this.__dragEndY == this.__dragStartY || this.__dragEndX == this.__dragStartX) ) {
		if (usingX) {
			this.__dragEndX += (30 * d);
			this._dndProxy.style.top = m * this.__dragEndX + c;
			this._dndProxy.style.left = this.__dragEndX;
		} else {
			this.__dragEndY += (30 * d);
			this._dndProxy.style.top = this.__dragEndY;
			this._dndProxy.style.left = (this.__dragEndY - c) / m;
		}
		AjxTimedAction.scheduleAction(this.__badDropAction, 0);
 	} else {
  		this._destroyDragProxy(this._dndProxy);
		this._dragging = DwtControl._NO_DRAG;
  	}
};

/**
 * Attempts to display a tooltip for this control, triggered by the cursor having been
 * over the control for a period of time. The tooltip may have already been set (if it's
 * a static tooltip). For dynamic tooltip content, the control implements getToolTipContent()
 * to return the content or a callback. It should return a callback if it makes an
 * async server call to get data.
 *
 * @private
 */
DwtControl.prototype.__handleHoverOver =
function(event) {

	if (this._eventMgr.isListenerRegistered(DwtEvent.HOVEROVER)) {
		this._eventMgr.notifyListeners(DwtEvent.HOVEROVER, event);
	}

	var mouseEv = event && event.object;
	var tooltip = this.getToolTipContent(mouseEv);
	var content, callback;
	if (!tooltip) {
		content = "";
	} else if (typeof(tooltip) == "string") {
		content = tooltip;
	} else if (tooltip.isAjxCallback || AjxUtil.isFunction(tooltip)) {
		callback = tooltip;
	} else if (typeof(tooltip) == "object") {
		content = tooltip.content;
		callback = tooltip.callback;
	}

	if (!content && callback && tooltip.loading) {
		content = AjxMsg.loading;
	}

	if (content) {
		this.__showToolTip(event, content);
	}

	if (callback) {
		var callback1 = new AjxCallback(this, this.__showToolTip, [event]);
		AjxTimedAction.scheduleAction(new AjxTimedAction(null, function() { callback.run(callback1); }), 0);
	}
};

/**
 * @private
 */
DwtControl.prototype.__showToolTip =
function(event, content) {

	if (!content) { return; }
    DwtControl.showToolTip(content, event.x, event.y, this, event);
	this.__lastTooltipX = event.x;
	this.__lastTooltipY = event.y;
	this.__tooltipClosed = false;
};

/**
 * @private
 */
DwtControl.prototype.__handleHoverOut =
function(event) {
	if (this._eventMgr.isListenerRegistered(DwtEvent.HOVEROUT)) {
		this._eventMgr.notifyListeners(DwtEvent.HOVEROUT, event);
	}
    DwtControl.hideToolTip();
	this.__lastTooltipX = null;
	this.__lastTooltipY = null;
};

/**
 * @private
 */
DwtControl.prototype.__isInputEl =
function(targetEl) {
	var bIsInput = false;
	if(!targetEl || !targetEl.tagName) {
		return bIsInput;
	}
	var tagName = targetEl.tagName.toLowerCase();
	var type = tagName == "input" ? targetEl.type.toLowerCase() : null;

	if (tagName == "textarea" || (type && (type == "text" || type == "password")))
		bIsInput = true;

	return bIsInput;
};


/**
 * onunload hacking
 * @private
 */
DwtControl.ON_UNLOAD =
function() {
	// break widget-element references
	var h = DwtControl.ALL_BY_ID, i;
	for (i in h) {
		h[i]._elRef = null;
	}
	DwtControl.ALL_BY_ID = {};
};

if (window.attachEvent) {
	window.attachEvent("onunload", DwtControl.ON_UNLOAD);
}
else if (window.addEventListener) {
	window.addEventListener("unload", DwtControl.ON_UNLOAD, false);
}

/**
 *  A helper method to show the toolTips.
 * @param content
 * @param x [Number] The x coordinate of the toolTip.
 * @param y [Number] The y coordinate of the toolTip.
 */
DwtControl.showToolTip =
function(content, x, y, obj, hoverEv) {
	if (!content) { return; }
	var tooltip = DwtShell.getShell(window).getToolTip();
	tooltip.setContent(content);
	tooltip.popup(x, y, false, false, obj, hoverEv);
};

/**
 * A helper method to hide the toolTip.
 */
DwtControl.hideToolTip =
function() {
	DwtShell.getShell(window).getToolTip().popdown();
};

/**
 * Returns the element that should be used as a base for positioning the tooltip.
 * If overridden to return null, the cursor position will be used as the base.
 * 
 * @param {DwtHoverEvent}	hoverEv		hover event (from hover mgr)
 */
DwtControl.prototype.getTooltipBase =
function(hoverEv) {
	return this.getHtmlElement();
};

DwtControl.prototype.boundsForChild =
function(child) {
	if (child && child.getHtmlElement) {
		child = child.getHtmlElement();
	}

	var fn = function(bounds, node) {
		var margins = Dwt.getMargins(node);
		var bounds = Dwt.insetBounds(bounds, Dwt.getInsets(node));
		bounds.width =
			Math.max(bounds.width - margins.left - margins.right, 0);
		bounds.height =
			Math.max(bounds.height - margins.top - margins.bottom, 0);
		return bounds;
	};

	var bounds = new DwtRectangle(0, 0, this.getHtmlElement().clientWidth,
	                              this.getHtmlElement().clientHeight);

	return AjxUtil.reduce(Dwt.getAncestors(child, this.getHtmlElement(), true),
	                      fn, bounds);
};

// Convenience methods for manipulating attributes of this control's DIV
DwtControl.prototype.hasAttribute = function(attr) {
	return this.getHtmlElement().hasAttribute(attr);
};
DwtControl.prototype.getAttribute = function(attr) {
	return this.getHtmlElement().getAttribute(attr);
};
DwtControl.prototype.setAttribute = function(attr, value) {
	this.getHtmlElement().setAttribute(attr, value);
};
DwtControl.prototype.removeAttribute = function(attr) {
	this.getHtmlElement().removeAttribute(attr);
};

}
if (AjxPackage.define("ajax.dwt.widgets.DwtComposite")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * @overview
 * This file contains a Dwt composite control.
 * 
 */

/**
 * @class
 * A composite may contain other controls. All controls that need to contain child controls
 * (such as menus, trees) should inherit from this class.
 * 
 * @param {hash}	params		a hash of parameters
 * @param {DwtComposite}	params.parent	the parent widget
 * @param {string}	params.className		the CSS class
 * @param {constant}	params.posStyle		the positioning style
 * @param {boolean}	params.deferred		if <code>true</code>, postpone initialization until needed
 * @param {string}	params.id			an explicit ID to use for the control's HTML element
 * @param {number}	params.index 		the index at which to add this control among parent's children
 * 
 * @extends	DwtControl
 */
DwtComposite = function(params) {
	if (arguments.length == 0) { return; }
	params = Dwt.getParams(arguments, DwtComposite.PARAMS);
	
	params.className = params.className || "DwtComposite";
	DwtControl.call(this, params);

	var desc = this.toString();
	if (desc == 'DwtComposite') {
		desc = this.getHTMLElId();
	}

	this._compositeTabGroup = new DwtTabGroup(desc + ' (DwtComposite)');

	/**
	 * Vector of child elements
	 * @type AjxVector
	 */
	this._children = new AjxVector();
}

DwtComposite.PARAMS = DwtControl.PARAMS.concat();

DwtComposite.prototype = new DwtControl;
DwtComposite.prototype.constructor = DwtComposite;

DwtComposite.prototype.isDwtComposite = true;
DwtComposite.prototype.toString = function() { return "DwtComposite"; }



/**
 * Pending elements hash (i.e. elements that have not yet been realized).
 * @private
 */
DwtComposite._pendingElements = new Object();


/**
 * Disposes of the control. This method will remove the control from under the
 * control of it's parent and release any resources associate with the component.
 * The method will also notify any event listeners on registered {@link DwtEvent.DISPOSE} event type.
 * 
 * <p>
 * In the case of {@link DwtComposite} this method will also dispose of all of the composite's
 * children.
 * 
 * <p> 
 * Subclasses may override this method to perform their own dispose functionality but
 * should generally call the parent <code>dispose()</code> method.
 * 
 * @see DwtControl#isDisposed
 * @see DwtControl#addDisposeListener
 * @see DwtControl#removeDisposeListener
 */
DwtComposite.prototype.dispose =
function() {
	if (this._disposed) return;

	var children = this._children.getArray();
	while (children.length > 0) {
        children.pop().dispose();
	}

	if (this._compositeTabGroup) {
		this._compositeTabGroup.removeAllMembers();
	}
	this._compositeTabGroup = null;

	DwtControl.prototype.dispose.call(this);
}

/**
 * Get a list of children of this composite.
 * 
 * @return	{array}		an array of {@link DwtControl} objects
 */
DwtComposite.prototype.getChildren =
function() {
	return this._children.getArray().slice(0);
}

/**
 * Get the Nth child of this composite.
 * 
 * @param {number}	index 		the index of the child.
 *
 * @return	{DwtControl}		the child.
 */
DwtComposite.prototype.getChild =
function(idx) {
	return this._children.get(idx);
};

/**
 * collapses consecutive separators into one. Gets rid of head or tail separators as well .
 * Note that is does not remove the separators, just hides them so they can re-displayed as needed, next time this is called and other elements
 * become visible
 *
 * this would be used on such subclasses as DwtMenu and DwtToolbar .
 * However, currently it does not work with the toolbars, since separators there are not added as children to the toolbar composite.
 * I tried to make it consistent with the DwtMenu approach, but it seemed a bit complicated right now.
 * so for now I try to make it so no complete groups (items between separators) are hidden at one time. It might also be possible
 * to do it for the toolbar using the _items HTML elements array, but probably less elegant than this approach.
 */
DwtComposite.prototype.cleanupSeparators =
function() {
	var items = this.getChildren();
	var previousVisibleIsSeparator = true; // I lie so that upfront separator would be cleaned up
	var lastSeparator;
	for (var i = 0; i < items.length; i++) {
		var item = items[i];
		var isSeparator = item.isStyle && item.isStyle(DwtMenuItem.SEPARATOR_STYLE);

		if (isSeparator) {
			item.setVisible(!previousVisibleIsSeparator);
			if (!previousVisibleIsSeparator || !lastSeparator) { //the !lastSeparator is the edge case of first item is separator. (see comment about lie above)
				//keep track of last visible separator (if it's also last item visible overall)
				previousVisibleIsSeparator = true;
				lastSeparator = item;
			}
			continue;
		}

		//not a separator
		if (item.getVisible()) {
			previousVisibleIsSeparator = false;
		}
	}
	//cleanup tail separator
	if (previousVisibleIsSeparator && lastSeparator) {
		lastSeparator.setVisible(false);
	}
};




/**
 * Gets the number of children of this composite.
 * 
 * @return {number} 		the number of composite children
 */
DwtComposite.prototype.getNumChildren =
function() {
	return this._children.size();
}

/**
 * Removes all of the composite children.
 * 
 */
DwtComposite.prototype.removeChildren =
function() {
	var a = this._children.getArray();
	while (a.length > 0) {
		a[0].dispose();
	}
	if (this._compositeTabGroup) {
		this._compositeTabGroup.removeAllMembers();
	}
}

/**
 * Clears the composite HTML element of content and removes
 * all composite children by calling <code>removeChildren</code>.
 * 
 * @see #removeChildren
 */
DwtComposite.prototype.clear =
function() {
	this.removeChildren();
	this.getHtmlElement().innerHTML = "";
}

/**
* Adds the given child control to this composite at the index (if specified).
*
* @param {DwtControl} child		the child control to add
* @param {number}	index		the index at which to add the child (may be <code>null</code>)
*/
DwtComposite.prototype.addChild =
function(child, index) {
	this._children.add(child, index);
	this._compositeTabGroup.addMember(child, index);
	
	// check for a previously removed element
	var childHtmlEl = child.getHtmlElement();
	childHtmlEl.setAttribute("parentId", this._htmlElId);
	if (this instanceof DwtShell && this.isVirtual()) {
		// If we are operating in "virtual shell" mode, then children of the shell's html elements
		// are actually parented to the body
		document.body.appendChild(childHtmlEl);
	} else {
		child.reparentHtmlElement(child.__parentElement || this.getHtmlElement(), index);
		child.__parentElement = null; // don't keep the reference to element, if any
	}
};

/**
* Removes the specified child control from this control. A removed child is no longer retrievable via
* <code>getHtmlElement()</code>, so there is an option to save a reference to the removed child. 
* That way it can be added later using <code>addChild()</code>.
*
* @param {DwtConrol} child		the child control to remove
* @see #addChild
*/
DwtComposite.prototype.removeChild =
function(child) {
	DBG.println(AjxDebug.DBG3, "DwtComposite.prototype.removeChild: " + child._htmlElId + " - " + child.toString());
	// Make sure that the child is initialized. Certain children (such as DwtTreeItems)
	// can be created in a deferred manner (i.e. they will only be initialized if they
	// are becoming visible.
	if (child.isInitialized()) {
		this._children.remove(child);
		this._compositeTabGroup.removeMember(child);
		// Sometimes children are nested in arbitrary HTML so we elect to remove them
		// in this fashion rather than use this.getHtmlElement().removeChild(child.getHtmlElement()
		var childHtmlEl = child.getHtmlElement();
        if (childHtmlEl) {
			childHtmlEl.removeAttribute("parentId");
			if (childHtmlEl.parentNode) {
				var el = childHtmlEl.parentNode.removeChild(childHtmlEl);
			}
		}
	}
}

/**
 * Return this.tabGroupMember if present (it always overrides any other contender), otherwise if this composite has
 * children return the composite tab group, otherwise just return this control (instead of a group with one member).
 *
 * @returns {DwtComposite|DwtTabGroup}
 */
DwtComposite.prototype.getTabGroupMember = function() {

	return this.tabGroupMember || (this.getNumChildren() > 0 ? this._compositeTabGroup : this);
};

/**
 * Allows the user to use the mouse to select text on the control.
 * 
 * @private
 */
DwtComposite.prototype._setAllowSelection =
function() {
	if (!this._allowSelection) {
		this._allowSelection = true;
		this.addListener(DwtEvent.ONMOUSEDOWN, new AjxListener(this, this._mouseDownListener));
		this.addListener(DwtEvent.ONCONTEXTMENU, new AjxListener(this, this._contextMenuListener));
	}
};

/**
 * Sets whether to prevent the browser from allowing text selection.
 * 
 * @see DwtControl#preventSelection
 * @private
 */
DwtComposite.prototype.preventSelection = 
function(targetEl) {
	return this._allowSelection ? false : DwtControl.prototype.preventSelection.call(this, targetEl);
};

/**
 * Determines whether to prevent the browser from displaying its context menu.
 * 
 * @see DwtControl#preventContextMenu
 * @private
 */
DwtComposite.prototype.preventContextMenu =
function(target) {
	if (!this._allowSelection) {
		return DwtControl.prototype.preventContextMenu.apply(this, arguments);
	}
	
	var bObjFound = target ? (target.id.indexOf("OBJ_") == 0) : false;
	var bSelection = false;

	// determine if anything has been selected (IE and mozilla do it differently)
	if (document.selection) {			// IE
		bSelection = document.selection.type == "Text";
	} else if (getSelection()) {		// mozilla
		bSelection = getSelection().toString().length > 0;
	}

	// if something has been selected and target is not a custom object,
	return (bSelection && !bObjFound) ? false : true;
};

/**
 * Handles focus control when the mouse button is released
 * 
 * @see DwtControl#_focusByMouseUpEvent
 * @private
 */
DwtComposite.prototype._focusByMouseUpEvent =
function()  {
	if (!this._allowSelection) {
		DwtControl.prototype._focusByMouseUpEvent.apply(this, arguments);
	}
	// ...Else do nothing....
	// When text is being selected, we don't want the superclass
	// to give focus to the keyboard input control.
};

/**
 * Event listener that is only registered when this control allows selection
 * 
 * @see _allowSelection
 * @private
 */
DwtComposite.prototype._mouseDownListener =
function(ev) {
	if (ev.button == DwtMouseEvent.LEFT) {
		// reset mouse event to propagate event to browser (allows text selection)
		//todo - look into changing this, it's currently very confusing and inconsistent.
		//bug 23462 change it to stop propagation, so supposedly it should NOT allow selection.
		// (so the above comment is wrong). But it's more complicated than this, since ev._dontCallPreventDefault is more
		// important, and is not set here, so a listener could set it to TRUE thus making it allow selection, despite
		// _stopPropagation being set to true here. (not sure what the meaning is).
		// Note for example the inconsistency with the DwtComposite.prototype._contextMenuListener method below
		// As one cool way to allow selection look at ZmConvView2Header constructor, the line:
		// this.setEventPropagation(true, [DwtEvent.ONMOUSEDOWN, DwtEvent.ONSELECTSTART, DwtEvent.ONMOUSEUP, DwtEvent.ONMOUSEMOVE]);
		// which causes _dontCallPreventDefault to be set to true, not being overriden here, thus selection works.
		ev._stopPropagation = true;
		ev._returnValue = true;
	}
};

/**
 * Event listener that is only registered when this control allows selection
 * 
 * @see _allowSelection
 * @private
 */
DwtComposite.prototype._contextMenuListener =
function(ev) {
	// reset mouse event to propagate event to browser (allows context menu)
	ev._stopPropagation = false;
	ev._returnValue = true;
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtShell")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * Creates a shell.
 * @constructor
 * @class
 * This class represents a shell, the first widget that must be instantiated in a Dwt based 
 * application. By default the shell covers the whole browser window, though it may also be 
 * instantiated within an HTML element.
 * <p>
 * {@link DwtShell} should <b>NOT</b> be subclassed.
 * </p>
 *
 * @author Ross Dargahi
 * 
 * @param	{hash}	params		a hash of parameters
 * @param {string}	params.className			the CSS class name
 * @param {boolean}	params.docBodyScrollable	if <code>true</code>, then the document body is set to be scrollable
 * @param {Element}	params.userShell			an HTML element that will be reparented into an absolutely
 *											postioned container in this shell. This is useful in the situation where you have an HTML 
 *											template and want to use this in context of Dwt.
 * @param {Boolean}	params.useCurtain			if <code>true</code>, a curtain overlay is created to be used between hidden and viewable elements 
 *											using z-index (see {@link Dwt}) for various layering constants)
 *
 * @extends		DwtComposite
 */
DwtShell = function(params) {
	if (window._dwtShellId) {
		throw new DwtException("DwtShell already exists for window", DwtException.INVALID_OP, "DwtShell");
	}

	var className = params.className || "DwtShell";
	DwtComposite.call(this, {className:className});

	// HACK! This is a hack to make sure that the control methods work 
	// with DwtShell since the parent of DwtShell is null. 
	this.__ctrlInited = true;

	document.body.style.margin = 0;
	if (!params.docBodyScrollable) {
		if (AjxEnv.isIE) {
			document.body.onscroll = DwtShell.__onBodyScroll;
		}
		document.body.style.overflow = "hidden";
	}

	document.body.onselect = DwtShell._preventDefaultSelectPrt;
	document.body.onselectstart = DwtShell._preventDefaultSelectPrt;
	document.body.oncontextmenu = DwtShell._preventDefaultPrt;
	window.onresize = DwtShell._resizeHdlr;

	var htmlElement = document.createElement("div");
	this._htmlElId = window._dwtShellId = htmlElement.id = params.id || Dwt.getNextId();
	DwtControl.ALL_BY_ID[this._htmlElId] = this;

	htmlElement.className = className;
	htmlElement.style.width = htmlElement.style.height = "100%";
	Dwt.setPosition(htmlElement, DwtControl.ABSOLUTE_STYLE);

	if (htmlElement.style.overflow) {
		htmlElement.style.overflow = null;
	}

	// if there is a user shell (body content), move it below this shell
	// into a container that's absolutely positioned
	try {
		if (params.userShell) {
			document.body.removeChild(params.userShell);
		}
	} catch (ex) {}
	document.body.appendChild(htmlElement);
	if (params.userShell) {
		var userShellContainer = new DwtControl({parent:this, posStyle:Dwt.ABSOLUTE_STYLE});
		userShellContainer.getHtmlElement().appendChild(params.userShell);
		userShellContainer.setSize("100%", "100%");
		userShellContainer.zShow(true);
		this._userShell = params.userShell;
	} else {
		this._userShell = null;
	}
	this.shell = this;

	// Busy overlay - used when we want to enforce a modal busy state
	this._createBusyOverlay(htmlElement);

	// Veil overlay - used by DwtDialog to disable underlying app
	this._veilOverlay = document.createElement("div");
	this._veilOverlay.className = (!AjxEnv.isLinux) ? "VeilOverlay" : "VeilOverlay-linux";
	this._veilOverlay.style.position = "absolute";
	this._veilOverlay.style.cursor = "not-allowed";
	this._veilOverlay.veilZ = new Array();
	this._veilOverlay.veilZ.push(Dwt.Z_HIDDEN);
	this._veilOverlay.dialogZ = new Array();
	this._veilOverlay.activeDialogs = new Array();
	this._veilOverlay.innerHTML = "<table cellspacing=0 cellpadding=0 style='width:100%; height:100%'><tr><td>&nbsp;</td></tr></table>";
	htmlElement.appendChild(this._veilOverlay);
	Dwt.setBounds(this._veilOverlay, 0, 0, "100%", "100%");
	Dwt.setZIndex(this._veilOverlay, Dwt.Z_HIDDEN);

	// Curtain overlay - used between hidden and viewable elements using z-index
	if (params.useCurtain) {
		this._curtainOverlay = document.createElement("div");
		this._curtainOverlay.className = "CurtainOverlay";
		this._curtainOverlay.style.position = "absolute";
		this._curtainOverlay.innerHTML = "<table cellspacing=0 cellpadding=0 style='width:100%; height:100%'><tr><td>&nbsp;</td></tr></table>";
		htmlElement.appendChild(this._curtainOverlay);
		Dwt.setBounds(this._curtainOverlay, 0, 0, "100%", "100%");
		Dwt.setZIndex(this._curtainOverlay, Dwt.Z_CURTAIN);
	}

	this._uiEvent = new DwtUiEvent(true);
	this.relayout();

	// tooltip singleton used by all controls in shell
	this._toolTip = new DwtToolTip(this);
	this._hoverMgr = new DwtHoverMgr();
	
	this._keyboardMgr = new DwtKeyboardMgr(this);
}

DwtShell.prototype = new DwtComposite;
DwtShell.prototype.constructor = DwtShell;

/**
 * DwtDialog not defined yet, can't base ID on it
 * @private
 */
DwtShell.CANCEL_BUTTON = -1;

// Event objects used to populate events so we dont need to create them for each event
DwtShell.controlEvent 	= new DwtControlEvent();
DwtShell.focusEvent 	= new DwtFocusEvent();
DwtShell.keyEvent 		= new DwtKeyEvent();
DwtShell.mouseEvent 	= new DwtMouseEvent();
DwtShell.selectionEvent = new DwtSelectionEvent(true);
DwtShell.treeEvent 		= new DwtTreeEvent();

DwtShell._GLOBAL_SELECTION = "GlobalSelection";

// Public methods

DwtShell.prototype.toString = 
function() {
	return "DwtShell";
}

/**
 * Gets the shell managing the browser window (if any).
 *
 * @param {Window}      win     the global context
 * @return {DwtShell}		the shell or <code>null</code>
 */
DwtShell.getShell = function(win) {
    win = win || window;
	return DwtControl.fromElementId(win._dwtShellId);
};

/**
 * Gets the shell's keyboard manager.
 * 
 * @return	{DwtKeyboardMgr}		the keyboard manager
 * 
 * @private
 */
DwtShell.prototype.getKeyboardMgr =
function() {
	return this._keyboardMgr;
}

/**
 * Sets the busy overlay. The busy overlay disables input to the application and makes the 
 * cursor a wait cursor. Optionally a work in progress (WIP) dialog may be requested. Since
 * multiple calls to this method may be interleaved, it accepts a unique ID to keep them
 * separate. We also maintain a count of outstanding calls to <code>setBusy(true)</code>. When that count
 * changes between 0 and 1, the busy overlay is applied or removed.
 * 
 * @param {boolean}	busy			if <code>true</code>, set the busy overlay, otherwise hide the busy overlay
 * @param {number}	id					a unique ID for this instance
 * @param {boolean}	showBusyDialog 		if <code>true</code>, show the WIP dialog
 * @param {number}	busyDialogDelay 		the number of ms to delay before popping up the WIP dialog
 * @param {AjxCallback}	cancelBusyCallback	the callback to run when OK button is pressed in WIP dialog
 */ 
DwtShell.prototype.setBusy =
function(busy, id, showBusyDialog, busyDialogDelay, cancelBusyCallback) {
	if (busy) {
		this._setBusyCount++;
	} else if (this._setBusyCount > 0) {
		this._setBusyCount--;
	}

    if (!this._setBusy && (this._setBusyCount > 0)) {
		// transition from non-busy to busy state
		Dwt.setCursor(this._busyOverlay, "wait");
    	Dwt.setVisible(this._busyOverlay, true);
    	this._setBusy = this._blockInput = true;
    	DBG.println(AjxDebug.DBG2, "set busy overlay, id = " + id);
    } else if (this._setBusy && (this._setBusyCount <= 0)) {
		// transition from busy to non-busy state
	    Dwt.setCursor(this._busyOverlay, "default");
	    Dwt.setVisible(this._busyOverlay, false);
	    this._setBusy = this._blockInput = false;
    	DBG.println(AjxDebug.DBG2, "remove busy overlay, id = " + id);
	}
	
	// handle busy dialog whether we've changed state or not
	if (busy && showBusyDialog) {
		if (busyDialogDelay && busyDialogDelay > 0) {
			this._busyActionId[id] = AjxTimedAction.scheduleAction(this._busyTimedAction, busyDialogDelay);
		} else {
			this._showBusyDialogAction(id);
		}

		this._cancelBusyCallback = cancelBusyCallback;
		if (this._busyDialog) {
			this._busyDialog.setButtonEnabled(DwtShell.CANCEL_BUTTON, (cancelBusyCallback != null));
		}
	} else {
    	if (this._busyActionId[id] && (this._busyActionId[id] != -1)) {
    		AjxTimedAction.cancelAction(this._busyActionId[id]);
    		this._busyActionId[id] = -1;
    	}
   		if (this._busyDialog && this._busyDialog.isPoppedUp) {
    		this._busyDialog.popdown();
   		}
    } 
}

// (hee hee)
DwtShell.prototype.getBusy =
function() {
	return this._setBusy;
};

/**
 * Sets the text for the shell busy dialog
 *
 * @param {string}	text 		the text to set (may be HTML)
 */
DwtShell.prototype.setBusyDialogText =
function(text) {
	this._busyDialogText = text;
	if (this._busyDialogTxt) {
		this._busyDialogTxt.innerHTML = (text) ? text : "";
	}
}

/**
 * Sets the shell busy dialog title.
 * 
 * @param {string}	title 		the title text
 */
DwtShell.prototype.setBusyDialogTitle =
function(title) {
	this._busyDialogTitle = title;
	if (this._busyDialog) {
		this._busyDialog.setTitle((title) ? title : AjxMsg.workInProgress);
	}
}

DwtShell.prototype.getHoverMgr = 
function() {
	return this._hoverMgr;
}

/**
 * Gets the tool tip.
 * 
 * @return	{string}	the tool tip
 */
DwtShell.prototype.getToolTip = 
function() {
	return this._toolTip;
}

DwtShell.prototype.getH = 
function(incScroll) {
	return (!this._virtual) ? Dwt.getSize(this.getHtmlElement(), incScroll).y
	                        : Dwt.getSize(document.body, incScroll).y;
}

DwtShell.prototype.getW = 
function(incScroll) {
	return (!this._virtual) ? Dwt.getSize(this.getHtmlElement(), incScroll).x
	                        : Dwt.getSize(document.body, incScroll).x;
}

DwtShell.prototype.getSize = 
function(incScroll) {
	return (!this._virtual) ? Dwt.getSize(this.getHtmlElement(), incScroll)
	                        : Dwt.getSize(document.body, incScroll);
}

DwtShell.prototype.getLocation =
function() {
	return (!this._virtual) ? Dwt.getLocation(this.getHtmlElement())
	                        : Dwt.getLocation(document.body);
}

DwtShell.prototype.getX =
function() {
	return (!this._virtual) ? Dwt.getLocation(this.getHtmlElement()).x
	                        : Dwt.getLocation(document.body).x;
}

DwtShell.prototype.getY =
function() {
	return (!this._virtual) ? Dwt.getLocation(this.getHtmlElement()).y
	                        : Dwt.getLocation(document.body).y;
}


DwtShell.prototype.getBounds = 
function(incScroll) {
	return (!this._virtual) ? Dwt.getBounds(this.getHtmlElement(), incScroll)
	                        : Dwt.getBounds(document.body, incScroll);
}

/**
 * If the shell is set as a virtual shell, then all children that are 
 * directly added to the shell become children on the page's body element. This
 * is useful in the cases where Dwt is to beused  with existing HTML documents
 * rather than as the foundation for an application.
 * 
 * @private
 */
DwtShell.prototype.setVirtual =
function() {
	this._virtual = true;
	this.setVisible(false);
}

/**
 * Adds a focus listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
DwtShell.prototype.addFocusListener =
function(listener) {
	if (!this._hasFocusHandler) {
		var doc = document;
		if ((typeof doc.onfocusin != "undefined" ) && doc.attachEvent) {  // if (IE)
			doc.attachEvent("onfocusin", DwtShell.__focusHdlr);
		} else if (window.addEventListener) {
			window.addEventListener("focus", DwtShell.__focusHdlr, false);
		}
		this._hasFocusHandler = true;
	}
	this.addListener(DwtEvent.ONFOCUS, listener);
};

/**
 * Adds a blur listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
DwtShell.prototype.addBlurListener =
function(listener) {
	if (!this._hasBlurHandler) {
		var doc = document;
		if ((typeof doc.onfocusin != "undefined" ) && doc.attachEvent) {  // if (IE)
			doc.attachEvent("onfocusout", DwtShell.__blurHdlr);
		} else if (window.addEventListener) {
			window.addEventListener("blur", DwtShell.__blurHdlr, false);
		}
		this._hasBlurHandler = true;
	}
	this.addListener(DwtEvent.ONBLUR, listener);
};

/**
 * Adds a global selection listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
DwtShell.prototype.addGlobalSelectionListener =
function(listener) {
	this.addListener(DwtShell._GLOBAL_SELECTION, listener);
};

/**
 * Removes a global selection listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
DwtShell.prototype.removeGlobalSelectionListener =
function(listener) {
	this.removeListener(DwtShell._GLOBAL_SELECTION, listener);
};

DwtShell.prototype.notifyGlobalSelection =
function(event) {
	this.notifyListeners(DwtShell._GLOBAL_SELECTION, event);
};

/**
 * @return {boolean}	<code>true</code> if the shell is virtual
 * 
 * @private
 */
DwtShell.prototype.isVirtual =
function() {
	return this._virtual;
}


// Private / protected methods

DwtShell.prototype._showBusyDialogAction =
function(id) {
	var bd = this._getBusyDialog();
	bd.popup();
	this._busyActionId[id] = -1;
}

DwtShell.prototype._createBusyOverlay =
function(htmlElement) {
    this._busyOverlay = document.createElement("div");
    this._busyOverlay.className = (!AjxEnv.isLinux) ? "BusyOverlay" : "BusyOverlay-linux";
    this._busyOverlay.style.position = "absolute";
    this._busyOverlay.innerHTML = "<table cellspacing=0 cellpadding=0 style='width:100%; height:100%'><tr><td>&nbsp;</td></tr></table>";
    htmlElement.appendChild(this._busyOverlay);
	Dwt.setBounds(this._busyOverlay, 0, 0, "100%", "100%");
	Dwt.setZIndex(this._busyOverlay, Dwt.Z_VEIL);
	Dwt.setVisible(this._busyOverlay, false);

	this._busyTimedAction = new AjxTimedAction(this, this._showBusyDialogAction);
	this._busyActionId = {};
	
	this._setBusyCount = 0;
	this._setBusy = false;
}

DwtShell.prototype._getBusyDialog =
function(htmlElement) {
	if (!this._busyDialog) {
		var cancelButton = new DwtDialog_ButtonDescriptor(DwtShell.CANCEL_BUTTON, AjxMsg.cancelRequest, DwtDialog.ALIGN_CENTER);
	    this._busyDialog = new DwtDialog({parent:this, className:"DwtShellBusyDialog", title:AjxMsg.workInProgress,
	    								  standardButtons:DwtDialog.NO_BUTTONS, extraButtons:[cancelButton], zIndex:Dwt.BUSY + 10});
	    this._busyDialog.registerCallback(DwtShell.CANCEL_BUTTON, this._busyCancelButtonListener, this);
	    var txtId = Dwt.getNextId();
	    var html = [
	        "<table class='DialogContent'><tr>",
	            "<td><div class='WaitIcon'></div></td><td class='MsgText' id='", txtId, "'>&nbsp;</td>",
	        "</tr></table>"].join("");
	    
	    this._busyDialog.setContent(html);
	    this._busyDialogTxt = document.getElementById(txtId);
		if (this._busyDialogText) {
			this._busyDialogTxt.innerHTML = this._busyDialogText;
		}
		if (this._busyDialogTitle) {
			this._busyDialog.setTitle(this._busyDialogTitle);
		}
		this._busyDialog.setButtonEnabled(DwtShell.CANCEL_BUTTON, (this._cancelBusyCallback != null));
	}
	return this._busyDialog;
};

/**
 *
 * Relayout user skin elements. Called whenever hiding or showing a
 * part of the user skin, or when resizing the window.
 *
 * The layout works on elements of class "skin_layout_filler" -- which
 * must also be of either class "skin_layout_row" or
 * "skin_layout_cell". It finds the size of our parent, subtract the
 * sizes all sibling rows or cells (excluding other fillers) and
 * divide the remaining size between this filler and any sibling
 * fillers.
 */
DwtShell.prototype.relayout =
function() {
    this._currWinSize = Dwt.getWindowSize();

    if (this._userShell) {
        var fillers = Dwt.byClassName('skin_layout_filler', this._userShell);

        AjxUtil.foreach(fillers, function(elem) {
            if (Dwt.hasClass(elem, 'skin_layout_row')) {
                var row = elem;
                var table = row.parentNode;
                var height = Dwt.getSize(table).y;
                var nfillers = 0;

                var insets = Dwt.getInsets(table);
                height -= insets.top + insets.bottom;
                var margins = Dwt.getMargins(row);
                height -= margins.top + margins.bottom;

                AjxUtil.foreach(table.children, function(otherrow) {
                    var margins = Dwt.getMargins(otherrow);
                    height -= margins.top + margins.bottom;

                    if (Dwt.hasClass(otherrow, 'skin_layout_filler')) {
                        nfillers += 1;
                    } else {
                        var otherheight = Dwt.getSize(otherrow).y;

                        AjxUtil.foreach(otherrow.children, function(cell) {
                            var margins = Dwt.getMargins(cell);
                            var height = Dwt.getSize(cell).y +
                                margins.top + margins.bottom;
                            otherheight = Math.max(otherheight, height);
                        });

                        height -= otherheight;
                    }
                });

                row.style.height = Math.max(height / nfillers, 0) + 'px';

            } else if (Dwt.hasClass(elem, 'skin_layout_cell')) {
                var cell = elem;
                var row = cell.parentNode;
                var table = row.parentNode;
                var width = Dwt.getSize(table).x;
                var nfillers = 0;

                var insets = Dwt.getInsets(table);
                width -= insets.left + insets.right;
                var margins = Dwt.getMargins(row);
                width -= margins.left + margins.right;

                AjxUtil.foreach(row.children, function(othercell) {
                    var margins = Dwt.getMargins(othercell);
                    width -= margins.left + margins.right;

                    if (Dwt.hasClass(othercell, 'skin_layout_filler')) {
                        nfillers += 1;
                    } else {

						if (cell.id === "skin_td_main" && othercell.id === "skin_td_tree_app_sash" &&
							AjxEnv.isChrome && !AjxUtil.isInt(window.devicePixelRatio)) {
							// See bug #96808.
							// Chrome seems to change the hardcoded pixel value.
							// Depending on the zoom level it fluctuates +/- 1. This messes up elements' width calculation.
							// The problematic element is #skin_td_tree_app_sash when calculating width for #skin_td_main.
							// The value of sash's width is set in skins.
							// Decreasing the width by 3 works on all zoom levels.
							// Only do this on non-integer devicePixelRatio
							// (e.g. skip 100% zoom on retina and non-retina displays where devicePixelRatio is 2 and 1).
							width -= 3;
						}

                        width -= Dwt.getSize(othercell).x;
                    }
                });

                cell.style.width = Math.max(width / nfillers, 0) + 'px';

            } else if (window.console) {
                console.warn('not fixing sizes for element!', elem);
            }
        });
    }
};

// Listeners

DwtShell.prototype._busyCancelButtonListener =
function(ev) {
	this._cancelBusyCallback.run();
	if (this._busyDialog) {
		this._busyDialog.popdown();
	}
}


// Static methods

DwtShell._preventDefaultSelectPrt =
function(ev) {
    var evt = DwtControl.fromElementId(window._dwtShellId)._uiEvent;
    evt.setFromDhtmlEvent(ev, true);

	if (evt.dwtObj && evt.dwtObj instanceof DwtControl && !evt.dwtObj.preventSelection(evt.target)) {
        evt._stopPropagation = false;
        evt._returnValue = true;
    } else {
        evt._stopPropagation = true;
        evt._returnValue = false;
    }
    evt.setToDhtmlEvent(ev);
    return !evt._stopPropagation;
};

DwtShell._preventDefaultPrt =
function(ev) {
	ev = DwtUiEvent.getEvent(ev);
	var target = ev.target ? ev.target : ev.srcElement;
	
    var evt = DwtControl.fromElementId(window._dwtShellId)._uiEvent;
    evt.setFromDhtmlEvent(ev, true);
	//default behavior
    evt._stopPropagation = true;
    evt._returnValue = false;
	if (evt.dwtObj && evt.dwtObj instanceof DwtControl && !evt.dwtObj.preventContextMenu(evt.target)) {
        evt._stopPropagation = false;
        evt._returnValue = true;
    } else if (target != null && typeof(target) == 'object') {
     	if ((target.tagName == "A" ||  target.tagName == "a") && target.href) {
	        evt._stopPropagation = false;
    	    evt._returnValue = true;
    	}
    } 
    
    evt.setToDhtmlEvent(ev);
    return evt._returnValue;
};


/* This the resize handler to track when the browser window size changes */
DwtShell._resizeHdlr =
function(ev) {
	var shell = DwtControl.fromElementId(window._dwtShellId);
	if (shell.isListenerRegistered(DwtEvent.CONTROL)) {
	 	var evt = DwtShell.controlEvent;
	 	evt.reset();
	 	evt.oldWidth = shell._currWinSize.x;
	 	evt.oldHeight = shell._currWinSize.y;
		shell.relayout();
	 	evt.newWidth = shell._currWinSize.x;
	 	evt.newHeight = shell._currWinSize.y;
	 	shell.notifyListeners(DwtEvent.CONTROL, evt);
	} else {
		shell.relayout();
	}
};

DwtShell.__onBodyScroll = function() {
	// alert(document.body.scrollTop + "/" + document.body.scrollLeft);
	document.body.scrollTop = 0;
	document.body.scrollLeft = 0;
	// DwtShell._resizeHdlr();
};

DwtShell.__focusHdlr =
function() {
	var focusEvent = DwtShell.focusEvent;
	var self = DwtShell.getShell(window);
	focusEvent.dwtObj = self;
	focusEvent.state = DwtFocusEvent.FOCUS;
	self.notifyListeners(DwtEvent.ONFOCUS, focusEvent);
};

DwtShell.__blurHdlr =
function() {
	var focusEvent = DwtShell.focusEvent;
	var self = DwtShell.getShell(window);
	focusEvent.dwtObj = self;
	focusEvent.state = DwtFocusEvent.BLUR;
	self.notifyListeners(DwtEvent.ONBLUR, focusEvent);
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtColorPicker")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * Creates a color picker displaying "Web safe" colors.
 * @constructor
 * @class
 * Instances of this class may be
 * used with {@link DwtMenu} to create a {@link DwtColorPicker} menu. Clicking on a color cell generates a
 * DwtSelectionEvent the detail attribute of which contains the color string associated
 * the cell on which the user clicked
 *
 *
 * @author Ross Dargahi
 * 
 * @param {hash}	params		a hash of parameters
 * @param {DwtComposite} params.parent		the parent widget
 * @param {string}       params.className	a CSS class
 * @param {constant}     params.posStyle	the positioning style
 * @param {boolean}      params.hideNoFill  True to hide the no-fill/use-default option
 * @param {string}       params.noFillLabel			the no-fill label
 * @param {boolean}      params.allowColorInput		if <code>true</code>, allow a text field to allow user to input their customized RGB value
 * @param {string}       params.defaultColor Default color.
 * 
 * @extends		DwtControl
 */
DwtColorPicker = function(params) {
	if (arguments.length == 0) return;
    params = Dwt.getParams(arguments, DwtColorPicker.PARAMS);

	params.className = params.className || "DwtColorPicker";
	DwtComposite.call(this, params);

    this._hideNoFill = params.hideNoFill;
	this._noFillLabel = params.noFillLabel;
    this._allowColorInput = params.allowColorInput;
    this._defaultColor = params.defaultColor || "#000000";
    this._createHtml();
};

DwtColorPicker.prototype = new DwtComposite;
DwtColorPicker.prototype.constructor = DwtColorPicker;

DwtColorPicker.prototype.toString = function() {
	return "DwtColorPicker";
};

DwtColorPicker.PARAMS = ["parent", "className", "posStyle", "noFillLabel", "allowColorInput", "defaultColor"];

//
// Constants
//

// RE to parse out components out of a "rgb(r, g, b);" string
DwtColorPicker._RGB_RE = /^rgb\(([0-9]{1,3}),\s*([0-9]{1,3}),\s*([0-9]{1,3})\)$/;
DwtColorPicker._HEX_RE = /^\#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i;

//
// Data
//

DwtColorPicker.prototype.TEMPLATE = "dwt.Widgets#DwtColorPicker";

//
// Public methods
//

/**
 * Adds a listener to be notified when the button is pressed.
 *
 * @param {AjxListener}	listener	a listener
 */
DwtColorPicker.prototype.addSelectionListener = 
function(listener) {
	this.addListener(DwtEvent.SELECTION, listener);
};

/**
 * Removes a selection listener.
 *
 * @param {AjxListener}	listener	a listener
 */
DwtColorPicker.prototype.removeSelectionListener = 
function(listener) { 
	this.removeListener(DwtEvent.SELECTION, listener);
};

DwtColorPicker.prototype.dispose = 
function () {
	if (this._disposed) { return; }
	DwtControl.prototype.dispose.call(this);
};

DwtColorPicker.prototype._createHtml = function(templateId) {
    this._createHtmlFromTemplate(templateId||this.TEMPLATE, {id:this.getHtmlElement().id});
};

DwtColorPicker.prototype._createHtmlFromTemplate = function(templateId, data) {
    data.allowColorInput = this._allowColorInput;
    data.hideNoFill = this._hideNoFill;
    data.noFillLabel = this._noFillLabel;
    DwtComposite.prototype._createHtmlFromTemplate.apply(this, arguments);

    // create controls
    if (data.allowColorInput) {
        var inputEl = document.getElementById(data.id+"_input");
	var inputParams = {
		parent: this,
		validationStyle: DwtInputField.CONTINUAL_VALIDATION, //update the preview for each key up 
		errorIconStyle: DwtInputField.ERROR_ICON_RIGHT, 
		validator: DwtColorPicker.__isValidInputValue
	};
        var input = this._colorInput = new DwtInputField(inputParams);
        input.replaceElement(inputEl);
	// Add  callback for update the preview when the input value is validated.
	var updateCallback = new AjxCallback(this, this._updatePreview);
	input.setValidationCallback(updateCallback);
	
	var error = this._error = new DwtLabel({parent:this});
	var errorEl = document.getElementById(data.id+"_error");
        error.replaceElement(errorEl);
        error.setVisible(false);
        
	this._preview = document.getElementById(data.id+"_preview");
        
	var buttonEl = document.getElementById(data.id+"_button");
        var button = new DwtButton({parent:this});
        button.setText(AjxMsg.setColor);
        button.replaceElement(buttonEl);
        button.addSelectionListener(new AjxListener(this, this._handleSetColor));
    }

    var buttonEl = document.getElementById(data.id+"_default");
    if (buttonEl) {
        if (!DwtColorPicker.Button) {
            DwtColorPicker.__defineClasses();
        }
        var button = this._defaultColorButton = new DwtColorPicker.Button({parent:this});
        button.setText(data.noFillLabel || AjxMsg.colorsUseDefault);
        button.replaceElement(buttonEl);
        button.addSelectionListener(new AjxListener(this, this._handleColorSelect, [0]));
    }

    // set color handlers
    var colorsEl = document.getElementById(data.id+"_colors");
    var mouseOver = AjxEnv.isIE ? DwtEvent.ONMOUSEENTER : DwtEvent.ONMOUSEOVER;
    var mouseOut  = AjxEnv.isIE ? DwtEvent.ONMOUSELEAVE : DwtEvent.ONMOUSEOUT;

    Dwt.setHandler(colorsEl, DwtEvent.ONMOUSEDOWN, AjxCallback.simpleClosure(this._handleMouseDown, this));
    Dwt.setHandler(colorsEl, DwtEvent.ONMOUSEUP, AjxCallback.simpleClosure(this._handleMouseUp, this));
    Dwt.setHandler(colorsEl, mouseOver, AjxCallback.simpleClosure(this._handleMouseOver, this));
    Dwt.setHandler(colorsEl, mouseOut, AjxCallback.simpleClosure(this._handleMouseOut, this));
};

DwtColorPicker.prototype._handleMouseOver = function(htmlEvent) {
    var event = DwtUiEvent.getEvent(htmlEvent);
    var target = DwtUiEvent.getTarget(event);
    if (!Dwt.hasClass(target, "Color")) return;

    this._handleMouseOut(htmlEvent);
    Dwt.addClass(target, DwtControl.HOVER);
    this._mouseOverEl = target;
};

DwtColorPicker.prototype._handleMouseOut = function(htmlEvent) {
    if (this._mouseOverEl) {
        Dwt.delClass(this._mouseOverEl, DwtControl.HOVER);
    }
    this._mouseOverEl = null;
};

DwtColorPicker.prototype._handleMouseDown = function(htmlEvent) {
    var event = DwtUiEvent.getEvent(htmlEvent);
    var target = DwtUiEvent.getTarget(event);
    this._mouseDownEl = Dwt.hasClass(target, "Color") ? target : null;
};
DwtColorPicker.prototype._handleMouseUp = function(htmlEvent) {
    var event = DwtUiEvent.getEvent(htmlEvent);
    var target = DwtUiEvent.getTarget(event);
    if (this._mouseDownEl != target) return;

    var cssColor = DwtCssStyle.getProperty(target, "background-color");
    this._handleColorSelect(DwtColorPicker.__color2hex(cssColor));
};

DwtColorPicker.prototype._handleSetColor = function(evt) {
    var color = this._colorInput.getValue();
    if (color) {
	color = DwtColorPicker.__color2hex(color);
	if(!color) 
		return; 
    	this._handleColorSelect(color);
    }
};

DwtColorPicker.prototype._handleColorSelect = function(color) {
    this._inputColor = color;

    // If our parent is a menu then we need to have it close
    if (this.parent instanceof DwtMenu) {
        DwtMenu.closeActiveMenu();
    }

    // Call Listeners on mouseEv.target.id
    if (this.isListenerRegistered(DwtEvent.SELECTION)) {
        var selEvent = DwtShell.selectionEvent;
//        DwtUiEvent.copy(selEvent, htmlEvent);
        selEvent.item = this;
        selEvent.detail = this._inputColor;
        this.notifyListeners(DwtEvent.SELECTION, selEvent);
    }
};

/**
 * Gets the input color.
 * 
 * @return	{string}	the color (in hex) from the input color field
 */
DwtColorPicker.prototype.getInputColor = function () {
    return this._inputColor;
};

DwtColorPicker.prototype.setDefaultColor = function (color) {
    if(this._defaultColorButton) {
        this._defaultColorButton.setDefaultColor(color);
    }
};

DwtColorPicker.__color2hex = function(s) {
	//in IE we can't get the calculated value so for white/black we get white/black (of course it could be set the the hex value in the markup but this is more bulletproof to make sure here)
	if (s == "white") {
		return "#FFFFFF";
	}
	if (s == "black") {
		return "#000000";
	}

    var m = s && s.match(DwtColorPicker._RGB_RE);
    if (m) {
	// each component should be in range of (0 - 255)
	for( var i = 1; i <= 3; i++ ) {
		if(parseInt(m[i]) > 255)
			return "";
	}
        return AjxColor.color(m[1], m[2], m[3]);
    }
    m = s && s.match(DwtColorPicker._HEX_RE);
    if (m) {
        return s;
    }
    return "";
};

DwtColorPicker.__isValidInputValue = function(s) {
   // null is valid for we consider the condition
   // the user delete all the word it has been input
   if (!s)
	return s;
   var r = DwtColorPicker.__color2hex(s);
   if (!r) { 
	throw AjxMsg.colorFormatError;	
   }
   return s;	
};

DwtColorPicker.prototype._updatePreview = function(inputelement, isValid, value){
   if (isValid) {
	value = DwtColorPicker.__color2hex(value);
	Dwt.setVisible(this._preview, true);
	this._preview.style.backgroundColor = value;
	this._error.setVisible(false);
   }
   else {
	Dwt.setVisible(this._preview, false);
	this._error.setVisible(true);
	this._error.setText(AjxMsg.colorFormatError);
   }
};
//
// Classes
//

DwtColorPicker.__defineClasses = function() {
    // HACK: This defines the custom button after the color picker has
    // HACK: been initialized and instantiated so that we dont' get
    // HACK: weird dependency issues. (I noticed this in particular
    // HACK: in the admin client.)
    DwtColorPicker.Button = function(params) {
        params.className = params.className || "DwtColorPickerButton";
        DwtButton.call(this, params);
        this._colorDiv = document.getElementById(this.getHtmlElement().id+"_color");
    };
    DwtColorPicker.Button.prototype = new DwtButton;
    DwtColorPicker.Button.prototype.constructor = DwtColorPicker.Button;

    DwtColorPicker.Button.prototype.setDefaultColor = function(color) {
        this._colorDiv.style.backgroundColor = (color === null) ? "" : color;
    };

    DwtColorPicker.Button.prototype.toString = function() {
        return "DwtColorPickerButton";
    };

    DwtColorPicker.Button.prototype.TEMPLATE = "dwt.Widgets#DwtColorPickerButton";
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtBaseDialog")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * @overview
 * This file contains a base Dwt dialog control.
 * 
 */

/**
 * @class
 * This is a base class for dialogs. Given content, this class will take care of 
 * showing and hiding the dialog, as well as dragging it.
 * <p>
 * Dialogs always hang off the main shell since their stacking order is managed through z-index.
 *
 * @author Ross Dargahi
 * @author Conrad Damon
 * 
 * @param {hash}	params		a hash of parameters
 * @param	{DwtComposite}	params.parent	the parent widget (the shell)
 * @param	{string}	params.className		the CSS class
 * @param	{string}	params.title		the title
 * @param	{number}	[params.zIndex=Dwt.Z_DIALOG]		the z-index to set for this dialog when it is visible
 * @param	{DwtBaseDialog.MODAL|DwtBaseDialog.MODELESS}	[params.mode=DwtBaseDialog.MODAL] 		the modality of the dialog
 * @param	{DwtPoint}	params.loc			the location at which to popup the dialog. Defaults to being centered within its parent
 * @param	{boolean}		params.disposeOnPopDown		    destroy the content of dialog on popdown, Defaults to false
 * @param	{DwtControl}	params.view 		the the control whose element is to be re-parented
 * @param	{string}	params.dragHandleId 		the the ID of element used as drag handle
 * 
 * @extends	DwtComposite
 */
DwtBaseDialog = function(params) {
	if (arguments.length == 0) { return; }

	params = Dwt.getParams(arguments, DwtBaseDialog.PARAMS);
	var parent = params.parent;
	if (!(parent instanceof DwtShell)) {
		throw new DwtException("DwtBaseDialog parent must be a DwtShell", DwtException.INVALIDPARENT, "DwtDialog");
	}
	params.className = params.className || "DwtBaseDialog";
	params.posStyle = DwtControl.ABSOLUTE_STYLE;
	params.isFocusable = false;

	this._title = params.title || "";

	DwtComposite.call(this, params);
    this._disposeOnPopDown = params.disposeOnPopDown || false;
	this._shell = parent;
	this._zIndex = params.zIndex || Dwt.Z_DIALOG;
	this._mode = params.mode || DwtBaseDialog.MODAL;
	
	this._loc = new DwtPoint();
	if (params.loc) {
		this._loc.x = params.loc.x;
		this._loc.y = params.loc.y
	} else {
		this._loc.x = this._loc.y = Dwt.LOC_NOWHERE;
	}

	// Default dialog tab group.
	this._tabGroup = new DwtTabGroup(this.toString());

    this._dragHandleId = params.dragHandleId || this._htmlElId + "_handle";
	this._createHtml();
    this._initializeDragging(this._dragHandleId);

	if (params.view) {
		this.setView(params.view);
    }

	// reset tab index
    this.setZIndex(Dwt.Z_HIDDEN); // not displayed until popup() called

    // Set visible to true now to allow for getting metrics. ZIndex hidden will prevent it
    // from actually being visible until the dialog is popped up.
	this.setVisible(true);

	this._position(DwtBaseDialog.__nowhereLoc);

	// Make sure mouse clicks propagate to the DwtDraggable handler (document.onMouseMove and onMouseUp)
	this._propagateEvent[DwtEvent.ONMOUSEUP] = true;

	this.shellResizeHandler = this._resizeHdlr.bind(this);
};

/**
 * @private
 */
DwtBaseDialog.PARAMS = ["parent", "className", "title", "zIndex", "mode", "loc", "view", "dragHandleId", "id"];

DwtBaseDialog.prototype = new DwtComposite;
DwtBaseDialog.prototype.constructor = DwtBaseDialog;

DwtBaseDialog.prototype.toString = function() { return "DwtBaseDialog"; };
DwtBaseDialog.prototype.isDwtBaseDialog = true;

DwtBaseDialog.prototype.role = 'dialog';
DwtBaseDialog.prototype.isFocusable = true;


//
// Constants
//

// modes

/**
 * Defines a "modeless" dialog.
 */
DwtBaseDialog.MODELESS = 1;

/**
 * Defines a "modal" dialog.
 */
DwtBaseDialog.MODAL = 2;

/**
 * @private
 */
DwtBaseDialog.__nowhereLoc = new DwtPoint(Dwt.LOC_NOWHERE, Dwt.LOC_NOWHERE);

//
// Data
//

/**
 * @private
 */
DwtBaseDialog.prototype.TEMPLATE = "dwt.Widgets#DwtBaseDialog";

/**
 * <strong>Note:</strong>
 * This member variable will be set by sub-classes that want a control bar
 * to appear below the dialog contents.
 * 
 * @private
 */
DwtBaseDialog.prototype.CONTROLS_TEMPLATE = null;

//
// Public methods
//

/**
 * Adds a popup listener.
 * 
 * @param		{AjxListener}	listener		the listener to add
 */
DwtBaseDialog.prototype.addPopupListener =
function(listener) {
	this.addListener(DwtEvent.POPUP, listener);
}

/**
 * Removes a popup listener.
 * 
 * @param		{AjxListener}	listener		the listener to remove
 */
DwtBaseDialog.prototype.removePopupListener = 
function(listener) {
	this.removeListener(DwtEvent.POPUP, listener);
}

/**
 * Adds a popdown listener.
 * 
 * @param		{AjxListener}	listener		the listener to add
 */
DwtBaseDialog.prototype.addPopdownListener = 
function(listener) {
	this.addListener(DwtEvent.POPDOWN, listener);
}

/**
 * Removes a popdown listener.
 * 
 * @param		{AjxListener}	listener		the listener to remove
 */
DwtBaseDialog.prototype.removePopdownListener = 
function(listener) {
	this.removeListener(DwtEvent.POPDOWN, listener);
}

/**
 * Pops-up the dialog, makes the dialog visible in places. Everything under the dialog will
 * become veiled if we are modal. Note: popping up a dialog will block
 * keyboard actions from being delivered to the global key action handler (if one
 * is registered).
 *
 * @param {DwtPoint}		loc		the desired location
 */
DwtBaseDialog.prototype.popup =
function(loc) {
	if (this._poppedUp) { return; }

	this.cleanup(true);
	var thisZ = this._zIndex;

	// if we're modal, setup the veil effect, and track which dialogs are open
	if (this._mode == DwtBaseDialog.MODAL) {
		thisZ = this._setModalEffect(thisZ);
	}

	this._shell._veilOverlay.activeDialogs.push(this);
	this.setVisible(true);
	
	// use whichever has a value, local has precedence
	if (loc) {
		this._loc.x = loc.x;
		this._loc.y = loc.y;
	}
	this._position(loc);

    //reset TAB focus before popup of dialog.
    //method be over-written to focus a different member.
    this._resetTabFocus();

	this.setZIndex(thisZ);
	this._poppedUp = true;

	// Push our tab group
	var kbMgr = this._shell.getKeyboardMgr();
	kbMgr.pushTabGroup(this._tabGroup);
	kbMgr.pushDefaultHandler(this);

	DwtShell.getShell().addListener(DwtEvent.CONTROL, this.shellResizeHandler);

	this.notifyListeners(DwtEvent.POPUP, this);
};

/**
 * @private
 */
DwtBaseDialog.prototype._resetTabFocus =
function(){
    this._tabGroup.resetFocusMember(true);
};

DwtBaseDialog.prototype.focus = 
function () {
	// if someone is listening for the focus to happen, give control to them,
	// otherwise focus on this dialog.
	if (this.isListenerRegistered(DwtEvent.ONFOCUS)) {
		this.notifyListeners(DwtEvent.ONFOCUS);
	} else if (this._focusElementId){
		var focEl = document.getElementById(this._focusElementId);
		if (focEl) {
			focEl.focus();
            return focEl;
		}
	}
};

/**
 * Checks if the dialog is popped-up.
 * 
 * @return	{boolean}	<code>true</code> if the dialog is popped-up; <code>false</code> otherwise
 */
DwtBaseDialog.prototype.isPoppedUp =
function () {
	return this._poppedUp;
};

/**
 * Pops-down and hides the dialog.
 * 
 */
DwtBaseDialog.prototype.popdown =
function() {

	if (this._poppedUp) {
		this._poppedUp = false;
		this.cleanup(false);
	
		//var myZIndex = this.getZIndex();
	    var myZIndex = this._zIndex;
		this.setZIndex(Dwt.Z_HIDDEN);
		this.setVisible(false);
		//TODO we should not create an object everytime we popdown a dialog (ditto w/popup)
		this._position(DwtBaseDialog.__nowhereLoc);
		if (this._mode == DwtBaseDialog.MODAL) {
			this._undoModality(myZIndex);
		} else {
			this._shell._veilOverlay.activeDialogs.pop();
		}
		//this.removeKeyListeners();

        //Dispose the dialog if _disposeOnPopDown is set to true
		if (this._disposeOnPopDown === true) {
            this.dispose();
        }

		// Pop our tab group
		var kbMgr = this._shell.getKeyboardMgr();
		kbMgr.popTabGroup(this._tabGroup);
		kbMgr.popDefaultHandler();

		DwtShell.getShell().removeListener(DwtEvent.CONTROL, this.shellResizeHandler);
		this.notifyListeners(DwtEvent.POPDOWN, this);
	}
};

/**
 * Sets the content of the dialog to a new view. Essentially re-parents
 * the supplied control's HTML element to the dialogs HTML element
 * 
 * @param {DwtControl} newView		the control whose element is to be re-parented
 */
DwtBaseDialog.prototype.setView =
function(newView) {
	this.reset();
	if (newView) {
		this._getContentDiv().appendChild(newView.getHtmlElement());
	}
};

/**
 * Resets the dialog back to its original state. Subclasses should override this method
 * to add any additional behavior, but should still call up into this method.
 * 
 */
DwtBaseDialog.prototype.reset =
function() {
	this._loc.x = this._loc.y = Dwt.LOC_NOWHERE;
}

/**
* Cleans up the dialog so it can be used again later.
* 
* @param	{boolean}		bPoppedUp		if <code>true</code>, the dialog is popped-up; <code>false</code> otherwise
*/
DwtBaseDialog.prototype.cleanup =
function(bPoppedUp) {
	//TODO handle different types of input fields e.g. checkboxes etc
	var inputFields = this._getInputFields();
	
	if (inputFields) {
		var len = inputFields.length;
		for (var i = 0; i < len; i++) {
			inputFields[i].disabled = !bPoppedUp;
			if (bPoppedUp)
				inputFields[i].value = "";
		}
	}
}

/**
 * Sets the title.
 * 
 * @param	{string}		title		the title
 */
DwtBaseDialog.prototype.setTitle =
function(title) {
    if (this._titleEl) {
        this._titleEl.innerHTML = title || "";
    }

    this._title = title;
};

/**
* Sets the dialog content (below the title, above the buttons).
*
* @param {string}		text		the dialog content
*/
DwtBaseDialog.prototype.setContent =
function(text) {
	var d = this._getContentDiv();
	if (d) {
		d.innerHTML = text || "";
	}
}

/**
 * @private
 */
DwtBaseDialog.prototype._getContentDiv =
function() {
	return this._contentEl;
};

/**
 * Adds an enter listener.
 * 
 * @param	{AjxListener}	listener		the listener to add
 */
DwtBaseDialog.prototype.addEnterListener =
function(listener) {
	this.addListener(DwtEvent.ENTER, listener);
};

/**
 * Gets the active dialog.
 * 
 * @return	{DwtBaseDialog}		the active dialog
 */
DwtBaseDialog.getActiveDialog = 
function() {
	var dialog = null;
	var shellObj = DwtShell.getShell(window);
	if (shellObj) {
		var len = shellObj._veilOverlay.activeDialogs.length;
		if (len > 0) {
			dialog = shellObj._veilOverlay.activeDialogs[len - 1];
		}
	}
	return dialog;
};

//
// Protected methods
//

DwtBaseDialog.prototype.getTabGroupMember = function() {
	return this._tabGroup;
};

/**
 * @private
 */
DwtBaseDialog.prototype._initializeDragging =
function(dragHandleId) {
	var dragHandle = document.getElementById(dragHandleId);
	if (dragHandle) {
		var control = DwtControl.fromElementId(window._dwtShellId);
		if (control) {
			var p = Dwt.getSize(control.getHtmlElement());
			var dragObj = document.getElementById(this._htmlElId);
			var size = this.getSize();
			var dragEndCb = new AjxCallback(this, this._dragEnd);
			var dragCb = new AjxCallback(this, this._duringDrag);
			var dragStartCb = new AjxCallback(this, this._dragStart);

			DwtDraggable.init(dragHandle, dragObj, 0,
							  document.body.offsetWidth - 10, 0, document.body.offsetHeight - 10, dragStartCb, dragCb, dragEndCb);
		}
	}
};

/**
 * @private
 */
DwtBaseDialog.prototype._getContentHtml =
function() {
    return "";
};

/**
 * @private
 */
DwtBaseDialog.prototype._createHtml = function(templateId) {
    var data = { id: this._htmlElId };
    this._createHtmlFromTemplate(templateId || this.TEMPLATE, data);
};

/**
 * @private
 */
DwtBaseDialog.prototype._createHtmlFromTemplate = function(templateId, data) {
    // set default params
    data.dragId = this._dragHandleId;
    data.title = this._title;
    data.icon = "";
    data.closeIcon1 = "";
    data.closeIcon2 = "";
    data.controlsTemplateId = this.CONTROLS_TEMPLATE;

    // expand template
    DwtComposite.prototype._createHtmlFromTemplate.call(this, templateId, data);

    // remember elements
    this._titleBarEl = document.getElementById(data.id+"_titlebar");
    this._titleEl = document.getElementById(data.id+"_title");
    this._contentEl = document.getElementById(data.id+"_content");

	if (this._titleEl) {
		this.setAttribute('aria-labelledby', this._titleEl.id);
		this._titleEl.setAttribute('role', 'heading');
		this._titleEl.setAttribute('aria-level', '2');
	}

    // NOTE: This is for backwards compatibility. There are just
    //       too many sub-classes of dialog that expect to return
    //       the dialog contents via the _getContentHtml method.
    this.setContent(this._getContentHtml());
};

/**
 * @private
 */
DwtBaseDialog.prototype._setModalEffect =
function() {
	// place veil under this dialog
	var dialogZ = this._shell._veilOverlay.dialogZ;
	var currentDialogZ = null;
	var thisZ, veilZ;
	if (dialogZ.length)
		currentDialogZ = dialogZ[dialogZ.length - 1];
	if (currentDialogZ) {
		thisZ = currentDialogZ + 2;
		veilZ = currentDialogZ + 1;
	} else {
		thisZ = this._zIndex;
		veilZ = Dwt.Z_VEIL;
	}
	this._shell._veilOverlay.veilZ.push(veilZ);
	this._shell._veilOverlay.dialogZ.push(thisZ);
	Dwt.setZIndex(this._shell._veilOverlay, veilZ);
	return thisZ;
};

/**
 * @private
 */
DwtBaseDialog.prototype._undoModality =
function (myZIndex) {
	var veilZ = this._shell._veilOverlay.veilZ;
	veilZ.pop();
	var newVeilZ = veilZ[veilZ.length - 1];
	Dwt.setZIndex(this._shell._veilOverlay, newVeilZ);
	this._shell._veilOverlay.dialogZ.pop();
	this._shell._veilOverlay.activeDialogs.pop();
	if (this._shell._veilOverlay.activeDialogs.length > 0 ) {
		this._shell._veilOverlay.activeDialogs[0].focus();
	}
};

/**
 * Subclasses should implement this method to return an array of input fields that
 * they want to be cleaned up between instances of the dialog being popped up and
 * down
 * 
 * @return An array of the input fields to be reset
 */
DwtBaseDialog.prototype._getInputFields = 
function() {
	// overload me
}

DwtBaseDialog.prototype._resizeHdlr =
function(ev) {
	if (this._loc.x === Dwt.LOC_NOWHERE && this._loc.y === Dwt.LOC_NOWHERE) {
		this._position();
	}
};

/**
 * @private
 */
DwtBaseDialog.prototype._dragStart =
function (x, y){
    // fix for bug 3177
    if (AjxEnv.isNav && !this._ignoreSetDragBoundries) {
        this._currSize = this.getSize();
        var control = DwtControl.fromElementId(window._dwtShellId);
        if (control) {
            var p = Dwt.getSize(control.getHtmlElement());
            DwtDraggable.setDragBoundaries(DwtDraggable.dragEl, 0, p.x - this._currSize.x, 0, p.y - this._currSize.y);
        }
    }
};

/**
 * @private
 */
DwtBaseDialog.prototype._dragEnd =
function(x, y) {
 	// save dropped position so popup(null) will not re-center dialog box
	this._loc.x = x;
	this._loc.y = y;
}

/**
 * @private
 */
DwtBaseDialog.prototype._duringDrag =
function(x, y) {
	// overload me
};

/**
 * @private
 */
DwtBaseDialog.prototype._doesContainElement = 
function (element) {
	return Dwt.contains(this.getHtmlElement(), element);
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtDialog")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * @overview
 * This file contains classes for a Dwt dialog pop-up.
 */

/**
 * @class
 * This class represents a popup dialog with a title and standard buttons.
 * A client or subclass sets the dialog content. Dialogs always hang-off the main shell
 * since their stacking order is managed through z-index.
 *
 * @author Ross Dargahi
 * @author Conrad Damon
 *
 * @param {hash}		params			a hash of parameters
 * @param	{DwtComposite}		params.parent			 		the parent widget (the shell)
 * @param	{string}	params.className					the CSS class
 * @param	{string}	params.title						the title of dialog
 * @param	{array|constant}	params.standardButtons		an array of standard buttons to include. Defaults to {@link DwtDialog.OK_BUTTON} and {@link DwtDialog.CANCEL_BUTTON}.
 * @param	{array}	params.extraButtons		  			a list of {@link DwtDialog_ButtonDescriptor} objects describing custom buttons to add to the dialog
 * @param	{number}	params.zIndex							the z-index to set for this dialog when it is visible. Defaults to {@link Dwt.Z_DIALOG}.
 * @param	{DwtDialog.MODELESS|DwtDialog.MODAL}	params.mode 						the modality of the dialog. Defaults to {@link DwtDialog.MODAL}.
 * @param	{boolean}		params.disposeOnPopDown		    destroy the content of dialog on popdown, Defaults to false
 * @param	{DwtPoint}		params.loc						the location at which to popup the dialog. Defaults to centered within its parent.
 * 
 * @see		DwtDialog.CANCEL_BUTTON
 * @see		DwtDialog.OK_BUTTON
 * @see		DwtDialog.DISMISS_BUTTON
 * @see		DwtDialog.NO_BUTTON
 * @see		DwtDialog.YES_BUTTON
 * @see		DwtDialog.ALL_BUTTONS
 * @see		DwtDialog.NO_BUTTONS
 * 
 * @extends	DwtBaseDialog
 */
DwtDialog = function(params) {
	if (arguments.length == 0) { return; }
	params = Dwt.getParams(arguments, DwtDialog.PARAMS);
	params.className = params.className || "DwtDialog";
	this._title = params.title = params.title || "";

	// standard buttons default to OK / Cancel
	var standardButtons = params.standardButtons;
	var extraButtons = params.extraButtons;
	if (!standardButtons) {
		standardButtons = [DwtDialog.OK_BUTTON, DwtDialog.CANCEL_BUTTON];
	} else if (standardButtons == DwtDialog.NO_BUTTONS) {
		standardButtons = null;
	} else if (standardButtons && !standardButtons.length) {
		standardButtons = [standardButtons];
	}

	// assemble the list of button IDs, and the list of button descriptors
	this._buttonList = [];
	var buttonOrder = {};
	buttonOrder[DwtDialog.ALIGN_LEFT] = [];
	buttonOrder[DwtDialog.ALIGN_CENTER] = [];
	buttonOrder[DwtDialog.ALIGN_RIGHT] = [];
	if (standardButtons || extraButtons) {
		this._buttonDesc = {};
		if (standardButtons && standardButtons.length) {
			this._initialEnterButtonId = this._enterButtonId = standardButtons[0];
			for (var i = 0; i < standardButtons.length; i++) {
				var buttonId = standardButtons[i];
				this._buttonList.push(buttonId);
				var align = DwtDialog.ALIGN[buttonId];
				if (align) {
					buttonOrder[align].push(buttonId);
				}
				// creating standard button descriptors on file read didn't work, so we create them here
				this._buttonDesc[buttonId] = new DwtDialog_ButtonDescriptor(buttonId, AjxMsg[DwtDialog.MSG_KEY[buttonId]], align);
			}
			// set standard callbacks
			this._resetCallbacks();
		}
		if (extraButtons && extraButtons.length) {
			if (!this._enterButtonId) {
				this._initialEnterButtonId = this._enterButtonId = extraButtons[0];
			}
			for (var i = 0; i < extraButtons.length; i++) {
				var buttonId = extraButtons[i].id;
				this._buttonList.push(buttonId);
				var align = extraButtons[i].align;
				if (align) {
					buttonOrder[align].push(buttonId);
				}
				this._buttonDesc[buttonId] = extraButtons[i];
			}
		}
	}

	// get button IDs
	this._buttonElementId = {};
	for (var i = 0; i < this._buttonList.length; i++) {
		var buttonId = this._buttonList[i];
		//this._buttonElementId[this._buttonList[i]] = params.id + "_button" + buttonId + "_cell";
		this._buttonElementId[buttonId] = this._buttonDesc[buttonId].label? this._buttonDesc[buttonId].label + "_" + Dwt.getNextId():Dwt.getNextId();
	}

	DwtBaseDialog.call(this, params);

	// set up buttons
	this._button = {};
	for (var i = 0; i < this._buttonList.length; i++) {
		var buttonId = this._buttonList[i];
		var b = this._button[buttonId] = new DwtButton({parent:this,id:this._htmlElId+"_button"+buttonId});
		b.setText(this._buttonDesc[buttonId].label);
		b.buttonId = buttonId;
		b.addSelectionListener(new AjxListener(this, this._buttonListener));
		var el = document.getElementById(this._buttonElementId[buttonId]);
		if (el) {
			el.appendChild(b.getHtmlElement());
		}
	}
	// add to tab group, in order
	var list = buttonOrder[DwtDialog.ALIGN_LEFT].concat(buttonOrder[DwtDialog.ALIGN_CENTER], buttonOrder[DwtDialog.ALIGN_RIGHT]);
	for (var i = 0; i < list.length; i++) {
		var button = this._button[list[i]];
		this._tabGroup.addMember(button);		
	}
};

DwtDialog.PARAMS = ["parent", "className", "title", "standardButtons", "extraButtons", "zIndex", "mode", "loc", "id"];

DwtDialog.prototype = new DwtBaseDialog;
DwtDialog.prototype.constructor = DwtDialog;

DwtDialog.prototype.isDwtDialog = true;
DwtDialog.prototype.toString = function() { return "DwtDialog"; };

//
// Constants
//

/**
 * Defines the "left" align.
 */
DwtDialog.ALIGN_LEFT 		= 1;
/**
 * Defines the "right" align.
 */
DwtDialog.ALIGN_RIGHT 		= 2;
/**
 * Defines the "center" align.
 */
DwtDialog.ALIGN_CENTER 		= 3;

// standard buttons, their labels, and their positioning

/**
 * Defines the "Cancel" button.
 */
DwtDialog.CANCEL_BUTTON 	= 1;
/**
 * Defines the "OK" button.
 */
DwtDialog.OK_BUTTON 		= 2;
/**
 * Defines the "Dismiss" button.
 */
DwtDialog.DISMISS_BUTTON 	= 3;
/**
 * Defines the "No" button.
 */
DwtDialog.NO_BUTTON 		= 4;
/**
 * Defines the "Yes" button.
 */
DwtDialog.YES_BUTTON 		= 5;

DwtDialog.LAST_BUTTON 		= 5;

/**
 * Defines "no" buttons. This constant is used to show no buttons.
 */
DwtDialog.NO_BUTTONS 		= 256;
/**
 * Defines "all" buttons. This constant is used to show all buttons.
 */
DwtDialog.ALL_BUTTONS 		= [DwtDialog.CANCEL_BUTTON, DwtDialog.OK_BUTTON, 
							   DwtDialog.DISMISS_BUTTON, DwtDialog.NO_BUTTON, 
							   DwtDialog.YES_BUTTON];

DwtDialog.MSG_KEY = {};
DwtDialog.MSG_KEY[DwtDialog.CANCEL_BUTTON] 	= "cancel";
DwtDialog.MSG_KEY[DwtDialog.OK_BUTTON] 		= "ok";
DwtDialog.MSG_KEY[DwtDialog.DISMISS_BUTTON] = "close";
DwtDialog.MSG_KEY[DwtDialog.NO_BUTTON] 		= "no";
DwtDialog.MSG_KEY[DwtDialog.YES_BUTTON] 	= "yes";

DwtDialog.ALIGN = {};
DwtDialog.ALIGN[DwtDialog.CANCEL_BUTTON]	= DwtDialog.ALIGN_RIGHT;
DwtDialog.ALIGN[DwtDialog.OK_BUTTON] 		= DwtDialog.ALIGN_RIGHT;
DwtDialog.ALIGN[DwtDialog.DISMISS_BUTTON] 	= DwtDialog.ALIGN_RIGHT;
DwtDialog.ALIGN[DwtDialog.NO_BUTTON] 		= DwtDialog.ALIGN_RIGHT;
DwtDialog.ALIGN[DwtDialog.YES_BUTTON] 		= DwtDialog.ALIGN_RIGHT;

/**
 * Defines a "modeless" dialog.
 * 
 * @see	DwtBaseDialog.MODELESS
 */
DwtDialog.MODELESS = DwtBaseDialog.MODELESS;

/**
 * Defines a "modal" dialog.
 * 
 * @see	DwtBaseDialog.MODAL
 */
DwtDialog.MODAL = DwtBaseDialog.MODAL;

//
// Data
//
/**
 * @private
 */
DwtDialog.prototype.CONTROLS_TEMPLATE = "dwt.Widgets#DwtDialogControls";

//
// Public methods
//

DwtDialog.prototype.popdown =
function() {
	DwtBaseDialog.prototype.popdown.call(this);
	if (!this._disposeOnPopDown) {
		this.resetButtonStates();
	}
};

/**
 * This method will pop-up the dialog.
 * 
 * @param	{DwtPoint}	loc		the location
 * @param	{constant}	focusButtonId		the button Id
 */
DwtDialog.prototype.popup =
function(loc, focusButtonId) {
	this._focusButtonId = focusButtonId;
	DwtBaseDialog.prototype.popup.call(this, loc);
};

/**
 * @private
 */
DwtDialog.prototype._resetTabFocus =
function(){
	if (this._focusButtonId) {
		var focusButton = this.getButton(this._focusButtonId);
		this._tabGroup.setFocusMember(focusButton, true);
	} else {
		DwtBaseDialog.prototype._resetTabFocus.call(this);
	}
};

DwtDialog.prototype.reset =
function() {
	this._resetCallbacks();
	this.resetButtonStates();
	DwtBaseDialog.prototype.reset.call(this);
};

/**
 * Sets all buttons back to inactive state.
 * 
 */
DwtDialog.prototype.resetButtonStates =
function() {
	for (b in this._button) {
		this._button[b].setEnabled(true);
		this._button[b].setHovered(false);
	}
	this.associateEnterWithButton(this._initialEnterButtonId);
};

/**
 * Gets a button by the specified Id.
 * 
 * @param	{constant}		buttonId		the button Id
 * @return	{DwtButton}		the button or <code>null</code> if not found
 */
DwtDialog.prototype.getButton =
function(buttonId) {
	return this._button[buttonId];
};

/**
 * Sets the button enabled state.
 * 
 * @param	{constant}		buttonId		the button Id
 * @param	{boolean}		enabled		if <code>true</code>, enable the button; <code>false</code> otherwise
 */
DwtDialog.prototype.setButtonEnabled = 
function(buttonId, enabled) {
	if (!this._button[buttonId]) {
		return;
	}
	this._button[buttonId].setEnabled(enabled);
};

/**
 * Sets the button visible state.
 * 
 * @param	{constant}		buttonId		the button Id
 * @param	{boolean}		enabled		if <code>true</code>, make the button visible; <code>false</code> otherwise
 */
DwtDialog.prototype.setButtonVisible = 
function(buttonId, visible) {
	if (!this._button[buttonId]) {
		return;
	}
	this._button[buttonId].setVisible(visible);
};

/**
 * Gets the button enabled state.
 * 
 * @param	{constant}		buttonId		the button Id
 * @return	{boolean}	<code>true</code> if the button is enabled; <code>false</code> otherwise
 */
DwtDialog.prototype.getButtonEnabled = 
function(buttonId) {
	return this._button[buttonId].getEnabled();
};

/**
 * Registers a callback for a given button. Can be passed an AjxCallback,
 * the params needed to create one, or as a bound function.
 *
 * @param {constant}		buttonId	one of the standard dialog buttons
 * @param {AjxCallback}	func		the callback method
 * @param {Object}		obj			the callback object
 * @param {array}		args		the callback args
 */
DwtDialog.prototype.registerCallback =
function(buttonId, func, obj, args) {
	this._buttonDesc[buttonId].callback = (func && (func.isAjxCallback || (!obj && !args))) ? func : (new AjxCallback(obj, func, args));
};

/**
 * Unregisters a callback for a given button.
 *
 * @param {constant}		buttonId	one of the standard dialog buttons
 */
DwtDialog.prototype.unregisterCallback =
function(buttonId) {
	this._buttonDesc[buttonId].callback = null;
};

/**
 * Sets the given listener as the only listener for the given button.
 *
 * @param {constant}		buttonId	one of the standard dialog buttons
 * @param {AjxListener}			listener	a listener
 */
DwtDialog.prototype.setButtonListener =
function(buttonId, listener) {
	this._button[buttonId].removeSelectionListeners();
	this._button[buttonId].addSelectionListener(listener);
};

/**
 * Sets the enter key listener.
 * 
 * @param	{AjxListener}	listener	a listener
 */
DwtDialog.prototype.setEnterListener =
function(listener) {
	this.removeAllListeners(DwtEvent.ENTER);
	this.addEnterListener(listener);
};

/**
 * Associates the "enter" key with a given button.
 * 
 * @param {constant}		buttonId	one of the standard dialog buttons
 */
DwtDialog.prototype.associateEnterWithButton =
function(id) {
	this._enterButtonId = id;
};

DwtDialog.prototype.getKeyMapName = 
function() {
	return DwtKeyMap.MAP_DIALOG;
};

DwtDialog.prototype.handleKeyAction =
function(actionCode, ev) {
	switch (actionCode) {
		
		case DwtKeyMap.ENTER:
			this.notifyListeners(DwtEvent.ENTER, ev);
			break;
			
		case DwtKeyMap.CANCEL:
			// hitting ESC should act as a cancel
            //TODO: dialog should set ESC/Enter listeners so we don't have to guess the action to take
			var handled = false;
			handled = handled || this._runCallbackForButtonId(DwtDialog.CANCEL_BUTTON);
			handled = handled || this._runCallbackForButtonId(DwtDialog.NO_BUTTON);
			handled = handled || this._runCallbackForButtonId(DwtDialog.DISMISS_BUTTON);

            //don't let OK act as cancel if there are other buttons
            if (!handled && this._buttonDesc[DwtDialog.OK_BUTTON] && this._buttonList.length == 1) {
                handled = handled || this._runCallbackForButtonId(DwtDialog.OK_BUTTON);
            }
            this.popdown();
			return true;

		case DwtKeyMap.YES:
			if (this._buttonDesc[DwtDialog.YES_BUTTON]) {
				this._runCallbackForButtonId(DwtDialog.YES_BUTTON);
			}
			break;

		case DwtKeyMap.NO:
			if (this._buttonDesc[DwtDialog.NO_BUTTON]) {
				this._runCallbackForButtonId(DwtDialog.NO_BUTTON);
			}
			break;

		default:
			return false;
	}
	return true;
};

//
// Protected methods
//

/**
 * @private
 */
DwtDialog.prototype._createHtmlFromTemplate =
function(templateId, data) {
	DwtBaseDialog.prototype._createHtmlFromTemplate.call(this, templateId, data);

	var focusId = data.id+"_focus";
	if (document.getElementById(focusId)) {
		this._focusElementId = focusId;
	}
	this._buttonsEl = document.getElementById(data.id+"_buttons");
	if (this._buttonsEl) {
		var html = [];
		var idx = 0;
		this._addButtonsHtml(html,idx);
		this._buttonsEl.innerHTML = html.join("");
	}
};

// TODO: Get rid of these button template methods!
/**
 * @private
 */
DwtDialog.prototype._getButtonsContainerStartTemplate =
function () {
	return "<table role='presentation' width='100%'><tr>";
};

/**
 * @private
 */
DwtDialog.prototype._getButtonsAlignStartTemplate =
function () {
	return "<td align=\"{0}\"><table role='presentation'><tr>";
};

/**
 * @private
 */
DwtDialog.prototype._getButtonsAlignEndTemplate =
function () {
	return "</tr></table></td>";
};

/**
 * @private
 */
DwtDialog.prototype._getButtonsCellTemplate =
function () {
	return "<td id=\"{0}\"></td>";
};

/**
 * @private
 */
DwtDialog.prototype._getButtonsContainerEndTemplate =
function () {
	return  "</tr></table>";
};

/**
 * @private
 */
DwtDialog.prototype._addButtonsHtml =
function(html, idx) {
	if (this._buttonList && this._buttonList.length) {
		var leftButtons = new Array();
		var rightButtons = new Array();
		var centerButtons = new Array();
		for (var i = 0; i < this._buttonList.length; i++) {
			var buttonId = this._buttonList[i];
			switch (this._buttonDesc[buttonId].align) {
				case DwtDialog.ALIGN_RIGHT: 	rightButtons.push(buttonId); break;
				case DwtDialog.ALIGN_LEFT: 		leftButtons.push(buttonId); break;
				case DwtDialog.ALIGN_CENTER:	centerButtons.push(buttonId); break;
			}
		}
		html[idx++] = this._getButtonsContainerStartTemplate();
		
		if (leftButtons.length) {
			html[idx++] = AjxMessageFormat.format(
								  this._getButtonsAlignStartTemplate(),
								  ["left"]);
			for (var i = 0; i < leftButtons.length; i++) {
				var buttonId = leftButtons[i];
				var cellTemplate = this._buttonDesc[buttonId].cellTemplate ? 
					this._buttonDesc[buttonId].cellTemplate : this._getButtonsCellTemplate();
		 		html[idx++] = AjxMessageFormat.format(
								  cellTemplate,
								  [this._buttonElementId[buttonId]]);
		 	}
			html[idx++] = this._getButtonsAlignEndTemplate();
		}
		if (centerButtons.length){
			html[idx++] = AjxMessageFormat.format(
								this._getButtonsAlignStartTemplate(),
								["center"]);
			for (var i = 0; i < centerButtons.length; i++) {
				var buttonId = centerButtons[i];
				var cellTemplate = this._buttonDesc[buttonId].cellTemplate ? 
					this._buttonDesc[buttonId].cellTemplate : this._getButtonsCellTemplate();				
		 		html[idx++] = AjxMessageFormat.format(
								cellTemplate,
								[this._buttonElementId[buttonId]]);
		 	}
			html[idx++] = this._getButtonsAlignEndTemplate();
		}
		if (rightButtons.length) {
			html[idx++] = AjxMessageFormat.format(
								this._getButtonsAlignStartTemplate(),
								["right"]);
			for (var i = 0; i < rightButtons.length; i++) {
				var buttonId = rightButtons[i];
				var cellTemplate = this._buttonDesc[buttonId].cellTemplate ? 
					this._buttonDesc[buttonId].cellTemplate : this._getButtonsCellTemplate();				

		 		html[idx++] = AjxMessageFormat.format(cellTemplate,
													[this._buttonElementId[buttonId]]);
		 	}
			html[idx++] = this._getButtonsAlignEndTemplate();
		}
		html[idx++] = this._getButtonsContainerEndTemplate();
	}	
	return idx;
};

/**
 * Button listener that checks for callbacks.
 * 
 * @private
 */
DwtDialog.prototype._buttonListener =
function(ev, args) {
	var obj = DwtControl.getTargetControl(ev);
	var buttonId = (obj && obj.buttonId) || this._enterButtonId;
	if (buttonId) {
		this._runCallbackForButtonId(buttonId, args);
	}
};

/**
 * @private
 */
DwtDialog.prototype._runCallbackForButtonId =
function(id, args) {
	var buttonDesc = this._buttonDesc[id];
	var callback = buttonDesc && buttonDesc.callback;
	if (!callback) {
		return false;
	}
	args = (args instanceof Array) ? args : [args];
	callback.run.apply(callback, args);
	return true;
};

/**
 * @private
 */
DwtDialog.prototype._runEnterCallback =
function(args) {
	if (this._enterButtonId && this.getButtonEnabled(this._enterButtonId)) {
		this._runCallbackForButtonId(this._enterButtonId, args);
	}
};

/**
 * Default callbacks for the standard buttons.
 * 
 * @private
 */
DwtDialog.prototype._resetCallbacks =
function() {
	if (this._buttonDesc) {
		for (var i = 0; i < DwtDialog.ALL_BUTTONS.length; i++) {
			var id = DwtDialog.ALL_BUTTONS[i];
			if (this._buttonDesc[id])
				this._buttonDesc[id].callback = new AjxCallback(this, this.popdown);
		}
	}
};

//
// Classes
//

/**
 * @class
 * This class represents a button descriptor.
 * 
 * @param	{string}	id		the button Id
 * @param	{string}	label		the button label
 * @param	{constant}	align		the alignment
 * @param	{AjxCallback}	callback		the callback
 * @param	{string}	cellTemplate		the template
 */
DwtDialog_ButtonDescriptor = function(id, label, align, callback, cellTemplate) {
	this.id = id;
	this.label = label;
	this.align = align;
	this.callback = callback;
	this.cellTemplate = cellTemplate;
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtLabel")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * @overview
 * This file defines a label.
 *
 */

/**
 * Creates a label.
 * @constructor
 * @class
 * This class represents a label, which consists of an image and/or text. It is used
 * both as a concrete class and as the base class for {@link DwtButton}. The label
 * components are managed within a table. The label can be enabled or disabled, which are reflected in 
 * its display. A disabled label looks greyed out.
 * 
 * <h4>CSS</h4>
 * <ul>
 * <li><code>.className table</code> - the label table</li>
 * <li><code>.className .Icon</code> - class name for the icon image cell</li>
 * <li><code>.className .Text</code> - enabled text cell</li>
 * <li><code>.className .DisabledText</code> - disabled text cell</li>
 * </ul>
 * 
 * <h4>Keyboard Actions</h4>
 * None
 * 
 * <h4>Events</h4>
 * None
 * 
 * @author Ross Dargahi
 * 
 * @param {hash}		params		the hash of parameters
 * @param	{DwtComposite}	params.parent	the parent widget
 * @param	{constant}	params.style		the label style: May be one of: {@link DwtLabel.IMAGE_LEFT} 
 * 											or {@link DwtLabel.IMAGE_RIGHT} arithmetically or'd (|) with  one of:
 * 											{@link DwtLabel.ALIGN_LEFT}, {@link DwtLabel.ALIGN_CENTER}, or {@link DwtLabel.ALIGN_LEFT}
 * 											The first determines were in the label the icon will appear (if one is set), the second
 * 											determine how the content of the label will be aligned. The default value for
 * 											this parameter is: {@link DwtLabel.IMAGE_LEFT} | {@link DwtLabel.ALIGN_CENTER}
 * @param	{string}	params.className	the CSS class
 * @param	{constant}	params.posStyle		the positioning style (see {@link DwtControl})
 * @param	{string}	params.id			the to use for the control HTML element
 * @param	{number}	params.index 		the index at which to add this control among parent's children
 *        
 * @extends DwtComposite
 */
DwtLabel = function(params) {
	if (arguments.length == 0) { return; }
	params = Dwt.getParams(arguments, DwtLabel.PARAMS);
	
	params.className = params.className || "DwtLabel";
	DwtComposite.call(this, params);

	/**
	 * The label style. See the constructor for more info.
	 */
	this._style = params.style || (DwtLabel.IMAGE_LEFT | DwtLabel.ALIGN_CENTER);
	
	/**
	 * The label text background color.
	 */
	this._textBackground = null;
	
	/**
	 * The label text foreground color.
	 */
	this._textForeground = null;

    this._createHtml(params.template);
    //MOW:  this.setCursor("default");
}

DwtLabel.PARAMS = ["parent", "style", "className", "posStyle", "id", "index"];

DwtLabel.prototype = new DwtComposite;
DwtLabel.prototype.constructor = DwtLabel;

DwtLabel.prototype.isFocusable = true;

/**
 * Returns a string representation of the object.
 * 
 * @return		{string}		a string representation of the object
 */
DwtLabel.prototype.toString =
function() {
	return "DwtLabel";
}

//
// Constants
//

// display styles
/**
 * Defines the "left" align image (i.e. align to the left of text, if both present).
 */
DwtLabel.IMAGE_LEFT = 1;

/**
 * Defines the "right" align image (i.e. align to the right of text, if both present).
 */
DwtLabel.IMAGE_RIGHT = 2;

/**
 * Defines both "right" and "left" align images (i.e. align to the left and to the right of text, if all present).
 */
DwtLabel.IMAGE_BOTH = 4;

/**
 * Defines the "left" align label.
 */
DwtLabel.ALIGN_LEFT = 8;

/**
 * Defines the "right" align label.
 */
DwtLabel.ALIGN_RIGHT = 16;

/**
 * Defines the "center" align label.
 */
DwtLabel.ALIGN_CENTER = 32;

/**
 * Defines the last style label (used for subclasses).
 * @private
 */
DwtLabel._LAST_STYLE = 32;

/**
 * Defines the "left" side icon
 */
DwtLabel.LEFT = "left";

/**
 * Defines the "right" side icon
 */
DwtLabel.RIGHT = "right";

//
// Data
//

DwtLabel.prototype.TEMPLATE = "dwt.Widgets#ZLabel";

//
// Public methods
//

/**
 * Disposes of the label.
 * 
 */
DwtLabel.prototype.dispose =
function() {
	delete this._dropDownEl;
	delete this._iconEl;
	delete this._textEl;
	DwtControl.prototype.dispose.call(this);
};

/**
 * Sets the enabled/disabled state of the label. A disabled label may have a different
 * image, and greyed out text. This method overrides {@link DwtControl#setEnabled}.
 *
 * @param {boolean} enabled 		if <code>true</code>, set the label as enabled
 */
DwtLabel.prototype.setEnabled =
function(enabled) {
	if (enabled != this._enabled) {
		DwtControl.prototype.setEnabled.call(this, enabled);
		var direction = this._style & DwtLabel.IMAGE_RIGHT ? DwtLabel.RIGHT : DwtLabel.LEFT;
		this.__imageInfo = this.__imageInfo || {};
		this.__setImage(this.__imageInfo[direction]);
	}
}

/**
 * Gets the current image info.
 *
 * @param	{string}	direction		position of the image
 *
 * @return	{string}	the image info
 */
DwtLabel.prototype.getImage =
function(direction) {
	direction = direction || (this._style & DwtLabel.IMAGE_RIGHT ? DwtLabel.RIGHT : DwtLabel.LEFT);
	return this.__imageInfo[direction];
}

/**
 * Sets the main (enabled) image. If the label is currently enabled, the image is updated.
 *
 * @param	{string}	imageInfo		the image
 * @param	{string}	direction		position of the image
 * @param	{string}	altText			alternate text for non-visual users
 */
DwtLabel.prototype.setImage =
function(imageInfo, direction, altText) {
	direction = direction || (this._style & DwtLabel.IMAGE_RIGHT ? DwtLabel.RIGHT : DwtLabel.LEFT);
	this.__imageInfo = this.__imageInfo || {};
	this.__imageInfo[direction] = imageInfo;
	this.__setImage(imageInfo, direction, altText);
}

/**
 *
 * Set _iconEl, used for buttons that contains only images
 *
 * @param	htmlElement/DOM node
 * @param	{string}				direction		position of the image
 *
 */
DwtLabel.prototype.setIconEl = function(iconElement, direction) {
	this._iconEl = this._iconEl || {};
	direction = direction || (this._style & DwtLabel.IMAGE_RIGHT ? DwtLabel.RIGHT : DwtLabel.LEFT);
	this._iconEl[direction] =  iconElement;
}

/**
 * Sets the disabled image. If the label is currently disabled, its image is updated.
 *
 * @param	{string}	imageInfo		the image
 * @deprecated		no longer support different images for disabled
 * @see		#setImage
 */
DwtLabel.prototype.setDisabledImage =
function(imageInfo) {
	// DEPRECATED -- we no longer support different images for disabled.
	//	See __setImage() for details.
}

/**
 * Gets the label text.
 * 
 * @return	{string}	the text or <code>null</code> if not set
 */
DwtLabel.prototype.getText =
function() {
	return (this.__text != null) ? this.__text : null;
}

/**
* Sets the label text, and manages the placement and display.
*
* @param {string}	text	the new label text
*/
DwtLabel.prototype.setText = function(text) {

    if (!this._textEl) {
	    return;
    }

    if (text == null || text == "") {
        this.__text = null;
        this._textEl.innerHTML = "";
    }
    else {
		this.__text = text;
        this._textEl.innerHTML = text;
    }

	this._textSet(text);
};

/**
 * Sets the text background.
 * 
 * @param	{string}	color	the background color
 */
DwtLabel.prototype.setTextBackground =
function(color) {
	this._textBackground = color;
    if (this._textEl) {
        this._textEl.style.backgroundColor = color;
    }
}

/**
 * Sets the text foreground.
 * 
 * @param	{string}	color	the foreground color
 */
DwtLabel.prototype.setTextForeground =
function(color) {
	this._textForeground = color;
    if (this._textEl) {
		this._textEl.style.color = color;
    }
}

/**
 * Sets the align style.
 * 
 * @param		{constant}		alignStyle		the align style (see {@link DwtControl})
 */
DwtLabel.prototype.setAlign =
function(alignStyle) {
	this._style = alignStyle;

	// reset dom since alignment style may have changed
	var direction = this._style & DwtLabel.IMAGE_RIGHT ? DwtLabel.RIGHT : DwtLabel.LEFT;
	this.__imageInfo = this.__imageInfo || {};
    this.__setImage(this.__imageInfo[direction]);
}

/**
 * Checks if the given style is set as the current label style.
 * 
 * @param	{constant}	style	the style
 * @return	{boolean}	<code>true</code> if the style is set
 */
DwtLabel.prototype.isStyle = function(style) {
    return this._style & style;
};

DwtLabel.prototype.getTabGroupMember =
function() {
	// DwtLabel descends from DwtComposite, as some buttons contain nested
	// members; it's a widget, however, and should be directly focusable
	return DwtControl.prototype.getTabGroupMember.apply(this, arguments);
}

//
// Protected methods
//

/**
 * @private
 */
DwtLabel.prototype._createHtml = function(templateId) {
    var data = { id: this._htmlElId };
    this._createHtmlFromTemplate(templateId || this.TEMPLATE, data);
};

/**
 * @private
 */
DwtLabel.prototype._createHtmlFromTemplate = function(templateId, data) {
    DwtControl.prototype._createHtmlFromTemplate.call(this, templateId, data);
    this._textEl = document.getElementById(data.id+"_title");
};

/**
 * @private
 *
 * @param	{string}	direction		position of the image
 */
DwtLabel.prototype._getIconEl = function(direction) {
    var _dir = this._style & DwtLabel.IMAGE_RIGHT ? DwtLabel.RIGHT : DwtLabel.LEFT;
    direction = typeof direction === 'boolean' ? _dir : (direction || _dir);    // fix for Bug 90130
	// MOW: getting the proper icon element on demand rather than all the time for speed
	this._iconEl = this._iconEl || {};
	return this._iconEl[direction] ||
		(this._iconEl[direction] = document.getElementById(this._htmlElId+"_"+direction+"_icon"));
};

//
// Private methods
//

/**
 * Set the label's image, and manage its placement.
 *
 * @private
 *
 * @param	{string}	imageInfo		the image
 * @param	{string}	direction		position of the image
 * @param	{string}	altText			alternate text for non-visual users
 */
DwtLabel.prototype.__setImage =
function(imageInfo, direction, altText) {
	this.__altText = altText || this.__altText;

	var iconEl = this._getIconEl(direction);
	if (iconEl) {
		if (imageInfo) {
			AjxImg.setImage(iconEl, imageInfo, null, !this._enabled, null, this.__altText);

			// set a ZHasRightIcon or ZHasLeftIcon on the outer element, depending on which we set
			var elementClass = (this._style & DwtLabel.IMAGE_RIGHT ? "ZHasRightIcon" : "ZHasLeftIcon");
			Dwt.addClass(this.getHtmlElement(), elementClass);
		} else {
			iconEl.innerHTML = "";
		}
	}
};

// Accessibility
DwtLabel.prototype._textSet = function(text) {

	// assign the ARIA label directly; we want it to override the tooltip, if any
	if (!this.hasAttribute('aria-labelledby')) {
		if (text) {
			this.setAttribute('aria-label', text);
		} else {
			this.removeAttribute('aria-label');
		}
	}
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtCheckbox")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * Creates a checkbox.
 * @constructor
 * @class
 * This class represents a checkbox.
 * 
 * @param {hash}	params	a hash of parameters
 * @param {DwtComposite}	params.parent	the parent widget
 * @param {DwtCheckbox.TEXT_LEFT|DwtCheckbox.TEXT_RIGHT}       [params.style=DwtCheckbox.TEXT_RIGHT] 	the text style
 * @param {string}       params.name		the input control name (required for IE)
 * @param {string}       params.value     the input control value
 * @param {boolean}       params.checked	the input control checked status (required for IE)
 * @param {string}       params.className	the CSS class
 * @param {constant}       params.posStyle	the positioning style (see {@link Dwt})
 * @param {string}       params.id		an explicit ID to use for the control's HTML element
 * @param {number}       params.index 	the index at which to add this control among parent's children
 * 
 *  @extends		DwtControl
 */
DwtCheckbox = function(params) {
	if (arguments.length == 0) { return; }

	params = Dwt.getParams(arguments, DwtCheckbox.PARAMS);
	params.className = params.className || "DwtCheckbox";

	DwtControl.call(this, params);

	this._textPosition = DwtCheckbox.DEFAULT_POSITION;
	this._initName = params.name;
    this._initValue = params.value;
	this._createHtml();

	this.setSelected(params.checked);
};

DwtCheckbox.prototype = new DwtControl;
DwtCheckbox.prototype.constructor = DwtCheckbox;

DwtCheckbox.prototype.isDwtCheckbox = true;
DwtCheckbox.prototype.isInputControl = true;
DwtCheckbox.prototype.toString = function() { return "DwtCheckbox"; };

//
// Constants
//
DwtCheckbox.PARAMS = [
	"parent",
	"style",
	"name",
	"checked",
	"className",
	"posStyle",
	"id",
	"index",
    "value"
];
/**
 * Defines the "left" text style position.
 */
DwtCheckbox.TEXT_LEFT			= "left";
/**
 * Defines the "right" text style position.
 */
DwtCheckbox.TEXT_RIGHT			= "right";
/**
 * Defines the default text style position.
 */
DwtCheckbox.DEFAULT_POSITION	= DwtCheckbox.TEXT_RIGHT;

//
// Data
//
DwtCheckbox.prototype.TEMPLATE = "dwt.Widgets#DwtCheckbox";

DwtCheckbox.prototype.INPUT_TYPE = 'checkbox';

//
// Public methods
//
DwtCheckbox.prototype.getInputElement =
function() {
	return this._inputEl;
};

DwtCheckbox.prototype._focus =
function() {
	Dwt.addClass(this.getHtmlElement(), DwtControl.FOCUSED);
};

DwtCheckbox.prototype._blur =
function() {
	Dwt.delClass(this.getHtmlElement(), DwtControl.FOCUSED);
};

// listeners

/**
 * Adds a selection listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
DwtCheckbox.prototype.addSelectionListener =
function(listener) {
	this.addListener(DwtEvent.SELECTION, listener);
};

/**
 * Removes a selection listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
DwtCheckbox.prototype.removeSelectionListener =
function(listener) {
	this.removeListener(DwtEvent.SELECTION, listener);
};

// properties

/**
 * Sets the enabled state.
 * 
 * @param	{boolean}	enabled		if <code>true</code>, the checkbox is enabled
 */
DwtCheckbox.prototype.setEnabled =
function(enabled) {
	if (enabled != this._enabled) {
		DwtControl.prototype.setEnabled.call(this, enabled);
		this._inputEl.disabled = !enabled;
		var className = enabled ? "Text" : "DisabledText";
		if (this._textElLeft) this._textElLeft.className = className;
		if (this._textElRight) this._textElRight.className = className;
	}
};

/**
 * Sets the selected state.
 * 
 * @param	{boolean}	selected		if <code>true</code>, the checkbox is selected
 */
DwtCheckbox.prototype.setSelected =
function(selected) {
	if (this._inputEl && this._inputEl.checked != selected) {
		this._inputEl.checked = selected;
	}
};

/**
 * Checks if the checkbox is selected state.
 * 
 * @return	{boolean}	<code>true</code> if the checkbox is selected
 */
DwtCheckbox.prototype.isSelected =
function() {
	return this._inputEl && this._inputEl.checked;
};

/**
 * Sets the checkbox text.
 * 
 * @param		{string}	text		the text
 */
DwtCheckbox.prototype.setText =
function(text) {
	if (this._textEl && this._text != text) {
		this._text = text;
		this._textEl.innerHTML = text || "";
	}
};

/**
 * Gets the checkbox text.
 * 
 * @return	{string}	the text
 */
DwtCheckbox.prototype.getText =
function() {
	return this._text;
};

/**
 * Sets the text position.
 * 
 * @param	{DwtCheckbox.TEXT_LEFT|DwtCheckbox.TEXT_RIGHT}		position	the position
 */
DwtCheckbox.prototype.setTextPosition =
function(position) {
	this._textEl = position == DwtCheckbox.TEXT_LEFT ? this._textElLeft : this._textElRight;
	if (this._textPosition != position) {
		this._textPosition = position;
		if (this._textElLeft) this._textElLeft.innerHTML = "";
		if (this._textElRight) this._textElRight.innerHTML = "";
		this.setText(this._text);
	}
};

/**
 * Gets the text position.
 * 
 * @return	{DwtCheckbox.TEXT_LEFT|DwtCheckbox.TEXT_RIGHT}		the position
 */
DwtCheckbox.prototype.getTextPosition =
function() {
	return this._textPosition;
};

/**
 * Sets the value.
 * 
 * @param	{string}		value		the value
 */
DwtCheckbox.prototype.setValue =
function(value) {
    var object = this._inputEl || this;
	if (object.value !== value) {
        object.value = value;
    }
};

/**
 * Gets the value.
 * 
 * @return		{string}		the value
 */
DwtCheckbox.prototype.getValue =
function() {
    var object = this._inputEl || this;
	return object.value != null ? object.value : this.getText();
};

/**
 * Gets the input element.
 * 
 * @return		{Element}		the element
 */
DwtCheckbox.prototype.getInputElement =
function() {
	return this._inputEl;
};

//
// DwtControl methods
//

DwtCheckbox.prototype.setToolTipContent = function(content) {
    if (content && !this.__mouseEventsSet) {
        // NOTE: We need mouse events in order to initiate tooltips on hover.
        // TODO: This should be done transparently in DwtControl for all
        // TODO: controls with tooltips.
        this.__mouseEventsSet = true;
        this._setMouseEvents();
    }
    DwtControl.prototype.setToolTipContent.apply(this, arguments);
};

//
// Protected methods
//

/**
 * The input field inherits the id for accessibility purposes.
 * 
 * @private
 */
DwtCheckbox.prototype._replaceElementHook =
function(oel, nel, inheritClass, inheritStyle) {
	nel = this.getInputElement();
	DwtControl.prototype._replaceElementHook.call(this, oel, nel, inheritClass, inheritStyle);
	if (oel.id) {
		this.setHtmlElementId(oel.id+"_control");
		nel.id = oel.id;
		if (this._textEl) {
			this._textEl.setAttribute(AjxEnv.isIE ? "htmlFor" : "for", oel.id);
		}
	}
};

//
// Private methods
//

DwtCheckbox.prototype._createHtml =
function(templateId) {
	var data = { id: this._htmlElId };
	this._createHtmlFromTemplate(templateId || this.TEMPLATE, data);
};

DwtCheckbox.prototype._createHtmlFromTemplate =
function(templateId, data) {
	// NOTE: If  you don't set the name and checked status when
	//       creating checkboxes and radio buttons on IE, they will
	//       not take the first programmatic value. So we pass in
	//       the init values from the constructor.
	data.name = this._initName || this._htmlElId;
    data.value = this._initValue;
	data.type = this.INPUT_TYPE;
	DwtControl.prototype._createHtmlFromTemplate.call(this, templateId, data);
	this._inputEl = document.getElementById(data.id+"_input");
	if (this._inputEl) {
		var keyboardMgr = DwtShell.getShell(window).getKeyboardMgr();
		var handleFocus = AjxCallback.simpleClosure(keyboardMgr.grabFocus, keyboardMgr, this.getInputElement());
		Dwt.setHandler(this._inputEl, DwtEvent.ONFOCUS, handleFocus);
		Dwt.setHandler(this._inputEl, DwtEvent.ONCLICK, DwtCheckbox.__handleClick);
		this.setFocusElement();
	}
	this._textElLeft = document.getElementById(data.id+"_text_left");
	this._textElRight = document.getElementById(data.id+"_text_right");
	this.setTextPosition(this._textPosition);
};

//
// Private functions
//

DwtCheckbox.__handleClick =
function(evt) {
	var event = DwtUiEvent.getEvent(evt);
	var target = DwtUiEvent.getTarget(event);

	var selEv = DwtShell.selectionEvent;
	DwtUiEvent.copy(selEv, event);
	selEv.item = this;
	selEv.detail = target.checked;

	var checkbox = DwtControl.findControl(target);
	checkbox.setSelected(target.checked);
	checkbox.focus();
	checkbox.notifyListeners(DwtEvent.SELECTION, selEv);
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtRadioButton")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * Creates a radio button.
 * @constructor
 * @class
 * This class implements a radio button.
 * 
 * @param {hash}	params	a hash of parameters
 * @param  {DwtComposite}     params.parent	the parent widget
 * @param  {constant}     params.style 	the text style. May be one of: {@link DwtCheckbox.TEXT_LEFT} or
 * 									{@link DwtCheckbox.TEXT_RIGHT} arithimatically or'd (|) with one of:
 * 									{@link DwtCheckbox.ALIGN_LEFT}, {@link DwtCheckbox.ALIGN_CENTER}, or
 * 									{@link DwtCheckbox.ALIGN_LEFT}.
 * 									The first determines were in the checkbox the text will appear
 * 									(if set), the second determine how the content of the text will be
 * 									aligned. The default value for this parameter is: 
 * 									{@link DwtCheckbox.TEXT_LEFT} | {@link DwtCheckbox.ALIGN_CENTER}
 * @param  {string}     params.name		the input control name (required for IE)
 * @param  {string}     params.value     the input control value.
 * @param  {boolean}     params.checked	the input control checked status (required for IE)
 * @param  {string}     params.className	the CSS class
 * @param  {constant}     params.posStyle	the positioning style (see {@link DwtControl})
 * @param  {string}     params.id		an explicit ID to use for the control's HTML element
 * @param  {number}     params.index 	the index at which to add this control among parent's children
 * 
 * @extends	DwtCheckbox
 */
DwtRadioButton = function(params) {
	if (arguments.length == 0) { return; }
	params = Dwt.getParams(arguments, DwtRadioButton.PARAMS);
	params.className = params.className || "DwtRadioButton";
	DwtCheckbox.call(this, params);
}

DwtRadioButton.PARAMS = DwtCheckbox.PARAMS;

DwtRadioButton.prototype = new DwtCheckbox;
DwtRadioButton.prototype.constructor = DwtRadioButton;

DwtRadioButton.prototype.isDwtRadioButton = true;
DwtRadioButton.prototype.isInputControl = true;
DwtRadioButton.prototype.toString = function() { return "DwtRadioButton"; };

//
// Data
//

DwtRadioButton.prototype.INPUT_TYPE = 'radio';
}
if (AjxPackage.define("ajax.dwt.widgets.DwtListView")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * Creates a list view.
 * @constructor
 * @class
 * A list view presents a list of items as rows with fields (columns).
 * 
 * @author Parag Shah
 * @author Conrad Damon
 * 
 * @param {hash}	params		a hash of parameters
 * @param  {DwtComposite}     parent		the parent widget
 * @param {string}	className		the CSS class
 * @param {constant}	posStyle		the positioning style (see {@link DwtControl})
 * @param  {array}	headerList	a list of IDs for columns
 * @param {boolean}	noMaximize	if <code>true</code>, all columns are fixed-width (otherwise, one will
 * 											expand to fill available space)
 * @param  {constant}     view			the ID of view
 * 
 * @extends		DwtComposite
 */
DwtListView = function(params) {
	if (arguments.length == 0) { return; }
	params = Dwt.getParams(arguments, DwtListView.PARAMS);
	params.className = params.className || "DwtListView";
	DwtComposite.call(this, params);

	this._view = params.view || Dwt.getNextId();
	if (params.headerList) {
		var htmlElement = this.getHtmlElement();

        var html = new Array(50);
        var idx = 0;
        var headId = Dwt.getNextId();
        var colId = Dwt.getNextId();
        html[idx++] = "<table width='100%'><tr><td ";
        html[idx++] = "id=" + headId;
        html[idx++] = "></td></tr><tr><td ";
        html[idx++] = "id=" + colId;
        html[idx++] = "></td></tr></table>";
        htmlElement.innerHTML = html.join("");

        var headHtml = document.getElementById(headId);
        this._listColDiv = document.createElement("div");
        this._listColDiv.id = DwtId.getListViewId(this._view, DwtId.LIST_VIEW_HEADERS);
        headHtml.appendChild(this._listColDiv);

        var colHtml = document.getElementById(colId);
        this._listDiv = this.useListElement() ? document.createElement("ul") : document.createElement("div");
        this._listDiv.id = DwtId.getListViewId(this._view, DwtId.LIST_VIEW_ROWS);
        this._listDiv.className = "DwtListView-Rows";
        colHtml.appendChild(this._listDiv);

		// setup vars needed for sorting
		this._bSortAsc = false;
		this._currentColId = null;
		this.sortingEnabled = true;
	} else {
		this._listDiv = document.getElementById(params.id);
		this.setScrollStyle(DwtControl.SCROLL); // auto scroll
	}

	this._setMouseEventHdlrs();
	
	this._listenerMouseOver = this._mouseOverListener.bind(this);
	this._listenerMouseOut = this._mouseOutListener.bind(this);
	this._listenerMouseDown = this._mouseDownListener.bind(this);
	this._listenerMouseUp = this._mouseUpListener.bind(this);
	this._listenerMouseMove = this._mouseMoveListener.bind(this);
	this._listenerDoubleClick = this._doubleClickListener.bind(this);
	this.addListener(DwtEvent.ONMOUSEOVER, this._listenerMouseOver);
	this.addListener(DwtEvent.ONMOUSEOUT, this._listenerMouseOut);
	this.addListener(DwtEvent.ONMOUSEDOWN, this._listenerMouseDown);
	this.addListener(DwtEvent.ONMOUSEUP, this._listenerMouseUp);
	this.addListener(DwtEvent.ONMOUSEMOVE, this._listenerMouseMove);
	this.addListener(DwtEvent.ONDBLCLICK, this._listenerDoubleClick);

	this._evtMgr = new AjxEventMgr();
	this._selectedItems = new AjxVector();
	this._selAnchor = null; 
	this._kbAnchor = null; 
	this._selEv = new DwtSelectionEvent(true);
	this._actionEv = new DwtListViewActionEvent(true);
	this._stateChangeEv = new DwtEvent(true);
	this._headerList = params.headerList;
	this._noMaximize = params.noMaximize;
	if (this._headerList) {
		this._parentEl = this._listDiv;
	} else {
		this._parentEl = this.getHtmlElement();
		if (this.useListElement()) {
			//insert unordered list element
			var ul = document.createElement("ul");
			ul.className = "DwtListView-Rows";
			this._parentEl.appendChild(ul);
			this._parentEl = ul;
		}
	}
    this._parentEl.tabIndex = 0;

    this._list = null;
	this.offset = 0;
	this.headerColCreated = false;
	this.setMultiSelect(true);
	this.firstSelIndex = -1;

	// the key is the HTML ID of the item's associated DIV; the value is an object
	// with information about that row
	this._data = {};

    // item classes
    this._rowClass = [ this._className, DwtListView.ROW_CLASS ].join("");
	var nc = this._normalClass = DwtListView.ROW_CLASS;
	this._selectedClass = [nc, DwtCssStyle.SELECTED].join("-");
	this._viewedButUnselectedClass = [nc, DwtCssStyle.ALT_SELECTED].join("-");
	this._disabledSelectedClass = [this._selectedClass, DwtCssStyle.DISABLED].join("-");
	this._kbFocusClass = [nc, DwtCssStyle.FOCUSED].join("-");
	this._dndClass = [nc, DwtCssStyle.DRAG_PROXY].join("-");
	this._rightClickClass = [this._selectedClass, DwtCssStyle.ACTIONED].join("-");

    this._styleRe = this._getStyleRegex();
};

DwtListView.prototype = new DwtComposite;
DwtListView.prototype.constructor = DwtListView;

DwtListView.prototype.isDwtListView = true;
DwtListView.prototype.toString = function() { return "DwtListView"; };

DwtListView.prototype.role = 'list';
DwtListView.prototype.itemRole = 'listitem';

// Consts

DwtListView.PARAMS					= ["parent", "className", "posStyle", "headerList", "noMaximize"];
DwtListView.ITEM_SELECTED 			= 1;
DwtListView.ITEM_DESELECTED 		= 2;
DwtListView.ITEM_DBL_CLICKED 		= 3;
DwtListView._LAST_REASON 			= 3;
DwtListView._TOOLTIP_DELAY 			= 250;
DwtListView.HEADERITEM_HEIGHT 		= 24;
DwtListView.TYPE_HEADER_ITEM 		= "1";
DwtListView.TYPE_LIST_ITEM 			= "2";
DwtListView.TYPE_HEADER_SASH 		= "3";
DwtListView.DEFAULT_LIMIT			= 25;
DwtListView.MAX_REPLENISH_THRESHOLD	= 10;
DwtListView.MIN_COLUMN_WIDTH		= 20;
DwtListView.COL_MOVE_THRESHOLD		= 3;
DwtListView.ROW_CLASS				= "Row";
DwtListView.ROW_CLASS_ODD			= "RowEven";
DwtListView.ROW_CLASS_EVEN			= "RowOdd";

// property names for row DIV to store styles
DwtListView._STYLE_CLASS				= "_sc";
DwtListView._SELECTED_STYLE_CLASS		= "_ssc";
DwtListView._SELECTED_DIS_STYLE_CLASS	= "_sdsc";
DwtListView._KBFOCUS_CLASS				= "_kfc";


// Public methods


DwtListView.prototype.dispose =
function() {
	this._listColDiv = null;
	this._listDiv = null;
	this._parentEl = null;
	this._clickDiv = null;
	this._selectedItems = null;
	DwtComposite.prototype.dispose.call(this);
};

/**
 * Sets the enabled flag.
 * 
 * @param	{boolean}	enabled		if <code>true</code>, enable the list view
 */
DwtListView.prototype.setEnabled =
function(enabled) {
	DwtComposite.prototype.setEnabled.call(this, enabled);
	// always remove listeners to avoid adding listeners multiple times
	this.removeListener(DwtEvent.ONMOUSEOVER, this._listenerMouseOver);
	this.removeListener(DwtEvent.ONMOUSEOUT, this._listenerMouseOut);
	this.removeListener(DwtEvent.ONMOUSEDOWN, this._listenerMouseDown);
	this.removeListener(DwtEvent.ONMOUSEUP, this._listenerMouseUp);
	this.removeListener(DwtEvent.ONMOUSEMOVE, this._listenerMouseMove);
	this.removeListener(DwtEvent.ONDBLCLICK, this._listenerDoubleClick);
	// now re-add listeners, if needed
	if (enabled) {
		this.addListener(DwtEvent.ONMOUSEOVER, this._listenerMouseOver);
		this.addListener(DwtEvent.ONMOUSEOUT, this._listenerMouseOut);
		this.addListener(DwtEvent.ONMOUSEDOWN, this._listenerMouseDown);
		this.addListener(DwtEvent.ONMOUSEUP, this._listenerMouseUp);
		this.addListener(DwtEvent.ONMOUSEMOVE, this._listenerMouseMove);
		this.addListener(DwtEvent.ONDBLCLICK, this._listenerDoubleClick);
	}
	// modify selection classes
	var selection = this.getSelectedItems();
	if (selection) {
		var elements = selection.getArray();
        for (var i = 0; i < elements.length; i++) {
            Dwt.delClass(elements[i], this._styleRe, enabled ? this._selectedClass : this._disabledSelectedClass);
		}
	}
};

DwtListView.prototype.createHeaderHtml =
function(defaultColumnSort, isColumnHeaderTableFixed) {
	// does this list view have headers or have they already been created?
	if (!this._headerList || this.headerColCreated) { return; }

	this._headerHash = {};
	this._headerIdHash = {};

	var idx = 0;
	var htmlArr = [];

	htmlArr[idx++] = "<table id='";
	htmlArr[idx++] = DwtId.getListViewHdrId(DwtId.WIDGET_HDR_TABLE, this._view);
	htmlArr[idx++] = "' height=100%";
	htmlArr[idx++] = this._noMaximize ? ">" : " width=100%>";
	htmlArr[idx++] = "<tr>";

	var numCols = this._headerList.length;
	for (var i = 0; i < numCols; i++) {
		var headerCol = this._headerList[i];
		var field = headerCol._field;
		headerCol._index = i;
		var id = headerCol._id = DwtId.getListViewHdrId(DwtId.WIDGET_HDR, this._view, field);

		this._headerHash[field] = headerCol;
		this._headerIdHash[id] = headerCol;

		if (headerCol._variable) {
			this._variableHeaderCol = headerCol;
		}

		if (headerCol._visible) {
			idx = this._createHeader(htmlArr, idx, headerCol, i, numCols, id, defaultColumnSort);
		}
	}
	htmlArr[idx++] = "</tr></table>";

	this._listColDiv.innerHTML = htmlArr.join("");
	this._listColDiv.className = "DwtListView-ColHeader" + (isColumnHeaderTableFixed ? " FixedColumnHeaderTables" : "");

	setTimeout($.proxy(function() {
		//run this after the header is fully visible otherwise width will be inaccurate.
		//TODO run this as a callback after grid is visible instead of settimeout.
		for (var i = 0; i < numCols; i++) {
			//find the elements with width auto and create the styles for it.
			var headerCol = this._headerList[i];
			if (headerCol._cssClass && headerCol._resizeable && headerCol._width === 'auto') {
				this._createHeaderCssStyle(headerCol, this._calcRelativeWidth(i));
			}
		}
	}, this), 0);

	// for each sortable column, sets its identifier
	var numResizeable = 0, resizeableCol;
	for (var j = 0; j < this._headerList.length; j++) {
		var headerCol = this._headerList[j];
		var cell = document.getElementById(headerCol._id);
		if (!cell) { continue; }

		if (headerCol._sortable && headerCol._field == defaultColumnSort) {
			cell.className = "DwtListView-Column DwtListView-ColumnActive";
		}

		if (headerCol._resizeable) {
			// always get the sibling cell to the right
			var sashId = DwtId.getListViewHdrId(DwtId.WIDGET_HDR_SASH, this._view, headerCol._field);
			var sashCell = document.getElementById(sashId);
			if (sashCell) {
				this.associateItemWithElement(headerCol, sashCell, DwtListView.TYPE_HEADER_SASH, sashId, {index:j});
			}
			numResizeable++;
			resizeableCol = headerCol;
		}
		this.associateItemWithElement(headerCol, cell, DwtListView.TYPE_HEADER_ITEM, headerCol._id, {index:j});
	}

	if (numResizeable == 1) {
		resizeableCol._resizeable = false;
	}

	this.headerColCreated = true;
};

DwtListView.prototype._createHeader =
function(htmlArr, idx, headerCol, i, numCols, id, defaultColumnSort) {

	var field = headerCol._field;

	htmlArr[idx++] = "<td id='";
	htmlArr[idx++] = id;
	htmlArr[idx++] = "' class='";
    var tmpClass = (id == this._currentColId) ? "DwtListView-Column DwtListView-ColumnActive"
		: "DwtListView-Column";
    tmpClass += headerCol._sortable ? "" : " DwtDefaultCursor";
    htmlArr[idx++] = tmpClass + "'";
	if (headerCol._width) {
		htmlArr[idx++] = " width=";
		htmlArr[idx++] = headerCol._width;
		if (headerCol._cssClass && headerCol._resizeable && headerCol._width !== 'auto') {
			this._createHeaderCssStyle(headerCol, headerCol._width);
		}
		if (headerCol._widthUnits) {
			htmlArr[idx++] = headerCol._widthUnits;
		}
    }
	if (headerCol._tooltip && DwtControl.useBrowserTooltips) {
		htmlArr[idx++] = " title='" + headerCol._tooltip + "'";
	}
	htmlArr[idx++] = ">";
	// must add a div to force clipping :(
	htmlArr[idx++] = "<div";
	var headerColWidth = null;
	if (headerCol._width && headerCol._width != "auto") {
		headerColWidth = headerCol._width;
		if (headerCol._widthUnits) {
			headerColWidth += headerCol._widthUnits;
		}
	}
	if (!!headerColWidth) {
		htmlArr[idx++] = " style='overflow: hidden; width: ";
		htmlArr[idx++] = headerColWidth;
		htmlArr[idx++] = "'>";
	} else {
		htmlArr[idx++] = ">";
	}

	// add new table for icon/label/sorting arrow
	htmlArr[idx++] = "<table width=100%><tr>";
	if (headerCol._iconInfo) {
		var idText = ["id='", DwtId.getListViewHdrId(DwtId.WIDGET_HDR_ICON, this._view, field), "'"].join("");
		htmlArr[idx++] = "<td><center>";
		htmlArr[idx++] = AjxImg.getImageHtml(headerCol._iconInfo, null, idText);
		htmlArr[idx++] = "</center></td>";
	}

	if (headerCol._label) {
		htmlArr[idx++] = "<td id='";
		htmlArr[idx++] = DwtId.getListViewHdrId(DwtId.WIDGET_HDR_LABEL, this._view, field);
		htmlArr[idx++] = "' class='DwtListHeaderItem-label' style='padding-right:6px; padding-left:6px'>";
		htmlArr[idx++] = headerCol._label;
		htmlArr[idx++] = "</td>";
	}

	if (headerCol._sortable && !headerCol._noSortArrow) {
		var arrowIcon = this._bSortAsc ? "ColumnUpArrow" : "ColumnDownArrow";

		htmlArr[idx++] = "<td align=right style='padding-right:2px' width='8px' id='";
		htmlArr[idx++] = DwtId.getListViewHdrId(DwtId.WIDGET_HDR_ARROW, this._view, field);
		htmlArr[idx++] = "'>";
		var isDefault = (field == defaultColumnSort);
		htmlArr[idx++] = AjxImg.getImageHtml(arrowIcon, isDefault ? null : "visibility:hidden");
		htmlArr[idx++] = "</td>";
		if (isDefault) {
			this._currentColId = id;
		}
	}

	// ALWAYS add "sash" separators
	if (i < (numCols - 1)) {
		htmlArr[idx++] = "<td width=6>";
		htmlArr[idx++] = "<table align=right width=4 height=100% id='";
		htmlArr[idx++] = DwtId.getListViewHdrId(DwtId.WIDGET_HDR_SASH, this._view, field);
		htmlArr[idx++] = "'><tr>";
		htmlArr[idx++] = "<td class='DwtListView-Sash'><div style='width: 1px; height: ";
		htmlArr[idx++] = (DwtListView.HEADERITEM_HEIGHT - 2);
		htmlArr[idx++] = "px; background-color: #8A8A8A;margin-left:2px'></div></td><td class='DwtListView-Sash'><div style='width: 1px; height: ";
		htmlArr[idx++] = (DwtListView.HEADERITEM_HEIGHT - 2);
		htmlArr[idx++] = "px;'></div></td></tr></table>";
		htmlArr[idx++] = "</td>";
	}

	htmlArr[idx++] = "</tr></table>";
	htmlArr[idx++] = "</div></td>";

	return idx;
};

DwtListView.prototype._createHeaderCssStyle =
function(headerCol, width) {
	if (!headerCol._cssClass || !headerCol._resizeable) {
		return;
	}
	if (headerCol._cssRuleIndex) {
		DwtCssStyle.removeRule(document.styleSheets[0], headerCol._cssRuleIndex);
	}
	//add a dynamic stylesheet for this header
	var selector = "#" + this.parent._htmlElId;
	selector += " ." + headerCol._cssClass;
	var declaration = "width:" + width + ($.isNumeric(width) ? "px;" : ";");
	headerCol._cssRuleIndex = DwtCssStyle.addRule(document.styleSheets[0], selector, declaration, headerCol._cssRuleIndex);
};
/**
 * Gets the index of the given item.
 *
 * @param	{Object}	item		the item
 * @return	{number}	the index or <code>null</code> if not found
 */
DwtListView.prototype.getItemIndex =
function(item) {
	var list = this._list;
	if (list) {
		var len = list.size();
		for (var i = 0; i < len; ++i) {
			if (list.get(i).id == item.id) {
				return i;
			}
		}
	}
	return null;
};

/**
 * Sets the size of the view.
 * 
 * @param	{number|string}	width		the width (for example: 100, "100px", "75%")
 * @param	{number|string}	height		the height (for example: 100, "100px", "75%")
 */
DwtListView.prototype.setSize =
function(width, height) {
	DwtComposite.prototype.setSize.call(this, width, height);
	this._sizeChildren(height);
};

/**
 * Gets the count of items in the list.
 * 
 * @return	{number}	the count of items
 */
DwtListView.prototype.size =
function() {
	return this._list ? this._list.size() : 0;
};

/**
 * Creates a list view out of the given vector of items. The derived class should override _createItemHtml()
 * in order to display an item.
 *
 * @param {AjxVector}	list			a vector of items
 * @param {number}	[defaultColumnSort]	the default column field to sort
 * @param {boolean}	noResultsOk		if <code>true</code>, do not show "No Results" for empty list
 */
DwtListView.prototype.set =
function(list, defaultColumnSort, noResultsOk) {
	if (this._selectedItems) {
		this._selectedItems.removeAll();
	}
	this._curViewedItem = null;
	this._rightSelItem = null;
	this.sortingEnabled = true;
	this._resetList();
	this._list = list;
	this.setUI(defaultColumnSort, noResultsOk);
};

/**
 * Renders the list view using the current list of items.
 *
 * @param {string}	defaultColumnSort		the ID of column that represents default sort order
 * @param {boolean}	noResultsOk			if <code>true</code>, do not show "No Results" for empty list
 */
DwtListView.prototype.setUI =
function(defaultColumnSort, noResultsOk) {
	this.removeAll();
	this.createHeaderHtml(defaultColumnSort);
	this._renderList(this._list, noResultsOk);
};

DwtListView.prototype._renderList =
function(list, noResultsOk, doAdd) {
	if (list instanceof AjxVector && list.size()) {
		var now = new Date();
		var size = list.size();
		var htmlArr = [];

		if (!doAdd) {
			this._parentEl.innerHTML = '';
		}

		Dwt.delClass(this._parentEl, 'DwtListView-Rows-Empty');

		for (var i = 0; i < size; i++) {
			var item = list.get(i);
			var div = this._createItemHtml(item, {now:now}, false, i);
			if (div) {
				if (div instanceof Array) {
					for (var j = 0; j < div.length; j++){
						this._addRow(div[j]);
					}
				} else {
					this._addRow(div);
				}
                this._itemAdded(item);
			}
		}
	} else if (!noResultsOk) {
		this._setNoResultsHtml();
		Dwt.addClass(this._parentEl, 'DwtListView-Rows-Empty');
	}
};

/**
 * Adds the items.
 * 
 * @param	{array}		itemArray		an array of items
 */
DwtListView.prototype.addItems =
function(itemArray) {
	if (AjxUtil.isArray(itemArray)) {
		if (!this._list) {
			this._list = new AjxVector();
		}

		// clear the "no results" message before adding!
		if (this._list.size() == 0) {
			this._resetList();
		}
		this._renderList(AjxVector.fromArray(itemArray), null, true);
		this._list.addList(itemArray);
	}
};

/**
 * Adds a row for the given item to the list view.
 *
 * @param {Object}	item			the data item
 * @param {number}	index			the index at which to add item to list and list view
 * @param {boolean}	skipNotify	if <code>true</code>, do not notify listeners
 * @param {number}	itemIndex		index at which to add item to list, if different
 * 									from the one for the list view
 */
DwtListView.prototype.addItem =
function(item, index, skipNotify, itemIndex) {
	if (!this._list) {
		this._list = new AjxVector();
	}

	// clear the "no results" message before adding!
	if (this._list.size() == 0) {
		this._resetList();
	}

	this._list.add(item, (itemIndex != null) ? itemIndex : index);
	var div = this._createItemHtml(item);
	if (div) {
		if (div instanceof Array) {
			for (var j = 0; j < div.length; j++) {
				this._addRow(div[j]);
			}
		} else {
			this._addRow(div, index);
		}
	}

	if (!skipNotify && this._evtMgr.isListenerRegistered(DwtEvent.STATE_CHANGE)) {
		this._evtMgr.notifyListeners(DwtEvent.STATE_CHANGE, this._stateChangeEv);
	}
};

/**
 * Removes a row for the given item to the list view.
 *
 * @param {Object}	item			the data item
 * @param {boolean}	skipNotify	if <code>true</code>, do not notify listeners
 * @param {boolean}	skipAlternation		if <code>true</code>, do not fix alternation
 */
DwtListView.prototype.removeItem =
function(item, skipNotify, skipAlternation) {

	var itemEl = this._getElFromItem(item);
	if (!itemEl) { return; }

	var altIndex = this._getRowIndex(item);	// get index before we remove row

	this._selectedItems.remove(itemEl);
	if (this._rightSelItem === itemEl) {
		this._rightSelItem = null;
	}
	if (this._kbAnchor === itemEl) {
		this._kbAnchor = null;
	}
	if (itemEl.parentNode === this._parentEl) {
		this._parentEl.removeChild(itemEl);
	}
	if (this._list) {
		this._list.remove(item);
	}
	var id = itemEl.id;
	if (this._data[id]) {
		this._data[id] = null;
		delete this._data[id];
	}
	if (!skipAlternation) {
		this._fixAlternation(altIndex);
	}

	if (!skipNotify && this._evtMgr.isListenerRegistered(DwtEvent.STATE_CHANGE)) {
		this._evtMgr.notifyListeners(DwtEvent.STATE_CHANGE, this._stateChangeEv);
	}
};

DwtListView.prototype.redrawItem =
function(item) {
    var odiv = this._getElFromItem(item);
    if (odiv) {
		var className = odiv.className;
        var ndiv = this._createItemHtml(item);
		ndiv.className = className;	// preserve classes
        odiv.parentNode.replaceChild(ndiv, odiv);
		// preserve selection
		if (this._selectedItems.contains(odiv)) {
			this._selectedItems.remove(odiv);
			this.selectItem(item);
		}

        //update the _kbAnchor as the old element has been swapped with the new element
        if (this._kbAnchor === odiv){
            this._setKbFocusElement(ndiv);
        }
    }
};

/**
 * Adds a selection listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
DwtListView.prototype.addSelectionListener =
function(listener) {
	this._evtMgr.addListener(DwtEvent.SELECTION, listener);
};

/**
 * Removes a selection listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
DwtListView.prototype.removeSelectionListener =
function(listener) {
	this._evtMgr.removeListener(DwtEvent.SELECTION, listener);
};

/**
 * Adds an action listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
DwtListView.prototype.addActionListener =
function(listener) {
	this._evtMgr.addListener(DwtEvent.ACTION, listener);
};

/**
 * Removes an action listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
DwtListView.prototype.removeActionListener =
function(listener) {
	this._evtMgr.removeListener(DwtEvent.ACTION, listener);
};

/**
 * Adds a state change listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
DwtListView.prototype.addStateChangeListener =
function(listener) {
	this._evtMgr.addListener(DwtEvent.STATE_CHANGE, listener);
};

/**
 * Adds a state change listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
DwtListView.prototype.removeStateChangeListener =
function(listener) {
	this._evtMgr.removeListener(DwtEvent.STATE_CHANGE, listener);
};

/**
 * Removes all the items from the list.
 * 
 * @param {boolean}	skipNotify	if <code>true</code>, do not notify listeners
 */
DwtListView.prototype.removeAll =
function(skipNotify) {
	if (this._parentEl) {
		this._parentEl.innerHTML = "";
	}
	if (this._selectedItems) {
		this._selectedItems.removeAll();
	}
	this._rightSelItem = this._selAnchor = this._kbAnchor = null;

	if (!skipNotify && this._evtMgr.isListenerRegistered(DwtEvent.STATE_CHANGE)) {
		this._evtMgr.notifyListeners(DwtEvent.STATE_CHANGE, this._stateChangeEv);
	}
};

/**
 * Selects all items in the list.
 * 
 */
DwtListView.prototype.selectAll =
function() {
	if (this._list && this._list.size()) {
		this.setSelectedItems(this._list.getArray());
	}
};

/**
 * De-selects all items in the list.
 * 
 */
DwtListView.prototype.deselectAll =
function() {
	if(this._selectedItems) {
		var a = this._selectedItems.getArray();
		var sz = this._selectedItems.size();
		for (var i = 0; i < sz; i++) {
	        Dwt.delClass(a[i], this._styleRe);
	        a[i].removeAttribute('aria-selected');
	    }
	    this._selectedItems.removeAll();
		this._rightSelItem = this._selAnchor = null;
	
		if (this._kbAnchor != null && this.hasFocus()) {
			Dwt.addClass(this._kbAnchor, this._kbFocusClass);
		}
	}
};

DwtListView.prototype._markUnselectedViewedItem =
function(on) {
	var viewedItem = this._curViewedItem;
	var viewedEl = viewedItem && this._getElFromItem(viewedItem);
	if (!viewedEl) {
		return;
	}
	if (on) {
		Dwt.delClass(viewedEl, this._styleRe, this._viewedButUnselectedClass);  //ADDING the selectedForViewOnly class
	}
	else {
		//turn off the highlight
		Dwt.delClass(viewedEl, this._viewedButUnselectedClass);
	}
};

DwtListView.prototype.getDnDSelection =
function() {
	if (this._dndSelection instanceof AjxVector) {
		return this.getSelection();
	} else {
		return this.getItemFromElement(this._dndSelection);
	}
};

DwtListView.prototype.getSelection =
function() {
	var a = [];
	if (this._rightSelItem) {
		a.push(this.getItemFromElement(this._rightSelItem));
	} else if (this._selectedItems) {
        var sa = this._selectedItems.getArray();
		var saLen = this._selectedItems.size();
		for (var i = 0; i < saLen; i++) {
			a[i] = this.getItemFromElement(sa[i]);
		}
	}
	return a;
};

/**
 * Gets the selected items.
 * 
 * @return	{Array}	an array of selected items
 */
DwtListView.prototype.getSelectedItems =
function() {
	return this._selectedItems;
};

DwtListView.prototype.setSelection =
function(item, skipNotify, forceSelection) {

	if (!item) {
		return;
	}

	var el = this._getElFromItem(item);
	if (el) {
		if (this._selectedItems.size() == 1 && this._selectedItems.get(0) == el && !forceSelection) {
			return;
		}
		this.deselectAll();
		this._unmarkKbAnchorElement(true);
		this._setKbFocusElement(el);
		this._selAnchor = el;
		this.selectItem(item, this.getEnabled());

		// reset the selected index
		this.firstSelIndex = (this._list && this._list.size() > 0) ? this._list.indexOf(item) : -1;

		this._scrollList(el);

		if (!skipNotify && this._evtMgr.isListenerRegistered(DwtEvent.SELECTION)) {
			var selEv = new DwtSelectionEvent(true);
			selEv.button = DwtMouseEvent.LEFT;
			selEv.target = el;
			selEv.item = this.getItemFromElement(el);
			selEv.detail = DwtListView.ITEM_SELECTED;
			selEv.ersatz = true;
			this._evtMgr.notifyListeners(DwtEvent.SELECTION, selEv);
		}
	}
};

DwtListView.prototype.setMultiSelection =
function(clickedEl, bContained, ev) {
	if (bContained) {
		this._selectedItems.remove(clickedEl);
		clickedEl.removeAttribute('aria-selected');
		Dwt.delClass(clickedEl, this._styleRe);		// , this._normalClass	MOW
		this._selEv.detail = DwtListView.ITEM_DESELECTED;
	} else {
		this._selectedItems.add(clickedEl, null, true);
		clickedEl.setAttribute('aria-selected', true);
		Dwt.delClass(clickedEl, this._styleRe, this._selectedClass);
		this._selEv.detail = DwtListView.ITEM_SELECTED;
	}

	// Remove the keyboard hilite from the current anchor
	if (this._kbAnchor && this._kbAnchor != clickedEl) {
		Dwt.delClass(this._kbAnchor, this._kbFocusClass);
	}

	// The element that was part of the ctrl action always becomes the anchor
	// since it gets focus
	this._setKbFocusElement(clickedEl);
	this._selAnchor = clickedEl;
	Dwt.addClass(this._kbAnchor, this._kbFocusClass);
};

DwtListView.prototype.setSelectedItems =
function(selectedArray) {
	this.deselectAll();
	var sz = selectedArray.length, doSelect = this.getEnabled();
	for (var i = 0; i < sz; ++i) {
		this.selectItem(selectedArray[i], doSelect);
	}
};

/**
 * Selects or deselects a single item.
 * 
 * @param	{boolean}	selected		if <code>true</code>, select the item
 */
DwtListView.prototype.selectItem =
function(item, selected) {

	var el = this._getElFromItem(item);
	if (el) {
		Dwt.delClass(el, this._styleRe, selected ? this._selectedClass : this._disabledSelectedClass);
		if (this._kbAnchor == el && this.hasFocus()) {
			Dwt.addClass(el, this._kbFocusClass);
			el.focus();
		}
		this._selectedItems.add(el);
		el.setAttribute('aria-selected', true);
	}
};

/**
 * Gets the selection count.
 * 
 * @return	{number}	the selection count
 */
DwtListView.prototype.getSelectionCount =
function() {
	return this._rightSelItem ? 1 : this._selectedItems.size();
};

DwtListView.prototype.handleActionPopdown =
function() {
	this._clearRightSel();
};

/**
 * Pairs an item with an element. As a side effect, provides a mechanism for storing
 * data about a particular element, referenced by its ID.
 *
 * @param {Object}	item		an item
 * @param {Element}	element	an HTML element
 * @param {constant}	[type=DwtListView.TYPE_LIST_ITEM]		a role that element has
 * @param {string}	[id]		the ID for element; if not provided, one is generated from the item
 * @param {hash}	[data]		any additional attributes to store
 * 
 * @private
 */
DwtListView.prototype.associateItemWithElement =
function(item, element, type, id, data) {
	id = id || this._getItemId(item);
	if (element) {
		element.id = id;
	}
	type = type || DwtListView.TYPE_LIST_ITEM;
	this._data[id] = {item:item, id:id, type:type};
	if (data) {
		for (var key in data) {
			this._data[id][key] = data[key];
		}
	}
	return id;
};

DwtListView.prototype.getItemFromElement =
function(el) {
	return this._getItemData(el, "item");
};

/**
 * Starts with an element and works its way up the element chain until it finds one
 * with an ID that maps to an item, then returns the associated item.
 *
 * @param {Element}	el	element to start with
 * @return	{Object}	the item
 */
DwtListView.prototype.findItem =
function(el)  {
	if (!el) { return; }
	var div = this.findItemDiv(el);
	return this._getItemData(div, "item");
};

/**
 * Starts with an element and works its way up the element chain until it finds one
 * with an ID that maps to an item.
 *
 * @param {Element}	el	the element to start with
 * @return	{Element}	the element
 */
DwtListView.prototype.findItemDiv =
function(el)  {
	if (!el) { return; }
	while (el && (el.id != this._htmlElId)) {
		if (el.id && this._data[el.id]) {
			return el;
		}
		el = el.parentNode;
	}
	return null;
};

/**
 * Gets the item associated with the given event. Starts with the
 * event target and works its way up the element chain until it finds one
 * with an ID that maps to an item.
 *
 * @param {DwtEvent}	ev				the event
 * @return	{Object}	the item
 */
DwtListView.prototype.getTargetItem =
function(ev)  {
	return this.findItem(DwtUiEvent.getTarget(ev));
};

/**
 * Gets the item DIV associated with the given event. Starts with the
 * event target and works its way up the element chain until it finds one
 * with an ID that maps to an item.
 *
 * @param {DwtEvent}	ev				the event
 * @return	{Object}	the item
 */
DwtListView.prototype.getTargetItemDiv =
function(ev)  {
	return this.findItemDiv(DwtUiEvent.getTarget(ev));
};

DwtListView.prototype.dragSelect =
function(row) {
	// If we have something previously selected, try and remove the selection
	if (this._dragHighlight) {
		var oldRow = document.getElementById(this._dragHighlight);
		// only go forward if the row doesn't exist, or if the new selection
		// is different from the old selection.
		// In the case where a header item is dragged over, the row might be
		// null or void.
		if (!row || (oldRow && (row.id != oldRow.id))) {
			this._updateDragSelection(oldRow, false);
		}
	}

	if (!row) { return; }

	// Don't try and select if we are over a header item
	if (this._getItemData(row, "type") != DwtListView.TYPE_LIST_ITEM) { return; }

	// Try and select only if the new row is different from the currently
	// highlighted row.
	if (row.id != this._dragHighlight) {
		this._dragHighlight = row.id;
		this._updateDragSelection(row, true);
	}
};

DwtListView.prototype.dragDeselect =
function(row) {
	if (this._dragHighlight) {
		var oldRow = document.getElementById(this._dragHighlight);
		this._updateDragSelection(oldRow, false);
		this._dragHighlight = null;
	}
};

DwtListView.prototype.getScrollContainer = function() {

    return this._parentEl;
};

DwtListView.prototype.scrollToItem =
function(item){
    var el = this._getElFromItem(item);
    if(el){
        this._listDiv.scrollTop = el.offsetTop;
    }
};

DwtListView.prototype.scrollToTop =
function() {
	this._listDiv.scrollTop = 0;
};

/**
 * Scrolls the list view up or down one page.
 *
 * @param {boolean}	up	if true, scroll up
 */
DwtListView.prototype.scrollPage =
function(up) {
	var el = this._parentEl;
	if (el.clientHeight >= el.scrollHeight) { return; }
	el.scrollTop = up ? Math.max(el.scrollTop - el.clientHeight, 0) :
				   		Math.min(el.scrollTop + el.clientHeight, el.scrollHeight - el.clientHeight);
};

DwtListView.prototype.setSortByAsc =
function(column, bSortByAsc) {
	if (!this._headerList) { return; }

	this._bSortAsc = bSortByAsc;
	var columnId = null;
	for (var i = 0; i < this._headerList.length; i++) {
		if (this._headerList[i]._sortable && this._headerList[i]._field == column) {
			columnId = this._headerList[i]._id;
			break;
		}
	}
	if (columnId) {
		this._setSortedColStyle(columnId);
	}
};

DwtListView.prototype.getNewOffset =
function(bPageForward) {
	var limit = this.getLimit();
	var offset = bPageForward ? (this.offset + limit) : (this.offset - limit);
	return (offset < 0) ? 0 : offset;
};

DwtListView.prototype.getLimit =
function() {
	// return the default limit value unless overloaded
	return DwtListView.DEFAULT_LIMIT;
};

DwtListView.prototype.getReplenishThreshold =
function() {
	// return the default threshold value unless overloaded
	return DwtListView.MAX_REPLENISH_THRESHOLD;
};

DwtListView.prototype.getList =
function() {
	return this._list;
};

DwtListView.prototype.getFocusElement = function() {

	if (!this._kbAnchor) {
		this._setKbFocusElement(null, true);
	}

	return this._kbAnchor || this._parentEl;
};

// this method simply appends the given list to this current one
DwtListView.prototype.replenish =
function(list) {
	this._list.addList(list);

	var size = list.size();
	for (var i = 0; i < size; i++) {
		var item = list.get(i);
		var div = this._createItemHtml(item);
		if (div) {
			this._addRow(div);
		}
	}
};

DwtListView.prototype.getKeyMapName =
function() {
	return DwtKeyMap.MAP_LIST;
};

DwtListView.prototype.handleKeyAction = function(actionCode, ev) {

    if (!this.size()) {
        return false;
    }

	switch (actionCode) {
		case DwtKeyMap.SELECT:			this._emulateSingleClick({target:this._kbAnchor, button:DwtMouseEvent.LEFT, kbNavEvent:true}); break;
		case DwtKeyMap.SELECT_CURRENT:	this._emulateSingleClick({target:this._kbAnchor, button:DwtMouseEvent.LEFT, ctrlKey:true, kbNavEvent:true}); break;
		case DwtKeyMap.SELECT_NEXT:		this._selectItem(true, false, true); break;
		case DwtKeyMap.SELECT_PREV:		this._selectItem(false, false, true); break;
		case DwtKeyMap.ADD_SELECT_NEXT: this._selectItem(true, true, true); break;
		case DwtKeyMap.ADD_SELECT_PREV: this._selectItem(false, true, true); break;
		case DwtKeyMap.PREV:			this._setKbFocusElement(false); break;
		case DwtKeyMap.NEXT:			this._setKbFocusElement(true); break;

		case DwtKeyMap.DBLCLICK: {
			if (!this._kbAnchor) {
                break;
            }
			var anchorSelected = false;
			var a = this.getSelectedItems().getArray();
			for (var i = 0; i < a.length; i++) {
				if (a[i] == this._kbAnchor) {
					anchorSelected = true;
					break;
				}
			}
			if (anchorSelected) {
				this.emulateDblClick(this.getItemFromElement(this._kbAnchor), true);
			} else {
				this._emulateSingleClick({target:this._kbAnchor, button:DwtMouseEvent.LEFT, kbNavEvent:true});
			}
			break;
		}

		case DwtKeyMap.SELECT_ALL:
			this.selectAll();
			break;

		case DwtKeyMap.SELECT_FIRST:
		case DwtKeyMap.SELECT_LAST:
			var item = (actionCode == DwtKeyMap.SELECT_FIRST) ? this._getFirstItem() : this._getLastItem();
			if (item) {
				this.setSelection(item);
				this._scrollList(this._kbAnchor);
			}
			break;

		case DwtKeyMap.SUBMENU:
			if (this._evtMgr.isListenerRegistered(DwtEvent.ACTION)) {
				var p = Dwt.toWindow(this._kbAnchor, 0, 0);
				var s = Dwt.getSize(this._kbAnchor);
				var docX = p.x + s.x / 4;
				var docY = p.y + s.y / 2;
				this._emulateSingleClick({target:this._kbAnchor, button:DwtMouseEvent.RIGHT, docX:docX, docY:docY, kbNavEvent:true});
			}
			break;

		case DwtKeyMap.PAGE_UP:
		case DwtKeyMap.PAGE_DOWN:
			this.scrollPage(actionCode == DwtKeyMap.PAGE_UP);
			break;

		default:
			return false;
	}

	return true;
};

DwtListView.prototype.setMultiSelect = function (enabled) {
	this.setAttribute('aria-multiselectable', Boolean(enabled));
};

DwtListView.prototype.isMultiSelectEnabled = function () {
	return this.getAttribute('aria-multiselectable') === "true";
};

// DO NOT REMOVE - used by xforms
DwtListView.prototype.setListDivHeight =
function (listViewHeight) {
	if (this._listDiv && this._listColDiv) {
		var headerHeight = Dwt.getSize (this._listColDiv).y ;
		//the 25px allows for the diff between container and list for all browsers and eliminates vertical unnecessary scrolls
		var listDivHeight = listViewHeight - headerHeight - 25;
		Dwt.setSize(this._listDiv, Dwt.DEFAULT, listDivHeight);
	}
};


// Private methods

// returns a regex that matches modified styles such as "Row-selected-actioned"
DwtListView.prototype._getStyleRegex =
function() {
	return new RegExp("\\bRow(-(" + [DwtCssStyle.ALT_SELECTED,
									 DwtCssStyle.SELECTED,
									 DwtCssStyle.ACTIONED,
									 DwtCssStyle.FOCUSED,
									 DwtCssStyle.DISABLED,
									 DwtCssStyle.DRAG_PROXY].join("|") +
					  "))+\\b", "g");
};

/**
 * This is the designated means of adding a row to the table. It does certain
 * processing on the row, so don't use any other means.
 */
DwtListView.prototype._addRow =
function(row, index) {

	if (!row || !this._parentEl) { return; }

	// bug fix #1894 - check for childNodes length otherwise IE barfs
	var len = this._parentEl.childNodes.length;
	if (index != null && len > 0 && index != len) {
		this._parentEl.insertBefore(row, this._parentEl.childNodes[index]);
	} else {
		this._parentEl.appendChild(row);
	}
	this._fixAlternation((index != null) ? index : len);

	row.setAttribute('role', this.itemRole);
};

// Placeholder function for any post-add processing
DwtListView.prototype._itemAdded = function(item) {};

DwtListView.prototype._fixAlternation =
function(index) {

	var childNodes = this._parentEl.childNodes;
	if (!(childNodes && childNodes.length)) { return; }
	if (!(this._list && this._list.size())) { return; }

	var row = childNodes[index];
	if (!row) { return; }
	var odd = Boolean(index % 2);
	this._setAlternatingRowClass(row, odd);
	var sibling = row.nextSibling;
	while (sibling) {
		odd = !odd;
		this._setAlternatingRowClass(sibling, odd);
		sibling = sibling.nextSibling;
	}
};

DwtListView.prototype._setAlternatingRowClass =
function(row, odd) {
	var oclass = odd ? DwtListView.ROW_CLASS_ODD : DwtListView.ROW_CLASS_EVEN;
	var nclass = odd ? DwtListView.ROW_CLASS_EVEN : DwtListView.ROW_CLASS_ODD;
	Dwt.delClass(row, oclass, nclass);
};

/**
 * Renders a single item as a DIV element within a list view. The DIV will
 * contain a TABLE with a column for each field. Subclasses will want to
 * override supporting classes at their discretion. At the very least, they
 * will want to override _getCellContents(). Callers can pass
 * in arbitrary info via the params hash, and it will get passed to the
 * support functions.
 *
 * @param {Object}	item			the item to render
 * @param {hash}	params		a hash of optional parameters
 * @param {Date}      params.now			the current time
 * @param {boolean}      params.isDragProxy	if <code>true</code>, we are rendering a the row to be a drag proxy (dragged around the screen)
 * @param {Element}      params.div			the <code>div</code> to fill with content
 * @param {array}      params.headerList	a list of column headers
 * @param	{boolean}	asHtml
 * @param	{number}	idx
 * 
 * @private
 */
DwtListView.prototype._createItemHtml =
function(item, params, asHtml, count) {

	params = params || {};
	this._addParams(item, params, htmlArr, idx);
	var div;

	var htmlArr = [];
	var idx = 0;

	if (asHtml) {
		idx = this._getDivHtml(item, params, htmlArr, idx, count);
	} else {
		if (params.div) {
			var classes = [this._getDivClass(params.divClass || this._normalClass, item, params),
				(count % 2) ? DwtListView.ROW_CLASS_EVEN : DwtListView.ROW_CLASS_ODD];
			params.div.className = classes.join(" ");
		}
		div = params.div || this._getDiv(item, params);
	}

	var useListEl = this.useListElement();
	if (!useListEl) {
		idx = this._getTable(htmlArr, idx, params);
	}
	idx = this._getRow(htmlArr, idx, item, params);

	// Cells
	var headerList = params.headerList || this._headerList;
	if (headerList && headerList.length) {
		for (var colIdx = 0; colIdx < headerList.length; colIdx++) {
			if (!headerList[colIdx]._visible) { continue; }

			var field = headerList[colIdx]._field;
			idx = this._getCell(htmlArr, idx, item, field, colIdx, params);
		}
	} else {
		idx = this._getCell(htmlArr, idx, item, null, null, params);
	}

	htmlArr[idx++] = useListEl ? "</div>" : "</tr></table>";

	if (asHtml) {
		htmlArr[idx++] = useListEl ? "</li>" : "</div>";
		return htmlArr.join("");
	}

	div.innerHTML = htmlArr.join("");
	return div;
};

/**
 * Subclasses can override to add params to pass to functions below.
 *
 * @param {Object}	item			the item to render
 * @param {hash}	params		a hash of optional parameters
 * 
 * @private
 */
DwtListView.prototype._addParams = function(item, params) {};

/**
 * Returns the DIV that contains the item HTML, and sets up styles that will
 * be used to represent its selection state.
 *
 * @param {Object}	item			the item to render
 * @param {hash}	params		a hash of optional parameters
 * 
 * @private
 */
DwtListView.prototype._getDiv =
function(item, params) {

	var	div = document.createElement("div");
	var html = [];
	this._getDivHtml(item, params, html, 0, 0);
	div.innerHTML = html.join("");

	return div.firstChild; //we want the div that includes the style and class in its element, so we wrap it just for fun (actually not for fun - outerHTML doesn't work)
};

/**
 * override if needed. Currently in ZmMailListView for coloring messages.
 * @param item
 * @return {*}
 * @private
 */
DwtListView.prototype._getExtraStyle =
function(item) {
	return null;
};

/**
 * This is the "HTML" version of the routine above. Instead of returning a DIV
 * element, it returns HTML containing the DIV.
 *
 * @param {Object}	item		the item to render
 * @param {hash}	params	a hash of optional parameters
 * @param {array}	html		the array used to contain HTML code
 * @param {number}	idx		the index used to contain HTML code
 * @param {number}	count		the count of row currently being processed
 * @param {array}	classes		the css classes to be assigned to this element
 * 
 * @private
 */
DwtListView.prototype._getDivHtml =
function(item, params, html, idx, count, classes) {

	html[idx++] = this.useListElement()? "<li ":"<div ";
	classes = classes || [];
	classes.push(this._getDivClass(params.divClass || this._normalClass, item, params));
	classes.push((count % 2) ? DwtListView.ROW_CLASS_EVEN : DwtListView.ROW_CLASS_ODD);
	html[idx++] = AjxUtil.getClassAttr(classes);

	var style = [];
	if (params.isDragProxy && AjxEnv.isMozilla) {
		style.push("overflow:visible");		// bug fix #3654 - yuck
	}
	if (params.isDragProxy) {
		style.push("position:absolute");
		style.push("width:" + this.getSize().x + "px");
	}

	var extraStyle = this._getExtraStyle(item);
	if (extraStyle) {
		style.push(extraStyle);
	}

	if (style.length) {
		html[idx++] = " style='";
		html[idx++] = style.join(";");
		html[idx++] = "'";
	}

	var id = params.isDragProxy ? this._getItemId(item) + "_dnd" : null;
	html[idx++] = " id='";
	html[idx++] = this.associateItemWithElement(item, null, null, id);
	html[idx++] = "'>";

	return idx;
};

/**
 * Returns the name of the class to use for the DIV that contains the HTML for this item.
 * Typically, a modifier is added to a base class for certain types of rows. For example,
 * a row that is created to be dragged will get the class "Row-dnd".
 *
 * @param {string}	base		the name of base class
 * @param {Object}	item		the item to render
 * @param {hash}	params	a hash of optional parameters
 * 
 * @private
 */
DwtListView.prototype._getDivClass =
function(base, item, params) {
	return params.isDragProxy ? ([base, " ", base, "-", DwtCssStyle.DRAG_PROXY].join("")) : base;
};

/**
 * Creates the TABLE that holds the items.
 *
 * @param {array}	htmlArr	the array that holds lines of HTML
 * @param {number}	idx		the current line of array
 * @param {hash}	params	a hash of optional parameters
 * 
 * @private
 */
DwtListView.prototype._getTable =
function(htmlArr, idx, params) {
	htmlArr[idx++] = "<table width=";
	htmlArr[idx++] = !params.isDragProxy ? "100%>" : (this.getSize().x + ">");
	return idx;
};

/**
 * Creates a TR for the given item.
 *
 * @param {array}	htmlArr		the array that holds lines of HTML
 * @param {number}	idx		the current line of array
 * @param {object}	item		the item to render
 * @param {hash}	params	a hash of optional parameters
 * @param {array}	classes	a list of css classes for this row
 * 
 * @private
 */
DwtListView.prototype._getRow =
function(htmlArr, idx, item, params, classes) {
	var rowId = this._getRowId(item, params) || Dwt.getNextId();
	var className = this._getRowClass(item, params);
	if (this.useListElement()) {
		htmlArr[idx++] =  "<div ";
		classes = classes || [];
		if (className) {
			classes.push(className);
		}
		if (rowId) {
			htmlArr[idx++] = ["id='", rowId, "'"].join("");
		}
		htmlArr[idx++] = AjxUtil.getClassAttr(classes) + ">";
	} else {
		htmlArr[idx++] = rowId ? ["<tr id='", rowId, "'"].join("") : "<tr";
		htmlArr[idx++] = className ? ([" class='", className, "'>"].join("")) : ">";
	}
	return idx;
};

/**
 * Use the list elements <ul> and <li> instead of div and table elements
 *
 */
DwtListView.prototype.useListElement =
function() {
	return false;
}

/**
 * Returns the class name for this item's TR.
 *
 * @param {Object}	item		the item to render
 * @param {hash}	params		a hash of optional parameters
 * 
 * @private
 */
DwtListView.prototype._getRowClass =
function(item, params) {
	return null;
};

/**
 * Returns the DOM ID to be used for this item's TR.
 *
 * @param {Object}	item		the item to render
 * @param {hash}	params		a hash of optional parameters
 * 
 * @private
 */
DwtListView.prototype._getRowId =
function(item, params) {
	return null;
};

/**
 * Creates a TD and its content for a single field of the given item. Subclasses
 * may override several dependent functions to customize the TD and its content.
 *
 * @param htmlArr	[array]		array that holds lines of HTML
 * @param idx		[int]		current line of array
 * @param item		[object]	item to render
 * @param field		[constant]	column identifier
 * @param colIdx	[int]		index of column (starts at 0)
 * @param params	[hash]*		hash of optional params
 * 
 * @private
 */
DwtListView.prototype._getCell =
function(htmlArr, idx, item, field, colIdx, params) {
	if (this.useListElement()) {
		var classes = [];
		var className = this._getCellClass(item, field, params);
		if (className) {
			classes.push(className);
		}
		idx = this._getCellContents(htmlArr, idx, item, field, colIdx, params, [className || ""])
	} else {
		var cellId = this._getCellId(item, field, params);
		var idText = cellId ? [" id=", "'", cellId, "'"].join("") : "";
		var width = this._getCellWidth(colIdx, params);
		var widthText = width ? ([" width=", width].join("")) : (" width='100%'");
		var className = this._getCellClass(item, field, params);
		var classText = className ? [" class=", className].join("") : "";
		var alignValue = this._getCellAlign(colIdx, params);
		var alignText = alignValue ? [" align=", alignValue].join("") : "";
		var otherText = (this._getCellAttrText(item, field, params)) || "";
		var attrText = [idText, widthText, classText, alignText, otherText].join(" ");
		htmlArr[idx++] = "<td";
		htmlArr[idx++] = attrText ? (" " + attrText) : "";
		htmlArr[idx++] = ">";
		idx = this._getCellContents(htmlArr, idx, item, field, colIdx, params);
		htmlArr[idx++] = "</td>";
	}

	return idx;
};

/**
 * Returns the width that should be used for the TD, based on the header setup.
 *
 * @param colIdx	[int]		index of column (starts at 0)
 * @param params	[hash]*		hash of optional params
 * 
 * @private
 */
DwtListView.prototype._getCellWidth =
function(colIdx, params) {
	if (colIdx == null) { return null; }
	// IE/Safari do not obey box model properly so we overcompensate :(
	var headerList = params.headerList || this._headerList;
	var width = headerList[colIdx]._width;
	if (width) {
		if (width != "auto" && width > 0) {
			if (AjxEnv.isIE)		return (width + 2);
			if (AjxEnv.isSafari && !AjxEnv.isSafari6up && !AjxEnv.isChrome19up) {
				return (width + 5);
			}
		}
		return width;
	}
	return null;
};

DwtListView.prototype._getCellAlign =
function(colIdx, params) {
	if (colIdx == null) { return null; }
	// IE/Safari do not obey box model properly so we overcompensate :(
	var headerList = params.headerList || this._headerList;
	return headerList[colIdx]._align;
};

/**
 * Returns the DOM ID for the TD. The main reasons to provide an ID are to support
 * tooltips, and to be able to update cell content dynamically.
 *
 * @param item		[object]	item to render
 * @param field		[constant]	column identifier
 * @param params	[hash]*		hash of optional params
 * 
 * @private
 */
DwtListView.prototype._getCellId =
function(item, field, params) {
	return null;
};

/**
 * Returns the class to be used for the TD.
 *
 * @param item		[object]	item to render
 * @param field		[constant]	column identifier
 * @param params	[hash]*		hash of optional params
 * 
 * @private
 */
DwtListView.prototype._getCellClass =
function(item, field, params) {
	return null;
};

/**
 * Returns a string of any extra attributes to be used for the TD.
 *
 * @param item		[object]	item to render
 * @param field		[constant]	column identifier
 * @param params	[hash]*		hash of optional params
 * 
 * @private
 */
DwtListView.prototype._getCellAttrText =
function(item, field, params) {
	return null;
};

/**
 * Fills the TD with content. The default implementation converts the item
 * to a string and uses that.
 *
 * @param htmlArr	[array]		array that holds lines of HTML
 * @param idx		[int]		current line of array
 * @param item		[object]	item to render
 * @param field		[constant]	column identifier
 * @param colIdx	[int]		index of column (starts at 0)
 * @param params	[hash]*		hash of optional params
 * 
 * @private
 */
DwtListView.prototype._getCellContents =
function(htmlArr, idx, item, field, colIdx, params) {
	htmlArr[idx++] = item.toString ? item.toString() : item;
	return idx;
};

/**
 * Returns a DOM ID for the given field within the given item.
 *
 * @param item		[object]	item to render
 * @param field		[constant]	column identifier
 * 
 * @private
 */
DwtListView.prototype._getFieldId =
function(item, field) {
	return DwtId.getListViewItemId(DwtId.WIDGET_ITEM_FIELD, this._view, item.id, field);
};

/**
 * Returns the element that represents the given field of the given item.
 * Typically returns either a TD or an img DIV.
 *
 * @param item		[object]	item to render
 * @param field		[constant]	column identifier
 * 
 * @private
 */
DwtListView.prototype._getElement =
function(item, field) {
	return document.getElementById(this._getFieldId(item, field));
};

DwtListView.prototype._getDragProxy =
function(dragOp) {
	var dndSelection = this.getDnDSelection();
	if (!dndSelection) { return null; }

	var icon;
	var div;
	var roundPlusStyle;
	this._dndImg = null;

	if (!(dndSelection instanceof Array) || dndSelection.length == 1) {
		var item = (dndSelection instanceof Array) ? dndSelection[0] : dndSelection;
		icon = this._createItemHtml(item, {now:new Date(), isDragProxy:true});
		this._setItemData(icon, "origClassName", icon.className);
		Dwt.setPosition(icon, Dwt.ABSOLUTE_STYLE);

		roundPlusStyle = "position:absolute;top:18;left:-11;visibility:hidden";
	} else {
		// Create multi one
		icon = document.createElement("div");
		icon.className = "DragProxy";
		Dwt.setPosition(icon, Dwt.ABSOLUTE_STYLE);

		AjxImg.setImage(icon, "DndMultiYes_48");
		this._dndImg = icon;

		div = document.createElement("div");
		Dwt.setPosition(div, Dwt.ABSOLUTE_STYLE);
		var text = this.allSelected ? ZmMsg.all : dndSelection.length;
		div.innerHTML = "<table><tr><td class='DragProxyTextLabel'>"
						+ text + "</td></tr></table>";
		icon.appendChild(div);

		roundPlusStyle = "position:absolute;top:30;left:0;visibility:hidden";

		// The size of the Icon is envelopeImg.width + sealImg.width - 20, ditto for height
		Dwt.setBounds(icon, Dwt.LOC_NOWHERE, Dwt.LOC_NOWHERE, 43 + 32 - 16, 36 + 32 - 20);
	}

	var imgHtml = AjxImg.getImageHtml("RoundPlus", roundPlusStyle, "id=" + DwtId.DND_PLUS_ID);
	if (!this._noDndPlusImage) {
		icon.appendChild(Dwt.parseHtmlFragment(imgHtml));
	}

	this.shell.getHtmlElement().appendChild(icon);

	// If we have multiple items selected, then we have our cool little dnd icon,
	// so position the text in the middle of the seal
	if (div) {
		var sz = Dwt.getSize(div);
		Dwt.setLocation(div, 16 + (32 - sz.x) / 2, 19 + (32 - sz.y) / 2);
	}

	Dwt.setZIndex(icon, Dwt.Z_DND);
	return icon;
};

DwtListView.prototype._setDragProxyState =
function(dropAllowed) {
	// If we are moving multiple items then set borders & icons, else delegate up
	// to DwtControl.prototype._setDragProxyState()
	if (this._dndImg) {
		AjxImg.setImage(this._dndImg, dropAllowed ? "DndMultiYes_48" : "DndMultiNo_48");
	} else if (this._dndProxy) {
		var addClass = dropAllowed ? DwtCssStyle.DROPPABLE : DwtCssStyle.NOT_DROPPABLE;
		var origClass = this._getItemData(this._dndProxy, "origClassName");
		this._dndProxy.className = [origClass, addClass].join(" ");
	}
};

DwtListView.prototype._setNoResultsHtml =
function() {
	var	div = document.createElement("div");
	var subs = {
		message: this._getNoResultsMessage(),
		type: this.type
	};
	div.innerHTML = AjxTemplate.expand("dwt.Widgets#DwtListView-NoResults", subs);
	this._addRow(div);
};

DwtListView.prototype._getNoResultsMessage =
function() {
	return AjxMsg.noResults;
};

DwtListView.prototype._clearRightSel =
function() {
	if (!this._rightSelItem) {
		return;
	}
	Dwt.delClass(this._rightSelItem, this._rightClickClass);
	this._rightSelItem = null;
	if (!this._curViewedItem) {
		return;
	}
	this.deselectAll();
	this.selectItem(this._curViewedItem, true);
};

DwtListView.prototype._getItemId =
function(item) {
	return DwtId.getListViewItemId(DwtId.WIDGET_ITEM, this._view, (item && item.id) ? item.id : Dwt.getNextId());
};

DwtListView.prototype._getElFromItem =
function(item) {
	return Dwt.byId(this._getItemId(item));
};

// returns the index of the given item based on the position of the row
// in this list view that represents it
DwtListView.prototype._getRowIndex =
function(item) {
	var id = this._getItemId(item);
	var childNodes = this._parentEl.childNodes;
	for (var i = 0; i < childNodes.length; i++) {
		if (childNodes[i].id == id) {
			return i;
		}
	}
	return null;
};

/**
 * Returns data associated with the given element.
 * 
 * @param el		[Element]	an HTML element
 * @param field		[string]	key for desired data
 * @param id		[string]*	ID that overrides element ID (or if element is not provided)
 * 
 * @private
 */
DwtListView.prototype._getItemData =
function(el, field, id) {
	id = id || (el ? el.id : null);
	var data = this._data[id];
	return data ? data[field] : null;
};

/**
 * Sets data associated with the given element.
 * 
 * @param el		[Element]	an HTML element
 * @param field		[string]	key
 * @param value		[object]	value
 * @param id		[string]*	ID that overrides element ID (or if element is not provided)
 * 
 * @private
 */
DwtListView.prototype._setItemData =
function(el, field, value, id) {
	id = id || (el ? el.id : null);
	var data = this._data[id];
	if (data) {
		data[field] = value;
	}
};

// Return true only if the event occurred in one of our Divs. See DwtControl for more info
DwtListView.prototype._isValidDragObject =
function(ev) {
	return (this.getTargetItemDiv(ev) != null);
};

DwtListView.prototype._updateDragSelection =
function(row, select) {

	if (!row) { return; }
	
    if (!select) {
		row.className = this._getItemData(row, "origClassName");
	} else {
		this._setItemData(row, "origClassName", row.className);
		Dwt.delClass(row, this._styleRe, this._dndClass);
	}
};

DwtListView.prototype._mouseOverAction =
function(mouseEv, div) {
	var type = this._getItemData(div, "type");
	if (type == DwtListView.TYPE_HEADER_ITEM){
		var hdr = this.getItemFromElement(div);
		if (hdr && this.sortingEnabled && hdr._sortable && !this._headerClone) {
			div.className += " DwtListView-ColumnHover";
		}
	} else if (type == DwtListView.TYPE_HEADER_SASH) {
		div.style.cursor = AjxEnv.isIE ? "col-resize" : "e-resize";
	}

	return true;
};

DwtListView.prototype._mouseOutAction =
function(mouseEv, div) {
	var type = this._getItemData(div, "type");
	if (type == DwtListView.TYPE_HEADER_ITEM && !this._headerClone) {
		div.className = (div.id != this._currentColId)
			? "DwtListView-Column"
			: "DwtListView-Column DwtListView-ColumnActive";
        var hdr = this.getItemFromElement(div);
        if (!hdr._sortable)
            div.className += " DwtDefaultCursor";
	} else if (type == DwtListView.TYPE_HEADER_SASH) {
		div.style.cursor = "auto";
	}

	return true;
};

DwtListView.prototype._mouseOverListener =
function(ev) {
	var div = this.getTargetItemDiv(ev);
	if (!div) { return; }

	this._mouseOverAction(ev, div);
};

DwtListView.prototype._mouseOutListener =
function(ev) {
	var div = this.getTargetItemDiv(ev);
	if (!div) { return; }

	// NOTE: The DwtListView handles the mouse events on the list items
	//		 that have associated tooltip text. Therefore, we must
	//		 explicitly null out the tooltip content whenever we handle
	//		 a mouse out event. This will prevent the tooltip from
	//		 being displayed when we re-enter the listview even though
	//		 we're not over a list item.
	this.setToolTipContent(null);
	this._mouseOutAction(ev, div);
};

DwtListView.prototype._mouseMoveListener =
function(ev) {
	if (!this._clickDiv) { return; }

	var type = this._getItemData(this._clickDiv, "type");
	if (type == DwtListView.TYPE_HEADER_ITEM) {
		this._handleColHeaderMove(ev);
	} else if (type == DwtListView.TYPE_HEADER_SASH) {
		this._handleColHeaderResize(ev);
	}
};

DwtListView.prototype._mouseDownListener =
function(ev) {
	var div = this.getTargetItemDiv(ev);

	if (!div) {
		this._dndSelection = null;
	} else {
		this._clickDiv = div;
		if (this._getItemData(div, "type") != DwtListView.TYPE_LIST_ITEM) {
			this._dndSelection = null;
		} else {
			this._dndSelection = (this._selectedItems.contains(div)) ? this._selectedItems : div;
		}
	}
	this._mouseDownAction(ev, div);
};

DwtListView.prototype._mouseUpListener =
function(ev) {
	var div = this.getTargetItemDiv(ev);

	var wasDraggingCol = this._handleColHeaderDrop(ev);
	var wasDraggingSash = this._handleColSashDrop(ev);

	if (!div || div != this._clickDiv || wasDraggingCol || wasDraggingSash) {
		delete this._clickDiv;
		this._mouseUpAction(ev, div);
		return;
	}
	delete this._clickDiv;

	var type = this._getItemData(div, "type");
	if (this._headerList && type == DwtListView.TYPE_HEADER_ITEM) {
		if (ev.button == DwtMouseEvent.LEFT) {
			this._columnClicked(div, ev);
		} else if (ev.button == DwtMouseEvent.RIGHT) {
			var actionMenu = this._colHeaderActionMenu = this._getActionMenuForColHeader();
			if (actionMenu && actionMenu instanceof DwtMenu) {
				actionMenu.popup(0, ev.docX, ev.docY);
			}
		}
	} else if (type == DwtListView.TYPE_LIST_ITEM) {
		// set item selection, then hand off to derived class for handling
		if (ev.button == DwtMouseEvent.LEFT || ev.button == DwtMouseEvent.RIGHT) {
			this._itemClicked(div, ev);
		}
	}
	this._mouseUpAction(ev, div);
};

// allow subclasses to set props on mouse event
DwtListView.prototype._mouseDownAction = function(mouseEv, div) {};
DwtListView.prototype._mouseUpAction = function(mouseEv, div) {};

DwtListView.prototype._doubleClickAction =
function(mouseEv, div) {return true;};

DwtListView.prototype._doubleClickListener =
function(ev) {
	var div = this.getTargetItemDiv(ev);
	if (!div) { return; }

	var type = this._getItemData(div, "type");
	if (type == DwtListView.TYPE_LIST_ITEM) {
		if (!this._doubleClickAction(ev, div)) {
			return;
		}
		if (this._evtMgr.isListenerRegistered(DwtEvent.SELECTION)) {
			DwtUiEvent.copy(this._selEv, ev);
			this._selEv.item = this.getItemFromElement(div);
			this._selEv.detail = DwtListView.ITEM_DBL_CLICKED;
			this._evtMgr.notifyListeners(DwtEvent.SELECTION, this._selEv);
		}
	}
};

DwtListView.prototype.emulateDblClick =
function(item, kbNavEvent) {
	var div = document.getElementById(this._getItemId(item));
	if (div) {
		var mev = new DwtMouseEvent();
		this._setMouseEvent(mev, {target:div, button:DwtMouseEvent.LEFT});
		mev.kbNavEvent = kbNavEvent;
		this._itemClicked(div, mev);
		this._doubleClickListener(mev);
	}
};

DwtListView.prototype._selectItem =
function(next, addSelect, kbNavEvent) {
	// If there are no elements in the list, then bail
	if (!this.size()) { return; }

	// if there is currently a selection anchor, then find the next/prev item
	// from the anchor
	var itemDiv = (this._kbAnchor)
		? this._getSiblingElement(this._kbAnchor, next)
		: this._parentEl.firstChild;

	this._scrollList(itemDiv);
	this._emulateSingleClick({target:itemDiv, button:DwtMouseEvent.LEFT, shiftKey:addSelect, kbNavEvent:kbNavEvent});
};

DwtListView.prototype._getSiblingElement =
function(element, next) {
	if (!element) { return null; }

	var el = next ? element.nextSibling : element.previousSibling;
	while (this._hasHiddenRows && el && !Dwt.getVisible(el)) {
		el = next ? el.nextSibling : el.previousSibling;
	}
	return (!el || (this._hasHiddenRows && !Dwt.getVisible(el))) ? element : el;
};

/**
 * This method will scroll the list to ensure that <code>itemDiv</code> is
 * scrolled into view.
 * 
 * @private
 */
DwtListView.prototype._scrollList =
function(itemDiv) {
	Dwt.scrollIntoView(itemDiv, itemDiv.parentNode);
};

DwtListView.prototype._setRowHeight =
function() {
	if (!this._rowHeight) {
		var row = this._parentEl.firstChild;
		this._rowHeight = row && Dwt.getSize(row).y;
	}
};

DwtListView.prototype._emulateSingleClick =
function(params) {
	this._clickDiv = this.findItemDiv(params.target);
	var mev = new DwtMouseEvent();
	this._setMouseEvent(mev, params);
	mev.kbNavEvent = params.kbNavEvent;
	this.notifyListeners(DwtEvent.ONMOUSEUP, mev);
};

/**
 * Sets the anchor row for selection and keyboard nav.
 *
 * Please note that merely assigning to this._kbAnchor is insufficient;
 * accessibility technologies require that the element receive browser focus as
 * well.
 *
 * @private
 *
 * @param {boolean|Element}		next	row to make anchor, or if true, move anchor
 * 										to next row
 */
DwtListView.prototype._setKbFocusElement = function(next, noSetFocus) {

	// If there are no elements in the list, then bail
	if (!this._list || !this._list.size()) {
		this._kbAnchor = null;
		this.setFocusElement(this.getHtmlElement());
        return;
    }

	if (this._kbAnchor) {
        this._setEventHdlrs([ DwtEvent.ONFOCUS, DwtEvent.ONBLUR ], true, this._kbAnchor);
		this._unmarkKbAnchorElement();
	}

	if (next && next !== true) {
		this._kbAnchor = next;
	}
    else if (this._kbAnchor) {
		this._kbAnchor = this._getSiblingElement(this._kbAnchor, next);
	}
    else {
		this._kbAnchor = this._parentEl.firstChild;
	}

    this.setFocusElement(this._kbAnchor);

    if (this._kbAnchor && !noSetFocus) {
		Dwt.addClass(this._kbAnchor, this._kbFocusClass);

		if (!this._duringFocusByMouseDown) {
			this._scrollList(this._kbAnchor);
		}

        var kbMgr = this.shell.getKeyboardMgr();
		if (this.hasFocus() || kbMgr.getFocusObj() === this) {
            kbMgr.grabFocus(this);
		}
	}
};

DwtListView.prototype._itemSelected =
function(itemDiv, ev) {
	if (this._allowLeftSelection(itemDiv, ev, ev && ev.button)) {
		/* Unmark the KB focus element. We need to do this because it is
		 * possible for this element to not be the same as the selection
		 * anchor due to NEXT and PREV keyboard actions */
		this._unmarkKbAnchorElement(true);

		// clear out old left click selection(s)
		this.deselectAll();

		// save new left click selection
		this._selectedItems.add(itemDiv);
		itemDiv.setAttribute('aria-selected', true);

		this._setKbFocusElement(itemDiv);
		this._selAnchor = itemDiv;
		Dwt.delClass(itemDiv, this._styleRe, this._selectedClass);
		if (this.hasFocus()) {
			Dwt.addClass(itemDiv, this._kbFocusClass);
		}

		var item = this.getItemFromElement(itemDiv);
		//since we now select a new item, unmark the list item that was marked as viewed but unselected (if any)
		this._markUnselectedViewedItem(false);
		this._curViewedItem = item;
		this.firstSelIndex = (this._list && item) ? this._list.indexOf(item) : -1;
		//DwtKeyboardMgr.grabFocus(this);
	}
};

DwtListView.prototype._itemClicked =
function(clickedEl, ev) {

	// always clear out old right click selection
	if (this._rightSelItem) {
		Dwt.delClass(this._rightSelItem, this._styleRe);	// , this._normalClass	MOW
		this._rightSelItem = null;
	}

	var numSelectedItems = this._selectedItems.size();
	var bContained = this._selectedItems.contains(clickedEl);

	if ((!ev.shiftKey && !ev.ctrlKey) || !this.isMultiSelectEnabled()) {
		// always reset detail if left/right click
		if (ev.button == DwtMouseEvent.LEFT || ev.button == DwtMouseEvent.RIGHT) {
			this._selEv.detail = DwtListView.ITEM_SELECTED;
		}

		if (ev.button == DwtMouseEvent.LEFT) {
			this._itemSelected(clickedEl, ev);
		}
		else if (ev.button == DwtMouseEvent.RIGHT && !bContained && this._evtMgr.isListenerRegistered(DwtEvent.ACTION)) {
			// Right click - OUTSIDE of selection
			// Deselect all - otherwise, we can have a selection that is already showing,
			// but the context menu is not applied to it - very confusing
			this.deselectAll();
			this._markUnselectedViewedItem(true);

			// save right click selection
			this._rightSelItem = clickedEl;
            Dwt.delClass(clickedEl, this._styleRe, this._rightClickClass);

            this._setKbFocusElement(clickedEl, true);
		}
	}
	else if (ev.button == DwtMouseEvent.LEFT) {
		if (ev.ctrlKey) {
			this.setMultiSelection(clickedEl, bContained, ev);
		} else { // SHIFT KEY
			// Adds to the selection to/from the current node to the selection anchor
			if (!this._selAnchor) { return; }
			var els = this._getChildren() || clickedEl.parentNode.childNodes;
			var numEls = els.length;
			var el;
			var state = 0;
			this._rightSelItem = null;

			this._selectedItems.removeAll();
			for (var i = 0; i < numEls; i++) {
				el = els[i];
				var item = this.getItemFromElement(el);
				if (item === null) {
					continue; //ignore separators
				}

				var selStyleClass = this._selectedClass;
				var include = (state === 1);
				if (el === clickedEl || el === this._selAnchor || el.id === clickedEl.id || el.id === this._selAnchor.id) {
					/* Increment the state.
					 * 0 - means we havent started
					 * 1 - means we are in selection range
					 * 2 - means we are out of selection range */
					state++;
					include = true; //the borders (clickedEl and _selAnchor) are both included in the selection.
				}
				if (include) {
					this._selectedItems.add(el);
					el.setAttribute('aria-selected', true);
					Dwt.delClass(el, this._styleRe, selStyleClass);
				}
				else if (el.className.indexOf(selStyleClass) !== -1) {
					Dwt.delClass(el, this._styleRe);		// , this._normalClass	MOW
					el.removeAttribute('aria-selected');
				}
			}

			this._setKbFocusElement(clickedEl);

			var newSelectedItems = this._selectedItems.size();
			if (numSelectedItems < newSelectedItems) {
				this._selEv.detail = DwtListView.ITEM_SELECTED;
			} else if (numSelectedItems > newSelectedItems) {
				this._selEv.detail = DwtListView.ITEM_DESELECTED;
			} else {
				return;
			}
		}
	}

	if (ev.button == DwtMouseEvent.LEFT && this._evtMgr.isListenerRegistered(DwtEvent.SELECTION)) {
		if (this._setListEvent(ev, this._selEv, clickedEl)) {
			this._evtMgr.notifyListeners(DwtEvent.SELECTION, this._selEv);
		}

		if (!this.hasFocus()) {
			this.focus();
		}
	} else if (ev.button == DwtMouseEvent.RIGHT && !ev.shiftKey && !ev.ctrlKey && this._evtMgr.isListenerRegistered(DwtEvent.ACTION)) {
		if (this._setListEvent(ev, this._actionEv, clickedEl)) {
			this._evtMgr.notifyListeners(DwtEvent.ACTION, this._actionEv);
		}
	}
};

DwtListView.prototype._focusByMouseDownEvent =
function() {
	// Do nothing, we'll focus manually later. If we focus now, the list will
	// jump to the top before an item is selected
};

/**
 * Creates a list event from a mouse event. Returns true if it is okay to notify listeners.
 * Subclasses may override to add more properties to the list event.
 *
 * @param	[DwtEvent]		mouse event
 * @param	[DwtEvent]		list event (selection or action)
 * @param	[element]		HTML element that received mouse click
 * 
 * @private
 */
DwtListView.prototype._setListEvent =
function(ev, listEv, clickedEl) {
	DwtUiEvent.copy(listEv, ev);
	listEv.kbNavEvent = ev.kbNavEvent;
	listEv.item = this.findItem(clickedEl);
	return true;
};

DwtListView.prototype._columnClicked =
function(clickedCol, ev) {
	var hdr = this.getItemFromElement(clickedCol);
	if (!(hdr._sortable && this.sortingEnabled)) { return; }

	var list = this.getList();
	var size = list ? list.size() : null;
	var customQuery = this._columnHasCustomQuery(hdr);
	if (!size && !customQuery) { return; }

	// reset order by sorting preference
	this._bSortAsc = (hdr._id === this._currentColId) ? !this._bSortAsc : this._isDefaultSortAscending(hdr);

	// reset arrows as necessary
	this._setSortedColStyle(hdr._id);

	// call sorting callback if more than one item to sort
	if (size >= 1 || customQuery) {
		this._sortColumn(hdr, this._bSortAsc);
	}
};

DwtListView.prototype._columnHasCustomQuery =
function(columnItem) {
	// overload me
	return false;
};

DwtListView.prototype._sortColumn =
function(columnItem, bSortAsc) {
	// overload me
};

DwtListView.prototype._getActionMenuForColHeader =
function() {
	// overload me if you want action menu for column headers
	return null;
};

DwtListView.prototype._isDefaultSortAscending =
function(colHeader) {
	// by default, always return ascending
	return true;
};

DwtListView.prototype._allowLeftSelection =
function(clickedEl, ev, button) {
	// overload me (and return false) if you dont want to actually select clickedEl
	return true;
};

DwtListView.prototype._setSortedColStyle = 
function(columnId) {
	
	if (this._currentColId && (columnId != this._currentColId)) {
		// unset current column arrow
		var headerCol = this._headerIdHash[this._currentColId];
		if (headerCol && !headerCol._noSortArrow) {
			var field = headerCol._field;
			var oldArrowId = DwtId.getListViewHdrId(DwtId.WIDGET_HDR_ARROW, this._view, field);
			var oldArrowCell = document.getElementById(oldArrowId);
			if (oldArrowCell && oldArrowCell.firstChild) {
				var imgEl = (AjxImg._mode == AjxImg.SINGLE_IMG) ? oldArrowCell.firstChild : oldArrowCell.firstChild.firstChild;
				if (imgEl) {
					imgEl.style.visibility = "hidden";
				}
			}
		}

		// reset style for old sorted column
		var oldSortedCol = document.getElementById(this._currentColId);
		if (oldSortedCol) {
			oldSortedCol.className = "DwtListView-Column";
		}
	}
	this._currentColId = columnId;
	var headerCol = this._headerIdHash[this._currentColId];

	// set new column arrow
	if (!headerCol._noSortArrow) {
		var field = headerCol._field;
		var newArrowId = DwtId.getListViewHdrId(DwtId.WIDGET_HDR_ARROW, this._view, field);
		var newArrowCell = document.getElementById(newArrowId);
		if (newArrowCell) {
			AjxImg.setImage(newArrowCell, this._bSortAsc ? "ColumnUpArrow" : "ColumnDownArrow");
			var imgEl = (AjxImg._mode == AjxImg.SINGLE_IMG) ? newArrowCell.firstChild : newArrowCell.firstChild.firstChild;
			if (imgEl) {
				imgEl.style.visibility = "visible";
			}
		}
	}
	
	// set new column style
	var newSortedCol = document.getElementById(columnId);
	if (newSortedCol) {
		newSortedCol.className = "DwtListView-Column DwtListView-ColumnActive";
	}
};

DwtListView.prototype._resetList =
function() {
	// clear out old list to force GC
	if (this._list && this._list.size()) {
		this._list.removeAll();
	}
	this._resetListView();
};

DwtListView.prototype._resetListView =
function() {
	// explicitly remove each child (setting innerHTML causes mem leak)
	var cDiv;
	while (this._parentEl && this._parentEl.hasChildNodes()) {
		var cDiv = this._parentEl.removeChild(this._parentEl.firstChild);
		this._data[cDiv.id] = null;
	}
	if (this._selectedItems) {
		this._selectedItems.removeAll();
	}
	this._rightSelItem = null;
};

DwtListView.prototype._destroyDragProxy =
function(icon) {
	this._data[icon.id] = null;
	DwtControl.prototype._destroyDragProxy.call(this, icon);
};

DwtListView.prototype._handleColHeaderMove = 
function(ev) {
	if (!this._headerClone) {
		if (!this._headerColX) {
			this._headerColX = ev.docX;
			return;
		} else {
			var threshold = Math.abs(this._headerColX - ev.docX);
			if (threshold < DwtListView.COL_MOVE_THRESHOLD) { return; }
		}
		
		// create a clone of the selected column to move
		this._headerClone = document.createElement("div");
		var size = Dwt.getSize(this._clickDiv);
		var width = AjxEnv.isIE ? size.x : size.x - 3;	// browser quirks
		var height = AjxEnv.isIE ? size.y : size.y - 5;
		Dwt.setSize(this._headerClone, width, height);
		Dwt.setPosition(this._headerClone, Dwt.ABSOLUTE_STYLE); 
		Dwt.setZIndex(this._headerClone, Dwt.Z_DND);
		Dwt.setLocation(this._headerClone, Dwt.DEFAULT, ev.docY);
		
		this._headerClone.className = this._clickDiv.className + " DragProxy";
		this._headerClone.innerHTML = this._clickDiv.innerHTML;
		this._clickDiv.className = "DwtListView-Column DwtListView-ColumnEmpty";
		
		// XXX: style hacks - improve this later
		this._headerClone.style.borderTop = "1px solid #777777";

		var headerCol = this._headerIdHash[this._clickDiv.id];
		var field = headerCol._field;
		var hdrLabelId = DwtId.getListViewHdrId(DwtId.WIDGET_HDR_LABEL, this._view, field);
		var labelCell = document.getElementById(hdrLabelId);
		if (labelCell) {
			labelCell.style.color = "#FFFFFF";
		}
		this.shell.getHtmlElement().appendChild(this._headerClone);
	} else {
		var div = this.getTargetItemDiv(ev);
		var type = this._getItemData(div, "type");
		if (type == DwtListView.TYPE_HEADER_ITEM) {
			if (this._headerCloneTarget && (this._headerCloneTarget == this._clickDiv)) {
				this._headerCloneTarget = null;
			} else if (this._headerCloneTarget != div) { 
				this._headerCloneTarget = div;
			}
		} else {
			this._headerCloneTarget = null;
		}
	}

	if (this._headerClone) {
		Dwt.setLocation(this._headerClone, ev.docX + 2);
	}
};

DwtListView.prototype._handleColHeaderResize = 
function(ev) {
	if (!this._headerSash) {
		this._headerSash = document.createElement("div");

		Dwt.setSize(this._headerSash, Dwt.DEFAULT, this.getSize().y);
		Dwt.setPosition(this._headerSash, Dwt.ABSOLUTE_STYLE); 
		Dwt.setZIndex(this._headerSash, Dwt.Z_DND);
		var sashLoc = this._getHeaderSashLocation();
		this._headerSashFudgeX = sashLoc.x;
		Dwt.setLocation(this._headerSash, Dwt.DEFAULT, sashLoc.y);

		this._headerSash.className = "DwtListView-ColumnSash";
		this.getHtmlElement().appendChild(this._headerSash);
		
		// remember the initial x-position
		this._headerSashX = ev.docX;
	}
	
	// always update the sash's position
	var parent = this._getParentForColResize();
	var loc = Dwt.toWindow(parent.getHtmlElement(), 0 ,0);
	Dwt.setLocation(this._headerSash, (ev.docX - loc.x) + this._headerSashFudgeX);
};

DwtListView.prototype._getHeaderSashLocation =
function() {
	if (!this._tmpPoint) {
		this._tmpPoint = new DwtPoint();
	}
	this._tmpPoint.x = 0;
	this._tmpPoint.y = 0;
	return this._tmpPoint;
};

DwtListView.prototype._handleColHeaderDrop = 
function(ev) {
	this._headerColX = null;

	if (this._headerClone == null || ev.button == DwtMouseEvent.RIGHT) { return false; }
	
	// did the user drop the column on a valid target?
	if (this._headerCloneTarget) {
		var divItemIdx = this._getItemData(this._clickDiv, "index");
		var tgtItemIdx = this._getItemData(this._headerCloneTarget, "index");
		this._reIndexColumn(divItemIdx, tgtItemIdx);
	}

	this._clickDiv.className = (this._clickDiv.id != this._currentColId)
		? "DwtListView-Column" : "DwtListView-Column DwtListView-ColumnActive";

	// clean up
	var parent = this._headerClone.parentNode;
	if (parent) {
		parent.removeChild(this._headerClone);
	}
	delete this._headerClone;

	var data = this._data[this._clickDiv.id];
	if (data.type != DwtListView.TYPE_HEADER_ITEM) {
		// something is messed up! redraw the header
		var headerCol = this._headerIdHash[this._currentColId];
		var sortField = headerCol._sortable ? headerCol._field : null;
		this.headerColCreated = false;
		this.createHeaderHtml(sortField);
	} else {
		// reset styles as necessary
		var headerCol = this._headerIdHash[this._clickDiv.id];
		var hdrLabelId = DwtId.getListViewHdrId(DwtId.WIDGET_HDR_LABEL, this._view, headerCol._field);
		var labelCell = document.getElementById(hdrLabelId);
		if (labelCell) {
			labelCell.style.color = "#000000";
		}
	}

	// force all relative widths to be static
	for (var i = 0; i < this._headerList.length; i++) {
		this._headerList[i]._width = this._calcRelativeWidth(i);
	}

	this._resetColWidth();

	return true;
};

DwtListView.prototype._reIndexColumn =
function(columnIdx, newIdx) {
	// do some sanity checks before continuing
	if (!this._headerList) { return; }
	var len = this._headerList.length;
	if (columnIdx < 0 || newIdx < 0 || columnIdx >= len || newIdx >= len || columnIdx == newIdx) { return; }

	// reindex the header list
	var temp = this._headerList.splice(columnIdx, 1);
	this._headerList.splice(newIdx, 0, temp[0]);

	// finally, relayout the list view (incl. header columns)
	this._relayout();
};

/**
 * Per bug #15853, the change in column width will remove width from the last
 * column unless the change makes the width of the last column less than
 * MIN_COLUMN_WIDTH.
 *
 * @param ev
 * 
 * @private
 */
DwtListView.prototype._handleColSashDrop =
function(ev) {
	if (this._headerSash == null || ev.button == DwtMouseEvent.RIGHT) {	return false; }
		
	// destroy the sash
	var parent = this._headerSash.parentNode;
	if (parent) {
		parent.removeChild(this._headerSash);
	}
	delete this._headerSash;

	// force all relative widths to be static
	for (var i = 0; i < this._headerList.length; i++) {
		this._headerList[i]._width = this._calcRelativeWidth(i);
	}

	// find out where the user dropped the sash and update column width
	var headerIdx = this._getItemData(this._clickDiv, "index");
	if (headerIdx == null) { return false; }

	var delta = ev.docX - this._headerSashX;

	var fcol = this._headerList[headerIdx];

	var col1 = fcol;
	var col2;// = this._variableHeaderCol;
	var resized = [];

	if (delta < 0) {
		if ((col1 == col2) || !col2) {
			col2 = this._getNextResizeableColumnHeader(col1);
		}
		if (!col2) return false;
		//delta =    - Math.min(fcol._width - DwtListView.MIN_COLUMN_WIDTH, -delta);
		delta = Math.max(DwtListView.MIN_COLUMN_WIDTH - fcol._width, delta);
		fcol._width = Math.max(fcol._width + delta, DwtListView.MIN_COLUMN_WIDTH);
		col2._width = Math.max(this._calcRelativeWidth(col2._index) - delta, DwtListView.MIN_COLUMN_WIDTH);
		resized.push(fcol._index, col2._index);
		
	} else if (delta > 0) {

		var remain = delta;
		while (remain > 0) {
			if ((col1 == col2) || !col2) {
				col2 = this._getNextResizeableColumnHeader(col1, [], false);
			}
			//if (!col2) return false;
			if (!col2) {
				delta -= remain;
				break;
			}
			var col2width = this._calcRelativeWidth(col2._index);
			var room = col2width - DwtListView.MIN_COLUMN_WIDTH;
			
			if (remain > room) { // There column is too small to be fully resized
				remain -= room;
				col2width = DwtListView.MIN_COLUMN_WIDTH;
			} else { // The column is not too small; all the requested delta may be taken from this column
				col2width -= remain;
				remain = 0;
			}
			col2._width = col2width;
			resized.push(col2._index);
			col1 = col2;
		}
	
		fcol._width = Math.max(fcol._width + delta, DwtListView.MIN_COLUMN_WIDTH);
		resized.push(fcol._index);

	}

	var col = this._getNextResizeableColumnHeader(fcol, resized, true);
	if (col) {
		col._width = "auto";
	}

	this._relayout();
	//recalculate the css styles after the width changes (_restColWidth calls recalculateCssStyle)
	this._resetColWidth();

	return true;
};

DwtListView.prototype.recalculateCssStyle =
function() {
	for (var i = 0; i < this._headerList.length; i++) {
		var headerCol = this._headerList[i];
		this._createHeaderCssStyle(headerCol, this._calcRelativeWidth(i));
	}
};

DwtListView.prototype._calcRelativeWidth =
function(headerIdx) {
	var column = this._headerList[headerIdx];
	if (!column._width || (column._width && column._width == "auto")) {
		var cell = document.getElementById(column._id);
		// UGH: clientWidth is 5px more than HTML-width (4px for IE)
		return (cell) ? (cell.clientWidth - (AjxEnv.isIE ? 4 : 5)) : null;
	}
	return column._width;
};

// This method will add padding to the *last* column depending on whether
// scrollbars are shown or not.
DwtListView.prototype._resetColWidth =
function() {

	if (!this.headerColCreated) { return; }

	var lastColIdx = this._getLastColumnIndex();
    if (lastColIdx) {
        var lastCol = this._headerList[lastColIdx];
        var lastCell = document.getElementById(lastCol._id);
		if (lastCell) {
			var div = lastCell.firstChild;
			var scrollbarPad = 16;

			var headerWidth = this._listColDiv.clientWidth;
			var rowWidth = this._listDiv.clientWidth;

			if (headerWidth != rowWidth) {
				lastCell.style.width = div.style.width = (lastCol._width != null && lastCol._width != "auto")
					? (lastCol._width + scrollbarPad  + "px")
					: (lastCell.clientWidth + scrollbarPad + "px");
			}
			else {
				Dwt.setSize(lastCell, lastCol._width, Dwt.DEFAULT);
				Dwt.setSize(div, lastCol._width, Dwt.DEFAULT);
			}
			this.recalculateCssStyle(); //make sure to call this AFTER modifying the last col width.
		}
    }
};

/**
 * Dynamically get column index for last column b/c columns may or may not be
 * visible.
 */
DwtListView.prototype._getLastColumnIndex =
function() {
	var lastColIdx = null;
	if (this._headerList) {
		var count = this._headerList.length - 1;
		while (lastColIdx == null && count >= 0) {
			if (this._headerList[count]._visible) {
				lastColIdx = count;
			}
			count--;
		}
	}
	return lastColIdx;
};

/**
 * Returns the index of the next resizeable (and visible) column after the one
 * with the given index. If it doesn't find one to the right, starts over at the
 * first column.
 *
 * @param start		[int]		index of reference column
 * @param exclude	[array]		list of indices to exclude
 * 
 * @private
 */
DwtListView.prototype._getNextResizeableColumnIndex =
function(start, exclude, wrap) {

	exclude = exclude ? AjxUtil.arrayAsHash(exclude) : {};
	exclude[start] = true;
	if (this._headerList) {
		for (var i = start + 1; i < this._headerList.length; i++) {
			var col = this._headerList[i];
			if (exclude[i]) { continue; }
			if (col._visible && col._resizeable) {
				return i;
			}
		}
		if (wrap) {
			for (var i = 0; i < start; i++) {
				if (exclude[i]) { continue; }
				var col = this._headerList[i];
				if (col._visible && col._resizeable) {
					return i;
				}
			}
		}
	}
	return null;
};

DwtListView.prototype._getNextResizeableColumnHeader =
function(start, exclude, wrap) {
	var index = this._getNextResizeableColumnIndex(start._index, exclude, wrap);
	return (index !== null) ? this._headerList[index] : false;
}

DwtListView.prototype._relayout =
function() {
	// force relayout of header column
	this.headerColCreated = false;
	var headerCol = this._headerIdHash[this._currentColId];
	var sortField = (headerCol && headerCol._sortable) ? headerCol._field : null;
	var sel = this.getSelection()[0];
	this.setUI(sortField);
	this.setSelection(sel, true);
};

DwtListView.prototype._getParentForColResize = 
function() {
	// overload me to return a higher inheritance chain parent
	return this;
};

DwtListView.prototype._sizeChildren =
function(height) {
	if (this.headerColCreated && this._listDiv && (height != Dwt.DEFAULT)) {
		Dwt.setSize(this._listDiv, Dwt.DEFAULT, height - DwtListView.HEADERITEM_HEIGHT);
		return true;
	} else {
		return false;
	}
};

// overload if parent element's children are not DIV's (i.e. div's w/in a table)
DwtListView.prototype._getChildren = 
function() {
	return null;
};

DwtListView.prototype._focus =
function() {
	if (this.size() == 0) { return; }

	if (this._kbAnchor) {
		Dwt.addClass(this._kbAnchor, this._kbFocusClass);
	} else {
		this._setKbFocusElement(null, true);
	}
};

DwtListView.prototype._blur =
function() {
	this._unmarkKbAnchorElement();
};

/**
 * Removes the "focus style" from the current KB anchor.
 * 
 * @param clear		[boolean]*		if true, clear KB anchor
 */
DwtListView.prototype._unmarkKbAnchorElement =
function(clear) {
	if (this._kbAnchor) {
		Dwt.delClass(this._kbAnchor, this._kbFocusClass);
	}
	if (clear) {
		this._kbAnchor = null;
	}
};

DwtListView.prototype._getFirstItem =
function() {
	var a = this._list.getArray();
	if (a && a.length > 1) {
		return a[0];
	}
	return null;
};

DwtListView.prototype._getLastItem =
function() {
	var a = this._list.getArray();
	if (a && a.length > 1) {
		return a[a.length - 1];
	}
	return null;
};

/**
 * DwtListHeaderItem
 * This is a (optional) "container" class for DwtListView objects which want a
 * column header to appear. Create a new DwtListViewItem for each column header
 * you want to appear. Be sure to specify width values (otherwise, undefined is
 * default)
 *
 * @param params		[hash]		hash of params:
 *        field			[int]		identifier for this column
 *        text	 		[string]*	text shown for the column
 *        icon	 		[string]*	icon shown for the column
 *        width 		[int]*		width of the column
 *        sortable 		[boolean]*	flag indicating whether column is sortable
 *        resizeable 	[boolean]*	flag indicating whether column can be resized
 *        visible 		[boolean]*	flag indicating whether column is initially visible
 *        name 			[string]*	description of column used if column headers have action menu
 * 									- if not supplied, uses label value. This param is
 *									primarily used for columns w/ only an icon (no label).
 *        align			[int]		alignment style of label
 *        noRemove		[boolean]*	flag indicating whether this column can be removed (overrides visible flag)
 *        view			[constant]	ID of owning view
 *        noSortArrow	[boolean]*	if true, do not show up/down sort arrow in column
 *        tooltip		[string]*	tooltip
 *        
 * @private
 */
DwtListHeaderItem = function(params) {

	if (arguments.length == 0) { return; }
	params = Dwt.getParams(arguments, DwtListView.PARAMS);

	this._field = params.field;
	this._label = params.text;
	this._iconInfo = params.icon;
	this._sortable = params.sortable;
	this._noSortArrow = params.noSortArrow;
	this._resizeable = params.resizeable;
	this._visible = (params.visible !== false); // default to visible
	this._name = params.name || params.text;
	this._align = params.align;
	this._noRemove = params.noRemove;
	this._tooltip = params.tooltip;
	this._cssClass = params.cssClass;
	
	// width:
	var w = parseInt(params.width);
	if (isNaN(w) || !w) {
		this._width = "auto";
		this._variable = true;
		this._resizeable = true;
	} else if (String(w) == String(params.width)) {
		this._width = w;
	} else {
		this._width = parseInt(String(params.width).substr(0, String(w).length));
		this._widthUnits = AjxStringUtil.getUnitsFromSizeString(params.width);
	}
};

DwtListHeaderItem.prototype.isDwtListHeaderItem = true;
DwtListHeaderItem.prototype.toString = function() { return "DwtListHeaderItem"; };

DwtListHeaderItem.PARAMS = ["id", "text", "icon", "width", "sortable", "resizeable", "visible", "name", "align", "noRemove", "view"];

DwtListHeaderItem.sortCompare =
function(a, b) {
	return a._index < b._index ? -1 : (a._index > b._index ? 1 : 0);
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtButton")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * @overview
 * This file defines a button.
 *
 */

/**
 * Creates a button.
 * @class
 * This class represents a button, which is basically a smart label that can handle
 * various UI events. It knows when it has been hovered (the mouse is over it),
 * when it is active (mouse down), and when it has been pressed (mouse up).
 * In addition to a label's image and/or text, a button may have a dropdown menu.
 * <p>
 * There are several different types of button:
 * <ul>
 * <li><i>Push</i> - This is the standard push button</li>
 * <li><i>Toggle</i> - This is a button that exhibits selectable behaviour when clicked
 * 		e.g. on/off. To make a button selectable style "or" {@link DwtButton.SELECT_STYLE}
 * 		to the constructor's style parameter</li>
 * <li><i>Menu</i> - By setting a mene via the {@link #setMenu} method a button will become
 * 		a drop down or menu button.</li>
 * </ul>
 *
 * <h4>CSS</h4>
 * <ul>
 * <li><i>className</i>-hover - hovered style</li>
 * <li><i>className</i>-active - mouse down style</li>
 * <li><i>className</i>-selected - permanently down style</li>
 * <li><i>className</i>-disabled - disabled style</li>
 * </ul>
 *
 * <h4>Keyboard Actions</h4>
 * <ul>
 * <li>{@link DwtKeyMap.SELECT} - triggers the button</li>
 * <li>{@link DwtKeyMap.SUBMENU} - display's the button's submenu if one is set</li>
 * </ul>
 *
 * @author Ross Dargahi
 * @author Conrad Damon
 * 
 * @param {hash}	params		a hash of parameters
 * @param {DwtComposite}	params.parent	the parent widget
 * @param {constant}	params.style		the button style
 * @param {string}	params.className		the CSS class
 * @param {constant}	params.posStyle		the positioning style
 * @param {DwtButton.ACTION_MOUSEUP|DwtButton.ACTION_MOUSEDOWN}	params.actionTiming	if {@link DwtButton.ACTION_MOUSEUP}, then the button is triggered
 *											on mouseup events, else if {@link DwtButton.ACTION_MOUSEDOWN},
 * 											then the button is triggered on mousedown events
 * @param {string}	params.id		the id to use for the control HTML element
 * @param {number}	params.index 		the index at which to add this control among parent's children
 * @param {hash}	params.listeners		a hash of event listeners
 *        
 * @extends		DwtLabel
 */
DwtButton = function(params) {
	if (arguments.length == 0) { return; }
	params = Dwt.getParams(arguments, DwtButton.PARAMS);
	
	params.className = params.className || "ZButton";
	DwtLabel.call(this, params);

	var parent = params.parent;
	if (!parent._hasSetMouseEvents || AjxEnv.isIE) {
		this._setMouseEvents();
	}
	
	var events;
	if (parent._hasSetMouseEvents) {
		events = AjxEnv.isIE ? [DwtEvent.ONMOUSEENTER, DwtEvent.ONMOUSELEAVE] : [];
	} else {
		events = AjxEnv.isIE
			? [DwtEvent.ONMOUSEENTER, DwtEvent.ONMOUSELEAVE]
			: [DwtEvent.ONMOUSEOVER, DwtEvent.ONMOUSEOUT];
		events.push(DwtEvent.ONMOUSEDOWN, DwtEvent.ONMOUSEUP, DwtEvent.ONCLICK);
	}
	if (events && events.length) {
		this._setEventHdlrs(events);
	}
	this._listeners = params.listeners || DwtButton._listeners;
	this._addMouseListeners();
	this._ignoreInternalOverOut = true;
	
	this._dropDownEvtMgr = new AjxEventMgr();

	this._selected = false;

	this._actionTiming = params.actionTiming || DwtButton.ACTION_MOUSEUP;
	this.__preventMenuFocus = null;
	this._menuPopupStyle = DwtButton.MENU_POPUP_STYLE_BELOW;
};

DwtButton.prototype = new DwtLabel;
DwtButton.prototype.constructor = DwtButton;

DwtButton.prototype.isDwtButton = true;
DwtButton.prototype.toString = function() { return "DwtButton"; };

DwtButton.prototype.role = 'button';

//
// Constants
//
DwtButton.PARAMS = ["parent", "style", "className", "posStyle", "actionTiming", "id", "index", "listeners"];
DwtButton.TOGGLE_STYLE = DwtLabel._LAST_STYLE * 2; // NOTE: These must be powers of 2 because we do bit-arithmetic to check the style.
DwtButton.ALWAYS_FLAT = DwtLabel._LAST_STYLE * 4;
DwtButton._LAST_STYLE = DwtButton.ALWAYS_FLAT;

DwtButton.ACTION_MOUSEUP = 1;
DwtButton.ACTION_MOUSEDOWN = 2; // No special appearance when hovered or active

DwtButton.NOTIFY_WINDOW = 500;  // Time (in ms) during which to block additional clicks from being processed

DwtButton.MENU_POPUP_STYLE_BELOW	= "BELOW";		// menu pops up just below the button (default)
DwtButton.MENU_POPUP_STYLE_ABOVE	= "ABOVE";		// menu pops up above the button
DwtButton.MENU_POPUP_STYLE_RIGHT	= "RIGHT";		// menu pops up below the button, with right edges aligned
DwtButton.MENU_POPUP_STYLE_CASCADE	= "CASCADE";	// menu pops up to right of the button

DwtButton.MOUSE_EVENTS = [DwtEvent.ONMOUSEDOWN, DwtEvent.ONMOUSEUP];

if (AjxEnv.isIE) {
	DwtButton.MOUSE_EVENTS.push(DwtEvent.ONMOUSEENTER, DwtEvent.ONMOUSELEAVE);
} else {
	DwtButton.MOUSE_EVENTS.push(DwtEvent.ONMOUSEOVER, DwtEvent.ONMOUSEOUT);
}

//
// Data
//
DwtButton.prototype.TEMPLATE = "dwt.Widgets#ZButton";

//
// Public methods
//

/**
 * Disposes of the button.
 * 
 */
DwtButton.prototype.dispose =
function() {
	if (this._menu && this._menu.isDwtMenu && (this._menu.parent == this)) {
		this._menu.dispose();
		this._menu = null;
	}
	DwtLabel.prototype.dispose.call(this);
};

/**
 * Adds a listener to be notified when the button is pressed.
 *
 * @param {AjxListener}	listener	the listener
 * @param {number}	index		the index at which to add listener
 */
DwtButton.prototype.addSelectionListener =
function(listener, index) {
	this.addListener(DwtEvent.SELECTION, listener, index);
};

/**
 * Removes a selection listener.
 *
 * @param {AjxListener}		listener	the listener to remove
 */
DwtButton.prototype.removeSelectionListener =
function(listener) {
	this.removeListener(DwtEvent.SELECTION, listener);
};

/**
 * Removes all the selection listeners.
 */
DwtButton.prototype.removeSelectionListeners =
function() {
	this.removeAllListeners(DwtEvent.SELECTION);
};

/**
 * Adds a listener to be notified when the dropdown arrow is pressed.
 *
 * @param {AjxListener}		listener	the listener
 */
DwtButton.prototype.addDropDownSelectionListener =
function(listener) {
	return this._dropDownEvtMgr.addListener(DwtEvent.SELECTION, listener);
};

/**
 * Removes a dropdown selection listener.
 *
 * @param {AjxListener}		listener	the listener to remove
 */
DwtButton.prototype.removeDropDownSelectionListener =
function(listener) {
	this._dropDownEvtMgr.removeListener(DwtEvent.SELECTION, listener);
};

// defaults for drop down images (set here once on prototype rather than on each button instance)
DwtButton.prototype._dropDownImg 	= "SelectPullDownArrow";
DwtButton.prototype._dropDownDepImg	= "SelectPullDownArrow";
DwtButton.prototype._dropDownHovImg = "SelectPullDownArrowHover";

/**
 * Sets the dropdown images.
 * 
 * @param	{string}	enabledImg		the enabled image
 * @param	{string}	disImg		the disabled image
 * @param	{string}	hovImg		the hover image
 * @param	{string}	depImg		the depressed image
 */
DwtButton.prototype.setDropDownImages =
function (enabledImg, disImg, hovImg, depImg) {
	this._dropDownImg = enabledImg;
	this._dropDownHovImg = hovImg;
	this._dropDownDepImg = depImg;
};

/**
 * Sets the Drop Down Hover Image
 */
DwtButton.prototype.setDropDownHovImage =
function(hovImg) {
    this._dropDownHovImg = hovImg;    
}

/**
 * @private
 */
DwtButton.prototype._addMouseListeners =
function() {
	AjxUtil.foreach(DwtButton.MOUSE_EVENTS, (function(event) {
		this.addListener(event, this._listeners[event]);
	}).bind(this));
};

/**
 * @private
 */
DwtButton.prototype._removeMouseListeners =
function() {
	AjxUtil.foreach(DwtButton.MOUSE_EVENTS, (function(event) {
		this.removeListener(event, this._listeners[event]);
	}).bind(this));
};

/**
 * Sets the display state.
 * 
 * @param	{string}	state		the display state
 * @param	{boolean}	force		if <code>true</code>, force the state change
 * @see		DwtControl
 */
DwtButton.prototype.setDisplayState =
function(state, force) {
    if (this._selected && state != DwtControl.SELECTED && !force) {
        state = [ DwtControl.SELECTED, state ].join(" ");
    }
    DwtLabel.prototype.setDisplayState.call(this, state);
};

/**
 * Sets the enabled/disabled state of the button. A disabled button may have a different
 * image, and greyed out text. The button (and its menu) will only have listeners if it
 * is enabled.
 *
 * @param {boolean}	enabled			if <code>true</code>, enable the button
 *
 */
DwtButton.prototype.setEnabled =
function(enabled) {
	if (enabled != this._enabled) {
		DwtLabel.prototype.setEnabled.call(this, enabled); // handles image/text
        if (enabled) {
			// bug fix #36253 - HACK for IE. ARGH!!!
			var el = (AjxEnv.isIE) ? this.getHtmlElement().firstChild : null;
			if (el) {
				var cname = el.className;
				el.className = "";
				el.className = cname;
			}
			this._addMouseListeners();
			// set event handler for pull down menu if applicable
			if (this._menu) {
				this._setDropDownCellMouseHandlers(true);
                if (this._dropDownEl && this._dropDownImg) {
                    AjxImg.setImage(this._dropDownEl, this._dropDownImg);
                }
            }

		} else {
			this._removeMouseListeners();
			// remove event handlers for pull down menu if applicable
			if (this._menu) {
				this._setDropDownCellMouseHandlers(false);
                if (this._dropDownEl && this._dropDownImg) {
                    AjxImg.setDisabledImage(this._dropDownEl, this._dropDownImg);
                }
			}
		}
	}
};

/**
 * Sets the main (enabled) image. If the button is currently enabled, the image is updated.
 * 
 * @param	{string}	imageInfo		the image
 */
DwtButton.prototype.setImage =
function(imageInfo, direction) {
	// This button is set to not show image. Doing it here is safer against bugs resulting from dynamically modified images and text such as teh case of spam vs. "no spam".
	// This way you don't have to worry in that code whether we show image or not (Which could change for example as it does in this bug when moving the button to the main buttons).
	if (this.whatToShow && !this.whatToShow.showImage) {
		return;
	}
	DwtLabel.prototype.setImage.apply(this, arguments);
	this._setMinWidth();
};

/**
 * Sets the text.
 * 
 * @param	{string}	text		the text
 */
DwtButton.prototype.setText =
function(text) {

	//see explanation in setImage
	if (this.whatToShow && !this.whatToShow.showText) {
		return;
	}
	DwtLabel.prototype.setText.call(this, text);
	this._setMinWidth();
};

/**
 * @private
 */
DwtButton.prototype._setMinWidth =
function() {
	if (this.getText() != null) {
		Dwt.addClass(this.getHtmlElement(), "ZHasText");
	} else {
		Dwt.delClass(this.getHtmlElement(), "ZHasText");
	}
};

/**
 * Sets the hover image.
 * 
 * @param	{string}	hoverImageInfo		the image
 * @param	{string}	direction			position of the image
 */
DwtButton.prototype.setHoverImage =
function (hoverImageInfo, direction) {
	direction = direction || (this._style & DwtLabel.IMAGE_RIGHT ? DwtLabel.RIGHT : DwtLabel.LEFT);
	this._hoverImageInfo = this._hoverImageInfo || {};
	this._hoverImageInfo[direction] = hoverImageInfo;
};

/**
 * Adds a dropdown menu to the button, available through a small down-arrow. If a
 * callback is passed as the dropdown menu, it is called the first time the
 * menu is requested. The callback must return a valid DwtMenu object.
 *
 * @param {hash}				params				hash of params:
 * @param {DwtMenu|AjxCallback}	menu				the dropdown menu or a callback
 * @param {boolean}				shouldToggle		if <code>true</code>, toggle
 * @param {string}				menuPopupStyle		one of DwtButton.MENU_POPUP_STYLE_* (default is BELOW)
 * @param {boolean}				popupAbove			if <code>true</code>, pop up the menu above the button
 * @param {boolean}				popupRight			if <code>true</code>, align the right edge of the menu to the right edge of the button
 */
DwtButton.prototype.setMenu =
function(params) {
	
	params = Dwt.getParams(arguments, DwtButton.setMenuParams, (arguments.length == 1 && arguments[0] && !arguments[0].menu));

    if (params){
	    this._menu = params.menu;
    }

	if (this._menu) {
		// if menu is a callback, wait until it's created to set menu-related properties
		if (this._menu.isDwtMenu) {
			this._shouldToggleMenu = (params.shouldToggle === true);
			if (params.popupAbove) {
				this._menuPopupStyle = DwtButton.MENU_POPUP_STYLE_ABOVE;
			}
			else if (params.popupRight) {
				this._menuPopupStyle = DwtButton.MENU_POPUP_STYLE_RIGHT;
			}
			else {
				this._menuPopupStyle = params.menuPopupStyle || DwtButton.MENU_POPUP_STYLE_BELOW;
			}
			this._menuAdded(this._menu);
		}
		else {
			this._savedMenuParams = params;
		}
        if (this._dropDownEl) {
			Dwt.addClass(this.getHtmlElement(), "ZHasDropDown");
			if (this._dropDownImg) {
            	AjxImg.setImage(this._dropDownEl, this._dropDownImg);
			}

			// set event handler if applicable
			if (this._enabled) {
				this._setDropDownCellMouseHandlers(true);
			}

            if (this._menu.isDwtMenu) {
                this._menu.setAssociatedElementId(this._dropDownEl.id);
            }
		}
		if ((this.__preventMenuFocus != null) && this._menu.isDwtMenu) {
			this._menu.dontStealFocus(this.__preventMenuFocus);
		}
    }
	// removing menu
    else if (this._dropDownEl) {
		Dwt.delClass(this.getHtmlElement(), "ZHasDropDown");
        this._dropDownEl.innerHTML = "";
    }
};
DwtButton.setMenuParams = ["menu", "shouldToggle", "followIconStyle", "popupAbove", "popupRight"];

/**
 * @private
 */
DwtButton.prototype._setDropDownCellMouseHandlers =
function(set) {
	this._dropDownEventsEnabled = set;
};

/**
* Gets the button menu.
*
* @param {boolean}		dontCreate	 if <code>true</code>, the menu will not be lazily created
* @return	{DwtMenu}	the menu or <code>null</code> if menu is not set
*/
DwtButton.prototype.getMenu =
function(dontCreate) {
	if (this._menu && this._menu.isAjxCallback) {
		if (dontCreate) {
			return null;
		}
		var callback = this._menu;
		var params = this._savedMenuParams || {};
		params.menu = callback.run(this);
		this.setMenu(params);
		if ((this.__preventMenuFocus != null) && (this._menu.isDwtMenu)) {
			this._menu.dontStealFocus(this.__preventMenuFocus);
		}
	}
    if (this._menu) {
        this.setAttribute("menuId", this._menu._htmlElId);
    }
    return this._menu;
};

/**
 * Resets the button display to normal (not hovered or active).
 * 
 */
DwtButton.prototype.resetClassName =
function() {
    this.setDisplayState(DwtControl.NORMAL);
};

/**
 * Sets whether actions for this button should occur on mouse up or mouse down.
 *
 * @param	{DwtButton.ACTION_MOUSEDOWN|DwtButton.ACTION_MOUSEUP}		actionTiming		the action timing
 */
DwtButton.prototype.setActionTiming =
function(actionTiming) {
      this._actionTiming = actionTiming;
};

/**
 * Activates/de-activates the button. A button is hovered when the mouse is over it.
 *
 * @param {boolean}	hovered		if <code>true</code>, the button is hovered
 */
DwtButton.prototype.setHovered =
function(hovered) {
    this.setDisplayState(hovered ? DwtControl.HOVER : DwtControl.NORMAL);
};

/**
 * Sets the enabled image
 * 
 * @param	{string}	imageInfo	the image
 */
DwtButton.prototype.setEnabledImage =
function (imageInfo) {
	this._enabledImageInfo = imageInfo;
	this.setImage(imageInfo);
};

/**
 * Sets the depressed image
 * 
 * @param	{string}	imageInfo	the image
 */
DwtButton.prototype.setDepressedImage =
function (imageInfo) {
    this._depressedImageInfo = imageInfo;
};

/**
 * Sets the button as selected.
 * 
 * @param	{boolean}	selected		if <code>true</code>, the button is selected
 */
DwtButton.prototype.setSelected =
function(selected) {
	if (this._selected != selected) {
		this._selected = selected;
        this.setDisplayState(selected ? DwtControl.SELECTED : DwtControl.NORMAL);
    }
};

/**
 * Checks if the button is toggled.
 * 
 * @return	{boolean}	<code>true</code> if toggled
 */
DwtButton.prototype.isToggled =
function() {
	return this._selected;
};

/**
 * Pops-up the button menu (if present).
 * 
 * @param	{DwtMenu}	menu		the menu to use or <code>null</code> to use currently set menu
 */
DwtButton.prototype.popup =
function(menu, event) {
	menu = menu || this.getMenu();

    if (!menu) { return; }

    var parent = menu.parent;
	var parentBounds = parent.getBounds();
	var windowSize = menu.shell.getSize();
	var menuSize = menu.getSize();
	var parentElement = parent.getHtmlElement();
	// since buttons are often absolutely positioned, and menus aren't, we need x,y relative to window
	var parentLocation = Dwt.toWindow(parentElement, 0, 0);
	var leftBorder = (parentElement.style.borderLeftWidth == "") ? 0 : parseInt(parentElement.style.borderLeftWidth);
	var kbGenerated = Boolean(event && DwtKeyEvent.isKeyEvent(event));

	var x;
	if (this._menuPopupStyle == DwtButton.MENU_POPUP_STYLE_RIGHT) {
		x = parentLocation.x + parentBounds.width - menuSize.x;
	}
	else if (this._menuPopupStyle == DwtButton.MENU_POPUP_STYLE_CASCADE) {
		x = parentLocation.x + parentBounds.width;
	}
	else {
		x = parentLocation.x + leftBorder;
		x = ((x + menuSize.x) >= windowSize.x) ? windowSize.x - menuSize.x : x;
	}

	var y;
	if (this._menuPopupStyle == DwtButton.MENU_POPUP_STYLE_ABOVE) {
		y = parentLocation.y - menuSize.y;
	}
	else if (this._menuPopupStyle == DwtButton.MENU_POPUP_STYLE_CASCADE) {
		y = parentLocation.y;
	}
	else {
		var horizontalBorder = (parentElement.style.borderTopWidth == "") ? 0 : parseInt(parentElement.style.borderTopWidth);
		horizontalBorder += (parentElement.style.borderBottomWidth == "") ? 0 : parseInt(parentElement.style.borderBottomWidth);
		y = parentLocation.y + parentBounds.height + horizontalBorder;
	}
	menu.popup(0, x, y, kbGenerated);
	menu.setSelectedItem(0);
};

/**
 * Gets the key map name.
 * 
 * @return	{string}	the key map name
 */
DwtButton.prototype.getKeyMapName =
function() {
	return DwtKeyMap.MAP_BUTTON;
};

/**
 * Handles a key action event.
 * 
 * @param	{constant}		actionCode		the action code (see {@link DwtKeyMap})
 * @param	{DwtEvent}		ev		the event
 * @return	{boolean}		<code>true</code> if the event is handled; <code>false</code> otherwise
 * @see		DwtKeyMap
 */
DwtButton.prototype.handleKeyAction =
function(actionCode, ev) {
	switch (actionCode) {
		case DwtKeyMap.SELECT:
			this._emulateSingleClick();
			break;

		case DwtKeyMap.SUBMENU:
			var menu = this.getMenu();
			if (!menu) return false;
			this._emulateDropDownClick();
			menu.setSelectedItem(0);
			break;
	}

	return true;
};

/**
 * Removes options from drop down menu
 */
DwtButton.prototype.removePullDownMenuOptions =
function() {
    if (this._menu) {
        this._setDropDownCellMouseHandlers(false);
        if (this._dropDownEl && this._dropDownImg) {
            // removes initial down arrow
            AjxImg.setImage(this._dropDownEl, "");
            // removes arrow image set by mouse hover, click, etc.
            this.setDropDownImages("", "", "", "");
        }
    }
};

// Private methods

/**
 * @private
 */
DwtButton.prototype._emulateSingleClick =
function() {
	this.trigger();
	var htmlEl = this.getHtmlElement();
	var p = Dwt.toWindow(htmlEl);
	var mev = new DwtMouseEvent();
	this._setMouseEvent(mev, {
		type: this._actionTiming == DwtButton.ACTION_MOUSEDOWN ?
			DwtEvent.ONMOUSEDOWN : DwtEvent.ONMOUSEUP,
		dwtObj: this,
		target: htmlEl,
		button: DwtMouseEvent.LEFT,
		docX: p.x,
		docY: p.y,
		kbNavEvent: true
	});
	this.notifyListeners(mev.type, mev);
};

/**
 * @private
 */
DwtButton.prototype._emulateDropDownClick =
function() {
    var htmlEl = this._dropDownEl;
    if (!htmlEl) { return; }

	var p = Dwt.toWindow(htmlEl);
	var mev = new DwtMouseEvent();
	this._setMouseEvent(mev, {
		dwtObj: this,
		target: htmlEl,
		button: DwtMouseEvent.LEFT,
		docX: p.x,
		docY: p.y,
		kbNavEvent: true
	});
	DwtButton._dropDownCellMouseUpHdlr(mev);
};

/**
 * This method is called from mouseUpHdlr in {@see DwtControl}.
 * 
 * @private
 */
DwtButton.prototype._focusByMouseUpEvent =
function()  {
	//do nothing, override parents so that we do not focus on button using mouseUp. Makes no sense to focus.
};

/**
 * NOTE: _focus and _blur will be reworked to reflect styles correctly
 * 
 * @private
 */
DwtButton.prototype._focus =
function() {
    this.setDisplayState(DwtControl.FOCUSED);
};

/**
 * @private
 */
DwtButton.prototype._blur =
function() {
    this.setDisplayState(DwtControl.NORMAL);
};

/**
 * @private
 */
DwtButton.prototype._toggleMenu =
function (event) {
	if (this._shouldToggleMenu){
        var menu = this.getMenu();
        if (!menu.isPoppedUp()){
			this.popup(null, event);
			this._menuUp = true;
		} else {
			menu.popdown(0, event);
			this._menuUp = false;
            this.deactivate();
        }
	} else {
		this.popup(null, event);
	}
};

/**
 * @private
 */
DwtButton.prototype._isDropDownEvent =
function(ev) {
	if (this._dropDownEventsEnabled && this._dropDownEl) {
		var mouseX = ev.docX;
		var dropDownX = Dwt.toWindow(this._dropDownEl, 0, 0, window).x;
		if (mouseX >= dropDownX) {
			return true;
		}
	}
	return false;
};

/**
 * @private
 */
DwtButton.prototype.trigger =
function (){
    if (this._depressedImageInfo) {
        this.setImage(this._depressedImageInfo);
    }
    this.setDisplayState(DwtControl.ACTIVE, true);
    this.isActive = true;
};

/**
 * @private
 */
DwtButton.prototype.deactivate =
function() {
	this._showHoverImage(true);

	if (this._style & DwtButton.TOGGLE_STYLE){
		this._selected = !this._selected;
	}
    this.setDisplayState(DwtControl.HOVER);
};

/**
 * @private
 */
DwtButton.prototype.dontStealFocus = function(val) {
	if (val == null) {
		val = true;
	}
	if (this._menu && this._menu.isDwtMenu) {
		this._menu.dontStealFocus(val);
	}
	this.__preventMenuFocus = val;
};

/**
 * @private
 */
DwtButton.prototype._toggleHoverClass =
function(show, direction) {
	var iconEl = this._getIconEl(direction);
	if (iconEl) {  //add a null check so buttons with no icon elements don't break the app.
		var info = show ? this._hoverImageInfo[direction] : this.__imageInfo[direction];
		iconEl.firstChild.className = AjxImg.getClassForImage(info);
	}
};

/**
 * @private
 */
DwtButton.prototype._showHoverImage =
function(show) {
	// if the button is image-only, DwtLabel#setImage is bad
	// because it clears the element first
	// (innerHTML = "") causing a mouseout event, then it
	// re-sets the image, which results in a new mouseover
	// event, thus looping forever eating your CPU and
	// blinking.
	if (!this._hoverImageInfo) {
		return;
	}
	if (this._hoverImageInfo.left) {
		this._toggleHoverClass(show, DwtLabel.LEFT);
	}
	if (this._hoverImageInfo.right) {
		this._toggleHoverClass(show, DwtLabel.RIGHT);
	}
};

/**
 * @private
 */
DwtButton.prototype._handleClick =
function(ev) {
	if (this.isListenerRegistered(DwtEvent.SELECTION)) {
		var now = (new Date()).getTime();
		if (!this._lastNotify || (now - this._lastNotify > DwtButton.NOTIFY_WINDOW)) {
			var selEv = DwtShell.selectionEvent;
			DwtUiEvent.copy(selEv, ev);
			selEv.item = this;
			selEv.detail = (typeof this.__detail == "undefined") ? 0 : this.__detail;
			this.notifyListeners(DwtEvent.SELECTION, selEv);
			this._lastNotify = now;
			this.shell.notifyGlobalSelection(selEv);
		}
	} else if (this._menu) {
		if(this._menu.isDwtMenu && !this.isListenerRegistered(DwtEvent.SELECTION)) {
			this._menu.setAssociatedObj(this);	
		}		
		this._toggleMenu(ev);
	}
};

/**
 * @private
 */
DwtButton.prototype._setMouseOutClassName =
function() {
    this.setDisplayState(DwtControl.NORMAL);
};

/**
 * @private
 */
DwtButton.prototype._createHtmlFromTemplate = function(templateId, data) {
    DwtLabel.prototype._createHtmlFromTemplate.call(this, templateId, data);
    this._dropDownEl = document.getElementById(data.id+"_dropdown");
};

// Accessibility
DwtButton.prototype._menuAdded = function(menu) {
	this.setAttribute("aria-haspopup", true);
	this.setAttribute("aria-controls", menu._htmlElId);
};

// Accessibility
DwtButton.prototype._menuItemSelected = function(menuItem) {};

/**
 * Pops up the dropdown menu.
 * 
 * @private
 */
DwtButton._dropDownCellMouseDownHdlr =
function(ev) {
	var obj = DwtControl.getTargetControl(ev);

    var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev, obj);

	if (mouseEv.button == DwtMouseEvent.LEFT) {
	    if (this._depImg){
			AjxImg.setImage(this, this._depImg);
	    }
	}

	mouseEv._stopPropagation = true;
	mouseEv._returnValue = false;
	mouseEv.setToDhtmlEvent(ev);
	return false;
};

/**
 * Updates the current mouse event (set from the previous mouse down).
 * 
 * @private
 */
DwtButton._dropDownCellMouseUpHdlr =
function(ev) {
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev);

	if (mouseEv.button == DwtMouseEvent.LEFT) {
	    if (this._dropDownHovImg && !this.noMenuBar) {
			AjxImg.setImage(this, this._dropDownHovImg);
	    }

		DwtEventManager.notifyListeners(DwtEvent.ONMOUSEDOWN, mouseEv);

		var obj = DwtControl.getTargetControl(ev);
		if (obj) {
			if (obj.getMenu() && obj.getMenu().isPoppedUp()) {
				obj.getMenu().popdown();
			}
			else {
				if (obj._menu && obj._menu.isAjxCallback) {
					obj.popup();
				}

				if (obj._dropDownEvtMgr.isListenerRegistered(DwtEvent.SELECTION)) {
					var selEv = DwtShell.selectionEvent;
					DwtUiEvent.copy(selEv, mouseEv);
					selEv.item = obj;
					obj._dropDownEvtMgr.notifyListeners(DwtEvent.SELECTION, selEv);
				} else {
					obj._toggleMenu(ev);
				}
			}
		}
	}
	
	mouseEv._stopPropagation = true;
	mouseEv._returnValue = false;
	mouseEv.setToDhtmlEvent(ev);
	return false;
};

/**
 * Activates the button.
 * 
 * @private
 */
DwtButton._mouseOverListener =
function(ev) {
	var button = ev.dwtObj;
	if (!button) { return false; }
	button._showHoverImage(true);
    button.setDisplayState(DwtControl.HOVER);

    var dropDown = button._dropDownEl;
    if (button._menu && dropDown && button._dropDownHovImg && !button.noMenuBar &&
        button.isListenerRegistered(DwtEvent.SELECTION)) {
		if (button._dropDownHovImg) {
			AjxImg.setImage(dropDown, button._dropDownHovImg);
		}
    }
	// bug fix 48266 IE hack, solution is similar to bug 36253
	// Just rewrite the el's Child's className to trigger IE to render it
	// In mouserOut, it seems the IE can render it automatically. 	
	if(AjxEnv.isIE){
	   	if(ev && ev.target && ev.target.firstChild){
			var el = ev.target.firstChild;
			var cname = el.className;
			el.className = "";
			el.className = cname;
		} 
	}    	
    ev._stopPropagation = true;
};

/**
 * @private
 */
DwtButton._mouseOutListener =
function(ev) {
	var button = ev.dwtObj;
	if (!button) { return false; }
	button._showHoverImage(false);
	button._setMouseOutClassName();
    button.isActive = false;

    var dropDown = button._dropDownEl;
    if (button._menu && dropDown && button._dropDownImg) {
		AjxImg.setImage(dropDown, button._dropDownImg);
    }
};

/**
 * @private
 */
DwtButton._mouseDownListener =
function(ev) {
	var button = ev.dwtObj;
	if (!button) { return false; }
	if (button._isDropDownEvent(ev)) {
		return DwtButton._dropDownCellMouseDownHdlr(ev);
	}

	if (ev.button != DwtMouseEvent.LEFT) { return; }

    var dropDown = button._dropDownEl;
    if (button._menu && dropDown && button._dropDownDepImg) {
		AjxImg.setImage(dropDown, button._dropDownDepImg);
    }
	switch (button._actionTiming) {
	  case DwtButton.ACTION_MOUSEDOWN:
		button.trigger();
		button._handleClick(ev);
		break;
	  case DwtButton.ACTION_MOUSEUP:
		button.trigger();
		break;
	}
};

/**
 * Button has been pressed, notify selection listeners.
 * 
 * @private
 */
DwtButton._mouseUpListener =
function(ev) {
	var button = ev.dwtObj;
	if (!button) { return false; }
	if (button._isDropDownEvent(ev)) {
		return DwtButton._dropDownCellMouseUpHdlr(ev);
	}
	if (ev.button != DwtMouseEvent.LEFT) { return; }

    var dropDown = button._dropDownEl;
    if (button._menu && dropDown && button._dropDownHovImg && !button.noMenuBar){
		AjxImg.setImage(dropDown, button._dropDownHovImg);
    }
	switch (button._actionTiming) {
	  case DwtButton.ACTION_MOUSEDOWN:
 	    button.deactivate();
		break;

	  case DwtButton.ACTION_MOUSEUP:
	    var el = button.getHtmlElement();
		if (button.isActive) {
			button.deactivate();
			button._handleClick(ev);
		}
		break;
	}
};

DwtButton._listeners = {};
DwtButton._listeners[DwtEvent.ONMOUSEOVER] = new AjxListener(null, DwtButton._mouseOverListener);
DwtButton._listeners[DwtEvent.ONMOUSEOUT] = new AjxListener(null, DwtButton._mouseOutListener);
DwtButton._listeners[DwtEvent.ONMOUSEDOWN] = new AjxListener(null, DwtButton._mouseDownListener);
DwtButton._listeners[DwtEvent.ONMOUSEUP] = new AjxListener(null, DwtButton._mouseUpListener);
DwtButton._listeners[DwtEvent.ONMOUSEENTER] = new AjxListener(null, DwtButton._mouseOverListener);
DwtButton._listeners[DwtEvent.ONMOUSELEAVE] = new AjxListener(null, DwtButton._mouseOutListener);
}
if (AjxPackage.define("ajax.dwt.widgets.DwtBorderlessButton")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * Creates a border less button.
 * @constructor
 * @class
 * This class represents a button without a border.
 *
 * @param {hash}	params		a hash of parameters
 * @param {DwtComposite}      params.parent		the parent widget
 * @param {constant}      params.style			the button style (see {@link DwtButton})
 * @param {string}      params.className		the CSS class
 * @param {constant}      params.posStyle		the positioning style (see {@link Dwt})
 * @param {DwtButton.ACTION_MOUSEUP|DwtButton.ACTION_MOUSEDOWN}      params.actionTiming	if {@link DwtButton.ACTION_MOUSEUP}, then the button is triggered
 *											on mouseup events, else if {@link DwtButton.ACTION_MOUSEDOWN},
 * 											then the button is triggered on mousedown events
 * @param {string}      params.id			the ID to use for the control's HTML element
 * @param {number}      params.index 		the index at which to add this control among parent's children
 * 
 * @extends		DwtButton
 */
DwtBorderlessButton = function(params) {
	if (arguments.length == 0) { return; }
	params = Dwt.getParams(arguments, DwtBorderlessButton.PARAMS);

	DwtButton.call(this, params);
}

DwtBorderlessButton.PARAMS = ["parent", "style", "className", "posStyle", "actionTiming", "id", "index"];

DwtBorderlessButton.prototype = new DwtButton;
DwtBorderlessButton.prototype.constructor = DwtBorderlessButton;

DwtBorderlessButton.prototype.toString =
function() {
	return "DwtBorderlessButton";
}

//
// Data
//

DwtBorderlessButton.prototype.TEMPLATE = "dwt.Widgets#ZBorderlessButton"

}
if (AjxPackage.define("ajax.dwt.widgets.DwtMenuItem")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * Creates a menu item.
 * @constructor
 * @class
 * Menu items can be part of a radio group, or can be checked style menu items.
 *
 * @author Ross Dargahi
 * 
 * @param {hash}	params		a hash of parameters
 * @param  {DwtComposite}     params.parent		the parent widget
 * @param  {constant}     params.style			the menu item style
 * @param  {string}     params.radioGroupId 	the radio group that the menu item is part of
 * @param  {number}     params.index 			the position in menu
 * @param  {string}     params.className		the CSS class
 * @param  {constant}     params.posStyle		the positioning style (see {@link DwtControl})
 * @param  {string}     params.id			an explicit ID to use for the control's HTML element
 * 
 * @extends		DwtButton
 */
DwtMenuItem = function(params) {
	if (arguments.length == 0) { return; }
	params = Dwt.getParams(arguments, DwtMenuItem.PARAMS);

	// check parameters
	var parent = params.parent;
	if (!(parent && parent.isDwtMenu)) {
		throw new DwtException("Parent must be a DwtMenu object", DwtException.INVALIDPARENT, "DwtMenuItem");
	}

	var style = params.style = params.style || DwtMenuItem.NO_STYLE;
	if (parent._style == DwtMenu.BAR_STYLE && style != DwtMenuItem.PUSH_STYLE) {
		throw new DwtException("DwtMenuItemInit: invalid style", DwtException.INVALID_PARAM, "DwtMenuItem");
	}

	// call super constructor
	params.className = params.className || "ZMenuItem";
	style &= ~DwtLabel.IMAGE_RIGHT; // remove image right style
	style |= DwtButton.ALWAYS_FLAT | DwtLabel.IMAGE_LEFT; // set default styles
	var isSeparator = (style & DwtMenuItem.SEPARATOR_STYLE);
	if (isSeparator) {
		params.className = "ZMenuItemSeparator";
		this.isFocusable = false;
        this.noTab = true;
		this.role = null;
	}
	params.listeners = DwtMenuItem._listeners;
	DwtButton.call(this, params);

	this.setDropDownImages("Cascade", "Cascade", "Cascade", "Cascade");
	this._radioGroupId = params.radioGroupId;

	// add this item at the specified index
	if (parent._addItem) {
		parent._addItem(this, params.index);
	}

	// add listeners if not menu item separator
	if (!isSeparator) {
		this.addSelectionListener(this.__handleItemSelect.bind(this));
	}
};

DwtMenuItem.PARAMS = ["parent", "style", "radioGroupId", "index", "className", "posStyle", "id"];

DwtMenuItem.prototype = new DwtButton;
DwtMenuItem.prototype.constructor = DwtMenuItem;

DwtMenuItem.prototype.isDwtMenuItem = true;
DwtMenuItem.prototype.toString = function() { return "DwtMenuItem"; };
DwtMenuItem.prototype.role = "menuitem";

//
// Constants
//

DwtMenuItem.CHECKED			= 1;
DwtMenuItem.UNCHECKED		= 2;

/**
 * Defines the "no" style.
 */
DwtMenuItem.NO_STYLE		= 0;
/**
 * Defines the "check" style.
 */
DwtMenuItem.CHECK_STYLE		= DwtButton._LAST_STYLE * 2;
/**
 * Defines the "radio" style.
 */
DwtMenuItem.RADIO_STYLE		= DwtButton._LAST_STYLE * 4;
/**
 * Defines the "separator" style.
 */
DwtMenuItem.SEPARATOR_STYLE = DwtButton._LAST_STYLE * 8;
/**
 * Defines the "cascade" style.
 */
DwtMenuItem.CASCADE_STYLE	= DwtButton._LAST_STYLE * 16;
/**
 * Defines the "push" style.
 */
DwtMenuItem.PUSH_STYLE		= DwtButton._LAST_STYLE * 32;
/**
 * Defines the "select" style.
 */
DwtMenuItem.SELECT_STYLE	= DwtButton._LAST_STYLE * 64;
DwtMenuItem._LAST_STYLE		= DwtMenuItem.SELECT_STYLE;

DwtMenuItem._MENU_POPUP_DELAY	= 250;
DwtMenuItem._MENU_POPDOWN_DELAY	= 250;

//
// Data
//

DwtMenuItem.prototype.TEMPLATE					= "dwt.Widgets#ZMenuItem";
DwtMenuItem.prototype.SEPARATOR_TEMPLATE		= "dwt.Widgets#ZMenuItemSeparator";
DwtMenuItem.prototype.BLANK_CHECK_TEMPLATE		= "dwt.Widgets#ZMenuItemBlankCheck";
DwtMenuItem.prototype.BLANK_ICON_TEMPLATE		= "dwt.Widgets#ZMenuItemBlankIcon";
DwtMenuItem.prototype.BLANK_CASCADE_TEMPLATE	= "dwt.Widgets#ZMenuItemBlankCascade";

//
// Public methods
//
DwtMenuItem.prototype.dispose =
function() {
	delete this._checkEl;
	DwtButton.prototype.dispose.call(this);
};

/**
 * Creates the menu item.
 * 
 * @param	{hash}	params		a hash of parameters
 */
DwtMenuItem.create =
function(params) {
	var mi = new DwtMenuItem(params);
	if (params.imageInfo) {
		mi.setImage(params.imageInfo);
	}
	if (params.text) {
		mi.setText(params.text);
	}
	mi.setEnabled(params.enabled !== false);
	return mi;
};

/**
 * Gets the checked flag.
 * 
 * @return	{boolean}	<code>true</code> if the item is checked
 */
DwtMenuItem.prototype.getChecked =
function() {
	return this._itemChecked;
};

/**
 * Sets the checked flag.
 * 
 * @param	{boolean}	checked			if <code>true</code>, check the item
 * @param	{boolean}	skipNotify		if <code>true</code>, do not notify listeners
 */
DwtMenuItem.prototype.setChecked =
function(checked, skipNotify) {
	this._setChecked(checked, null, skipNotify);
	this.parent._checkItemAdded(this);
};

DwtMenuItem.prototype.setImage =
function(imageInfo) {
	DwtButton.prototype.setImage.call(this, imageInfo);
	this.parent._iconItemAdded(this);
};

DwtMenuItem.prototype.setText =
function(text) {
	DwtButton.prototype.setText.call(this, text);
	if (this.parent.isPoppedUp()) {
		// resize menu if we reset text on the fly
		this.parent.render();
	}
};

DwtMenuItem.prototype.setMenu =
function(params) {
	var params = Dwt.getParams(arguments, DwtButton.setMenuParams);
	DwtButton.prototype.setMenu.call(this, params);
	this.parent._submenuItemAdded(this);
};

DwtMenuItem.prototype.setHoverDelay =
function(delay) {
	this._hoverDelay = delay;
};

DwtMenuItem.prototype.setShortcut =
function(shortcut) {
	if (shortcut && this._dropDownEl) {
		this._dropDownEl.innerHTML = shortcut;
	}
};

// Set whether the item is selectable even when it has an open submenu
DwtMenuItem.prototype.setSelectableWithSubmenu =
function(selectable) {
	this._selectableWithSubmenu = selectable;
};

DwtMenuItem.prototype.isSeparator =
function() {
	return Boolean(this._style & DwtMenuItem.SEPARATOR_STYLE);
};

DwtMenuItem.prototype.handleKeyAction =
function(actionCode, ev) {
	if (this.parent) {
		return this.parent.handleKeyAction(actionCode, ev)
	} else {
		return DwtButton.prototype.handleKeyAction.call(this, actionCode, ev);
	}
};

DwtMenuItem.prototype.getKeyMapName =
function() {
	return DwtKeyMap.MAP_MENU;
};

//
// Protected methods
//

DwtMenuItem.prototype._createHtml =
function(templateId) {
	var defaultTemplate = this.isSeparator() ? this.SEPARATOR_TEMPLATE : this.TEMPLATE;
	DwtButton.prototype._createHtml.call(this, templateId || defaultTemplate);
};

DwtMenuItem.prototype._createHtmlFromTemplate =
function(templateId, data) {
	DwtButton.prototype._createHtmlFromTemplate.call(this, templateId, data);
	this._checkEl = document.getElementById(data.id+"_check");
};

DwtMenuItem.prototype._setChecked =
function(checked, ev, skipNotify) {
	var isCheck = this._style & DwtMenuItem.CHECK_STYLE;
	var isRadio = this._style & DwtMenuItem.RADIO_STYLE;
	if ((isCheck || isRadio) && this._itemChecked != checked) {
		this._itemChecked = checked;

		if (this._checkEl) {
			this._checkEl.innerHTML = "";
			var icon = checked ? (isCheck ? "MenuCheck" : "MenuRadio") : "Blank_9";
			AjxImg.setImage(this._checkEl, icon);
			if (checked) {
				// deselect currently selected radio button
				if (isRadio) {
					this.parent._radioItemSelected(this, skipNotify);
				}
			}
		}
	}
};

DwtMenuItem.prototype._checkItemAdded = function(className) {};
DwtMenuItem.prototype._checkedItemsRemoved = function() {};

DwtMenuItem.prototype._submenuItemAdded =
function() {
	if (this.isSeparator()) { return; }

	if (this._cascCell == null) {
		this._cascCell = this._row.insertCell(-1);
		this._cascCell.noWrap = true;
	}
};

DwtMenuItem.prototype._submenuItemRemoved =
function() {
	if (this._dropDownEl) {
		this._dropDownEl.innerHTML = "";
	}
};

DwtMenuItem.prototype._popupMenu =
function(delay, kbGenerated) {
	var menu = this.getMenu();
	var pp = this.parent.parent;
	var pb = this.getBounds();
	var ws = menu.shell.getSize();
	var s = menu.getSize();
	var x;
	var y;
	var vBorder;
	var hBorder;
	var ppHtmlElement = pp.getHtmlElement();
	if (pp._style == DwtMenu.BAR_STYLE) {
		vBorder = (ppHtmlElement.style.borderLeftWidth == "") ? 0 : parseInt(ppHtmlElement.style.borderLeftWidth);
		x = pb.x + vBorder;
		hBorder = (ppHtmlElement.style.borderTopWidth == "") ? 0 : parseInt(ppHtmlElement.style.borderTopWidth);
		hBorder += (ppHtmlElement.style.borderBottomWidth == "") ? 0 : parseInt(ppHtmlElement.style.borderBottonWidth);
		y = pb.y + pb.height + hBorder;		
		x = ((x + s.x) >= ws.x) ? x - (x + s.x - ws.x): x;
	}
	else { // Drop Down
		vBorder = (ppHtmlElement.style.borderLeftWidth == "") ? 0 : parseInt(ppHtmlElement.style.borderLeftWidth);
		vBorder += (ppHtmlElement.style.borderRightWidth == "") ? 0 : parseInt(ppHtmlElement.style.borderRightWidth);
		x = pb.x + pb.width + vBorder;
		hBorder = (ppHtmlElement.style.borderTopWidth == "") ? 0 : parseInt(ppHtmlElement.style.borderTopWidth);
		y = pb.y + hBorder;
        if (menu.centerOnParentVertically()) {
            y += pb.height / 2;
        }
		//x = ((x + s.x) >= ws.x) ? pb.x - s.x - vBorder : x;
	}
	menu.popup(delay, x, y, kbGenerated);
};

DwtMenuItem.prototype._popdownMenu =
function() {
	var menu = this.getMenu();
	if (menu) {
		menu.popdown();
	}
};

DwtMenuItem.prototype._isMenuPoppedUp =
function() {
	var menu = this.getMenu();
	return (menu && menu.isPoppedUp());
};

DwtMenuItem.prototype._blur =
function() {
	var menu = this.parent;
	var mev = new DwtMouseEvent();

	this._setMouseEvent(mev, {
		dwtObj: this,
		ersatz: true,
		type: DwtEvent.ONMOUSEOUT
	});
	this.notifyListeners(DwtEvent.ONMOUSEOUT, mev);
	menu.__currentItem = null;

	DwtButton.prototype._blur.call(this);
};

DwtMenuItem.prototype._focus = function() {

	var menu = this.parent;
	var currItem = menu.__currentItem;
	var mev = new DwtMouseEvent();

	this._setMouseEvent(mev, {dwtObj:this, ersatz: true});
	this.notifyListeners(AjxEnv.isIE ? DwtEvent.ONMOUSEENTER : DwtEvent.ONMOUSEOVER, mev);	// mouseover selects a menu item
	menu.__currentItem = this;

	DwtButton.prototype._focus.call(this);
}

//
// Private methods
//

DwtMenuItem.prototype.__handleItemSelect =
function(event) {
	this.setDisplayState(DwtControl.NORMAL);
	if (this.isStyle(DwtMenuItem.CHECK_STYLE)) {
		this._setChecked(!this._itemChecked, null, true);
		event.detail = this.getChecked() ? DwtMenuItem.CHECKED : DwtMenuItem.UNCHECKED;
	}
	else if (this.isStyle(DwtMenuItem.RADIO_STYLE)) {
		this._setChecked(true, true);
		this.parent._radioItemSelected(this, true);
		event.detail = this.getChecked() ? DwtMenuItem.CHECKED : DwtMenuItem.UNCHECKED;
	}
	else if (this.isStyle(DwtMenuItem.PUSH_STYLE)) {
		if (this._menu) {
			if (this._isMenuPoppedUp()) {
				DwtMenu.closeActiveMenu(event);
			}
			else {
				this._popupMenu(DwtKeyEvent.isKeyEvent(ev));
			}
		}
		return;
	}
	if (!this.isStyle(DwtMenuItem.CASCADE_STYLE)) {
		if (this._selectableWithSubmenu || !this._menu || !this._menu.isPoppedUp || !this._menu.isPoppedUp()) {
			DwtMenu.closeActiveMenu(event);
		}
	}
};

DwtMenuItem._mouseOverListener =
function(ev) {
	var menuItem = ev.dwtObj;
	if (!menuItem) { return false; }
	var menu = menuItem.parent;
	if (menuItem.isSeparator()) { return false; }
	DwtButton._mouseOverListener(ev, menuItem);
	if (!ev.ersatz) {
		menu._popdownSubmenus();
	}
	if (!menuItem.hasFocus() && menuItem.getEnabled()) {
		menuItem.focus();
	}

	if (menuItem._menu && !ev.ersatz) {
		menuItem._popupMenu(menuItem._hoverDelay);
	}
};

DwtMenuItem._mouseOutListener =
function(ev) {
	var menuItem = ev.dwtObj;
	var submenu = menuItem && menuItem.getMenu();
	if (submenu && submenu.isPoppedUp()) { return; }
	DwtButton._mouseOutListener(ev);
};

/*
 * returns menu item table row element
 */
DwtMenuItem.prototype.getRowElement =
function() {
	var el = this._textEl ||
		this._dropDownEl ||
		(this._iconEl && this._iconEl.left) ||
		(this._iconEl && this._iconEl.right);
	if (el) {
		return el.parentNode;
	}
};

DwtMenuItem._listeners = {};
DwtMenuItem._listeners[DwtEvent.ONMOUSEOVER]	= DwtMenuItem._mouseOverListener.bind();
DwtMenuItem._listeners[DwtEvent.ONMOUSEOUT]		= DwtMenuItem._mouseOutListener.bind();
DwtMenuItem._listeners[DwtEvent.ONMOUSEDOWN]	= DwtButton._mouseDownListener.bind();
DwtMenuItem._listeners[DwtEvent.ONMOUSEUP]		= DwtButton._mouseUpListener.bind();
DwtMenuItem._listeners[DwtEvent.ONMOUSEENTER]	= DwtMenuItem._mouseOverListener.bind();
DwtMenuItem._listeners[DwtEvent.ONMOUSELEAVE]	= DwtButton._mouseOutListener.bind();
}
if (AjxPackage.define("ajax.dwt.widgets.DwtMenu")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * Creates a menu.
 * @constructor
 * @class
 * Creates a menu object to menu items can be added. Menus can be created in various styles as
 * follows:
 * <ul>
 * <li>DwtMenu.BAR_STYLE - Traditional menu bar</li>
 * <li>DwtMenu.POPUP_STYLE - Popup menu</li>
 * <li>DwtMenu.DROPDOWN_STYLE - Used when a menu is a drop down (e.g. parent is a button or another menu item)</li>
 * <li>DwtMenu.DROPDOWN_CENTERV_STYLE - like a dropdown, but position to the right, centered vertically on the parent</li>
 * <li>DwtMenu.COLOR_PICKER_STYLE - Menu is hosting a single color picker</li>
 * <li>DwtMenu.CALENDAR_PICKER_STYLE - Menu is hostng a single calendar</li>
 * <li>DwtMenu.GENERIC_WIDGET_STYLE - Menu is hosting a single "DwtInsertTableGrid"</li>
 * </ul>
  *
 * @author Ross Dargahi
 * 
 * @param {hash}	params		a hash of parameters
 * @param       {DwtComposite}	params.parent		the parent widget
 * @param {constant}      params.style			the menu style
 * @param {string}        params.className		the CSS class
 * @param {constant}      params.posStyle		the positioning style (see {@link DwtControl})
 * @param {constant}      params.layout			layout to use: DwtMenu.LAYOUT_STACK, DwtMenu.LAYOUT_CASCADE or DwtMenu.LAYOUT_SCROLL. A value of [true] defaults to DwtMenu.LAYOUT_CASCADE and a value of [false] defaults to DwtMenu.LAYOUT_STACK.
 * @param {int}		  params.maxRows=0	    	if >0 and layout = LAYOUT_CASCADE or DwtMenu.LAYOUT_SCROLL, define how many rows are allowed before cascading/scrolling
 * @param {boolean}		params.congruent		if the parent is a DwtMenuItem, align so that the submenu "merges" with the parent menu
 * 
 * @extends		DwtComposite
 */

DwtMenu = function(params) {
	this._created = false;
	if (arguments.length == 0) { return; }
	params = Dwt.getParams(arguments, DwtMenu.PARAMS);

	this._origStyle = params.style;
	var parent = params.parent;
	if (parent) {
		if (parent instanceof DwtMenuItem || parent instanceof DwtButton) {
			if ((params.style == DwtMenu.GENERIC_WIDGET_STYLE) ||
                (params.style == DwtMenu.DROPDOWN_CENTERV_STYLE)) {
				this._style = params.style;
			} else {
                this._style = DwtMenu.DROPDOWN_STYLE;
 			}
		} else {
			this._style = params.style || DwtMenu.POPUP_STYLE;
		}
		if (!params.posStyle) {
			params.posStyle = (this._style == DwtMenu.BAR_STYLE) ? DwtControl.STATIC_STYLE : DwtControl.ABSOLUTE_STYLE;
		}
	}
	params.className = params.className || "DwtMenu";

	this._layoutStyle = params.layout == null || params.layout;
	if (this._layoutStyle === true) {
		this._layoutStyle = DwtMenu.LAYOUT_CASCADE;
	} else if (this._layoutStyle === false) {
		this._layoutStyle = DwtMenu.LAYOUT_STACK;
	}
	this._maxRows = this._layoutStyle && params.maxRows || 0;
	this._congruent = params.congruent;

	// Hack to force us to hang off of the shell for positioning.
	params.parent = (parent instanceof DwtShell) ? parent : parent.shell;
	DwtComposite.call(this, params);
	this.parent = parent;

	if (this._isPopupStyle() && (this._layoutStyle == DwtMenu.LAYOUT_STACK)) {
		this.setScrollStyle(DwtControl.SCROLL);
	}

	if (!parent) { return; }

	var events = AjxEnv.isIE ? [DwtEvent.ONMOUSEDOWN, DwtEvent.ONMOUSEUP] :
							   [DwtEvent.ONMOUSEDOWN, DwtEvent.ONMOUSEUP, DwtEvent.ONMOUSEOVER, DwtEvent.ONMOUSEOUT];
	this._setEventHdlrs(events);
	this._hasSetMouseEvents = true;
	
	var htmlElement = this.getHtmlElement();

	if (params.posStyle != DwtControl.STATIC_STYLE) {
		Dwt.setLocation(htmlElement, Dwt.LOC_NOWHERE, Dwt.LOC_NOWHERE);
	}

	// Don't need to create table for color picker and calendar picker styles
	if (this._style != DwtMenu.COLOR_PICKER_STYLE &&
		this._style != DwtMenu.CALENDAR_PICKER_STYLE &&
		this._style != DwtMenu.GENERIC_WIDGET_STYLE)
	{
		this._table = document.createElement("table");
		this._table.border = this._table.cellPadding = this._table.cellSpacing = 0;
		this._table.className = "DwtMenuTable";
		this._table.id = Dwt.getNextId();


		if (this._layoutStyle == DwtMenu.LAYOUT_SCROLL) {
			this._setupScroll();
		} else {
			htmlElement.appendChild(this._table);
		}
		this._table.backgroundColor = DwtCssStyle.getProperty(htmlElement, "background-color");
    }

	if (params.style != DwtMenu.BAR_STYLE) {
		this.setVisible(false);
 		this._isPoppedUp = false;
	} else {
		DwtMenu._activeMenuIds.add(htmlElement.id, null, true);
		this._isPoppedUp = true;
 	}
	this._popdownAction = new AjxTimedAction(this, this._doPopdown);
	this._popdownActionId = -1;
	this._popupAction = new AjxTimedAction(this, this._doPopup);
	this._popupActionId = -1;

	this._outsideListener = new AjxListener(null, DwtMenu._outsideMouseDownListener);

	this._menuItemsHaveChecks = false;	
	this._menuItemsHaveIcons = false;
	this._menuItemsWithSubmenus = 0;
	this.__currentItem = null;
	this.__preventMenuFocus = false;

	this._created = true;

    // When items are added, the menu listens to selection events
    // and will propagate the event to listeners that are registered
    // on the menu itself.
    this._itemSelectionListener = new AjxListener(this, this._propagateItemSelection);

	// Accessibility
	if (parent._menuAdded) {
		parent._menuAdded(this);
	}
};

DwtMenu.PARAMS = ["parent", "style", "className", "posStyle", "cascade", "id"];

DwtMenu.prototype = new DwtComposite;
DwtMenu.prototype.constructor = DwtMenu;

DwtMenu.prototype.isDwtMenu = true;
DwtMenu.prototype.toString = function() { return "DwtMenu"; };
DwtMenu.prototype.role = "menu";

DwtMenu.BAR_STYLE				= "BAR";
DwtMenu.POPUP_STYLE				= "POPUP";
DwtMenu.DROPDOWN_STYLE			= "DROPDOWN";
DwtMenu.DROPDOWN_CENTERV_STYLE	= "DROPDOWN_CENTERV";
DwtMenu.COLOR_PICKER_STYLE		= "COLOR";
DwtMenu.CALENDAR_PICKER_STYLE	= "CALENDAR";
DwtMenu.GENERIC_WIDGET_STYLE	= "GENERIC";

DwtMenu.HAS_ICON = "ZHasIcon";
DwtMenu.HAS_CHECK = "ZHasCheck";
DwtMenu.HAS_SUBMENU = "ZHasSubMenu";

DwtMenu.LAYOUT_STACK 	= 0;
DwtMenu.LAYOUT_CASCADE 	= 1;
DwtMenu.LAYOUT_SCROLL 	= 2;

DwtMenu._activeMenuUp = false;
DwtMenu._activeMenuIds = new AjxVector();
DwtMenu._activeMenus = new AjxVector() ;

DwtMenu.prototype.dispose =
function() {
	this._table = null;
	DwtComposite.prototype.dispose.call(this);

	// Remove this from the shell. (Required because of hack in constructor.) 
	if (!(this.parent instanceof DwtShell)) {
		this.shell.removeChild(this);	
	}
};

/**
 * Adds a selection listener.
 * @param {AjxListener} listener The listener.
 */
DwtMenu.prototype.addSelectionListener = function(listener) {
    this.addListener(DwtEvent.SELECTION, listener);
};

/**
 * Removes a selection listener.
 * @param {AjxListener} listener The listener.
 */
DwtMenu.prototype.removeSelectionListener = function(listener) {
    this.removeListener(DwtEvent.SELECTION, listener);
};

/**
 * Adds a popup listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
DwtMenu.prototype.addPopupListener =
function(listener) {
	this.addListener(DwtEvent.POPUP, listener);
};

/**
 * Removes a popup listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
DwtMenu.prototype.removePopupListener = 
function(listener) {
	this.removeListener(DwtEvent.POPUP, listener);
};

/**
 * Adds a popdown listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
DwtMenu.prototype.addPopdownListener = 
function(listener) {
	this.addListener(DwtEvent.POPDOWN, listener);
};

/**
 * Removes a popdown listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
DwtMenu.prototype.removePopdownListener = 
function(listener) {
	this.removeListener(DwtEvent.POPDOWN, listener);
};

DwtMenu.prototype.setWidth = 
function(width) {
	this._width = width;

    if (this._table) {
        Dwt.setSize(this._table, width, Dwt.CLEAR);
    }
};

DwtMenu.prototype.centerOnParentVertically =
function() {
    return (this._style === DwtMenu.DROPDOWN_CENTERV_STYLE);
};

DwtMenu.prototype._isPopupStyle =
function() {
	return (this._style === DwtMenu.POPUP_STYLE || this._style === DwtMenu.DROPDOWN_STYLE || this._style === DwtMenu.DROPDOWN_CENTERV_STYLE);
};

/**
 * Gets a menu item.
 * 
 * @param	{string}	index		the index
 * @return	{DwtMenuItem}		the menu item
 */
DwtMenu.prototype.getItem =
function(index) {
	return this._children.get(index);
};

DwtMenu.prototype.getItemIndex =
function(item) {
	return this._children.indexOf(item);
};

/**
 * Gets the item by id.
 * 
 * @param	{string}	key		the id key
 * @param	{Object}	id		the id value
 * @return	{DwtMenuItem}	the menu item
 */
DwtMenu.prototype.getItemById =
function(key, id) {
	var items = this.getItems();
	for (var i = 0; i < items.length; i++) {
		var itemId = items[i].getData(key);
		if (itemId == id) {
			items[i].index = i; //needed in some caller
			return items[i];
		}
	}
	return null;
};

/**
 * Gets a count of the items.
 * 
 * @return	{number}	the count
 */
DwtMenu.prototype.getItemCount =
function() {
	return this._children.size();
};

/**
 * Gets an array of items.
 * 
 * @return	{array}	an array of {@link DwtMenuItem} objects
 */
DwtMenu.prototype.getItems =
function() {
	return this._children.getArray();
};

DwtMenu.prototype.getSelectedItem =
function(style) {
	var a = this._children.getArray();
	for (var i = 0; i < a.length; i++) {
		var mi = a[i];
		if ((style == null || (mi._style && style != 0)) && mi.getChecked())
			return mi;
	}
	return null;
};

/**
 * Checks if the menu is popped-up.
 * 
 * @return	{boolean}	<code>true</code> if popped-up
 */
DwtMenu.prototype.isPoppedUp =
function() {
	return this._isPoppedUp;
};

DwtMenu.prototype.popup = function(msec, x, y, kbGenerated) {

	if (this._style == DwtMenu.BAR_STYLE) {
        return;
    }
	
	if (this._popdownActionId != -1) {
		AjxTimedAction.cancelAction(this._popdownActionId);
		this._popdownActionId = -1;
	}
    else {
		if (this._isPoppedUp || (this._popupActionId != -1 && msec && msec > 0)) {
			return;
		}
        else if (this._popupActionId != -1) {
			AjxTimedAction.cancelAction(this._popupActionId);
			this._popupActionId = -1;
		}

		if (!msec) {
			this._doPopup(x, y, kbGenerated);
		}
        else {
			this._popupAction.args = [x, y, kbGenerated];
			this._popupActionId = AjxTimedAction.scheduleAction(this._popupAction, msec);
		}
	}
};

DwtMenu.prototype.popdown =
function(msec, ev) {
	if (this._style == DwtMenu.BAR_STYLE) return;

	if (this._popupActionId != -1) {
		AjxTimedAction.cancelAction(this._popupActionId);	
		this._popupActionId = -1;
	} else {
		if (!this._isPoppedUp || this._popdownActionId != -1)
			return;
		if (msec == null || msec == 0)
			this._doPopdown(ev);
		else
			this._popdownActionId = AjxTimedAction.scheduleAction(this._popdownAction, msec);
	}
};

DwtMenu.prototype._setupScroll = function() {
	var htmlElement = this.getHtmlElement();
	this._table.style.position = "relative";
			
	this._topScroller = document.createElement("div");
	this._topScroller.className = "DwtMenuScrollTop";
	this._topScroller.id = Dwt.getNextId();
	
	this._imgDivTop = document.createElement("div");
	this._imgDivTop.className = "ImgUpArrowSmall";
	this._topScroller.appendChild(this._imgDivTop);
	Dwt.setHandler(this._imgDivTop, DwtEvent.ONMOUSEOUT, DwtMenu._stopEvent);
	Dwt.setHandler(this._imgDivTop, DwtEvent.ONMOUSEOVER, DwtMenu._stopEvent);
	htmlElement.appendChild(this._topScroller);

	this._tableContainer = document.createElement("div");
	this._tableContainer.appendChild(this._table);
	htmlElement.appendChild(this._tableContainer);

	this._bottomScroller = document.createElement("div");
	this._bottomScroller.className = "DwtMenuScrollBottom";
	this._bottomScroller.id = Dwt.getNextId();
	
	this._imgDivBottom = document.createElement("div");
	this._imgDivBottom.className = "ImgDownArrowSmall";
	Dwt.setHandler(this._imgDivBottom, DwtEvent.ONMOUSEOUT, DwtMenu._stopEvent);
	Dwt.setHandler(this._imgDivBottom, DwtEvent.ONMOUSEOVER, DwtMenu._stopEvent);
	this._bottomScroller.appendChild(this._imgDivBottom);
	htmlElement.appendChild(this._bottomScroller);

	//scroll up
	var scrollUpStartListener = AjxCallback.simpleClosure(this._scroll, this, this._table.id, true, false);
	var scrollUpStopListener = AjxCallback.simpleClosure(this._scroll, this, this._table.id, false, false);
	var mouseOutTopListener = AjxCallback.simpleClosure(this._handleMouseOut, this, this._topScroller.id, this._table.id);
	var mouseOutBottomListener = AjxCallback.simpleClosure(this._handleMouseOut, this, this._bottomScroller.id, this._table.id);

	Dwt.setHandler(this._topScroller, DwtEvent.ONMOUSEDOWN, scrollUpStartListener);
	Dwt.setHandler(this._topScroller, DwtEvent.ONMOUSEUP, scrollUpStopListener);
	if (!AjxEnv.isIE) {
		Dwt.setHandler(this._topScroller, DwtEvent.ONMOUSEOUT, mouseOutTopListener);
	} else {
		Dwt.setHandler(this._topScroller, DwtEvent.ONMOUSELEAVE, scrollUpStopListener);
	}

	//scroll down
	var scrollDownStartListener = AjxCallback.simpleClosure(this._scroll, this, this._table.id, true, true);
	var scrollDownStopListener = AjxCallback.simpleClosure(this._scroll, this, this._table.id, false, true);

	Dwt.setHandler(this._bottomScroller, DwtEvent.ONMOUSEDOWN, scrollDownStartListener);
	Dwt.setHandler(this._bottomScroller, DwtEvent.ONMOUSEUP, scrollDownStopListener);
	Dwt.setHandler(this._bottomScroller, DwtEvent.ONMOUSEUP, scrollDownStopListener);
	if (!AjxEnv.isIE) {
		Dwt.setHandler(this._bottomScroller, DwtEvent.ONMOUSEOUT, mouseOutBottomListener);
	} else {
		Dwt.setHandler(this._bottomScroller, DwtEvent.ONMOUSELEAVE, scrollDownStopListener);
	}

	var wheelListener = AjxCallback.simpleClosure(this._handleScroll, this, this._table.id);
	Dwt.setHandler(htmlElement, DwtEvent.ONMOUSEWHEEL, wheelListener);
};

DwtMenu.prototype.render = function(x, y) {

	var windowSize = this.shell.getSize();
	var mySize = this.getSize();
	var htmlEl = this.getHtmlElement();

	// bug 9583 - can't query border size so just subtract generic padding
	windowSize.y -= 10 + (AjxEnv.isIE ? 20 : 0);
	windowSize.x -= 28;

	var isScroll = this._layoutStyle == DwtMenu.LAYOUT_SCROLL;
	var isPopup = this._isPopupStyle();
	var isCascade = this._layoutStyle == DwtMenu.LAYOUT_CASCADE;
	if (this._table) {
		if (isPopup && isCascade) {
			var space = windowSize.y;
			var newY = null;
			var rows = this._table.rows;
			var numRows = rows.length;
			var maxRows = this._maxRows;
			var height = mySize.y;
			var requiredSpace = space - 25; // Account for space on top & bottom of menu.
			for (var i = numRows - 1; i >= 0; i--) {
				height -= Dwt.getSize(rows[i]).y;
				if (height < requiredSpace) {
					break;
				}
			}
			var count = maxRows ? Math.min(i + 1, maxRows) : (i + 1);
			for (var j = count; j < numRows; j++) {
				var row = rows[(j - count) % count];
				var cell = row.insertCell(-1);
				cell.className = "DwtMenuCascadeCell";
				var child = rows[j].cells[0].firstChild;
				while (child != null) {
					cell.appendChild(child);
					child = child.nextSibling;
				}
			}
			for (j = rows.length - 1; j >= count; j--) {
				this._table.deleteRow(count);
			}
			var offset = numRows % count;
			if (offset > 0) {
				for (var j = offset; j < count; j++) {
					var row = rows[j];
					var cell = row.insertCell(-1);
					cell.className = "DwtMenuCascadeCell";
					cell.empty = true;
					cell.innerHTML = "&nbsp;";
				}
			}

			mySize = this.getSize();
			if (newY) {
				y = newY - mySize.y;
			}
		}
        else if (isPopup && isScroll) {
			var rows = this._table.rows;
			var numRows = rows.length;
			var maxRows = this._maxRows;
			var limRows = maxRows ? Math.min(maxRows, numRows) : numRows;
			var availableSpace = windowSize.y - 25; // Account for space on top & bottom of menu.

			var height = 20; //for scroll buttons
			for (var i = 0; i < limRows; i++) {
				var rowSize = Dwt.getSize(rows[i]).y;
				if (height + rowSize <= availableSpace) {
					height += rowSize;
                }
				else {
					break;
                }
			}
			mySize.y = height;
		}
	}

	var newW = "auto";
	var newH = "auto";
	if (isPopup && isScroll) {
		newH = mySize.y;
		if (this._tableContainer) {
			this._tableContainer.style.height = (newH - 20) +"px";
        }
	}
    else if ((isPopup && isCascade) || y + mySize.y < windowSize.y - 5 ) {
		newH = "auto";
	}
    else {
		newH = windowSize.y - y - 5;
	}
    if (isScroll) {
	    if (this._table) {
		    this._table.style.width = mySize.x;
        }
        newW = mySize.x;
    }
    this.setSize(newW, newH);
	// NOTE: This hack is needed for FF/Moz because the containing div
	//	   allows the inner table to overflow. When the menu cascades
	//	   and the menu items get pushed off of the visible area, the
	//	   div's border doesn't surround the menu items. This hack
	//	   forces the outer div's width to surround the table.

	if ((AjxEnv.isGeckoBased || AjxEnv.isSafari || (this._origStyle == DwtMenu.CALENDAR_PICKER_STYLE)) && this._table && !isScroll) {
		htmlEl.style.width = (mySize.x + (isPopup && !isCascade ? 10 : 0)) + "px";
	}

	// Popup menu type
	var newX = x + mySize.x >= windowSize.x ? windowSize.x - mySize.x : x;
	if (this.parent instanceof DwtMenuItem) {
		Dwt.delClass(htmlEl, "DwtMenu-congruentLeft");
		Dwt.delClass(htmlEl, "DwtMenu-congruentRight");

		var pbound = this.parent.getBounds();
		var pmstyle = DwtCssStyle.getComputedStyleObject(this.parent.parent.getHtmlElement()); // Get the style for the DwtMenu holding the parent DwtMenuItem
		var tstyle = DwtCssStyle.getComputedStyleObject(htmlEl); // Get the style for this menu (includes skinning)

		//if the cascading extends over the edge of the screen, cascade to the left
		if (((newX > pbound.x && newX < pbound.x + pbound.width) || (pbound.x >= newX && pbound.x < newX + mySize.x)) && pbound.x >= mySize.x) {
			var totalWidth = parseInt(tstyle.width);
			if (!AjxEnv.isIE) {
				totalWidth += parseInt(tstyle.paddingLeft) + parseInt(tstyle.paddingRight) + parseInt(tstyle.borderLeftWidth) + parseInt(tstyle.borderRightWidth);
            }
			newX = (parseInt(pmstyle.left) || pbound.x) - (totalWidth || mySize.x);
			if (this._congruent) {
				var offset;
				if (AjxEnv.isIE) {
					offset = parseInt(tstyle.borderLeftWidth);
                }
				else {
					offset = parseInt(tstyle.borderLeftWidth) + parseInt(tstyle.borderRightWidth);
                }
				if (!isNaN(offset)) {
					newX += offset;
					Dwt.addClass(htmlEl, "DwtMenu-congruentLeft");
				}
			}
		}
        else { // Cascade to the right
			var left = parseInt(pmstyle.left) || (pbound.x - (parseInt(pmstyle.paddingLeft) || 0));
			var width = parseInt(pmstyle.width) || pbound.width;
			newX = left + width;
			if (this._congruent) {
				var offset = parseInt(pmstyle.paddingRight) + parseInt(tstyle.paddingLeft) + parseInt(tstyle.borderLeftWidth);
				if (!isNaN(offset)) {
					newX += offset;
					Dwt.addClass(htmlEl, "DwtMenu-congruentRight");
				}
			}
		}
	}

    if (this._style === DwtMenu.DROPDOWN_CENTERV_STYLE) {
        y -=  mySize.y/2;
        if (y < 0) {
            y = 0;
        }
    }
	var newY = isPopup && y + mySize.y >= windowSize.y ? windowSize.y - mySize.y : y;

	if (this.parent instanceof DwtMenuItem && this._congruent) {
		var offset = (parseInt(tstyle.paddingTop) || 0) - (parseInt(tstyle.borderTopWidth) || 0);
		if (offset > 0) {
			newY -= offset;
        }
	}

    // make sure we aren't locating the menu offscreen
    newX = newX < 0 && newX !== Dwt.DEFAULT ? 0 : newX;
    newY = newY < 0 && newY !== Dwt.DEFAULT ? 0 : newY;
	this.setLocation(newX, newY);
};

DwtMenu.prototype.getKeyMapName = 
function() {
	return DwtKeyMap.MAP_MENU;
};

DwtMenu.prototype._handleScroll =
function(divID, ev) {
	if (!ev) ev = window.event;
	var div = Dwt.byId(divID);
	if (div && ev) {
	 	ev = ev ? ev : window.event;
	  	var wheelData = ev.detail ? ev.detail * -1 : ev.wheelDelta / 40;
		var rows = div.rows;
		var step = Dwt.getSize(rows[0]).y || 10;
		this._popdownSubmenus();
		if (wheelData > 0) { //scroll up
			this._doScroll(div, +step)
		} else if (wheelData < 0) { //scroll down
			this._doScroll(div, -step)
		}
	}
};

DwtMenu.prototype._handleMouseOut = 
function(divID, tableID, ev) {
	if (divID && ev.type && ev.type == "mouseout" && !AjxEnv.isIE) {
		var div = divID ? Dwt.byId(divID) : null;
		fromEl = ev.target;
		if (fromEl != div) {
			return;
		}
		toEl = ev.relatedTarget;
		while (toEl) {
			toEl = toEl.parentNode;
			if (toEl == div) {
				return;
			}
		}
		this._scroll(tableID, false, false, null);
	}
};

DwtMenu.prototype._scroll =
function(divID, scrolling, direction, ev) {
	var div = divID ? document.getElementById(divID) : null;
	if (div && scrolling) {
		var rows = div.rows;
		var step = Dwt.getSize(rows[0]).y || 10;
		if (this._direction != direction || !this._scrollTimer) {
			this._popdownSubmenus();
			this._direction = direction;
			if (this._scrollTimer) {
				clearInterval(this._scrollTimer);
				this._scrollTimer = null;
			}
	
			if (direction) { //scroll down
				this._scrollTimer = setInterval(AjxCallback.simpleClosure(this._doScroll, this, div, -step), 100);
				this._doScroll(div, -step);
			} else { //scroll up
				this._scrollTimer = setInterval(AjxCallback.simpleClosure(this._doScroll, this, div, step), 100);
				this._doScroll(div, step);
			}
		}
	} else {
		if (this._scrollTimer) {
			clearInterval(this._scrollTimer);
			this._scrollTimer = null;
		}
	}
};

DwtMenu.prototype._doScroll =
function(div, step) {
	if (div && step) {
		var old = parseInt(div.style.top) || 0;
		var top;
		if (step < 0) { // scroll down
			var rows = this._table.rows || null;
			var height = rows && rows.length && Dwt.getSize(rows[0]).y;
			var max = div.scrollHeight - (parseInt(div.parentNode.style.height) || ((this._maxRows || (rows && rows.length)) * height) || 0);
			if (Math.abs(old + step) <= max) {
				top = old + step;
			} else {
				top = -max;
			}
		} else { // scroll up
			if ((old + step) < 0) {
				top = old + step;
			} else {
				top = 0;
			}
		}
		Dwt.setLocation(div, Dwt.DEFAULT, top);
	}
};

/**
 * Checks a menu item (the menu must be radio or checkbox style). The menu item
 * is identified through the given field/value pair.
 *
 * @param {DwtMenuItem}		item				the menu item to scroll to
 * @param {boolean}			justMakeVisible		false: scroll so the item is in the topmost row; true: scroll so the item is visible (scrolling down to an item puts it in the bottom row, doesn't scroll if the item is already visible)
 * 
 */
DwtMenu.prototype.scrollToItem =
function(item, justMakeVisible) {
	var index = this.getItemIndex(item);
	if (index != -1)
		this.scrollToIndex(index, justMakeVisible);
};

DwtMenu.prototype.scrollToIndex = 
function(index, justMakeVisible) {
	if (this._created && this._layoutStyle == DwtMenu.LAYOUT_SCROLL && index !== null && index >= 0 && this._table) {
		var rows = this._table.rows;
		if (rows) {
			var maxRows = this._maxRows;
			var visibleHeight = 0;
			var rowHeights = [];
			for (var i = 0, numRows = rows.length; i < numRows; i++) {
				var h = Dwt.getSize(rows[i]).y;
				if (i < maxRows)
					visibleHeight += h;
				rowHeights.push(h);
			}
		
			var itemHeight = rowHeights[index];
			var currentOffset = parseInt(this._table.style.top) || 0;
			if (index >= rows.length)
				index = rows.length-1;
			
			var itemOffset = 0;
			for (var i=0; i<index && i<rowHeights.length; i++) {
				itemOffset += rowHeights[i];
			}
			var delta = 0;
			if (justMakeVisible) {
				if (itemOffset < -currentOffset) {
					delta = -(itemOffset + currentOffset); // Scroll up, making the item the topmost visible row
				} else if (itemOffset + itemHeight > visibleHeight - currentOffset) {
					delta = -(itemOffset + currentOffset - visibleHeight + itemHeight); // Scroll down, making the item the lowermost visible row
				} // else do not scroll; item is already visible
			} else {
				delta = -(itemOffset + currentOffset); // Scroll so that the item is the topmost visible row
			}
			if (delta) {
				this._popdownSubmenus();
				this._doScroll(this._table, delta);
			}
		}
	}
};

DwtMenu.prototype.handleKeyAction = function(actionCode, ev) {

	// For now don't deal with anything but BAR, POPUP, and DROPDOWN style menus
	switch (this._style) {
		case DwtMenu.BAR_STYLE:
		case DwtMenu.POPUP_STYLE:
        case DwtMenu.DROPDOWN_STYLE:
        case DwtMenu.DROPDOWN_CENTERV_STYLE:
			break;
			
		default:
			return false;
	}

	switch (actionCode) {

		case DwtKeyMap.PAGE_UP:
		case DwtKeyMap.PAGE_DOWN:
			var item = this.__currentItem || this._children.get(0);
			var index = this.getItemIndex(item);
			if (this._maxRows && index !== -1) {
				this.setSelectedItem(index + ((actionCode === DwtKeyMap.PAGE_UP) ? -this._maxRows : this._maxRows));
			}
            else {
				this.setSelectedItem(actionCode === DwtKeyMap.PAGE_DOWN);
			}
			break;

        case DwtKeyMap.SELECT_PREV:
		case DwtKeyMap.SELECT_NEXT:
			this.setSelectedItem(actionCode === DwtKeyMap.SELECT_NEXT);
			break;

		case DwtKeyMap.SELECT:
			if (this.__currentItem) {
				this.__currentItem._emulateSingleClick();
			}
			break;
		
		case DwtKeyMap.SUBMENU:
			if (this.__currentItem && this.__currentItem._menu) {
				this.__currentItem._popupMenu(0, true);	
			}
			break;
			
		case DwtKeyMap.PARENTMENU:
			if (this.parent.isDwtMenuItem) {
				this.popdown();
                this.parent.focus();
			}

			break;
			
		case DwtKeyMap.CANCEL:
			this.popdown();
			break;		
			
		default:
			return false;		
	}
	
	return true;
};

/**
 * This allows the caller to associate one object with the menu. Association
 * means, for events, treat the menu, and this object as one. If I click on
 * elements pertaining to this object, we will think of them as part of the
 * menu. 
 * @see _outsideMouseListener.
 * 
 * @private
 */
DwtMenu.prototype.setAssociatedObj =
function(dwtObj) {
	this._associatedObj = dwtObj;
};

DwtMenu.prototype.setAssociatedElementId =
function(id){
	this._associatedElId = id;
};

/**
 * Checks a menu item (the menu must be radio or checkbox style). The menu item
 * is identified through the given field/value pair.
 *
 * @param {Object}	field		a key for menu item data
 * @param {Object}	value		value for the data of the menu item to check
 * 
 */
DwtMenu.prototype.checkItem =
function(field, value, skipNotify) {
	var items = this._children.getArray();
	for (var i = 0; i < items.length; i++) {
		var item = items[i];
		if (!(item.isStyle(DwtMenuItem.CHECK_STYLE) || item.isStyle(DwtMenuItem.RADIO_STYLE))) {
			continue;
		}
		var val = item.getData(field);
	 	if (val == value)
			item.setChecked(true, skipNotify);
	}
};

/**
 * Programmatically selects a menu item. The item can be specified with an index,
 * or as the next or previous item based on which item is currently selected. If
 * the new item is a separator or is disabled, it won't be selected. Instead, the
 * next suitable item will be used.
 * 
 * @param {boolean|number}	which		if <code>true</code>, selects the next menu item
 * 									if <code>false</code>, selects the previous menu item
 * 									if <code>DwtMenuItem</code>, select that menu item
 * 									if <code>int</code>, selects the menu item with that index
 */
DwtMenu.prototype.setSelectedItem =
function(which, preventFocus) {
	var currItem = this.__currentItem;
	if (typeof(which) == "boolean") {
		currItem = !currItem
			? this._children.get(0)
			: which ? this._children.getNext(currItem) : this._children.getPrev(currItem);
	} else if (which instanceof DwtMenuItem) {
		if (this._children.contains(which))
			currItem = which;
	} else {
		which = Math.max(0, Math.min(this._children.size()-1, which));
		currItem = this._children.get(which);
	}
	// While the current item is not enabled or is a separator, try another
	while (currItem) {
		if (!currItem.isStyle) { // this is not a DwtMenuItem
			if (!preventFocus) {
				currItem.focus();
			}
			break;
		}
		else if (!currItem.isStyle(DwtMenuItem.SEPARATOR_STYLE) && currItem.getEnabled() && currItem.getVisible()) {
			break;
		}
		currItem = (which === false) ? this._children.getPrev(currItem) : this._children.getNext(currItem);
	}
	if (!currItem) { return; }

	this.scrollToItem(currItem, true);
	if (!preventFocus) {
		currItem.focus();
	}

	if (this.parent && this.parent._menuItemSelected) {
		this.parent._menuItemSelected(currItem);
	}
};

DwtMenu.prototype.clearExternallySelectedItems =
function() {
	if (this._externallySelected != null) {
		this._externallySelected._deselect();
		this._externallySelected = null;
	}
};

DwtMenu.prototype.removeChild =
function(child) {
	if (this._table) {
		if (this._style == DwtMenu.BAR_STYLE) {
			var cell = child.getHtmlElement().parentNode;
			this._table.rows[0].deleteCell(Dwt.getCellIndex(cell));
		} else {
			var el = child.getHtmlElement();
			if (el && el.parentNode && el.parentNode.parentNode.rowIndex > -1)// Make sure that the element exists in the table
				this._table.deleteRow(el.parentNode.parentNode.rowIndex);
		}
	}
	this._children.remove(child);

    if (child.removeSelectionListener) {
        child.removeSelectionListener(this._itemSelectionListener);
    }
};

DwtMenu.prototype.addChild = 
function(child) {
    DwtComposite.prototype.addChild.apply(this, arguments);
    // Color pickers and calendars are not menu aware so we have to deal with
	// them acordingly
	if (Dwt.instanceOf(child, "DwtColorPicker") || Dwt.instanceOf(child, "DwtCalendar") ||
	    (this._style == DwtMenu.GENERIC_WIDGET_STYLE)) {
		
		this._addItem(child);
	}

    if (child.addSelectionListener) {
        child.addSelectionListener(this._itemSelectionListener);
    }
};

// All children are added now, including menu items. Previously, it wasn't
// reparenting and that was preventing the menu items from using templates
// because they need to be in the DOM in order to get access to elements
// within the template.
DwtMenu.prototype._addItem =
function(item, index) {
	if (this._style == DwtMenu.COLOR_PICKER_STYLE ||
		this._style == DwtMenu.CALENDAR_PICKER_STYLE ||
		this._style == DwtMenu.GENERIC_WIDGET_STYLE)
	{
		return;
	}

	var row;
	var col;
	if (this._style == DwtMenu.BAR_STYLE) {
		var rows = this._table.rows;
		row = (rows.length != 0) ? rows[0]: this._table.insertRow(0);
		if (index == null || index > row.cells.length)
			index = rows.cells.length;
		col = row.insertCell(index);
		col.align = "center";
		col.vAlign = "middle";
		var spc = row.insertCell(-1);
		spc.nowrap = true;
		spc.width = "7px";
	} else {
		// If item we're adding is check/radio style, and its the first such
		// item in the menu, then we must instruct our other children to add 
		// a "checked column" to ensure that things line up
		if (item.isStyle && (item.isStyle(DwtMenuItem.CHECK_STYLE) || item.isStyle(DwtMenuItem.RADIO_STYLE))) {
			this._checkItemAdded();
		}
		if (index == null || index > this._table.rows.length)
			index = -1;
		row = this._table.insertRow(index);
		col = row.insertCell(0);
	}
	col.noWrap = true;
	col.appendChild(item.getHtmlElement());
//	this._children.add(item, index);
};

DwtMenu.prototype._radioItemSelected =
function(child, skipNotify) {
	var radioGroupId = child._radioGroupId;
	var sz = this._children.size();
	var a = this._children.getArray();
	for (var i = 0; i < sz; i++) {
		if (a[i] != child && a[i].isStyle(DwtMenuItem.RADIO_STYLE) &&
			a[i]._radioGroupId == radioGroupId && a[i]._itemChecked)
		{
			a[i].setChecked(false, skipNotify);
			break;
		}
	}
};

DwtMenu.prototype._propagateItemSelection = function(evt) {
    if (this.isListenerRegistered(DwtEvent.SELECTION)) {
        this.notifyListeners(DwtEvent.SELECTION, evt);
    }
};

DwtMenu.prototype._menuHasCheckedItems =
function() {
	return this._menuItemsHaveChecks;
};

DwtMenu.prototype._menuHasItemsWithIcons =
function() {
	return this._menuItemsHaveIcons;
};

DwtMenu.prototype._menuHasSubmenus =
function() {
	return (this._menuItemsWithSubmenus > 0);
};

/* Once an icon is added to any menuItem, then the menu will be considered
 * to contain menu items with icons in perpetuity */
DwtMenu.prototype._iconItemAdded =
function(item) {
	if (!this._menuItemsHaveIcons) Dwt.addClass(this.getHtmlElement(), DwtMenu.HAS_ICON);
	this._menuItemsHaveIcons = true;
};

/* Once an check/radio is added to any menuItem, then the menu will be considered
 * to contain checked items in perpetuity */
DwtMenu.prototype._checkItemAdded = function(item) {
	if (!this._menuItemsHaveChecks) Dwt.addClass(this.getHtmlElement(), DwtMenu.HAS_CHECK);
	this._menuItemsHaveChecks = true;
};

DwtMenu.prototype._submenuItemAdded =
function() {
	Dwt.addClass(this.getHtmlElement(), DwtMenu.HAS_SUBMENU);
	this._menuItemsWithSubmenus++;
};

DwtMenu.prototype._submenuItemRemoved =
function() {
	if (this._menuItemsWithSubmenus == 1) {
		var sz = this._children.size();
		var a = this._children.getArray();
		for (var i = 0; i < sz; i++)
			a[i]._submenuItemRemoved();
	}
	this._menuItemsWithSubmenus--;
	if (this._menuItemsWithSubmenus == 0) {
		Dwt.delClass(this.getHtmlElement(), DwtMenu.HAS_SUBMENU);
	}
};

DwtMenu.prototype._popdownSubmenus = function() {
	var sz = this._children.size();
	var a = this._children.getArray();
	for (var i = 0; i < sz; i++) {
		if (a[i]._popdownMenu) a[i]._popdownMenu();
	}
};

DwtMenu.prototype.dontStealFocus =
function(val) {
	if (val == null)
		val = true;
	this.__preventMenuFocus = !!val;
};

DwtMenu.prototype._doPopup =
function(x, y, kbGenerated) {

	// bump z-index if we're inside a dialog
	var zIndex = DwtBaseDialog.getActiveDialog() ? Dwt.Z_DIALOG_MENU : Dwt.Z_MENU;
	this.setZIndex(zIndex);
	this.setVisible(true);

	this.render(x, y);

	var isScroll = this._layoutStyle == DwtMenu.LAYOUT_SCROLL;
	var isCascade = this._layoutStyle == DwtMenu.LAYOUT_CASCADE;
	if (!isScroll) {
		this.setScrollStyle(this._isPopupStyle() && isCascade ? Dwt.CLIP : Dwt.SCROLL);
	} else if (this._tableContainer) {
		Dwt.setScrollStyle(this._tableContainer, Dwt.CLIP);
	}
	
	this.notifyListeners(DwtEvent.POPUP, this);

	// Hide the tooltip
	var tooltip = this.shell.getToolTip();
	if (tooltip) {
		tooltip.popdown();
	}

	this._popupActionId = -1;
	this._isPoppedUp = true;

	var omem = DwtOutsideMouseEventMgr.INSTANCE;
	var omemParams = {
		id:					"DwtMenu",
		obj:				this,
		outsideListener:	this._outsideListener
	}
	omem.startListening(omemParams);

	if (!DwtMenu._activeMenu) {
		DwtMenu._activeMenu = this;
		DwtMenu._activeMenuUp = true;
	}

	DwtMenu._activeMenuIds.add(this._htmlElId, null, true);
	DwtMenu._activeMenuIds.sort();	
	DwtMenu._activeMenus.add(this, null, true);

	// Put our tabgroup in play
	DwtShell.getShell(window).getKeyboardMgr().pushTabGroup(this._compositeTabGroup, this.__preventMenuFocus);

	/* If the popup was keyboard generated, then pick the first enabled child
	   item */
	if (kbGenerated || !this.parent.isDwtMenu) {
	 	this.setSelectedItem(0, this.__preventMenuFocus);
	}
};

DwtMenu.prototype.getSize =
function(incScroll) {
	var size;
	if (this._table) {
		size = Dwt.getSize(this._table, incScroll);
	} else {
		size = DwtComposite.prototype.getSize.call(this, incScroll);
	}
	if (this._width && this._width > size.x) size.x = this._width;
	return size;
};

DwtMenu.prototype._doPopdown =
function(ev) {
	// Notify all sub menus to pop themselves down
	var a = this._children.getArray();
	var s = this._children.size();
	for (var i = 0; i < s; i++) {
		if ((a[i] instanceof DwtMenuItem) && !(a[i].isStyle(DwtMenuItem.SEPARATOR_STYLE))) {
			a[i]._popdownMenu();
		}
	}
	this.setVisible(false);
	this._ev = ev;

	this.notifyListeners(DwtEvent.POPDOWN, this);

	var omem = DwtOutsideMouseEventMgr.INSTANCE;
	omem.stopListening({id:"DwtMenu", obj:this});

	if (DwtMenu._activeMenu == this) {
		DwtMenu._activeMenu = null;
		DwtMenu._activeMenuUp = false;
	}
	DwtMenu._activeMenuIds.remove(this._htmlElId);
	DwtMenu._activeMenus.remove(this);
	this._popdownActionId = -1;
	this._isPoppedUp = false;

	if (this._isPopupStyle() && this._table && this._table.rows && this._table.rows.length && this._table.rows[0].cells.length)	{
		var numColumns = this._table.rows[0].cells.length;
		var numRows = this._table.rows.length;
		for (var i = 1; i < numColumns; i++) {
			for (var j = 0; j < numRows; j++) {
				var cell = this._table.rows[j].cells[i];
				if (!cell.empty) {
					var child = cell.firstChild;
					var row = this._table.insertRow(this._table.rows.length);
					var cell = row.insertCell(0);
					while (child != null) {
						cell.appendChild(child);
						child = child.nextSibling;
					}
				}
			}
		}
		for (var j = 0; j < numRows; j++) {
			var row = this._table.rows[j];
			for (var i = row.cells.length - 1; i > 0; i--) {
				row.deleteCell(i);
			}
		}
	}

	if (this.__currentItem) {
		this.__currentItem.blur();
	}

	// Take our tabgroup out of play
	DwtShell.getShell(window).getKeyboardMgr().popTabGroup(this._compositeTabGroup);
};

DwtMenu.prototype._getActiveItem = 
function(){
	var a = this._children.getArray();
	var s = this._children.size();
	for (var i = 0; i < s; i++) {
		if (a[i]._isMenuPoppedUp())
			return a[i];
	}
	return null;
};

DwtMenu._outsideMouseDownListener =
function(ev) {

	if (DwtMenu._activeMenuUp) {
		var menu = DwtMenu._activeMenu;

		// assuming that the active menu is the parent of all other menus
		// that are up, search through the array of child menu dom IDs as
		// well as our own.
		var id = menu._htmlElId;
		var htmlEl = DwtUiEvent.getTarget(ev);
		while (htmlEl != null) {
			if (htmlEl.id && htmlEl.id != "" && 
				(htmlEl.id == id || htmlEl.id == menu._associatedElId ||
				 DwtMenu._activeMenuIds.binarySearch(htmlEl.id) != -1 )) {
				return false;
			}
			htmlEl = htmlEl.parentNode;
		}

		// If we've gotten here, the mousedown happened outside the active
		// menu, so we hide it.
		menu.popdown(0, ev);
		
		//it should remove all the active menus 
		var cMenu = null ;
		do {
			cMenu = DwtMenu._activeMenus.getLast();
			if (cMenu!= null && cMenu instanceof DwtMenu) cMenu.popdown();
		} while (cMenu != null) ;
	}
};

DwtMenu._stopEvent = function(e) {
	if (!e) e = window.event;
	e.cancelBubble = true;
	if (e.stopPropagation) {
		e.stopPropagation();
	}
};

/*
* Returns true if any menu is currently popped up.
*/
DwtMenu.menuShowing =
function() {
	return DwtMenu._activeMenuUp;
};

DwtMenu.closeActiveMenu =
function(ev) {
	if (DwtMenu._activeMenuUp) {
		DwtMenu._activeMenu.popdown(0, ev);
	}
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtMessageDialog")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * @overview
 * This file contains classes for a message dialog.
 */

/**
 * @class
 * 
 * Creates a new message dialog. This class represents a reusable message dialog box.
 * Messages can be informational, warning, or critical.
 * 
 * @author Ross Dargahi
 * 
 * @param {hash}		params			a hash of parameters
 * @param {DwtComposite}	params.parent		the parent widget (the shell)
 * @param {string}	params.className 		the CSS class
 * @param {array}	params.buttons				the buttons to show. Defaults to {@link DwtDialog.OK_BUTTON} button
 * @param {array}	params.extraButtons	  	a list of {@link DwtDialog_ButtonDescriptor} objects describing custom buttons to add to the dialog
 * @param {String} params.helpText  shows a left aligned help button with the text specified in this param.
 * 
 * @extends	DwtDialog
 */
DwtMessageDialog = function(params) {
	if (arguments.length == 0) { return; }
	params = Dwt.getParams(arguments, DwtMessageDialog.PARAMS);
	this._msgCellId = Dwt.getNextId("MessageDialog_");
	params.standardButtons = params.buttons || [DwtDialog.OK_BUTTON];

	if (params.helpText) {
		var helpButton = new DwtDialog_ButtonDescriptor(DwtMessageDialog.HELP_BUTTON, params.helpText, DwtDialog.ALIGN_LEFT);
		params.extraButtons = params.extraButtons || [];
		params.extraButtons.push(helpButton);
		DwtDialog.call(this, params);
		this.registerCallback(DwtMessageDialog.HELP_BUTTON, function() {
			ZmZimbraMail.helpLinkCallback(this._helpURL);
		},this);
	} else {
		DwtDialog.call(this, params);
	}
	
	this.setContent(this._contentHtml());
	this._msgCell = document.getElementById(this._msgCellId);
	this.addEnterListener(new AjxListener(this, this._enterListener));
	this._setAllowSelection();

	if (AjxEnv.isSafari) {
		this.setAttribute('aria-labelledby',
		                  this._titleEl.id + ' ' + this._msgCellId);
	} else {
		this.setAttribute('aria-describedby', this._msgCellId);
	}
};

DwtMessageDialog.PARAMS = ["parent", "className", "buttons", "extraButtons", "id"];

DwtMessageDialog.prototype = new DwtDialog;
DwtMessageDialog.prototype.constructor = DwtMessageDialog;
DwtMessageDialog.prototype.isDwtMessageDialog = true;
DwtMessageDialog.prototype.role = 'alertdialog';

DwtMessageDialog.prototype.toString = function() {
	return "DwtMessageDialog";
};

/**
 * Defines the "critical" style.
 */
DwtMessageDialog.CRITICAL_STYLE = 1;
/**
 * Defines the "info" style.
 */
DwtMessageDialog.INFO_STYLE = 2;
/**
 * Defines the "warning" style.
 */
DwtMessageDialog.WARNING_STYLE = 3;
/**
 * Defines a style with no icon.
 */
DwtMessageDialog.PLAIN_STYLE = 4;

DwtMessageDialog.TITLE = {};
DwtMessageDialog.TITLE[DwtMessageDialog.CRITICAL_STYLE] = AjxMsg.criticalMsg;
DwtMessageDialog.TITLE[DwtMessageDialog.INFO_STYLE] = AjxMsg.infoMsg;
DwtMessageDialog.TITLE[DwtMessageDialog.WARNING_STYLE] = AjxMsg.warningMsg;
DwtMessageDialog.TITLE[DwtMessageDialog.PLAIN_STYLE] = AjxMsg.infoMsg;

DwtMessageDialog.ICON = {};
DwtMessageDialog.ICON[DwtMessageDialog.CRITICAL_STYLE] = "Critical_32";
DwtMessageDialog.ICON[DwtMessageDialog.INFO_STYLE] = "Information_32";
DwtMessageDialog.ICON[DwtMessageDialog.WARNING_STYLE] = "Warning_32";

DwtMessageDialog.HELP_BUTTON = "Help";
// Public methods

/**
 * Returns a string representation of the object.
 * 
 * @return		{string}		a string representation of the object
 */
DwtMessageDialog.prototype.toString = 
function() {
	return "DwtMessageDialog";
};

/**
* Sets the message style (info/warning/critical) and content.
*
* @param {string}	msgStr		the message text
* @param {constant}	style		the style (see <code>DwtMessageDialog.*_STYLE</code> constants)
* @param {string}	title		the dialog box title
*/
DwtMessageDialog.prototype.setMessage =
function(msgStr, style, title) {
	this._message = msgStr || "";
	this._style = style || this._getDefaultStyle();

	this.setTitle(title || DwtMessageDialog.TITLE[this._style]);

	if (msgStr) {
        var html = [];
		var i = 0;
		html[i++] = "<table role='presentation' cellspacing=0 cellpadding=0 border=0 width=100% height=100%><tr>";
		if (DwtMessageDialog.ICON[this._style]) {
			html[i++] = "<td valign='top'>"
			html[i++] = AjxImg.getImageHtml({
				imageName: DwtMessageDialog.ICON[this._style],
				attrStr: "id='" +  this._msgCellId + "_Image''",
				altText: DwtMessageDialog.TITLE[this._style]
			});
			html[i++] = "</td>";
		}
		html[i++] = "<td class='DwtMsgArea' id='" +  this._msgCellId +"_Msg'>";
		html[i++] = msgStr;
		html[i++] = "</td></tr></table>";
		this._msgCell.innerHTML = html.join("");
	} else {
		this._msgCell.innerHTML = "";
	}
};

/**
 * Sets the message style (info/warning/critical) and content.
 *
 * @param {string}	url		the url of the help
 */
DwtMessageDialog.prototype.setHelpURL =
function(url) {
	this._helpURL = url;
}

DwtMessageDialog.prototype.setSize =
function(width, height) {
	var msgCell = document.getElementById(this._msgCellId);
	if (msgCell && (width || height)) {
		Dwt.setSize(msgCell, width, height);
	}
};

DwtMessageDialog.prototype._getDefaultStyle = function() {
	return DwtMessageDialog.INFO_STYLE;
}

/**
 * Resets the message dialog. This should be performed to "reuse" the dialog.
 * 
 */
DwtMessageDialog.prototype.reset = 
function() {
	this._msgCell.innerHTML = "";
	this._helpURL = "";
	DwtDialog.prototype.reset.call(this);
};

/**
 * Handles the dialog key action. If the user hits the "Esc" key and no "Cancel" button is present,
 * the key action is treated it as a press of the "OK" button.
 * 
 * @param	{DwtKeyMap}		actionCode	the key action code
 * @param	{DwtKeyEvent}	ev	the key event
 * 
 * @private
 */
DwtMessageDialog.prototype.handleKeyAction =
function(actionCode, ev) {
	return DwtDialog.prototype.handleKeyAction.call(this, actionCode, ev);
};

// Private methods

/**
 * @private
 */
DwtMessageDialog.prototype._contentHtml = 
function() {
	return "<div id='" + this._msgCellId + "' class='DwtMsgDialog'></div>";
};

/**
 * @private
 */
DwtMessageDialog.prototype._enterListener =
function(ev) {
	this._runEnterCallback();
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtOptionDialog")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * @overview
 *
 * This file contains a class for an option dialog; a message dialog asking a
 * question and providing a radio group of answers.
 */

/**
 * @class
 *
 * Creates a new option dialog.
 *
 * @author Dan Villiom Podlaski Christiansen
 *
 * @param {hash}		params			a hash of parameters
 * @param {DwtComposite}	params.parent		the parent widget (the shell)
 * @param {string}	params.className 		the CSS class
 * @param {array}	params.options				the options?
 * @param {string}	params.message 		the message/question to display
 * @param {string}	params.title 		dialog title
 *
 * @extends	DwtMessageDialog
 */
DwtOptionDialog = function(params) {
	if (arguments.length == 0) { return; }

	params.buttons =
		params.buttons || [DwtDialog.OK_BUTTON, DwtDialog.CANCEL_BUTTON];

	DwtMessageDialog.call(this, params);

	var options = params.options || [];

	this._options = [];
	this._selectedIdx = 0;

	this._buttonContainer = document.createElement('FIELDSET');
	this._buttonContainer.setAttribute('role', 'radiogroup');

	this._getContentDiv().appendChild(this._buttonContainer);

	for (var i = 0; i < options.length; i++) {
		var option = AjxUtil.hashCopy(options[i]);
		option.index = i;

		var checked = (i === 0);

		var button = option.button = new DwtRadioButton({
			parent: this,
			parentElement: this._buttonContainer,
			id: [this.getHTMLElId(), name, 'button'].join('_'),
			name: option.name,
			value: option.value || option.name,
			checked: checked
		});

		if (option.text) {
			button.setText(option.text);
		}

		button.getInputElement().setAttribute('aria-setsize', options.length);
		button.getInputElement().setAttribute('aria-posinset', i + 1);

		button.addSelectionListener(this._selectionListener.bind(this, i));

		this._options.push(option);
	}

	if (params.message) {
		this.setMessage(params.message, null, params.title);
	} else if (params.title) {
		this.setTitle(params.title);
	}
};

DwtOptionDialog.prototype = new DwtMessageDialog;
DwtOptionDialog.prototype.constructor = DwtOptionDialog;
DwtOptionDialog.prototype.isDwtOptionDialog = true;

DwtOptionDialog.prototype.toString = function() {
	return "DwtOptionDialog";
};

DwtOptionDialog.prototype.getKeyMapName =
function() {
	return DwtKeyMap.MAP_OPTION_DIALOG;
};

DwtOptionDialog.prototype._getDefaultStyle = function() {
	return DwtMessageDialog.PLAIN_STYLE;
}

DwtOptionDialog.prototype._updateSelection = function(idx, focus) {

	if (!AjxUtil.isNumber(idx) || idx < 0 || idx >= this._options.length) {
		return false;
	}

	this._selectedIdx = idx;

	for (var i = 0; i < this._options.length; i++) {
		this._options[i].button.setSelected(i === idx);
	}

	if (focus) {
		this._options[idx].button.focus();
	}

	return true;
};

DwtOptionDialog.prototype._getOptionByName = function(name) {
	for (var i = 0; i < this._options.length; i++) {
		if (this._options[i].name === name) {
			return this._options[i];
		}
	}

	return null;
};

DwtOptionDialog.prototype._selectionListener = function(idx, ev) {
	if (!ev.detail) {
		return;
	}

	this._updateSelection(idx);
};

DwtOptionDialog.prototype.getSelection = function() {
	var option = this._options[this._selectedIdx];
	return option.button ? option.button.getValue() : null;
};

DwtOptionDialog.prototype.setSelection = function(name) {
	var option = this._getOptionByName(name);
	this._updateSelection(option && option.index);
};

DwtOptionDialog.prototype.getButton = function(name) {
	var option = this._getOptionByName(name);
	return option && option.button;
};

DwtOptionDialog.prototype.handleKeyAction =
function(actionCode, ev) {
	switch (actionCode) {
	case DwtKeyMap.NEXT:
		return this._updateSelection(this._selectedIdx + 1, true);

	case DwtKeyMap.PREV:
		return this._updateSelection(this._selectedIdx - 1, true);

	default:
		return DwtMessageDialog.prototype.handleKeyAction.apply(this, arguments);
	}
};

DwtOptionDialog.prototype.popup =
function(loc) {
	DwtMessageDialog.prototype.popup.call(this, loc);

	this._updateSelection(0, true);
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtInputField")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * Creates an input field.
 * @constructor
 * @class
 * This class represents an input field..
 * <p>
 * <h3>CSS Elements</h3>
 * <ul>
 * <li><code>&lt;className&gt;</code> input 			specifies the look of the input field during normal editing
 * <li><code>&lt;className&gt;-error</code> input		specifies the look of the input field in an error state
 * </ul>
 *
 * @author Ross Dargahi
 *
 * @param {hash}	params			a hash of parameters
 * @param {DwtComposite}      params.parent			the parent widget
 * @param {constant}      params.type				the data type of the input field
 * @param {string}      params.initialValue		the initial value of the field
 * @param {number}      params.size				size of the input field (in characters)
 * @param {number}      params.rows				the number of rows (more than 1 means textarea)
 * @param {boolean}      params.forceMultiRow		if <code>true</code>, forces use of textarea even if rows == 1
 * @param {number}      params.maxLen			the maximum length (in characters) of the input
 * @param {constant}      params.errorIconStyle		the error icon style
 * @param {constant}      params.validationStyle	the validation type
 * @param  {function}     params.validator			the custom validation function
 * @param {Object}      params.validatorCtxtObj		the object context for validation function
 * @param {string}      params.className			the CSS class
 * @param {constant}      params.posStyle			the positioning style (see {@link DwtControl})
 * @param {boolean}      params.required          if <code>true</code>, mark as required.
 * @param {string}      params.hint				a hint to display in the input field when the value is empty.
 * @param {string}      params.id				an explicit ID to use for the control's DIV element
 * @param {string}      params.inputId			an explicit ID to use for the control's INPUT element
 *
 * @extends		DwtComposite
 * 
 */
DwtInputField = function(params) {

	if (arguments.length == 0) return;
	params.className = params.className  || "DwtInputField";
	this._origClassName = params.className;
	this._errorClassName = this._origClassName + "-error";
	this._hintClassName = this._origClassName + "-hint";
	this._disabledClassName = this._origClassName + "-disabled";
	this._focusedClassName = this._origClassName + "-focused";
	this._errorHintClassName = this._origClassName + "-errorhint";
	this._requiredClassName = this._origClassName + "-required";
	DwtComposite.call(this, params);

    this._inputEventHandlers = {};

    this._type = params.type ? params.type : DwtInputField.STRING;
    this._rows = params.rows ? params.rows : 1;
    this._size = params.size;

	this._errorIconStyle = params.errorIconStyle ? params.errorIconStyle :
							params.validator ? DwtInputField.ERROR_ICON_RIGHT : DwtInputField.ERROR_ICON_NONE;
	this._validationStyle = params.validationStyle ? params.validationStyle : DwtInputField.ONEXIT_VALIDATION;

	this._hasError = false;
	this._hintIsVisible = false;
	this._hint = params.hint;
	this._label = params.label;

	this.addListener(DwtEvent.ONFOCUS, this._focusHdlr.bind(this));
	this.addListener(DwtEvent.ONBLUR, this._blurHdlr.bind(this));
	this.addListener(DwtEvent.STATE_CHANGE, this._stateChanged.bind(this));

	var inputFieldId = params.inputId || Dwt.getNextId();
	var errorIconId = Dwt.getNextId();
	var htmlEl = this.getHtmlElement();
	if (this._errorIconStyle == DwtInputField.ERROR_ICON_NONE) {
		if (params.forceMultiRow || (params.rows && params.rows > 1)) {
			var htmlArr = ["<textarea id='", inputFieldId, "' rows=", params.rows];
			var i = htmlArr.length;
			if (params.forceMultiRow || params.size) {
				htmlArr[i++] = " cols=";
				htmlArr[i++] = params.size || 1;
			}
			if (params.wrap) {
				htmlArr[i++] = " wrap=";
				htmlArr[i++] = params.wrap;
			}
			htmlArr[i++] = "></textarea>"
			htmlEl.innerHTML = htmlArr.join("");
		} else {
			htmlEl.innerHTML = ["<input id='",inputFieldId,"'>"].join("");
		}

	} else {
		var htmlArr = ["<table cellspacing='0' cellpadding='0'><tr>"];
		var i = 1;
		if (this._errorIconStyle == DwtInputField.ERROR_ICON_LEFT)
			htmlArr[i++] = ["<td style='padding-right:2px;'id='", errorIconId, "'></td>"].join("");

		htmlArr[i++] = ["<td>", "<input id='", inputFieldId, "'>", "</td>"].join("");

		if (this._errorIconStyle == DwtInputField.ERROR_ICON_RIGHT)
			htmlArr[i++] = ["<td style='padding-left:2px;' id='", errorIconId, "'></td>"].join("");

		htmlArr[i++] = "</tr></table>";
		htmlEl.innerHTML = htmlArr.join("");

		if (this._errorIconStyle != DwtInputField.ERROR_ICON_NONE) {
			this._errorIconTd = document.getElementById(errorIconId);
			this._errorIconTd.vAlign = "middle";
			this._errorIconTd.innerHTML = DwtInputField._NOERROR_ICON_HTML;
		}
	}

	if (params.forceMultiRow || this._rows > 1) {
        this._inputField = document.getElementById(inputFieldId);
        this._inputField.onkeyup = DwtInputField._keyUpHdlr;
        this._inputField.onkeydown = DwtInputField._keyDownHdlr;

        if (params.size)
            this._inputField.size = params.size;
        if (params.maxLen)
            this._inputField.maxLength = this._maxLen = params.maxLen;

        //MOW:  this.setCursor("default");

        this._inputField.value = params.initialValue || "";
	}
    else {
        var oinput = document.getElementById(inputFieldId);
        var ninput = this.__createInputEl(params);
		// bug fix #
		if (AjxEnv.isCamino) {
			oinput.parentNode.style.overflow = "hidden";
		}
		oinput.parentNode.replaceChild(ninput, oinput);
	}

    this.setFocusElement(); // now that INPUT has been created
    this.setValidatorFunction(params.validatorCtxtObj, params.validator);
	this._setMouseEventHdlrs(false);
	this._setKeyPressEventHdlr(false);
	
    if (params.required != null) {
        this.setRequired(params.required);
    }

    if (params.hint != null) {
        this.setHint(params.hint);
    }
};

DwtInputField.prototype = new DwtComposite;
DwtInputField.prototype.constructor = DwtInputField;

DwtInputField.prototype.isDwtInputField = true;
DwtInputField.prototype.isInputControl = true;
DwtInputField.prototype.toString = function() { return "DwtInputField"; };

//
// Constants
//

// Error Icon Style
/**
 * Defines the "left" error icon style.
 */
DwtInputField.ERROR_ICON_LEFT = 1;
/**
 * Defines the "right" error icon style.
 */
DwtInputField.ERROR_ICON_RIGHT = 2;
/**
 * Defines the "none" error icon style.
 */
DwtInputField.ERROR_ICON_NONE = 3;

// Validation Style
/**
 * Validate field after each character is typed.
 */
DwtInputField.CONTINUAL_VALIDATION = 1;
/**
 * Validate the field (i.e. after TAB or CR).
 */
DwtInputField.ONEXIT_VALIDATION    = 2;
/**
 * Validate the field  manually.
 */
DwtInputField.MANUAL_VALIDATION    = 3;

// types
/**
 * Defines the "Integer or float input field" data type.
 */
DwtInputField.NUMBER 	= 1;
/**
 * Defines the "Integer input field (no floating point numbers)" data type.
 */
DwtInputField.INTEGER	= 2;
/**
 * Defines the "Numeric input field" data type.
 */
DwtInputField.FLOAT		= 3;
/**
 * Defines the "String input field" data type.
 */
DwtInputField.STRING	= 4;
/**
 * Defines the "Password input field" data type.
 */
DwtInputField.PASSWORD	= 5;
/**
 * Defines the "Date input field" data type.
 */
DwtInputField.DATE 		= 6;

DwtInputField._ERROR_ICON_HTML = AjxImg.getImageHtml("Critical");
DwtInputField._NOERROR_ICON_HTML = AjxImg.getImageHtml("Blank_9");

//
// Public methods
//

DwtInputField.prototype.dispose =
function() {
	this._errorIconTd = null;
	this._inputField = null;
	DwtComposite.prototype.dispose.call(this);
};

DwtInputField.prototype.setHandler =
function(eventType, hdlrFunc) {
	if (!this._checkState()) return;
    this._inputEventHandlers[eventType] = hdlrFunc;
	Dwt.setHandler(this.getInputElement(), eventType, hdlrFunc);
};

/**
 * Sets the input type.
 * 
 * @param	{constant}	type		the input type
 */
DwtInputField.prototype.setInputType = function(type) {

    if (type != this._type && this._rows == 1) {
        this._type = type;
        if (AjxEnv.isIE) {
            var oinput = this._inputField;
            var ninput = this.__createInputEl();
            oinput.parentNode.replaceChild(ninput, oinput);
        }
        else {
            this._inputField.type = this._type != DwtInputField.PASSWORD ? "text" : "password";
        }
    }
};

/**
 * Applies a regular expression to the contents of this input field, retaining
 * selection and carent location if supported by the browser.
 *
 * @param	{RegExp}	regex		the regular expression to search for
 * @param	{String}	replacement	the replacement string
 */
DwtInputField.prototype.applySubstitution = function(regex, replacement) {
	var match;

	while ((match = regex.exec(this.getValue()))) {
		this._inputField.setRangeText(replacement, match.index,
			                      match.index + match[0].length);

		if (!regex.global)
			return;
	}
};

/**
* Sets the validator function. This function is executed during validation.
*
* @param {Object}	obj 		if present, the validator function is executed within
*		the context of this object
* @param {function}	validator 	the validator function
*/
DwtInputField.prototype.setValidatorFunction =
function(obj, validator) {
	if (validator) {
		this._validator = validator;
		this._validatorObj = obj;
	} else {
		switch (this._type) {
			case DwtInputField.NUMBER:	this._validator = DwtInputField.validateNumber; break;
		    case DwtInputField.INTEGER:	this._validator = DwtInputField.validateInteger; break;
		    case DwtInputField.FLOAT:	this._validator = DwtInputField.validateFloat; break;
		    case DwtInputField.STRING:
		    case DwtInputField.PASSWORD:this._validator = DwtInputField.validateString;	break;
		    case DwtInputField.DATE: 	this._validator = DwtInputField.validateDate; break;
		    default: 					this._validator = DwtInputField.validateAny;
		}
	}
};

/**
* Sets the validator to be a regular expression instead of a function.
*
* @param {string}	regExp 	the regular expression
* @param {string}	errorString 		the error string to set for tooltip if the user enters invalid data
*/
DwtInputField.prototype.setValidatorRegExp =
function(regExp, errorString) {
	this._validator = regExp;
	this._validatorObj = null;
	this._errorString = errorString || "";
};

/**
* Sets a validation callback. This callback is invoked any time
* the input field is validated. The callback is invoked with two
* parameters. The first <code>params[0]</code> is the value of the input field.
* The second <code>params[1]</code> is a {Boolean} that if <code>true</code> indicates if the value is valid.
*
* @param {AjxCallback}	callback the callback
*/
DwtInputField.prototype.setValidationCallback =
function(callback) {
	this._validationCallback = callback;
};

/**
* Gets the internal native input element
*
* @return {Element}	the input element
*/
DwtInputField.prototype.getInputElement =
function() {
	return this._inputField;
};

/**
* Gets the input field current value.
*
* @return {string}	 the value
*/
DwtInputField.prototype.getValue =
function() {
	return this._hintIsVisible ? '' : AjxStringUtil.trim(this._inputField.value);
};

/**
 * Sets the value for the input field.
 *
 * @param	{string}	value	the value
 * @param	{boolean}	noValidate		if <code>true</code>, do not validate
 */
DwtInputField.prototype.setValue =
function(value, noValidate) {
	// XXX: if we're disabled, the validation step messes up the style
	value = value || "";
	this._inputField.value = value;
	if(!noValidate) {
		value = this._validateInput(value);
		if (value != null) {
			this._inputField.value = value;
		}
	}
	if (this._hintIsVisible && value) {
		this._hideHint(value);
	} else if (!value) {
		this._showHint();
	}
};

DwtInputField.prototype.clear =
function() {
	this.setValue("");
};

/**
 * Sets the hint for the input field.
 *
 * @param {string}	hint 	the hint
 */
DwtInputField.prototype.setHint =
function(hint) {
	this._hint = hint;
	var inputElement = this.getInputElement();
	if (AjxEnv.supportsPlaceholder) {
		inputElement.placeholder = hint || "";
		return;
	}

	if (this._hintIsVisible) {
		inputElement.value = hint;
		if (!hint) {
			this._hintIsVisible = false;
			this._updateClassName();
		}
	}
	else if (inputElement.value === '') {
		this._showHint();
	}
};

/**
 * Sets the ARIA label for the input field.
 *
 * @param {string}	label 	the label
 */
DwtInputField.prototype.setLabel =
function(label) {
	this._label = label;
	var inputElement = this.getInputElement();
	if (label) {
		inputElement.setAttribute('aria-label', label);
	} else {
		inputElement.removeAttribute('aria-label', label);
	}
};

/**
 * Sets a valid number range. This method is only applicable for numeric input fields. It sets
 * the valid range (inclusive) of numeric values for the field
 *
 * @param {number}		min 		the minimum permitted value or <code>null</code> for no minimum
 * @param {number}	max 		the maximum permitted value or <code>null</code> for no maximum
 */
DwtInputField.prototype.setValidNumberRange =
function(min, max) {
	this._minNumVal = min;
	this._maxNumVal = max;
	var value = this._validateInput(this.getValue());
	if (value != null)
		this.setValue(value);
};

/**
 * Sets a valid string length.
 *
 * @param {number}	min 		the minimum length or <code>null</code> for no minimum
 * @param {number}	max 		the maximum length or <code>null</code> for no maximum
 */
DwtInputField.prototype.setValidStringLengths =
function(minLen, maxLen) {
	this._minLen = minLen || 0;
	if (maxLen != null) {
		this._inputField.maxLength = maxLen;
		this._maxLen = maxLen;
	}
};

/**
 * Sets the number precision.
 * 
 * @param	{number}	decimals	the decimals
 */
DwtInputField.prototype.setNumberPrecision =
function(decimals) {
	this._decimals = decimals;
};

/**
 * Sets the read only flag.
 * 
 * @param	{boolean}	readonly		if <code>true</code>, make field read only
 */
DwtInputField.prototype.setReadOnly =
function(readonly) {
	this._inputField.setAttribute("readonly", (readonly == null ? true : readonly));
};

/**
 * Gets the required flag.
 * 
 * @return	{boolean}	<code>true</code> if the field is required
 */
DwtInputField.prototype.getRequired =
function() {
	var val = this.getInputElement().getAttribute('aria-required');

	//the attribute is always a String, and returns "true" or "false"
	return val && val.toLowerCase() === "true";
};

/**
 * Sets the required flag.
 * 
 * @param	{boolean}	required		if <code>true</code>, make field required
 */
DwtInputField.prototype.setRequired =
function(required) {
	//must set String as setAttribute only sets Strings... (no point in trying to set a boolean)
	this.getInputElement().setAttribute('aria-required', required ? "true" : "false");
};

/**
 * Sets the visibility flag.
 * 
 * @param	{boolean}	visible		if <code>true</code>, the field is visible
 */
DwtInputField.prototype.setVisible = function(visible) {
	DwtComposite.prototype.setVisible.apply(this, arguments);
	Dwt.setVisible(this.getInputElement(), visible);
};

/**
 * Checks the validity of the input field value.
 *
 * @return {string}	a canonical value if valid or <code>null</code> if the field value is not valid
 */
DwtInputField.prototype.isValid =
function() {
	if (!this.getEnabled()) {
		return this.getValue();
	}
	try {
		if (typeof this._validator == "function") {
			return this._validatorObj
				? this._validator.call(this._validatorObj, this.getValue(), this)
				: this._validator(this.getValue());
		} else {
			return this._validator.test(this._inputField.value);
		}
	} catch(ex) {
		if (typeof ex == "string")
			return null;
		else
			throw ex;
	}
};

/**
 * Checks the validity of the input field value; returns the error message, if any.
 */
DwtInputField.prototype.getValidationError =
function() {
	this.validate();

	return this._validationError;
};

/**
 * Validates the current input in the field. This method should be called
 * if the validation style has been set to DwtInputField.MANUAL_VALIDATION
 * and it is time for the field to be validated
 *
 * @return {boolean}	<code>true</code> if the field is valid
 */
DwtInputField.prototype.validate =
function() {
	var value = this._validateInput(this.getValue());
	if (value != null) {
		this.setValue(value);
		return true;
	} else {
		return false;
	}
};

/* Built-in validators */

/**
 * Validates a number.
 * 
 * @param	{string}	value		the value
 * @return	{boolean}	<code>true</code> if valid
 */
DwtInputField.validateNumber =
function(value) {
	var n = new Number(value);
	if (isNaN(n) || (Math.round(n) != n))
		throw AjxMsg.notAnInteger;
	return DwtInputField.validateFloat.call(this, value);
};

/**
 * Validates an integer.
 * 
 * @param	{string}	value		the value
 * @return	{boolean}	<code>true</code> if valid
 */
DwtInputField.validateInteger =
function(value) {
	var n = new Number(value);
	if (isNaN(n) || (Math.round(n) != n) || (n.toString() != value))
		throw AjxMsg.notAnInteger;
	if (this._minNumVal && value < this._minNumVal)
		throw AjxMessageFormat.format(AjxMsg.numberLessThanMin, this._minNumVal);
	if (this._maxNumVal && value > this._maxNumVal)
		throw AjxMessageFormat.format(AjxMsg.numberMoreThanMax, this._maxNumVal);
	return value;
};

/**
 * Validates a float.
 * 
 * @param	{string}	value		the value
 * @return	{boolean}	<code>true</code> if valid
 */
DwtInputField.validateFloat =
function(value) {
	var n = new Number(value);
	if (isNaN(n))
		throw AjxMsg.notANumber;
	if (this._minNumVal && value < this._minNumVal)
		throw AjxMessageFormat.format(AjxMsg.numberLessThanMin, this._minNumVal);
	if (this._maxNumVal && value > this._maxNumVal)
		throw AjxMessageFormat.format(AjxMsg.numberMoreThanMax, this._maxNumVal);

	// make canonical value
	if (this._decimals != null) {
		var str = n.toString();
		var pos = str.indexOf(".");
		if (pos == -1)
			pos = str.length;
		value = n.toPrecision(pos + this._decimals);
	} else {
		value = n.toString();
	}

	return value;
};

/**
 * Validates a string.
 * 
 * @param	{string}	value		the value
 * @return	{boolean}	<code>true</code> if valid
 */
DwtInputField.validateString =
function(value) {
	if (this._minLen != null && value.length < this._minLen)
		throw AjxMessageFormat.format(AjxMsg.stringTooShort, this._minLen);
	if (this._maxLen != null && value.length > this._maxLen)
		throw AjxMessageFormat.format(AjxMsg.stringTooLong, this._maxLen);
	return value;
};

/**
 * Validates a date.
 * 
 * @param	{string}	value		the value
 * @return	{boolean}	<code>true</code> if valid
 */
DwtInputField.validateDate = 
function(value) {
	if (AjxDateUtil.simpleParseDateStr(value) == null) {
		throw AjxMsg.invalidDatetimeString;
	}

	return value;
};

/**
 * Validates an email.
 * 
 * @param	{string}	value		the value
 * @return	{boolean}	<code>true</code> if valid
 */
DwtInputField.validateEmail = function(value) {
	if (!AjxEmailAddress.isValid(value))
		throw AjxMsg.invalidEmailAddr;
	return value;
};

DwtInputField.validateAny =
function(value) {
	// note that null will always be regarded as invalid. :-) I guess this
	// is OK.  An input field never has a null value.
	return value;
};

//
// Protected methods
//

DwtInputField.prototype._validateRegExp =
function(value) {
	if (this._regExp && !this._regExp.test(value)) {
		throw this._errorString;
	}
	return value;
};

DwtInputField._keyUpHdlr =
function(ev) {
	var keyEv = DwtShell.keyEvent;
	keyEv.setFromDhtmlEvent(ev, true);

	var obj = keyEv.dwtObj;
	var keyCode = keyEv.keyCode;
    if (obj.notifyListeners(DwtEvent.ONKEYUP, keyEv)) {
        return true;
    }

	// ENTER || TAB
	var val = null;
	if ((keyCode == 0x0D || keyCode == 0x09)
	    && obj._validationStyle == DwtInputField.ONEXIT_VALIDATION)
		val = obj._validateInput(obj.getValue());
	else if (obj._validationStyle == DwtInputField.CONTINUAL_VALIDATION)
		val = obj._validateInput(obj.getValue());

	if (val != null && val != obj.getValue())
		obj.setValue(val);

	return true;
};

DwtInputField.prototype._blurHdlr = function(ev) {

    DBG.println(AjxDebug.FOCUS, "DwtInputField ONBLUR: " + this);

    if (this.isDisposed()) {
        return;
    }
    this._updateClassName();
    if (this._validationStyle == DwtInputField.ONEXIT_VALIDATION) {
        var val = this._validateInput(this.getValue());
        if (val != null) {
            this.setValue(val);
        }
    }
    if (!this._hintIsVisible && this._hint) {
        this._showHint();
    }
};

DwtInputField.prototype._focusHdlr = function(ev) {

    DBG.println(AjxDebug.FOCUS, "DwtInputField ONFOCUS: " + this);
	appCtxt.getKeyboardMgr().updateFocus(this);
	this._updateClassName();
	if (this._hintIsVisible) {
		this._hideHint('');
	}
};

DwtInputField._keyDownHdlr =
function(ev) {
    var obj = DwtControl.getTargetControl(ev);
    if (obj) {
        if (obj._hintIsVisible) {
            obj._hideHint('');
        }
    }
};

DwtInputField.prototype._hideHint = 
function(value) {
	if (!AjxEnv.supportsPlaceholder) {
		var element = this.getInputElement();
		element.value = value;
		element.title = this._hint || "";
		this._hintIsVisible = false;
		this._updateClassName();
	}
};

DwtInputField.prototype._showHint = 
function() {
	if (!AjxEnv.supportsPlaceholder && this._hint) {
		var element = this.getInputElement();
		if (!element.value) {
			this._hintIsVisible = true;
			this._updateClassName();
			element.title = "";
			element.value = this._hint;
		}
	}
};

DwtInputField.prototype._updateClassName = 
function() {
	var classList = [];
	if (this._hasFocus) {
		classList.push(this._focusedClassName);
	}
	if (!this.getEnabled()) {
		classList.push(this._disabledClassName);
	} else if (this._hasError) {
		if (this._validationError === AjxMsg.valueIsRequired) {
			classList.push(this._requiredClassName);
		} else if (this._hintIsVisible && !this._hasFocus) {
			classList.push(this._errorHintClassName);
		} else {
			classList.push(this._errorClassName);
		}
	} else if (this._hintIsVisible && !this._hasFocus) {
		classList.push(this._hintClassName);
	}
	classList.push(this._origClassName);
	this.getHtmlElement().className = classList.join(' ');
};

DwtInputField.prototype._validateInput =
function(value) {
	var isValid = true;
	var retVal;
	this._validationError = null;

	if (!this.getEnabled()) {
		retVal = this.getValue();
	} else if (this.getRequired() && value == "") {
		this._validationError = AjxMsg.valueIsRequired;
	} else {
		try {
			if (typeof this._validator == "function") {
				retVal = value = this._validatorObj
					? this._validator.call(this._validatorObj, value, this)
					: this._validator(value);
			} else if (!this._validator.test(value)) {
				this._validationError = this._errorString;
			}
		} catch(ex) {
			if (typeof ex == "string")
				this._validationError = ex;
			else
				throw ex;
		}
	}
	
	if (this._validationError) {
		this._hasError = true;
		if (this._errorIconTd)
			this._errorIconTd.innerHTML = DwtInputField._ERROR_ICON_HTML;
		this.setToolTipContent(this._validationError);
		isValid = false;
		retVal = null;
	} else {
		this._hasError = false;
		if (this._errorIconTd)
			this._errorIconTd.innerHTML = DwtInputField._NOERROR_ICON_HTML;
		this.setToolTipContent(null);
		isValid = true;
	}
	this._updateClassName();

	if (this._validationCallback)
		this._validationCallback.run(this, isValid, value);

	return retVal;
};

/** 
 * Overriding default implementation in {@link DwtControl}.
 * 
 * @private
 */
DwtInputField.prototype._focusByMouseUpEvent =
function()  {
	if (this.getEnabled()) {
		this._hasFocus = true;
	}
};

/**
 * The input field inherits the id for accessibility purposes.
 *
 * @private
 */
DwtInputField.prototype._replaceElementHook =
function(oel, nel, inheritClass, inheritStyle) {
    nel = this.getInputElement();
    DwtControl.prototype._replaceElementHook.call(this, oel, nel, inheritClass, inheritStyle);
    if (oel.id) {
        nel.id = oel.id;
    }
	if (oel.size) {
		nel.size = oel.size;
	}
	if (oel.title) {
		this.setHint(oel.title);
	}
};

//
// Private methods
//


DwtInputField.prototype.__createInputEl =
function(params) {
	// clean up old input field if present
	var oinput = this._inputField;
	if (oinput) {
		for (var eventType in this._inputEventHandlers) {
			oinput.removeAttribute(eventType);
		}
	}

	// create new input field
	var ninput;
	var type = this._type != DwtInputField.PASSWORD ? "text" : "password";
	ninput = document.createElement("INPUT");
	ninput.type = type;
	this._inputField = ninput;

	// set common values
	var size = params ? params.size : oinput.size;
	var maxLen = params ? params.maxLen : oinput.maxLength;

	ninput.autocomplete = "off";
	if (size) {
		ninput.size = size;
	}
	if (maxLen) {
		ninput.maxLength = maxLen;
	}
	ninput.value = (params ? params.initialValue : oinput.value) || "";
	ninput.readonly = oinput ? oinput.readonly : false;
    if (params && params.inputId) {
        ninput.id = params.inputId;
    }

	if (AjxEnv.supportsPlaceholder && this._hint) {
		ninput.placeholder = this._hint;
	}

	if (this._label) {
		ninput.setAttribute('aria-label', this._label);
	}

	// add event handlers
	ninput.onkeyup = DwtInputField._keyUpHdlr;
    ninput.onkeydown = DwtInputField._keyDownHdlr;
	this._makeFocusable(ninput);

	for (var eventType in this._inputEventHandlers) {
		ninput[eventType] = this._inputEventHandlers[eventType];
	}

	return ninput;
};

DwtInputField.prototype._stateChanged = function(ev) {
	this.getInputElement().disabled = !this.getEnabled();
	this._validateInput(this.getValue());
}

/*
 * clears the onFocus handler
 */
DwtInputField.prototype.disableFocusHdlr =
function() {
    this._inputField.onfocus = null;
};

/*
 * enables the onFocus handler
 */
DwtInputField.prototype.enableFocusHdlr =
function(){
    this._inputField.onfocus = DwtInputField._focusHdlr;
};

/*
 * enables the onKeyDown handler
 * bug fix # 80423 - Firefox loses the handler
 */
DwtInputField.prototype.enableKeyDownHdlr =
function() {
    this._inputField.onkeydown = DwtInputField._keyDownHdlr;
};

DwtInputField.prototype.moveCursorToEnd =
function() {
	Dwt.moveCursorToEnd(this._inputField);
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtPasswordField")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * Creates a password field.
 * @constructor
 * @class
 * 
 * @param	{hash}		params		a hash of parameters
 * @param {DwtComposite}      params.parent			the parent widget
 * @param {string}      params.initialValue		the initial value of the field
 * @param {number}      params.size				size of the input field (in characters)
 * @param {number}      params.rows				the number of rows (more than 1 means textarea)
 * @param {boolean}      params.forceMultiRow		if <code>true</code>, forces use of textarea even if rows == 1
 * @param {number}      params.maxLen			the maximum length (in characters) of the input
 * @param {constant}      params.errorIconStyle		the error icon style
 * @param {constant}      params.validationStyle	the validation type
 * @param  {function}     params.validator			the custom validation function
 * @param {Object}      params.validatorCtxtObj		the object context for validation function
 * @param {string}      params.className			the CSS class
 * @param {constant}      params.posStyle			the positioning style (see {@link DwtControl})
 * @param {boolean}      params.required          if <code>true</code>, mark as required.
 * @param {string}      params.hint				a hint to display in the input field when the value is empty.
 * @param {string}      params.id				an explicit ID to use for the control's DIV element
 * @param {string}      params.inputId			an explicit ID to use for the control's INPUT element
 * 
 * @extends		DwtInputField
 */
DwtPasswordField = function(params) {
	if (arguments.length == 0) return;

	params = params || { parent: DwtShell.getShell(window) };
	params.type = DwtInputField.PASSWORD;
	DwtInputField.call(this, params);

	this._tabGroup = new DwtTabGroup(this._htmlElId);

	// TODO: templatize DwtInputField -- then we don't need to explicitly call _createHtml
	this._createHtml();
};
DwtPasswordField.prototype = new DwtInputField;
DwtPasswordField.prototype.constructor = DwtPasswordField;

//
// Data
//

DwtPasswordField.prototype.TEMPLATE = "dwt.Widgets#DwtPasswordField";

//
// Public methods
//

DwtPasswordField.prototype.getTabGroupMember = function() {
	return this._tabGroup;
};

/**
 * Shows the password.
 * 
 * @param	{boolean}	show		if <code>true</code>, show the password
 */
DwtPasswordField.prototype.setShowPassword = function(show) {
	this._showCheckbox.setSelected(show);
	this.setInputType(show ? DwtInputField.STRING : DwtInputField.PASSWORD);
};

//
// Protected methods
//

DwtPasswordField.prototype._createHtml = function(templateId) {
	var data = { id: this._htmlElId };
	this._createHtmlFromTemplate(templateId || this.TEMPLATE, data);
};

DwtPasswordField.prototype._createHtmlFromTemplate =
function(templateId, data) {
	this._tabGroup.removeAllMembers();

	// save old contents
	var fragment = document.createDocumentFragment();
	var child = this.getHtmlElement().firstChild;
	while (child) {
		var sibling = child.nextSibling;
		fragment.appendChild(child);
		child = sibling;
	};

	// create HTML and append content
	DwtInputField.prototype._createHtmlFromTemplate.apply(this, arguments);
	var inputEl = document.getElementById(data.id+"_input");
	inputEl.appendChild(fragment);
	this._tabGroup.addMember(this.getInputElement());

	var showCheckboxEl = document.getElementById(data.id+"_show_password");
	if (showCheckboxEl) {
		this._showCheckbox = new DwtCheckbox({parent:this});
		this._showCheckbox.setText(AjxMsg.showPassword);
		this._showCheckbox.addSelectionListener(new AjxListener(this, this._handleShowCheckbox));
		this._showCheckbox.replaceElement(showCheckboxEl);
		this._tabGroup.addMember(this._showCheckbox);
	}
};

DwtPasswordField.prototype._handleShowCheckbox = function(event) {
	this.setShowPassword(event.detail);
};

/**
* Overrides DwtInputField getValue to not do the leading/trailing spaces trimming.
*
* @return {string} the value
*/
DwtPasswordField.prototype.getValue =
function() {
	return this._inputField.value;
};

}
if (AjxPackage.define("ajax.dwt.widgets.DwtSash")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * Creates a sash.
 * @constructor
 * @class
 * A sash is a thin moveable border between two components that can be moved in
 * order to change the sizes of the elements on either side. Those one one side
 * will become larger, and those on the other side will become smaller.
 * 
 * @param {hash}	params		a hash of parameters
 * @param {DwtComposite}      params.parent		the parent widget
 * @param {DwtSash.HORIZONTAL_STYLE|DwtSash.VERTICAL_STYLE}      [params.style=DwtSash.VERTICAL_STYLE]			the sash style
 * @param {string}      params.className		the CSS class
 * @param    {number}	[params.threshold=1]		minimum movement (in pixels) that forces a UI update. Clients will likely want to set it higher.
 * @param {constant}       params.posStyle		the positioning style (see {@link DwtControl})
 * 
 * @extends		DwtControl
 */
DwtSash = function(params) {
	params = Dwt.getParams(arguments, DwtSash.PARAMS);
	params.className = params.className || "DwtSash";
	params.posStyle = params.posStyle || DwtControl.ABSOLUTE_STYLE;
	DwtControl.call(this, params);

    var htmlElement = this.getHtmlElement();
    var templatePrefix = "dwt.Widgets#";
    if (!params.style || params.style != DwtSash.HORIZONTAL_STYLE) {
		this._style = DwtSash.VERTICAL_STYLE;
		htmlElement.style.cursor = AjxEnv.isIE ? "row-resize" : "s-resize";
		htmlElement.innerHTML = AjxTemplate.expand(templatePrefix + "DwtVerticalSash");
	} else {
		this._style = DwtSash.HORIZONTAL_STYLE;
		htmlElement.style.cursor = AjxEnv.isIE ? "col-resize" : "w-resize";
		htmlElement.innerHTML = AjxTemplate.expand(templatePrefix + "DwtHorizontalSash");
	}
	this._threshold = (params.threshold > 0) ? params.threshold : 1;

	this._captureObj = new DwtMouseEventCapture({
		targetObj:this,
		id:"DwtSash",
		mouseOverHdlr:DwtSash._mouseOverHdlr,
		mouseDownHdlr:DwtSash._mouseDownHdlr,
		mouseMoveHdlr:DwtSash._mouseMoveHdlr,
		mouseUpHdlr:DwtSash._mouseUpHdlr,
		mouseOutHdlr:DwtSash._mouseOutHdlr
	});
	this.setHandler(DwtEvent.ONMOUSEDOWN, DwtSash._mouseDownHdlr);
	this.setHandler(DwtEvent.ONMOUSEOVER, DwtSash._mouseOverHdlr);
	this.setHandler(DwtEvent.ONMOUSEOUT, DwtSash._mouseOutHdlr);

	this.setZIndex(Dwt.Z_VIEW);
}

DwtSash.PARAMS = ["parent", "style", "className", "threshold", "posStyle"];

DwtSash.prototype = new DwtControl;
DwtSash.prototype.constructor = DwtSash;

DwtSash.prototype.toString = 
function() {
	return "DwtSash";
}

/**
 * Defines the "horizontal" sash style.
 */
DwtSash.HORIZONTAL_STYLE  = 1;
/**
 * Defines the "vertical" sash style.
 */
DwtSash.VERTICAL_STYLE = 2;

// The callback function will be called with a proposed delta. It should return a value indication
// how much of a delta was actually applied.
DwtSash.prototype.registerCallback =
function(callbackFunc, callbackObj) {
	this._callbackFunc = callbackFunc;
	this._callbackObj = callbackObj;
};

DwtSash._mouseOverHdlr =
function(ev) {
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev);
	mouseEv._stopPropagation = true;
	mouseEv._returnValue = false;
	mouseEv.setToDhtmlEvent(ev);
	return false;	
}

DwtSash._mouseDownHdlr =
function(ev) {
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev, true);
	if (mouseEv.button != DwtMouseEvent.LEFT) {
		DwtUiEvent.setBehaviour(ev, true, false);
		return false;
	}
	DwtEventManager.notifyListeners(DwtEvent.ONMOUSEDOWN, mouseEv);
	var sash = mouseEv.dwtObj;
	if (sash._callbackFunc != null) {
		sash._captureObj.capture();
		sash._startCoord = (sash._style == DwtSash.HORIZONTAL_STYLE) 
				? mouseEv.docX : mouseEv.docY;
	}
	mouseEv._stopPropagation = true;
	mouseEv._returnValue = false;
	mouseEv.setToDhtmlEvent(ev);
	
	return false;	
}

DwtSash._mouseMoveHdlr =
function(ev) {
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev);	
	var delta = 0;
	var sash = DwtMouseEventCapture.getTargetObj();
	if (sash._style == DwtSash.HORIZONTAL_STYLE) {
		if (mouseEv.docX > 0 && mouseEv.docX != sash._startCoord)
			delta = mouseEv.docX - sash._startCoord;
	} else  {
		if (mouseEv.docY > 0 && mouseEv.docY != sash._startCoord)
			delta = mouseEv.docY - sash._startCoord;
	}
		
	if (Math.abs(delta) >= sash._threshold) {
		if (sash._callbackObj != null)
			delta = sash._callbackFunc.call(sash._callbackObj, delta);
		else 
			delta = sash._callbackFunc(delta);		
		sash._startCoord += delta;
		// If movement happened, then shift our location by the actual amount of movement
		if (delta != 0 && sash.getHtmlElement().style.position == Dwt.ABSOLUTE_STYLE) {
			if (sash._style == DwtSash.HORIZONTAL_STYLE)
				sash.setLocation(sash.getLocation().x + delta, Dwt.DEFAULT);
			else
				sash.setLocation(Dwt.DEFAULT, sash.getLocation().y + delta);
		}
	}
	mouseEv._stopPropagation = true;
	mouseEv._returnValue = false;
	mouseEv.setToDhtmlEvent(ev);
	return false;	
}

DwtSash._mouseUpHdlr =
function(ev) {
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev);	
	if (mouseEv.button != DwtMouseEvent.LEFT) {
		DwtUiEvent.setBehaviour(ev, true, false);
		return false;
	}

	var sash = DwtMouseEventCapture.getTargetObj();
	if (sash._callbackFunc != null) {
		DwtMouseEventCapture.getCaptureObj().release();
	}

	sash.notifyListeners(DwtEvent.ONMOUSEUP, mouseEv);
	mouseEv._stopPropagation = true;
	mouseEv._returnValue = false;
	mouseEv.setToDhtmlEvent(ev);
	return false;	
}

DwtSash._mouseOutHdlr =
function(ev) {
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev);
	mouseEv._stopPropagation = true;
	mouseEv._returnValue = false;
	mouseEv.setToDhtmlEvent(ev);
	return false;	
}

}
if (AjxPackage.define("ajax.dwt.widgets.DwtToolBar")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * @overview
 * This file defines a toolbar.
 *
 */

/**
 * Creates a toolbar.
 * @constructor
 * @class
 * Creates a toolbar. Components must be added via the <code>add*()</code> functions.
 * A toolbar is a horizontal or vertical strip of widgets (usually buttons).
 *
 * @author Ross Dargahi
 * 
 * @param {hash}	params		a hash of parameters
 * @param	{DwtComposite}	params.parent	the parent widget
 * @param	{string}	params.className				the CSS class
 * @param	{DwtToolBar.HORIZ_STYLE|DwtToolBar.VERT_STYLE}	params.posStyle		the positioning style
 * @param	{constant}	params.style					the menu style
 * @param	{number}	params.index 				the index at which to add this control among parent's children
 * 
 * @extends	DwtComposite
 */
DwtToolBar = function(params) {
	if (arguments.length == 0) { return; }
	params = Dwt.getParams(arguments, DwtToolBar.PARAMS);

	params.className = params.className || "ZToolbar";
	DwtComposite.call(this, params);

	// since we attach event handlers at the toolbar level, make sure we don't double up on
	// handlers when we have a toolbar within a toolbar
	if (params.parent instanceof DwtToolBar) {
		this._hasSetMouseEvents = params.parent._hasSetMouseEvents;
	}
	if (params.handleMouse !== false && !this._hasSetMouseEvents) {
		var events = [DwtEvent.ONMOUSEDOWN, DwtEvent.ONMOUSEUP, DwtEvent.ONCLICK];
		if (!AjxEnv.isIE) {
			events.push(DwtEvent.ONMOUSEOVER, DwtEvent.ONMOUSEOUT);
		}
		this._setEventHdlrs(events);
		this._hasSetMouseEvents = true;
	}

	this._style = params.style || DwtToolBar.HORIZ_STYLE;
    this._createHtml();

    this._numFillers = 0;
	this._curFocusIndex = 0;

    // Let toolbar be a single tab stop, then manage focus among items using arrow keys
    this.tabGroupMember = this;

    this._keyMapName = (this._style == DwtToolBar.HORIZ_STYLE) ? DwtKeyMap.MAP_TOOLBAR_HORIZ : DwtKeyMap.MAP_TOOLBAR_VERT;
};

DwtToolBar.PARAMS = ["parent", "className", "posStyle", "style", "index", "id"];

DwtToolBar.prototype = new DwtComposite;
DwtToolBar.prototype.constructor = DwtToolBar;
DwtToolBar.prototype.role = 'toolbar';

DwtToolBar.prototype.isDwtToolBar = true;
DwtToolBar.prototype.toString = function() { return "DwtToolBar"; };

//
// Constants
//

/**
 * Defines the "horizontal" style.
 */
DwtToolBar.HORIZ_STYLE	= 1;
/**
 * Defines the "vertical" style.
 */
DwtToolBar.VERT_STYLE	= 2;

DwtToolBar.FIRST_ITEM    = "ZFirstItem";
DwtToolBar.LAST_ITEM     = "ZLastItem";
DwtToolBar.SELECTED_NEXT = DwtControl.SELECTED + "Next";
DwtToolBar.SELECTED_PREV = DwtControl.SELECTED + "Prev";
DwtToolBar._NEXT_PREV_RE = new RegExp(
    "\\b" +
    [ DwtToolBar.SELECTED_NEXT, DwtToolBar.SELECTED_PREV ].join("|") +
    "\\b", "g"
);

//
// Data
//

// main template

DwtToolBar.prototype.TEMPLATE = "dwt.Widgets#ZToolbar";

// item templates

DwtToolBar.prototype.ITEM_TEMPLATE = "dwt.Widgets#ZToolbarItem";
DwtToolBar.prototype.SEPARATOR_TEMPLATE = "dwt.Widgets#ZToolbarSeparator";
DwtToolBar.prototype.SPACER_TEMPLATE = "dwt.Widgets#ZToolbarSpacer";
DwtToolBar.prototype.FILLER_TEMPLATE = "dwt.Widgets#ZToolbarFiller";

// static data

DwtToolBar.__itemCount = 0;

//
// Public methods
//

DwtToolBar.prototype.dispose =
function() {
	DwtComposite.prototype.dispose.call(this);
	this._itemsEl = null;
	this._prefixEl = null;
	this._suffixEl = null;
};

/**
 * Gets the item.
 * 
 * @param	{int}		index	the index
 * @return	{Object}	the item
 */
DwtToolBar.prototype.getItem =
function(index) {
	return this._children.get(index);
};

/**
 * Gets the item count.
 * 
 * @return	{number}	the size of the children items
 */
DwtToolBar.prototype.getItemCount =
function() {
	return this._children.size();
};

/**
 * Gets the items.
 * 
 * @return	{array}	an array of children items
 */
DwtToolBar.prototype.getItems =
function() {
	return this._children.getArray();
};

// item creation
/**
 * Adds a spacer.
 * 
 * @param	{string}	className	the spacer CSS class name
 * @param	{number}	index		the index for the spacer
 * @return	{Object}	the newly added element
 */
DwtToolBar.prototype.addSpacer =
function(className, index) {
	var spacer = new DwtToolBarSpacer({
		parent: this,
		index: index,
		className: className,
		toolbarItemTemplate: this.SPACER_TEMPLATE,
		id: this._htmlElId + '_spacer' + DwtToolBar.__itemCount
	});

	return spacer;
};

/**
 * Adds a separator.
 * 
 * @param	{string}	className	the separator CSS class name
 * @param	{number}	index		the index for the separator
 * @return	{Object}	the newly added element
 */
DwtToolBar.prototype.addSeparator =
function(className, index) {
	var sep = new DwtToolBarSpacer({
		parent: this,
		index: index,
		className: className,
		toolbarItemTemplate: this.SEPARATOR_TEMPLATE,
		id: this._htmlElId + '_separator' + DwtToolBar.__itemCount
	});

	return sep;
};

/**
 * Adds a filler.
 * 
 * @param	{string}	className	the CSS class name
 * @param	{number}	index		the index for the filler
 * @return	{Object}	the newly added element
 */
DwtToolBar.prototype.addFiller =
function(className, index) {
	var filler = new DwtToolBarSpacer({
		parent: this,
		index: index,
		className: className,
		toolbarItemTemplate: this.FILLER_TEMPLATE,
		id: this._htmlElId + '_filler' + DwtToolBar.__itemCount
	});

	return filler;
};

// DwtComposite methods

/**
 * Adds a child item.
 * 
 * @param	{Object}	child	the child item
 * @param	{number}	index		the index for the child
 */
DwtToolBar.prototype.addChild = function(child, index) {

	// get the reference element for insertion
	var placeControl = this.getChild(index);
	var placeEl = placeControl ?
		placeControl.getHtmlElement().parentNode : this._suffixEl;

	// actually add the child
	DwtComposite.prototype.addChild.apply(this, arguments);

	// create and insert the item element
    if (this._itemsEl) {
        var itemEl = this._createItemElement(child.toolbarItemTemplate);
        this._itemsEl.insertBefore(itemEl, placeEl);
    }

	// finally, move the child to the item
	child.reparentHtmlElement(itemEl);
};

DwtToolBar.prototype.removeChild = function(child) {

	var item = child.getHtmlElement().parentNode;

	DwtComposite.prototype.removeChild.apply(this, arguments);

	if (item && item.parentNode) {
		item.parentNode.removeChild(item);
	}
};

// keyboard nav

/**
 * Gets the key map name.
 * 
 * @return	{string}	the key map name
 */
DwtToolBar.prototype.getKeyMapName =
function() {
    return this._keyMapName;
};

DwtToolBar.prototype.handleKeyAction = function(actionCode, ev) {

    // if the user typed a left or right arrow in an INPUT, only go to the previous/next item if the cursor is at the
    // beginning or end of the text in the INPUT
	var curFocusIndex = this._curFocusIndex,
	    numItems = this.getItemCount(),
        input = ev && ev.target && ev.target.nodeName.toLowerCase() === 'input' ? ev.target : null,
        cursorPos = input && input.selectionStart,
        valueLen = input && input.value && input.value.length;

	if (numItems < 2) {
		return false;
	}

    DBG.println(AjxDebug.FOCUS, 'DwtToolBar HANDLEKEYACTION: cur focus index = ' + curFocusIndex);

	switch (actionCode) {

		case DwtKeyMap.PREV:
            if (input && cursorPos > 0) {
                ev.forcePropagate = true;   // don't let subsequent handlers block propagation
                return false;
            }
			else if (curFocusIndex > 0) {
				this._moveFocus(true, ev);
				return true;
			}
			break;

		case DwtKeyMap.NEXT:
            if (input && cursorPos < valueLen) {
                ev.forcePropagate = true;   // don't let subsequent handlers block propagation
                return false;
            }
			else if (curFocusIndex < numItems - 1) {
				this._moveFocus(false);
				return true;
			}
			break;

		default:
			// pass everything else to currently focused item
            var item = this._getCurrentFocusItem();
			if (item) {
				return item.handleKeyAction(actionCode, ev);
			}
	}

	return true;
};

//
// Protected methods
//

// utility

/**
 * @private
 */
DwtToolBar.prototype._createItemId =
function(id) {
    id = id || this._htmlElId;
    var itemId = [id, "item", ++DwtToolBar.__itemCount].join("_");
    return itemId;
};

// html creation

/**
 * @private
 */
DwtToolBar.prototype._createHtml = function() {

    var data = { id: this._htmlElId };
    this._createHtmlFromTemplate(this.TEMPLATE, data);
    this._itemsEl = document.getElementById(data.id + "_items");
    this._prefixEl = document.getElementById(data.id + "_prefix");
    this._suffixEl = document.getElementById(data.id + "_suffix");
};

/**
 * @private
 */
DwtToolBar.prototype._createItemElement =
function(templateId) {
        templateId = templateId || this.ITEM_TEMPLATE;
        var data = { id: this._htmlElId, itemId: this._createItemId() };
        var html = AjxTemplate.expand(templateId, data);

        // the following is like scratching your back with your heel:
        //     var fragment = Dwt.toDocumentFragment(html, data.itemId);
        //     return (AjxUtil.getFirstElement(fragment));

        var cont = AjxStringUtil.calcDIV();
        cont.innerHTML = html;
        return cont.firstChild.rows[0].cells[0]; // DIV->TABLE->TR->TD
};

/**
 * Focuses the current item.
 *
 * @param {DwtControl}  item    (optional) specific toolbar item to focus
 */
DwtToolBar.prototype.focus = function(item) {

    DBG.println(AjxDebug.FOCUS, "DwtToolBar: FOCUS " + [this, this._htmlElId].join(' / '));

    this._setMenuKey();

	item = item || this._getCurrentFocusItem();
	if (item && this._canFocusItem(item)) {
        this._curFocusIndex = this.__getButtonIndex(item);
		return item.focus();
	}
    else {
		// if current item isn't focusable, find first one that is
		return this._moveFocus(false);
	}
};

/**
 * Blurs the current item.
 *
 * @param {DwtControl}  item    (optional) specific toolbar item to blur
 *
 * @private
 */
DwtToolBar.prototype.blur = function(item) {

    DBG.println(AjxDebug.FOCUS, "DwtToolBar: BLUR");
	item = item || this._getCurrentFocusItem();
	if (item && item.blur) {
		item.blur();
	}
};

/**
 * Returns the item at the given index, as long as it can accept focus.
 * For now, we only move focus to simple components like buttons. Also,
 * the item must be enabled and visible.
 *
 * @param {DwtControl}	item		an item within toolbar
 * @return	{boolean}	true if the item can be focused
 * 
 * @private
 */
DwtToolBar.prototype._canFocusItem = function(item) {

	if (!item)									{ return false; }
	if (!item.focus)							{ return false; }
	if (item.isDwtToolBarSpacer)				{ return false; }
	if (item.getEnabled && !item.getEnabled())	{ return false; }
	if (item.getVisible && !item.getVisible())	{ return false; }
	if (item.isDwtText && !item.getText())		{ return false; }

	return true;
};

DwtToolBar.prototype._getCurrentFocusItem = function() {

    return this.getItem(this._curFocusIndex);
};

DwtToolBar.prototype.getEnabled = function() {
	// toolbars delegate focus to their children, and so are only 'enabled' --
	// i.e. focusable -- when at least one child is
	return this._children.some(function(child) {
		return this._canFocusItem(child);
	}, this);
};

/**
 * Moves focus to next or previous item that can take focus.
 *
 * @param {boolean}	back		if <code>true</code>, move focus to previous item
 * 
 * @private
 */
DwtToolBar.prototype._moveFocus = function(back) {

	var index = this._curFocusIndex,
	    maxIndex = this.getItemCount() - 1,
	    item = null,
        found = false;

    index = back ? index - 1 : index + 1;
    while (!found && index >= 0 && index <= maxIndex) {
        item = this.getItem(index);
        if (this._canFocusItem(item)) {
            found = true;
        }
        index = back ? index - 1 : index + 1;
	}

	if (item && found) {
		this.blur();
		this.focus(item);
	}

    return item;
};

// make sure the key for expanding a button submenu matches our style
DwtToolBar.prototype._setMenuKey = function() {

    if (!this._submenuKeySet) {
        var kbm = this.shell.getKeyboardMgr();
        if (kbm.isEnabled()) {
            var kmm = kbm.__keyMapMgr;
            if (kmm) {
                if (this._style == DwtToolBar.HORIZ_STYLE) {
                    kmm.removeMapping(DwtKeyMap.MAP_BUTTON, "ArrowRight");
                    kmm.setMapping(DwtKeyMap.MAP_BUTTON, "ArrowDown", DwtKeyMap.SUBMENU);
                } else {
                    kmm.removeMapping(DwtKeyMap.MAP_BUTTON, "ArrowDown");
                    kmm.setMapping(DwtKeyMap.MAP_BUTTON, "ArrowRight", DwtKeyMap.SUBMENU);
                }
                kmm.reloadMap(DwtKeyMap.MAP_BUTTON);
            }
        }
        this._submenuKeySet = true;
    }
};

// Updates internal index when a child gets focus
DwtToolBar.prototype._childFocusListener = function(ev) {

    DBG.println(AjxDebug.FOCUS, "DwtToolBar CHILDFOCUSLISTENER: " + [ ev.dwtObj, ev.dwtObj._htmlElId ].join(' / '));
    this._curFocusIndex = this.__getButtonIndex(ev.dwtObj);
};

/**
 * @private
 */
DwtToolBar.prototype.__markPrevNext = function(id, opened) {

    var index = this.__getButtonIndex(id);
    var prev = this.getChild(index - 1);
    var next = this.getChild(index + 1);

    if (opened) {
        if (prev) {
            Dwt.delClass(prev.getHtmlElement(), DwtToolBar._NEXT_PREV_RE, DwtToolBar.SELECTED_PREV);
        }
        if (next) {
            Dwt.delClass(next.getHtmlElement(), DwtToolBar._NEXT_PREV_RE, DwtToolBar.SELECTED_NEXT);
        }
    }
    else {
        if (prev) {
            Dwt.delClass(prev.getHtmlElement(), DwtToolBar._NEXT_PREV_RE);
        }
        if (next) {
            Dwt.delClass(next.getHtmlElement(), DwtToolBar._NEXT_PREV_RE);
        }
    }

    // hack: mark the first and last items so we can style them specially
    //	MOW note: this should really not be here, as it only needs to be done once,
    //				but I'm not sure where to put it otherwise
    var first = this.getChild(0);
    if (first) {
        Dwt.addClass(first.getHtmlElement(), DwtToolBar.FIRST_ITEM);
    }

    var last = this.getChild(this.getItemCount()-1);
    if (last) {
        Dwt.addClass(last.getHtmlElement(), DwtToolBar.LAST_ITEM);
    }
};

/**
 * Find the array index of a toolbar button.
 *
 * @param id {String|DwtControl}    item ID, or item
 *
 * @return {number} Index of the id in the array, or -1 if the id does not exist.
 * @private
 */
DwtToolBar.prototype.__getButtonIndex = function(id) {

    var item = AjxUtil.isString(id) ? DwtControl.fromElementId(id) : id;

    for (var i = 0; i <= this.getItemCount() - 1; i++) {
        if (item === this.getItem(i)) {
            return i;
        }
    }

    return -1;
};

//
// Classes
//

/**
 * Creates a tool bar button.
 * @constructor
 * @class
 * This class represents a toolbar button.
 * 
 * @param	{hash}		params		a hash of parameters
 * @param {DwtComposite}	parent		the parent widget
 * @param {constant}	style				the menu style
 * @param {string}	className				the CSS class
 * @param {DwtToolBar.HORIZ_STYLE|DwtToolBar.VERT_STYLE}	posStyle		the positioning style
 * @param {Object}	actionTiming 	the action timing
 * @param {string}	id 	the id
 * @param {number}	index 				the index at which to add this control among parent's children
 *
 * @extends	DwtButton
 */
DwtToolBarButton = function(params) {
	if (arguments.length == 0) { return; }
	var params = Dwt.getParams(arguments, DwtToolBarButton.PARAMS);
	params.className = params.className || "ZToolbarButton";
	DwtButton.call(this, params);
};

DwtToolBarButton.PARAMS = ["parent", "style", "className", "posStyle", "actionTiming", "id", "index"];

DwtToolBarButton.prototype = new DwtButton;
DwtToolBarButton.prototype.constructor = DwtToolBarButton;

DwtToolBarButton.prototype.isDwtToolBarButton = true;
DwtToolBarButton.prototype.toString = function() { return "DwtToolBarButton"; };

// Data
DwtToolBarButton.prototype.TEMPLATE = "dwt.Widgets#ZToolbarButton";

// Spacing controls (spacer, separator, filler)
DwtToolBarSpacer = function(params) {
	if (arguments.length == 0) { return; }
	this._noFocus = this.noTab = true;
	this.toolbarItemTemplate = params.toolbarItemTemplate;
	DwtControl.call(this, params);
};

DwtToolBarSpacer.prototype = new DwtControl;

DwtToolBarSpacer.prototype.constructor = DwtToolBarSpacer;

DwtToolBarSpacer.prototype.isDwtToolBarSpacer = true;
DwtToolBarSpacer.prototype.toString = function() { return 'DwtToolBarSpacer'; };

DwtToolBarSpacer.prototype.role = 'separator';
}
if (AjxPackage.define("ajax.dwt.widgets.DwtToolTip")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * Singleton tooltip class.
 */
DwtToolTip = function(shell, className, dialog) {

	if (arguments.length == 0) { return; }

	this.shell = shell;
	this._dialog = dialog;
	this._poppedUp = false;
	this._div = document.createElement("div");
	this._div.className = className || "DwtToolTip";
	this._div.style.position = DwtControl.ABSOLUTE_STYLE;
	this.shell.getHtmlElement().appendChild(this._div);
	Dwt.setZIndex(this._div, Dwt.Z_HIDDEN);
	Dwt.setLocation(this._div, Dwt.LOC_NOWHERE, Dwt.LOC_NOWHERE);

	this._eventMgr = new AjxEventMgr();

    // create html
    // NOTE: This id is ok because there's only ever one instance of a tooltip
    var templateId = "dwt.Widgets#DwtToolTip";
    this._div.innerHTML = AjxTemplate.expand(templateId);

    var params = AjxTemplate.getParams(templateId);
    this._offsetX = (params.width != null) ? Number(params.width) : DwtToolTip.POPUP_OFFSET_X;
    this._offsetY = (params.height != null) ? Number(params.height) : DwtToolTip.POPUP_OFFSET_Y;

    // save reference to content div
    this._contentDiv = document.getElementById("tooltipContents");

    Dwt.setHandler(this._div, DwtEvent.ONMOUSEOVER, AjxCallback.simpleClosure(this._mouseOverListener, this));
    Dwt.setHandler(this._div, DwtEvent.ONMOUSEOUT, AjxCallback.simpleClosure(this._mouseOutListener, this));

	var events = [DwtEvent.ONCLICK,DwtEvent.ONDBLCLICK,DwtEvent.ONMOUSEDOWN,DwtEvent.ONMOUSEENTER,DwtEvent.ONMOUSELEAVE,DwtEvent.ONMOUSEMOVE,DwtEvent.ONMOUSEUP,DwtEvent.ONMOUSEWHEEL,DwtEvent.ONSCROLL];
	for (var i=0; i<events.length; i++) {
		var event = events[i];
    	Dwt.setHandler(this._div, event, AjxCallback.simpleClosure(this.notifyListeners, this, [event]));
	}
};

DwtToolTip.prototype.isDwtToolTip = true;
DwtToolTip.prototype.toString = function() { return "DwtToolTip"; };

//
// Constants
//

DwtToolTip.TOOLTIP_DELAY = 750;

DwtToolTip.WINDOW_GUTTER = 5;	// space to leave between tooltip and edge of shell
DwtToolTip.POPUP_OFFSET_X = 5;	// default horizontal offset from control
DwtToolTip.POPUP_OFFSET_Y = 5;	// default vertical offset from control

//
// Data
//

//
// Public methods
//

DwtToolTip.prototype.getContent =
function() {
    return this._div.innerHTML;
};

DwtToolTip.prototype.setContent =
function(content, setInnerHTML) {
	this._content = content;
	if(setInnerHTML) {
        this._contentDiv.innerHTML = this._content;
    }
};

/**
 * Shows the tooltip. By default, its position will be relative to the location of the
 * cursor when the mouseover event happened. Alternatively, the control that generated
 * the tooltip can be passed in, and the tooltip will be positioned relative to it. If
 * the control is a large composite control (eg a DwtListView), the hover event can be
 * passed so that the actual target of the event can be found.
 * 
 * @param {number}			x					X-coordinate of cursor
 * @param {number}			y					Y-coordinate of cursor
 * @param {boolean}			skipInnerHTML		if true, do not copy content to DOM
 * @param {boolean}			popdownOnMouseOver	if true, hide tooltip on mouseover
 * @param {DwtControl}		obj					control that tooltip is for (optional)
 * @param {DwtHoverEvent}	hoverEv				hover event (optional)
 * @param {AjxCallback}		popdownListener		callback to run when tooltip pops down
 */
DwtToolTip.prototype.popup = 
function(x, y, skipInnerHTML, popdownOnMouseOver, obj, hoverEv, popdownListener) {
	this._hovered = false;
    if (this._popupAction) {
        AjxTimedAction.cancelAction(this._popupAction);
        this._popupAction = null;
    }
	// popdownOnMouseOver may be true to pop down the tooltip if the mouse hovers over the tooltip. Optionally,
	// it can be an AjxCallback that will be called after popping the tooltip down.
    this._popdownOnMouseOver = popdownOnMouseOver;
	// popdownListener is always called after popping the tooltip down, regardless of what called the popdown
    this._popdownListener = popdownListener;
    if (this._content != null) {
		if(!skipInnerHTML) {
            this._contentDiv.innerHTML = this._content;
        }

		this._popupAction = new AjxTimedAction(this, this._positionElement, [x, y, obj, hoverEv]);
		AjxTimedAction.scheduleAction(this._popupAction, 5);
	}
};

/*
* setSticky allows making the tooltip not to popdown. 
* IMPORTANT: Tooltip is singleton inside Zimbra i.e. only one instance of tooltip is reused by all objects. 
* So, it is very important for the code setting tooltip to sticky to have some mechanism to close the tooltip by itself. 
* Like have a close-button inside tooltip and when clicked, should set the setSticky(false) and then close the tooltip.
*
* If setSticky(true) is called, _poppedUp is set to false, which is essentially pretending the tooltip is not
* up. In that case, a call to popdown will not close the tooltip. And that means tooltip will stay up even if some other
* code path calls popdown on the singleton tooltip.
*
*/
DwtToolTip.prototype.setSticky = 
function(bool) {
	this._poppedUp = !bool;
};

DwtToolTip.prototype.popdown = 
function() {
    this._popdownOnMouseOver = false;
	this._hovered = false;
    if (this._popupAction) {
        AjxTimedAction.cancelAction(this._popupAction);
        this._popupAction = null;
    }
	if (this._content != null && this._poppedUp) {
		Dwt.setLocation(this._div, Dwt.LOC_NOWHERE, Dwt.LOC_NOWHERE);
		this._poppedUp = false;
		if (this._popdownListener instanceof AjxCallback) {
			this._popdownListener.run();
		}
		this._popdownListener = null;
	}
};

//
// Protected methods
//

// Positions the tooltip relative to the base element based on vertical and horizontal offsets.
DwtToolTip.prototype._positionElement = 
function(startX, startY, obj, hoverEv) {
	
    this._popupAction = null;
	
	var wdSize = DwtShell.getShell(window).getSize();
	var wdWidth = wdSize.x, wdHeight = wdSize.y;

	var tooltipX, tooltipY, baseLoc;
	var baseEl = obj && obj.getTooltipBase(hoverEv);
	if (baseEl) {
		baseLoc = Dwt.toWindow(baseEl);
		var baseSz = Dwt.getSize(baseEl);
		tooltipX = baseLoc.x + this._offsetX;
		tooltipY = baseLoc.y + baseSz.y + this._offsetY;
	}
	else {
		tooltipX = startX + this._offsetX;
		tooltipY = startY + this._offsetY;
	}

	var popupSize = Dwt.getSize(this._div);
	var popupWidth = popupSize.x, popupHeight = popupSize.y;

	// check for sufficient room to the right
	if (tooltipX + popupWidth > wdWidth - DwtToolTip.WINDOW_GUTTER) {
		tooltipX = wdWidth - DwtToolTip.WINDOW_GUTTER - popupWidth;
	}
	// check for sufficient room below
	if (tooltipY + popupHeight > wdHeight - DwtToolTip.WINDOW_GUTTER) {
		tooltipY = (baseLoc ? baseLoc.y : tooltipY) - this._offsetY - popupHeight;
	}

	Dwt.setLocation(this._div, tooltipX, tooltipY);
	var zIndex = this._dialog ? this._dialog.getZIndex() + Dwt._Z_INC : Dwt.Z_TOOLTIP;
	Dwt.setZIndex(this._div, zIndex);
    this._poppedUp = true;
};

DwtToolTip.prototype._mouseOverListener = 
function(ev) {
	this._hovered = true;
    if (this._popdownOnMouseOver && this._poppedUp) {
        var callback = (this._popdownOnMouseOver.isAjxCallback || AjxUtil.isFunction(this._popdownOnMouseOver)) ? this._popdownOnMouseOver : null;
        this.popdown();
        if (callback) {
            callback.run();
		}
    }
	this.notifyListeners(DwtEvent.ONMOUSEOVER);
};

DwtToolTip.prototype._mouseOutListener = 
function(ev) {
	ev = DwtUiEvent.getEvent(ev, this._div)
	var location = Dwt.toWindow(this._div);
	var size = Dwt.getSize(this._div);
	// We sometimes get mouseover events even though the cursor is inside the tooltip, so double-check before popping down
	if (ev.clientX <= location.x || ev.clientX >= (location.x + size.x) || ev.clientY <= location.y || ev.clientY >= (location.y + size.y)) {
		this.popdown();
		this.notifyListeners(DwtEvent.ONMOUSEOUT);
	}
};

DwtToolTip.prototype.getHovered = 
function() {
	return this._hovered;
};


// The com_zimbra_email zimlet wants to put a listener on our mouseout event, but overwriting the existing handler is a no-no
// and we actually only want that event when the double-check above succeeds. Let API users add event listeners in a more clean way.
DwtToolTip.prototype.addListener =
function(eventType, listener, index) {
	return this._eventMgr.addListener(eventType, listener, index);
};

DwtToolTip.prototype.setListener =
function(eventType, listener, index) {
	this.removeAllListeners(eventType);
	return this._eventMgr.addListener(eventType, listener, index);
};

DwtToolTip.prototype.removeListener =
function(eventType, listener) {
	return this._eventMgr.removeListener(eventType, listener);
};

DwtToolTip.prototype.removeAllListeners =
function(eventType) {
	return this._eventMgr.removeAll(eventType);
};

DwtToolTip.prototype.isListenerRegistered =
function(eventType) {
	return this._eventMgr.isListenerRegistered(eventType);
};

DwtToolTip.prototype.notifyListeners =
function(eventType, event) {
	return this._eventMgr.notifyListeners(eventType, event);
};

}
if (AjxPackage.define("ajax.dwt.widgets.DwtTreeItem")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * Creates a Tree Item.
 * @constructor
 * @class
 * This class implements a tree item widget.
 *
 * @author Ross Dargahi
 * 
 * @param {hash}	params				a hash of parameters
 * @param {DwtComposite}      params.parent	the parent widget
 * @param {number}      params.index 			the index at which to add this control among parent's children
 * @param {string}      params.text 					the label text for the tree item
 * @param {string}      params.imageInfo			the icon for the left end of the tree item
 * @param {string}      params.extraInfo				the icon for the right end of the tree item
 * @param {string}      params.expandNodeImage		the icon to use for expanding tree item (instead of default)
 * @param {string}      params.collapseNodeImage     the icon to use for collapsing tree item (instead of default)
 * @param {string}      params.className				the CSS class
 * @param {constant}      params.posStyle				the positioning style (see {@link DwtControl})
 * @param {boolean}      params.deferred				if <code>true</code>, postpone initialization until needed.
 * @param {boolean}      params.selectable			if <code>true</code>, this item is selectable
 * @param {boolean}      params.forceNotifySelection	force notify selection even if checked style
 * @param {boolean}      params.forceNotifyAction		force notify action even if checked style
 * @param {boolean}      params.singleClickAction		if <code>true</code>, an action is performed in single click
 * @param {AjxCallback}      params.dndScrollCallback	the callback triggered when scrolling of a drop area for an object being dragged
 * @param {string}      params.dndScrollId			the id
 * @param {boolean}    params.arrowDisabled
 * @param {boolean}     params.dynamicWidth		if <code>true</code>, the table should be width auto instead of the default fixed
 *
 * @extends		DwtComposite		
 */
DwtTreeItem = function(params) {

    if (arguments.length == 0) { return; }    

    params = Dwt.getParams(arguments, DwtTreeItem.PARAMS);
	var parent = params.parent;
	if (parent instanceof DwtTree) {
		this._tree = parent;
	} else if (parent instanceof DwtTreeItem) {
		this._tree = parent._tree;
	} else {
		throw new DwtException("DwtTreeItem parent must be a DwtTree or DwtTreeItem", DwtException.INVALIDPARENT, "DwtTreeItem");
	}

	this._origClassName = params.className || "DwtTreeItem";
	this._textClassName = [this._origClassName, "Text"].join("-");
	this._selectedClassName = this._origClassName + ' ' + [this._origClassName, DwtCssStyle.SELECTED].join("-");
	this._selectedFocusedClassName = this._selectedClassName + ' ' + [this._origClassName, DwtCssStyle.SELECTED, DwtCssStyle.FOCUSED].join("-");
	this._actionedClassName = this._origClassName + ' ' + [this._origClassName, DwtCssStyle.ACTIONED].join("-");
	this._dragOverClassName = this._origClassName + ' ' + [this._origClassName, DwtCssStyle.DRAG_OVER].join("-");
    this._treeItemTextClass = "DwtTreeItem-Text";
    this._treeItemExtraImgClass = "DwtTreeItem-ExtraImg";

	this._dynamicWidth = params.dynamicWidth;

	params.deferred = (params.deferred !== false);
	params.className = 'DwtTreeItem-Control';
	DwtComposite.call(this, params);

	this._imageInfoParam = params.imageInfo;
	this._extraInfo = params.extraInfo;
	this._textParam = params.text;
	this._deferred = params.deferred;
	this._expandNodeImage = params.expandNodeImage || "NodeExpanded";
	this._collapseNodeImage = params.collapseNodeImage || "NodeCollapsed";
	this._itemChecked = false;
	this._initialized = false;
	this._selectionEnabled = Boolean(params.selectable !== false);
	this._forceNotifySelection = Boolean(params.forceNotifySelection);
	this._actionEnabled = true;
	this._forceNotifyAction = Boolean(params.forceNotifyAction);
	this._dndScrollCallback = params.dndScrollCallback;
	this._dndScrollId = params.dndScrollId;
	this._arrowDisabled = params.arrowDisabled;

	if (params.singleClickAction) {
		this._singleClickAction = true;
		this._selectedFocusedClassName = this._selectedClassName = this._textClassName;
		this._hoverClassName = [this._origClassName, DwtCssStyle.HOVER].join("-");
	} else {
		this._hoverClassName = this._textClassName;
	}

	// if our parent is DwtTree or our parent is initialized and is not deferred
	// type or is expanded, then initialize ourself, else wait
	if (parent instanceof DwtTree || (parent._initialized && (!parent._deferred || parent._expanded)) || !params.deferred) {
		this._initialize(params.index);
	} else {
		parent._addDeferredChild(this, params.index);
		this._index = params.index;
	}
};

DwtTreeItem.PARAMS = ["parent", "index", "text", "imageInfo", "deferred", "className", "posStyle",
					  "forceNotifySelection", "forceNotifyAction"];

DwtTreeItem.prototype = new DwtComposite;
DwtTreeItem.prototype.constructor = DwtTreeItem;

DwtTreeItem.prototype.isDwtTreeItem = true;
DwtTreeItem.prototype.toString = function() { return "DwtTreeItem"; };

DwtTreeItem.prototype.TEMPLATE = "dwt.Widgets#ZTreeItem";

DwtTreeItem.prototype.role = "treeitem";
DwtTreeItem.prototype.isFocusable = true;

DwtTreeItem.prototype._checkBoxVisible = true; // Assume it's shown, if check style

// Consts

DwtTreeItem._NODECELL_DIM = "16px";
DwtTreeItem._processedMouseDown = false;

// Public Methods

DwtTreeItem.prototype.dispose =
function() {
    DwtComposite.prototype.dispose.call(this);
	this._itemDiv = null;
	this._nodeCell = null;
	this._checkBoxCell = null;
	this._checkedImg = null;
	this._checkBox = null;
	this._imageCell = null;
	this._textCell = null;
	this._childDiv = null;
	this._initialized = false;
};

/**
 * override DwtControl.prototype.getData to take care of special case of KEY_OBJECT of type ZmOrganizer. See bug 82027
 * @param key
 * @return {*}
 */
DwtTreeItem.prototype.getData =
function(key) {
	var obj = this._data[key];
	if (key !== Dwt.KEY_OBJECT || !obj || !obj.isZmOrganizer) {
		return obj;
	}
	//special case for ZmOrganizer instance of the Dwt.KEY_OBJECT attribute.
	//bug 82027 - the folder attributes such as name could be wrong after refresh block+ rename when new instance was created but not set to the item Dwt.KEY_OBJECT attribute.
	var cachedOrganizer = obj && appCtxt.cacheGet(obj.id);
	return cachedOrganizer || obj; //just in case somehow it's no longer cached. No idea if could happen.
};

/**
 * Checks if the item is checked.
 * 
 * @return	{boolean}	<code>true</code> if the item is checked
 */
DwtTreeItem.prototype.getChecked =
function() {
	return this._itemChecked;
};

/**
 * Sets the checked flag.
 * 
 * @param	{boolean}	checked		if <code>true</code>, check the item
 * @param	{boolean}	force		if <code>true</code>, force the setting
 */
DwtTreeItem.prototype.setChecked =
function(checked, force) {
	if ((this._itemChecked != checked) || force) {
		this._itemChecked = checked;
		if (this._checkBox != null &&
			(this._checkBoxCell && Dwt.getVisible(this._checkBoxCell)))
		{
			Dwt.setVisible(this._checkedImg, checked);
		}
	}
};

DwtTreeItem.prototype._handleCheckboxOnclick =
function(ev) {
	this.setChecked(!Dwt.getVisible(this._checkedImg));

	ev = ev || window.event;
	ev.item = this;
	this._tree._itemChecked(this, ev);
};

DwtTreeItem.prototype.getExpanded =
function() {
	return this._expanded;
};

/**
 * Expands or collapses this tree item.
 *
 * @param {boolean}	expanded		if <code>true</code>, expands this node; otherwise collapses it
 * @param {boolean}	recurse		if <code>true</code>, expand children recursively (does not apply to collapsing)
 * @param	{boolean}	skipNotify		if <code>true</code>, do not notify the listeners
 */
DwtTreeItem.prototype.setExpanded =
function(expanded, recurse, skipNotify) {
	// Go up the chain, ensuring that parents are expanded/initialized
	if (expanded) {
		var p = this.parent;
		while (p instanceof DwtTreeItem && !p._expanded) {
			p.setExpanded(true);
			p = p.parent;
		}
		// Realize any deferred children
		this._realizeDeferredChildren();
	}
		
	// If we have children, then allow for expanding/collapsing
	if (this.getNumChildren()) {
		if (expanded && recurse) {
			if (!this._expanded) {
				this._expand(expanded, null, skipNotify);
			}
			var a = this.getChildren();
			for (var i = 0; i < a.length; i++) {
				if (a[i] instanceof DwtTreeItem) {
					a[i].setExpanded(expanded, recurse, skipNotify);
				}
			}
		} else if (this._expanded != expanded) {
			this._expand(expanded, null, skipNotify);
		}
	}
};

/**
 * Gets the child item count.
 * 
 * @return	{number}	the child item count
 */
DwtTreeItem.prototype.getItemCount =
function() {
	return this._children.size();
};

/**
 * Gets the items.
 * 
 * @return	{array}	an array of child {@link DwtTreeItem} objects
 */
DwtTreeItem.prototype.getItems =
function() {
	return this._children.getArray();
};

DwtTreeItem.prototype.getChildIndex =
function(item) {
	return this._children.indexOf(item);
};

/**
 * Get the nesting level; the toplevel tree is zero, and each lower layer
 * increases by one.
 * 
 * @return	{number}	the child item count
 */
DwtTreeItem.prototype.getNestingLevel =
function() {
	return this.parent.getNestingLevel() + 1;
};

/**
 * Gets the image.
 * 
 * @return	{string}	the image
 */
DwtTreeItem.prototype.getImage =
function() {
	return this._imageInfo;
};

/**
 * Sets the image.
 * 
 * @param	{string}	imageInfo		the image
 */
DwtTreeItem.prototype.setImage =
function(imageInfo) {
	if (this._initialized) {
		if (this._imageCell) {
			AjxImg.setImage(this._imageCell, imageInfo);
		}
		this._imageInfo = imageInfo;
	} else {
		this._imageInfoParam = imageInfo;
	}	
};

DwtTreeItem.prototype.setDndImage =
function(imageInfo) {
	this._dndImageInfo = imageInfo;
};

DwtTreeItem.prototype.getSelected =
function() {
	return this._selected;
};

DwtTreeItem.prototype.getActioned =
function() {
	return this._actioned;
};

/**
 * Gets the text.
 * 
 * @return	{string}	the text
 */
DwtTreeItem.prototype.getText =
function() {
	return this._text;
};

/**
 * Sets the text.
 * 
 * @param	{string}	text		the text
 */
DwtTreeItem.prototype.setText =
function(text) {
	if (this._initialized && this._textCell) {
		if (!text) text = "";
		this._text = this._textCell.innerHTML = text;
	} else {
		this._textParam = text;
	}
};

/**
 * Sets the drag-and-drop text.
 * 
 * @param	{string}	text		the text
 */
DwtTreeItem.prototype.setDndText =
function(text) {
	this._dndText = text;
};

/**
 * Shows (or hides) the check box.
 * 
 * @param	{boolean}	show		if <code>true</code>, show the check box
 */
DwtTreeItem.prototype.showCheckBox =
function(show) {
	this._checkBoxVisible = show;
	if (this._checkBoxCell) {
		Dwt.setVisible(this._checkBoxCell, show);
	}
};

/**
 * Shows (or hides) the expansion icon.
 * 
 * @param	{boolean}	show		if <code>true</code>, show the expansion icon
 */
DwtTreeItem.prototype.showExpansionIcon =
function(show) {
	if (this._nodeCell) {
		Dwt.setVisible(this._nodeCell, show);
	}
};

/**
 * Enables (or disables) the selection.
 * 
 * @param	{boolean}	enable		if <code>true</code>, enable selection
 */
DwtTreeItem.prototype.enableSelection =
function(enable) {
	this._selectionEnabled = enable;
	this._selectedClassName = enable
		? this._origClassName + "-" + DwtCssStyle.SELECTED
		: this._origClassName;

};

DwtTreeItem.prototype.isSelectionEnabled =
function() {
	return this._selectionEnabled;
};


DwtTreeItem.prototype.enableAction =
function(enable) {
	this._actionEnabled = enable;
};

/**
 * Adds a separator at the given index. If no index is provided, adds it at the
 * end. A separator cannot currently be added as the first item (the child DIV will
 * not have been created).
 *
 * @param {number}	index		the position at which to add the separator
 */
DwtTreeItem.prototype.addSeparator =
function(index) {
	this._children.add((new DwtTreeItemSeparator(this)), index);
};

/**
 * Makes this tree item, or just part of it, visible or hidden.
 *
 * @param {boolean}	visible		if <code>true</code>, item (or part of it) becomes visible
 * @param {boolean}	itemOnly		if <code>true</code>, apply to this item's DIV only; child items are unaffected
 * @param {boolean}	childOnly		if <code>true</code>, apply to this item's child items only
 */
DwtTreeItem.prototype.setVisible =
function(visible, itemOnly, childOnly) {
	if (itemOnly && !childOnly) {
		Dwt.setVisible(this._itemDiv, visible);
	} else if (childOnly && !itemOnly) {
		Dwt.setVisible(this._childDiv, visible);
	} else {
		DwtComposite.prototype.setVisible.call(this, visible);
	}
};

DwtTreeItem.prototype.removeChild =
function(child) {
	if (child._initialized) {
		this._tree._deselect(child);
		if (this._childDiv) {
			this._childDiv.removeChild(child.getHtmlElement());
		}
	}
	this._children.remove(child);

	// if we have no children and we are expanded, then mark us a collapsed.
	// Also if there are no deferred children, then make sure we remove the
	// expand/collapse icon and replace it with a blank16Icon.
	if (this._children.size() == 0) {
		if (this._expanded)
			this._expanded = false;

		this._expandable = false;
		this.removeAttribute('aria-expanded')
		
		if (this._initialized && this._nodeCell) {
			AjxImg.setImage(this._nodeCell, "Blank_16");
			var imgEl = AjxImg.getImageElement(this._nodeCell);
			if (imgEl)
				Dwt.clearHandler(imgEl, DwtEvent.ONMOUSEDOWN);
		}
	}
};

DwtTreeItem.prototype.getKeyMapName =
function() {
	return DwtKeyMap.MAP_TREE;
};

DwtTreeItem.prototype.handleKeyAction =
function(actionCode, ev) {

	switch (actionCode) {
		
		case DwtKeyMap.ENTER:
			this._tree.setEnterSelection(this, true);
			break;


		case DwtKeyMap.NEXT: {
			var ti = this._tree._getNextTreeItem(true);
			if (ti) {
				ti._tree.setSelection(ti, false, true);
			}
			break;
		}

		case DwtKeyMap.PREV: {
			var ti = this._tree._getNextTreeItem(false);
			if (ti) {
				ti._tree.setSelection(ti, false, true);
			}
			break;
		}

		case DwtKeyMap.SELECT_FIRST:
		case DwtKeyMap.SELECT_LAST: {
			var ti = (actionCode === DwtKeyMap.SELECT_FIRST) ?
				this._tree._getFirstTreeItem() : this._tree._getLastTreeItem();
			if (ti) {
				ti._tree.setSelection(ti, false, true);
			}
			break;
		}

		case DwtKeyMap.EXPAND: {
			if (!this._expanded) {
				this.setExpanded(true, false, true);
			} else if (this._children.size() > 0) {
				// Select first child node
				var firstChild = this._children.get(0);
				this._tree.setSelection(firstChild, false, true);
			}
			break;
		}

		case DwtKeyMap.COLLAPSE: {
			if (this._expanded) {
				this.setExpanded(false, false, true);
			} else if (this.parent.isDwtTreeItem) {
				// select parent
				this._tree.setSelection(this.parent, false, true);
			}
			break;
		}

		case DwtKeyMap.SUBMENU: {
			var target = this.getHtmlElement();
			var p = Dwt.toWindow(target, 0, 0);
			var s = this.getSize();
			var docX = p.x + s.x / 4;
			var docY = p.y + s.y / 2;
			this._gotMouseDownRight = true;
			this._emulateSingleClick({dwtObj:this, target:target, button:DwtMouseEvent.RIGHT,
									  docX:docX, docY:docY, kbNavEvent:true});
			break;
		}

		default:
			return false;

	}

	return true;
};

DwtTreeItem.prototype.addNodeIconListeners =
function() {
	var imgEl = AjxImg.getImageElement(this._nodeCell);
	if (imgEl) {
		Dwt.setHandler(imgEl, DwtEvent.ONMOUSEDOWN, DwtTreeItem._nodeIconMouseDownHdlr);
		Dwt.setHandler(imgEl, DwtEvent.ONMOUSEUP, DwtTreeItem._nodeIconMouseUpHdlr);
	}
};

DwtTreeItem.prototype._initialize =
function(index, realizeDeferred, forceNode) {
	this._checkState();
	if (AjxEnv.isIE) {
		this._setEventHdlrs([DwtEvent.ONMOUSEENTER, DwtEvent.ONMOUSELEAVE]);
	}
	if (AjxEnv.isSafari) {	// bug fix #25016
		this._setEventHdlrs([DwtEvent.ONCONTEXTMENU]);
	}
	var data = {
		id: this._htmlElId,
		divClassName: this._origClassName,
		isCheckedStyle: this._tree.isCheckedStyle,
		textClassName: this._textClassName
	};

	this._createHtmlFromTemplate(this.TEMPLATE, data);

	// add this object's HTML element to the DOM
	this.parent._addItem(this, index, realizeDeferred);

	// cache DOM objects here
	this._itemDiv = document.getElementById(data.id + "_div");
	this._nodeCell = document.getElementById(data.id + "_nodeCell");
	this._checkBoxCell = document.getElementById(data.id + "_checkboxCell");
	this._checkBox = document.getElementById(data.id + "_checkbox");
	this._checkedImg = document.getElementById(data.id + "_checkboxImg");
	this._imageCell = document.getElementById(data.id + "_imageCell");
	this._textCell = document.getElementById(data.id + "_textCell");
	this._extraCell = document.getElementById(data.id + "_extraCell");

	/* assign the ARIA level */
	this.setAttribute("aria-level", this.getNestingLevel());

	/* add a label for screenreaders, so that they don't read the entire
	   element */
	if (this._textCell) {
		this.setAttribute("aria-labelledby", this._textCell.id);
	}

	if (this._dynamicWidth){
		var tableNode = document.getElementById(data.id + "_table");
		if (tableNode) {
			tableNode.style.tableLayout = "auto";
		}
	}

	this._expandable = false;
	this.removeAttribute('aria-expanded');

	// If we have deferred children, then make sure we set up accordingly
	if (this._nodeCell) {
		this._nodeCell.style.minWidth = this._nodeCell.style.width = this._nodeCell.style.height = DwtTreeItem._NODECELL_DIM;
		if (this._children.size() > 0 || forceNode) {
			this._expandable = true;
			AjxImg.setImage(this._nodeCell, this._collapseNodeImage);
			this.addNodeIconListeners();
		}
	}

	if (this._extraCell) {
		AjxImg.setImage(this._extraCell, (this._extraInfo ||  "Blank_16"));
		this._extraCell.className = this._treeItemExtraImgClass;
	}

	// initialize checkbox
	if (this._tree.isCheckedStyle && this._checkBox) {
		this._checkBox.onclick = AjxCallback.simpleClosure(this._handleCheckboxOnclick, this);
		this.showCheckBox(this._checkBoxVisible);
		this.setChecked(this._tree.isCheckedByDefault, true);
	}

	// initialize icon
	if (this._imageCell && this._imageInfoParam) {
		AjxImg.setImage(this._imageCell, this._imageInfoParam);
		this._imageInfo = this._imageInfoParam;
	}

	// initialize text
	if (this._textCell && this._textParam) {
		this._textCell.innerHTML = this._text = this._textParam;
	}
	this._expanded = this._selected = this._actioned = false;
	this._gotMouseDownLeft = this._gotMouseDownRight = false;
	this._addMouseListeners();

	this._initialized = true;
};

/**
 * Sets the tree item color.
 * 
 * @param	{string}	className		the class name
 */
DwtTreeItem.prototype.setTreeItemColor = 
function(className) {
	var id = this._htmlElId +"_table";
	var treeItemTableEl = document.getElementById(id);
	var treeItemDivEl = document.getElementById(this._htmlElId + "_div");
	var treeItemEl = this.getHtmlElement();

	var newClassName = this._origClassName + " " + className;
	if (treeItemDivEl) {
		treeItemDivEl.className = newClassName;
	} else if (treeItemEl) {
		treeItemEl.className =  className;
	}
};

DwtTreeItem.prototype._addMouseListeners =
function() {
	var events = [DwtEvent.ONMOUSEDOWN, DwtEvent.ONMOUSEUP, DwtEvent.ONDBLCLICK];
	if (AjxEnv.isIE) {
		events.push(DwtEvent.ONMOUSEENTER, DwtEvent.ONMOUSELEAVE);
	} else {
		events.push(DwtEvent.ONMOUSEOVER, DwtEvent.ONMOUSEOUT);
	}
	if (AjxEnv.isSafari) {
		events.push(DwtEvent.ONCONTEXTMENU);
	}
	for (var i = 0; i < events.length; i++) {
		this.addListener(events[i], DwtTreeItem._listeners[events[i]]);
	}
};

DwtTreeItem.prototype._addDeferredChild =
function(child, index) {
	// If we are initialized, then we need to add a expansion node
	if (this._initialized && this._children.size() == 0) {
		if (this._nodeCell) {
			AjxImg.setImage(this._nodeCell, this._collapseNodeImage);
			var imgEl = AjxImg.getImageElement(this._nodeCell);
			if (imgEl) {
				this._expandable = true;
				this.setAttribute('aria-expanded', this._expanded);
				Dwt.setHandler(imgEl, DwtEvent.ONMOUSEDOWN, DwtTreeItem._nodeIconMouseDownHdlr);
				Dwt.setHandler(imgEl, DwtEvent.ONMOUSEUP, DwtTreeItem._nodeIconMouseUpHdlr);
			}
		}
	}
	this._children.add(child, index);
};

DwtTreeItem.prototype.addChild =
function(child) { /* do nothing since we add to the DOM our own way */ };

DwtTreeItem.prototype._addItem =
function(item, index, realizeDeferred) {
	if (!this._children.contains(item)) {
		this._children.add(item, index);
	}
	this._expandable = true;

	if (this._childDiv == null) {
		this._childDiv = document.createElement("div");
		this._childDiv.className = (this.parent != this._tree)
			? "DwtTreeItemChildDiv" : "DwtTreeItemLevel1ChildDiv";
		this._childDiv.setAttribute('role', 'group');
		this._childDiv.setAttribute('aria-labelledby', this._itemDiv.id);
		this._childDiv.setAttribute('aria-expanded', this._expanded);
		this.getHtmlElement().appendChild(this._childDiv);
		if (!this._expanded) {
			this._childDiv.style.display = "none";
		}
	}

	if (realizeDeferred && this._nodeCell) {
		if (AjxImg.getImageClass(this._nodeCell) == AjxImg.getClassForImage("Blank_16")) {
			AjxImg.setImage(this._nodeCell, this._expanded ? this._expandNodeImage : this._collapseNodeImage);
			var imgEl = AjxImg.getImageElement(this._nodeCell);
			if (imgEl) {
				Dwt.setHandler(imgEl, DwtEvent.ONMOUSEDOWN, DwtTreeItem._nodeIconMouseDownHdlr);
			}
		}
	}

	var childDiv = this._childDiv;
	var numChildren = childDiv.childNodes.length;
	if (index == null || index >= numChildren || numChildren == 0) {
		childDiv.appendChild(item.getHtmlElement());
	} else {
		childDiv.insertBefore(item.getHtmlElement(), childDiv.childNodes[index]);
	}
};

DwtTreeItem.prototype.sort =
function(cmp) {
	this._children.sort(cmp);
	if (this._childDiv) {
		this._setChildElOrder();
	} else {
		this._needsSort = true;
	}
};

DwtTreeItem.prototype._setChildElOrder =
function(cmp) {
	var df = document.createDocumentFragment();
	this._children.foreach(function(item, i) {
		df.appendChild(item.getHtmlElement());
		item._index = i;
	});
	this._childDiv.appendChild(df);
};

DwtTreeItem.prototype._getDragProxy =
function() {
	var icon = document.createElement("div");
	Dwt.setPosition(icon, Dwt.ABSOLUTE_STYLE); 
	var table = document.createElement("table");
	icon.appendChild(table);
	table.cellSpacing = table.cellPadding = 0;

	var row = table.insertRow(0);
	var i = 0;

	var c = row.insertCell(i++);
	c.noWrap = true;
	if (this._dndImageInfo) {
		AjxImg.setImage(c, this._dndImageInfo);
	} else if (this._imageInfo) {
		AjxImg.setImage(c, this._imageInfo);
	}

	c = row.insertCell(i);
	c.noWrap = true;
	c.className = this._origClassName;
	if (this._dndText) {
		c.innerHTML = this._dndText;
	} else if (this._text) {
		c.innerHTML = this._text;
	}

	this.shell.getHtmlElement().appendChild(icon);
	Dwt.setZIndex(icon, Dwt.Z_DND);
	return icon;
};

DwtTreeItem.prototype._dragEnter =
function() {
	this._preDragClassName = this._textCell.className;
	this._textCell.className = this._dragOverClassName;
	this._draghovering = true;
};

DwtTreeItem.prototype._dragHover =
function() {
	if (this.getNumChildren() > 0 && !this.getExpanded()) {
		this.setExpanded(true);
	}
};

DwtTreeItem.prototype._dragLeave =
function(ev) {
	if (this._preDragClassName) {
		this._textCell.className = this._preDragClassName;
	}
	this._draghovering = false;
};

DwtTreeItem.prototype._drop =
function() {
	if (this._preDragClassName) {
		this._textCell.className = this._preDragClassName;
	}
	this._draghovering = false;
};

/**
 *   This is for bug 45129.
 *   In the DwControl's focusByMouseDownEvent, it focuses the TreeItem 
 *   And change TreeItem's color. But sometimes when mousedown and mouseup
 *   haven't been matched on the one element. It will cause multiple selection. 
 *   For in the mouseup handle function, we has done focus if we find both mouse 
 *   down and up happened on the same element. So when the mouse is down, we just
 *   do nothing.
 */
DwtTreeItem.prototype._focusByMouseDownEvent =
function(ev) {
	
}

DwtTreeItem._nodeIconMouseDownHdlr =
function(ev) {
	var obj = DwtControl.getTargetControl(ev);
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev, obj);
	if (mouseEv.button == DwtMouseEvent.LEFT) {
		obj._expand(!obj._expanded, mouseEv);
	} else if (mouseEv.button == DwtMouseEvent.RIGHT) {
		mouseEv.dwtObj._tree._itemActioned(mouseEv.dwtObj, mouseEv);
	}

	mouseEv._stopPropagation = true;
	mouseEv._returnValue = false;
	mouseEv.setToDhtmlEvent(ev);
	return false;
};

DwtTreeItem._nodeIconMouseUpHdlr = 
function(ev) {
	var obj = DwtControl.getTargetControl(ev);
	var mouseEv = DwtShell.mouseEvent;
	mouseEv._stopPropagation = true;
	mouseEv._returnValue = false;
	mouseEv.setToDhtmlEvent(ev);
	return false;
};

DwtTreeItem.prototype._expand =
function(expand, ev, skipNotify) {
	if (expand !== this._expanded) {
		if (!expand) {
			this._expanded = false;
			this._childDiv.style.display = "none";
			if (this._nodeCell) {
				AjxImg.setImage(this._nodeCell, this._collapseNodeImage);
			}
			this._tree._itemCollapsed(this, ev, skipNotify);
		} else {
			// The first thing we need to do is initialize any deferred children so that they
			// actually have content
			this._realizeDeferredChildren();
			this._expanded = true;
			if(this._childDiv && this._childDiv.style)
				this._childDiv.style.display = "block";
			if (this._nodeCell) {
				AjxImg.setImage(this._nodeCell, this._expandNodeImage);
			}
			this._tree._itemExpanded(this, ev, skipNotify);
		}	

		this.setAttribute('aria-expanded', expand);
		this._childDiv.setAttribute('aria-expanded', expand);
		this._childDiv.setAttribute('aria-hidden', !expand);
	}
};

DwtTreeItem.prototype._realizeDeferredChildren =
function() {
	var a = this._children.getArray();
	for (var i = 0; i < a.length; i++) {
		var treeItem = a[i];
		if (!treeItem._initialized) {
			treeItem._initialize(treeItem._index, true);
		} else if (treeItem._isSeparator && !treeItem.div && this._childDiv) {
			// Note: separators marked as initialized on construction
			var div = treeItem.div = document.createElement("div");
			div.className = "vSpace";
			this._childDiv.appendChild(div);
			treeItem._initialized = true;
		}
	}
	if (this._needsSort) {
		if (a.length) {
			this._setChildElOrder();
		}
		delete this.__needsSort;
	}
};

DwtTreeItem.prototype._isChildOf =
function(item) {
	var test = this.parent;
	while (test && test != this._tree) {
		if (test == item)
			return true;
		test = test.parent;
	}
	return false;
};

DwtTreeItem.prototype._setTreeElementStyles =
function(img, focused) {
   if (this._arrowDisabled || this._draghovering) {
        return;
   }
   var selected = focused ? "-focused" : "";
   if (this._extraCell) {
        AjxImg.setImage(this._extraCell, img);
        this._extraCell.className = this._treeItemExtraImgClass + selected;
   }
   if (this._textCell)
        this._textCell.className = this._treeItemTextClass + selected;
}

DwtTreeItem.prototype._setSelected =
function(selected, noFocus) {
	if (this._selected != selected && !this._disposed) {
		this._selected = selected;
		if (!this._initialized) {
			this._initialize();
		}
		if (!this._itemDiv) { return; }

		var didSelect;

		if (selected && (this._selectionEnabled || this._forceNotifySelection) /*&& this._origClassName == "DwtTreeItem"*/) {
			this._itemDiv.className = this._selectedClassName;
			this._setTreeElementStyles("DownArrowSmall", true);
			this._tree.setAttribute('aria-activedescendant', this.getHTMLElId());
            if (!noFocus) {
				this.focus();
			}
			didSelect = true;
		} else {
			this.blur();
			this._setTreeElementStyles("Blank_16", false);
			this._itemDiv.className = this._origClassName;;
			this._tree.removeAttribute('aria-activedescendant');
			didSelect = false;
		}

		this.getHtmlElement().setAttribute('aria-selected', selected);
		/* TODO: disable on IE? screenreaders in IE may announce items twice if
		 * we do the below, which is not strictly necessary */
		var treeEl = this._tree.getHtmlElement();

		if (selected) {
			treeEl.setAttribute('aria-activedescendant', this.getHTMLElId());
		} else {
			treeEl.removeAttribute('aria-activedescendant');
		}

		return didSelect;
	}
};

DwtTreeItem.prototype._setActioned =
function(actioned) {
	if (this._actioned != actioned) {
		this._actioned = actioned;
		if (!this._initialized) {
			this._initialize();
		}

		if (!this._itemDiv) { return; }

		if (actioned && (this._actionEnabled || this._forceNotifyAction) && !this._selected) {
			this._itemDiv.className = this._actionedClassName;
			return true;
		}

		if (!actioned) {
			if (!this._selected) {
				this._itemDiv.className = this._origClassName;
			}
			return false;
		}
	}
};

DwtTreeItem.prototype._focus =
function() {
	if (!this._itemDiv) { return; }
	// focused tree item should always be selected as well
	this._itemDiv.className = this._selectedFocusedClassName;
	this._setTreeElementStyles("DownArrowSmall", true);
};

DwtTreeItem.prototype._blur =
function() {
	if (!this._itemDiv) { return; }
	this._itemDiv.className = this._selected
		? this._selectedClassName : this._origClassName;
	this._setTreeElementStyles(this._selected ? "DownArrowSmall" : "Blank_16", this._selected);
};

DwtTreeItem._mouseDownListener =
function(ev) {
	var treeItem = ev.dwtObj;
	if (!treeItem) { return false; }
	if (ev.target == treeItem._childDiv) { return; }

	if (ev.button == DwtMouseEvent.LEFT && (treeItem._selectionEnabled || treeItem._forceNotifySelection)) {
		treeItem._gotMouseDownLeft = true;
	} else if (ev.button == DwtMouseEvent.RIGHT && (treeItem._actionEnabled || treeItem._forceNotifyAction)) {
		treeItem._gotMouseDownRight = true;
	}

};

DwtTreeItem._mouseOutListener = 
function(ev) {
	var treeItem = ev.dwtObj;
	if (!treeItem) { return false; }
	if (ev.target == treeItem._childDiv) { return; }

	treeItem._gotMouseDownLeft = false;
	treeItem._gotMouseDownRight = false;
	if (treeItem._singleClickAction && treeItem._textCell) {
		treeItem._textCell.className = treeItem._textClassName;
	}
    if(!treeItem._selected){
       treeItem._setTreeElementStyles("Blank_16", false);
    }

};

DwtTreeItem._mouseOverListener =
function(ev) {
	var treeItem = ev.dwtObj;
	if (!treeItem) { return false; }
	if (ev.target == treeItem._childDiv) { return; }

	if (treeItem._singleClickAction && treeItem._textCell) {
		treeItem._textCell.className = treeItem._hoverClassName;
	}
    if(!treeItem._selected){
       treeItem._setTreeElementStyles("ColumnDownArrow", true);
    }
};

DwtTreeItem._mouseUpListener = function(ev) {

	var treeItem = ev.dwtObj;
	if (!treeItem) {
        return false;
    }

	// Ignore any mouse events in the child div i.e. the div which 
	// holds all the items children. In the case of IE, no clicks are
	// reported when clicking in the padding area (note all children
	// are indented using padding-left style); however, mozilla
	// reports mouse events that happen in the padding area
	if (ev.target === treeItem._childDiv) {
        return;
    }

	//ignore the collapse/expand arrow. This is handled in DwtTreeItem._nodeIconMouseDownHdlr. It should only collapse/expand and never select this item, so no point in going on.
	if (treeItem._expandable && ev.target === AjxImg.getImageElement(treeItem._nodeCell)) {
		return;
	}

    var targetElement = DwtUiEvent.getTargetWithProp(ev, "id"),
        isContextCmd = (treeItem._extraCell && targetElement && treeItem._extraCell.id === targetElement.id);

    if ((ev.button === DwtMouseEvent.RIGHT && treeItem._gotMouseDownRight) || isContextCmd) {
        treeItem._tree._itemActioned(treeItem, ev);
    }
    else if (ev.button === DwtMouseEvent.LEFT && treeItem._gotMouseDownLeft) {
		treeItem._tree._itemClicked(treeItem, ev);
	}
};

DwtTreeItem._doubleClickListener =
function(ev) {
	var treeItem = ev.dwtObj;
	if (!treeItem) { return false; }
	// See comment in DwtTreeItem.prototype._mouseDownListener
	if (ev.target == treeItem._childDiv) { return; }

	var obj = DwtControl.getTargetControl(ev);
	var mouseEv = DwtShell.mouseEvent;
	mouseEv.setFromDhtmlEvent(ev, obj);
	if (mouseEv.button == DwtMouseEvent.LEFT || mouseEv.button == DwtMouseEvent.NONE) {	// NONE for IE bug
		mouseEv.dwtObj._tree._itemDblClicked(mouseEv.dwtObj, mouseEv);
	}
};

DwtTreeItem._contextListener =
function(ev) {
	// for Safari, we have to fake a right click
	if (AjxEnv.isSafari) {
		var obj = DwtControl.getTargetControl(ev);
		var prevent = obj ? obj.preventContextMenu() : true;
		if (prevent) {
			obj.notifyListeners(DwtEvent.ONMOUSEDOWN, ev);
			return obj.notifyListeners(DwtEvent.ONMOUSEUP, ev);
		}
	}
};

DwtTreeItem.prototype._emulateSingleClick =
function(params) {
	var mev = new DwtMouseEvent();
	this._setMouseEvent(mev, params);
	mev.kbNavEvent = params.kbNavEvent;
	this.notifyListeners(DwtEvent.ONMOUSEUP, mev);
};

DwtTreeItem.prototype.getTooltipBase =
function(hoverEv) {
	return this._itemDiv;
};

DwtTreeItem._listeners = {};
DwtTreeItem._listeners[DwtEvent.ONMOUSEDOWN] = new AjxListener(null, DwtTreeItem._mouseDownListener);
DwtTreeItem._listeners[DwtEvent.ONMOUSEOUT] = new AjxListener(null, DwtTreeItem._mouseOutListener);
DwtTreeItem._listeners[DwtEvent.ONMOUSELEAVE] = new AjxListener(null, DwtTreeItem._mouseOutListener);
DwtTreeItem._listeners[DwtEvent.ONMOUSEENTER] = new AjxListener(null, DwtTreeItem._mouseOverListener);
DwtTreeItem._listeners[DwtEvent.ONMOUSEOVER] = new AjxListener(null, DwtTreeItem._mouseOverListener);
DwtTreeItem._listeners[DwtEvent.ONMOUSEUP] = new AjxListener(null, DwtTreeItem._mouseUpListener);
DwtTreeItem._listeners[DwtEvent.ONDBLCLICK] = new AjxListener(null, DwtTreeItem._doubleClickListener);
DwtTreeItem._listeners[DwtEvent.ONCONTEXTMENU] = new AjxListener(null, DwtTreeItem._contextListener);


/**
 * Minimal class for a separator (some vertical space) between other tree items.
 * The functions it has are to handle a dispose() call when the containing tree
 * is disposed.
 * 
 * TODO: At some point we should just make this a DwtControl, or find some other
 * 		 way of keeping it minimal.
 * 
 * 
 * @private
 */
DwtTreeItemSeparator = function(parent) {
	this.parent = parent;
	this._isSeparator = true;
	this._initialized = true;
};

DwtTreeItemSeparator.prototype.dispose =
function() {
	DwtComposite.prototype.removeChild.call(this.parent, this);
};

DwtTreeItemSeparator.prototype.isInitialized =
function() {
	return this._initialized;
};

DwtTreeItemSeparator.prototype.getHtmlElement =
function() {
	return this.div;
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtTree")) {
    // SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * Creates a Tree widget.
 * @constructor
 * @class
 * This class implements a tree widget. Tree widgets may contain one or more DwtTreeItems.
 *
 * @author Ross Dargahi
 * 
 * @param {hash}	params				a hash of parameters
 * @param  {DwtComposite}     params.parent			the parent widget
 * @param  {DwtTree.SINGLE_STYLE|DwtTree.MULTI_STYLE|DwtTree.CHECKEDITEM_STYLE}     params.style 	the tree style
 * @param  {string}     params.className				the CSS class
 * @param  {constant}     params.posStyle				the positioning style (see {@link DwtControl})
 * @param  {boolean}     params.isCheckedByDefault	default checked state if tree styles is "checked"
 * 
 * @extends		DwtComposite
 */
DwtTree = function(params) {
	if (arguments.length == 0) { return; }
	params = Dwt.getParams(arguments, DwtTree.PARAMS);
	params.className = params.className || "DwtTree";
	DwtComposite.call(this, params);

	var events = [DwtEvent.ONMOUSEDOWN, DwtEvent.ONMOUSEUP, DwtEvent.ONDBLCLICK];
	if (!AjxEnv.isIE) {
		events = events.concat([DwtEvent.ONMOUSEOVER, DwtEvent.ONMOUSEOUT]);
	}
	this._setEventHdlrs(events);

	var style = params.style;
	if (!style) {
		this._style = DwtTree.SINGLE_STYLE;
	} else {
		if (style == DwtTree.CHECKEDITEM_STYLE) {
			style |= DwtTree.SINGLE_STYLE;
		}
		this._style = style;
	}
	this.isCheckedStyle = ((this._style & DwtTree.CHECKEDITEM_STYLE) != 0);
	this.isCheckedByDefault = params.isCheckedByDefault;

	this._selectedItems = new AjxVector();
	this._selEv = new DwtSelectionEvent(true);
	this._selByClickEv = new DwtSelectionEvent(true);
	this._selByClickEv.clicked = true;
	this._selByEnterEv = new DwtSelectionEvent(true);
	this._selByEnterEv.enter = true;

    // Let tree be a single tab stop, then manage focus among items using arrow keys
    this.tabGroupMember = this;
};

DwtTree.PARAMS = ["parent", "style", "className", "posStyle"];

DwtTree.prototype = new DwtComposite;
DwtTree.prototype.constructor = DwtTree;
DwtTree.prototype.role = "tree";

DwtTree.prototype.toString = 
function() {
	return "DwtTree";
};

/**
 * Defines the "single" style.
 */
DwtTree.SINGLE_STYLE = 1;
/**
 * Defines the "multi" style.
 */
DwtTree.MULTI_STYLE = 2;
/**
 * Defines the "checked-item" style.
 */
DwtTree.CHECKEDITEM_STYLE = 4;

DwtTree.ITEM_SELECTED = 0;
DwtTree.ITEM_DESELECTED = 1;
DwtTree.ITEM_CHECKED = 2;
DwtTree.ITEM_ACTIONED = 3;
DwtTree.ITEM_DBL_CLICKED = 4;

DwtTree.ITEM_EXPANDED = 1;
DwtTree.ITEM_COLLAPSED = 2;

/**
 * Gets the style.
 * 
 * @return	{constant}	the style
 */
DwtTree.prototype.getStyle =
function() {
	return this._style;
};

/**
 * Get the nesting level; this is zero for trees.
 *
 * @return	{number}	the child item count
 */
DwtTree.prototype.getNestingLevel =
function() {
	return 0;
};

/**
 * Adds a selection listener.
 * 
 * @param	{AjxListener}	listener	the listener
 */
DwtTree.prototype.addSelectionListener = 
function(listener) {
	this.addListener(DwtEvent.SELECTION, listener);
};

/**
 * Removes a selection listener.
 * 
 * @param	{AjxListener}	listener	the listener
 */
DwtTree.prototype.removeSelectionListener = 
function(listener) {
	this.removeListener(DwtEvent.SELECTION, listener);    	
};

/**
 * Adds a tree listener.
 * 
 * @param	{AjxListener}	listener	the listener
 */
DwtTree.prototype.addTreeListener = 
function(listener) {
	this.addListener(DwtEvent.TREE, listener);
};

/**
 * Removes a selection listener.
 * 
 * @param	{AjxListener}	listener	the listener
 */
DwtTree.prototype.removeTreeListener = 
function(listener) {
	this.removeListener(DwtEvent.TREE, listener);
};

/**
 * Gets the tree item count.
 * 
 * @return	{number}	the item count
 */
DwtTree.prototype.getItemCount =
function() {
	return this.getItems().length;
};

/**
 * Gets the items.
 * 
 * @return	{array}	an array of {@link DwtTreeItem} objects
 */
DwtTree.prototype.getItems =
function() {
	return this._children.getArray();
};

/** Clears the tree items. */
DwtTree.prototype.clearItems = function() {
    var items = this.getItems();
    for (var i = 0; i < items.length; i++) {
        this.removeChild(items[i]);
    }
    this._getContainerElement().innerHTML = "";
};


/**
 * De-selects all items.
 * 
 */
DwtTree.prototype.deselectAll =
function() {
	var a = this._selectedItems.getArray();
	var sz = this._selectedItems.size();
	for (var i = 0; i < sz; i++) {
		if (a[i]) {
			a[i]._setSelected(false);
		}
	}
	if (sz > 0) {
		this._notifyListeners(DwtEvent.SELECTION, this._selectedItems.getArray(), DwtTree.ITEM_DESELECTED, null, this._selEv);
	}
	this._selectedItems.removeAll();
};

/**
 * Gets an array of selection items.
 * 
 * @return	{array}	an array of {@link DwtTreeItem} objects
 */
DwtTree.prototype.getSelection =
function() {
	return this._selectedItems.getArray();
};

DwtTree.prototype.setEnterSelection =
function(treeItem, kbNavEvent) {
	if (!treeItem) {
		return;
	}
	this._notifyListeners(DwtEvent.SELECTION, [treeItem], DwtTree.ITEM_SELECTED, null, this._selByEnterEv, kbNavEvent);
};


DwtTree.prototype.setSelection =
function(treeItem, skipNotify, kbNavEvent, noFocus) {
	if (!treeItem || !treeItem.isSelectionEnabled()) {
		return;
	}

	// Remove currently selected items from the selection list. if <treeItem> is in that list, then note it and return
	// after we are done processing the selected list
	var a = this._selectedItems.getArray();
	var sz = this._selectedItems.size();
	var da;
	var j = 0;
	var alreadySelected = false;
	for (var i = 0; i < sz; i++) {
		if (a[i] == treeItem) {
			alreadySelected = true;
		} else {
			a[i]._setSelected(false);
			this._selectedItems.remove(a[i]);
			if (da == null) {
				da = new Array();
			}
			da[j++] = a[i];
		}
	}

	if (da && !skipNotify) {
		this._notifyListeners(DwtEvent.SELECTION, da, DwtTree.ITEM_DESELECTED, null, this._selEv, kbNavEvent);
	}

	if (alreadySelected) { return; }
	this._selectedItems.add(treeItem);

	// Expand all parent nodes, and then set item selected
	this._expandUp(treeItem);
	if (treeItem._setSelected(true, noFocus) && !skipNotify) {
		this._notifyListeners(DwtEvent.SELECTION, [treeItem], DwtTree.ITEM_SELECTED, null, this._selEv, kbNavEvent);
	}
};

DwtTree.prototype.getSelectionCount =
function() {
	return this._selectedItems.size();
};

DwtTree.prototype.addChild = function(child) {

    // HACK: Tree items are added via _addItem. But we need to keep
    // HACK: the original addChild behavior for other controls that
    // HACK: may be added to the tree view.
    if (child.isDwtTreeItem) {
        return;
    }

    DwtComposite.prototype.addChild.apply(this, arguments);
};

/**
 * Adds a separator.
 * 
 */
DwtTree.prototype.addSeparator =
function() {
	var sep = document.createElement("div");
	sep.className = "vSpace";
	this._getContainerElement().appendChild(sep);
};

// Expand parent chain from given item up to root
DwtTree.prototype._expandUp =
function(item) {
	var parent = item.parent;
	while (parent instanceof DwtTreeItem) {
		parent.setExpanded(true);
		parent.setVisible(true);
		parent = parent.parent;
	}
};

DwtTree.prototype._addItem = function(item, index) {

	this._children.add(item, index);
	var thisHtmlElement = this._getContainerElement();
	var numChildren = thisHtmlElement.childNodes.length;
	if (index == null || index > numChildren) {
		thisHtmlElement.appendChild(item.getHtmlElement());
	} else {
		//IE Considers undefined as an illegal value for second argument in the insertBefore method
		thisHtmlElement.insertBefore(item.getHtmlElement(), thisHtmlElement.childNodes[index] || null);
	}
};

DwtTree.prototype._getContainerElement = DwtTree.prototype.getHtmlElement;

DwtTree.prototype.sort =
function(cmp) {
    var children = this.getItems();
    children.sort(cmp);
    var fragment = document.createDocumentFragment();
    AjxUtil.foreach(children, function(item, i){
        fragment.appendChild(item.getHtmlElement());
        item._index = i;
    });
    this._getContainerElement().appendChild(fragment);
};

DwtTree.prototype.removeChild =
function(child) {
	this._children.remove(child);
	this._selectedItems.remove(child);
    var childEl = child.getHtmlElement();
    if (childEl.parentNode) {
        childEl.parentNode.removeChild(childEl);
    }
};

/**
 * Returns the next (or previous) tree item relative to the currently selected
 * item, in top-to-bottom order as the tree appears visually. Items such as
 * separators that cannot be selected are skipped.
 * </p><p>
 * If there is no currently selected item, return the first or last item. If we go past
 * the beginning or end of the tree, return null.
 * </p><p>
 * For efficiency, a flattened list of the visible and selectable tree items is maintained.
 * It will be cleared on any change to the tree's display, then regenerated when it is
 * needed.
 *
 * @param {boolean}	next		if <code>true</code>, return next tree item; otherwise, return previous tree item
 * 
 * @private
 */
DwtTree.prototype._getNextTreeItem =
function(next) {

	var sel = this.getSelection();
	var curItem = (sel && sel.length) ? sel[0] : null;

	var nextItem = null, idx = -1;
	var list = this.getTreeItemList(true);
	if (curItem) {
		for (var i = 0, len = list.length; i < len; i++) {
			var ti = list[i];
			if (ti == curItem) {
				idx = next ? i + 1 : i - 1;
				break;
			}
		}
		nextItem = list[idx]; // if array index out of bounds, nextItem is undefined
	} else {
		// if nothing is selected yet, return the first or last item
		if (list && list.length) {
			nextItem = next ? list[0] : list[list.length - 1];
		}
	}
	return nextItem;
};

DwtTree.prototype._getFirstTreeItem =
function() {
	var a = this.getTreeItemList(true);
	if (a && a.length > 0) {
		return a[0];
	}
	return null;
};

DwtTree.prototype._getLastTreeItem =
function() {
	var a = this.getTreeItemList(true);
	if (a && a.length > 0) {
		return a[a.length - 1];
	}
	return null;
};

/**
 * Creates a flat list of this tree's items, going depth-first.
 *
 * @param {boolean}	visible		if <code>true</code>, only include visible/selectable items
 * @return	{array}	an array of {@link DwtTreeItem} objects
 */
DwtTree.prototype.getTreeItemList =
function(visible) {
	return this._addToList([], visible);
};

DwtTree.prototype._addToList =
function(list, visible, treeItem) {
	if (treeItem && !treeItem._isSeparator &&
		(!visible || (treeItem.getVisible() && treeItem._selectionEnabled))) {

		list.push(treeItem);
	}
	if (!treeItem || !visible || treeItem._expanded) {
		var parent = treeItem || this;
		var children = parent.getChildren ? parent.getChildren() : [];
		for (var i = 0; i < children.length; i++) {
			this._addToList(list, visible, children[i]);
		}
	}
	return list;
};

DwtTree.prototype._deselect =
function(item) {
	if (this._selectedItems.contains(item)) {
		this._selectedItems.remove(item);
		item._setSelected(false);
		this._notifyListeners(DwtEvent.SELECTION, [item], DwtTree.ITEM_DESELECTED, null, this._selEv);
	}
};

DwtTree.prototype._itemActioned =
function(item, ev) {
	if (this._actionedItem && !this._actionedItem.isDisposed()) {
		this._actionedItem._setActioned(false);
		this._notifyListeners(DwtEvent.SELECTION, [this._actionedItem], DwtTree.ITEM_DESELECTED, ev, this._selEv);
	}
	this._actionedItem = item;
	item._setActioned(true);
	this._notifyListeners(DwtEvent.SELECTION, [item], DwtTree.ITEM_ACTIONED, ev, this._selEv);
};

DwtTree.prototype._itemChecked =
function(item, ev) {
	this._notifyListeners(DwtEvent.SELECTION, [item], DwtTree.ITEM_CHECKED, ev, this._selEv);
};

DwtTree.prototype._itemClicked =
function(item, ev) {
	var i;
	var a = this._selectedItems.getArray();
	var numSelectedItems = this._selectedItems.size();
	if (this._style & DwtTree.SINGLE_STYLE || (!ev.shiftKey && !ev.ctrlKey)) {
		if (numSelectedItems > 0) {
			for (i = 0; i < numSelectedItems; i++) {
				a[i]._setSelected(false);
			}
			// Notify listeners of deselection
			this._notifyListeners(DwtEvent.SELECTION, this._selectedItems.getArray(), DwtTree.ITEM_DESELECTED, ev, this._selByClickEv);
			this._selectedItems.removeAll();
		}
		this._selectedItems.add(item);
		if (item._setSelected(true)) {
			this._notifyListeners(DwtEvent.SELECTION, [item], DwtTree.ITEM_SELECTED, ev, this._selByClickEv);
		}
	} else {
		if (ev.ctrlKey) {
			if (this._selectedItems.contains(item)) {
				this._selectedItems.remove(item);
				item._setSelected(false);
				this._notifyListeners(DwtEvent.SELECTION, [item], DwtTree.ITEM_DESELECTED, ev, this._selByClickEv);
			} else {
				this._selectedItems.add(item);
				if (item._setSelected(true)) {
					this._notifyListeners(DwtEvent.SELECTION, [item], DwtTree.ITEM_SELECTED, ev, this._selByClickEv);
				}
			}
		} else {
			// SHIFT KEY
		}
	}
};

DwtTree.prototype._itemDblClicked = 
function(item, ev) {
	this._notifyListeners(DwtEvent.SELECTION, [item], DwtTree.ITEM_DBL_CLICKED, ev, this._selEv);
};

DwtTree.prototype._itemExpanded =
function(item, ev, skipNotify) {
	if (!skipNotify) {
		this._notifyListeners(DwtEvent.TREE, [item], DwtTree.ITEM_EXPANDED, ev, DwtShell.treeEvent);
	}
};

DwtTree.prototype._itemCollapsed =
function(item, ev, skipNotify) {
	var i;
	if (!skipNotify) {
		this._notifyListeners(DwtEvent.TREE, [item], DwtTree.ITEM_COLLAPSED, ev, DwtShell.treeEvent);
	}
	var setSelection = false;
	var a = this._selectedItems.getArray();
	var numSelectedItems = this._selectedItems.size();
	var da;
	var j = 0;
	for (i = 0; i < numSelectedItems; i++) {
		if (a[i]._isChildOf(item)) {
			setSelection = true;
			if (da == null) {
				da = new Array();
			}
			da[j++] = a[i];
			a[i]._setSelected(false);
			this._selectedItems.remove(a[i]);
		}		
	}

	if (da) {
		this._notifyListeners(DwtEvent.SELECTION, da, DwtTree.ITEM_DESELECTED, ev, this._selEv);
	}

	if (setSelection && !this._selectedItems.contains(item)) {
		if (item._setSelected(true)) {
			this._selectedItems.add(item);
			this._notifyListeners(DwtEvent.SELECTION, [item], DwtTree.ITEM_SELECTED, ev, this._selEv);
		}
	}
};

DwtTree.prototype._notifyListeners =
function(listener, items, detail, srcEv, destEv, kbNavEvent) {
	if (this.isListenerRegistered(listener)) {
		if (srcEv) {
			DwtUiEvent.copy(destEv, srcEv);
		}
		destEv.items = items;
		if (items.length == 1) {
			destEv.item = items[0];
		}
		destEv.detail = detail;
		destEv.kbNavEvent = kbNavEvent;
		this.notifyListeners(listener, destEv);
		if (listener == DwtEvent.SELECTION) {
			this.shell.notifyGlobalSelection(destEv);
		}
	}
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtCalendar")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * Creates a calendar widget
 * @constructor
 * @class
 * This class provides a calendar view.
 *
 * @author Ross Dargahi
 * @author Roland Schemers
 *
 * @param {hash}		params			a hash of parameters
 * @param {DwtComposite}      params.parent			the parent widget
 * @param {string}      params.className			the CSS class
 * @param {constant}      params.posStyle			the positioning style (see {@link Dwt})
 * @param {constant}     [params.firstDayOfWeek=DwtCalendar.SUN]		the first day of the week
 * @param {boolean}	[params.forceRollOver=true] 	if <code>true</code>, then clicking on (or setting) the widget to a 
 *												date that is not part of the current month (i.e. one of 
 *												the grey prev or next month days) will result in the 
 *												widget rolling 	the date to that month.
 * @param {array}      params.workingDays		a list of days that are work days. This array assumes that
 * 												index 0 is Sunday. Defaults to Mon-Fri being work days.
 * @param {boolean}      params.hidePrevNextMo 	a flag indicating whether widget should hide days of the 
 *												previous/next month
 * @param {boolean}      params.readOnly 		a flag indicating that this widget is read-only (should not 
 *												process events such as mouse clicks)
 * @param {boolean}      params.showWeekNumber	a flag indicating whether widget should show week number
 *        
 * @extends		DwtComposite
 */
DwtCalendar = function(params) {
	if (arguments.length == 0) { return; }
	params = Dwt.getParams(arguments, DwtCalendar.PARAMS);
	params.className = params.className || "DwtCalendar";
	DwtComposite.call(this, params);

	this._skipNotifyOnPage = false;
	this._hidePrevNextMo = params.hidePrevNextMo;
	this._readOnly = params.readOnly;
	this._showWeekNumber = params.showWeekNumber;
	this._uuid = Dwt.getNextId();
	var cn = this._origDayClassName = params.className + "Day";
	this._todayClassName = " " + params.className + "Day-today";
	this._selectedDayClassName = " " + cn + "-" + DwtCssStyle.SELECTED;
	this._hoveredDayClassName = " " + cn + "-" + DwtCssStyle.HOVER;
	this._activeDayClassName = " " + cn + "-" + DwtCssStyle.ACTIVE;
	this._hiliteClassName = " " + cn + "-hilited";
	this._greyClassName = " " + cn + "-grey";
	
	if (!this._readOnly) {
		this._installListeners();
	}

	this._selectionMode = DwtCalendar.DAY;
	
	this._init();

	this._weekDays = new Array(7);
	this._workingDays = params.workingDays || DwtCalendar._DEF_WORKING_DAYS;
    this._useISO8601WeekNo = params.useISO8601WeekNo;
	this.setFirstDayOfWeek(params.firstDayOfWeek || DwtCalendar.SUN);
	
	this._forceRollOver = (params.forceRollOver !== false);
};

DwtCalendar.PARAMS = ["parent", "className", "posStyle", "firstDayOfWeek", "forceRollOver",
					  "workingDaysArray", "hidePrevNextMo", "readOnly"];

DwtCalendar.prototype = new DwtComposite;
DwtCalendar.prototype.constructor = DwtCalendar;

/**
 * Sunday.
 */
DwtCalendar.SUN = 0;
/**
 * Monday.
 */
DwtCalendar.MON = 1;
/**
 * Tuesday.
 */
DwtCalendar.TUE = 2;
/**
 * Wednesday.
 */
DwtCalendar.WED = 3;
/**
 * Thursday.
 */
DwtCalendar.THU = 4;
/**
 * Friday.
 */
DwtCalendar.FRI = 5;
/**
 * Saturday.
 */
DwtCalendar.SAT = 6;

// Selection modes
/**
 * Defines the "day" selection mode.
 */
DwtCalendar.DAY = 1;
/**
 * Defines the "week" selection mode.
 */
DwtCalendar.WEEK = 2;
/**
 * Defines the "work week" selection mode.
 */
DwtCalendar.WORK_WEEK = 3;
/**
 * Defines the "month" selection mode.
 */
DwtCalendar.MONTH = 4;

DwtCalendar.RANGE_CHANGE = "DwtCalendar.RANGE_CHANGE";

DwtCalendar._FULL_WEEK = [1, 1, 1, 1, 1, 1, 1];
DwtCalendar._DEF_WORKING_DAYS = [0, 1, 1, 1, 1, 1, 0];
DwtCalendar._DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

DwtCalendar._NO_MONTH = -2;
DwtCalendar._PREV_MONTH = -1;
DwtCalendar._THIS_MONTH = 0;
DwtCalendar._NEXT_MONTH = 1;

DwtCalendar._NORMAL = 1;
DwtCalendar._HOVERED = 2;
DwtCalendar._ACTIVE = 3;
DwtCalendar._SELECTED = 4;
DwtCalendar._DESELECTED = 5;

DwtCalendar.DATE_SELECTED 		= 1;
DwtCalendar.DATE_DESELECTED 	= 2;
DwtCalendar.DATE_DBL_CLICKED 	= 3;

DwtCalendar._LAST_DAY_CELL_IDX = 41;

DwtCalendar._BUTTON_CLASS = "DwtCalendarButton";
DwtCalendar._BUTTON_HOVERED_CLASS = DwtCalendar._BUTTON_CLASS + "-" + DwtCssStyle.HOVER;
DwtCalendar._BUTTON_ACTIVE_CLASS = DwtCalendar._BUTTON_CLASS + "-" + DwtCssStyle.ACTIVE;

DwtCalendar._TITLE_CLASS = "DwtCalendarTitle";
DwtCalendar._TITLE_HOVERED_CLASS = DwtCalendar._TITLE_CLASS + "-" + DwtCssStyle.HOVER;
DwtCalendar._TITLE_ACTIVE_CLASS = DwtCalendar._TITLE_CLASS + "-" + DwtCssStyle.ACTIVE;

/**
 * Returns a string representation of the object.
 * 
 * @return		{string}		a string representation of the object
 */
DwtCalendar.prototype.toString = 
function() {
	return "DwtCalendar";
};

/**
 * Adds a selection listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
DwtCalendar.prototype.addSelectionListener = 
function(listener) {
	this.addListener(DwtEvent.SELECTION, listener);
};

/**
 * Removes a selection listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
DwtCalendar.prototype.removeSelectionListener = 
function(listener) { 
	this.removeListener(DwtEvent.SELECTION, listener);
};

/**
 * Adds an action listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
DwtCalendar.prototype.addActionListener = 
function(listener) {
	this.addListener(DwtEvent.ACTION, listener);
};

/**
 * Removes an action listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
DwtCalendar.prototype.removeActionListener = 
function(listener) { 
	this.removeListener(DwtEvent.ACTION, listener);
};

/**
 * Adds a date range listener. Date range listeners are called whenever the date range of the calendar
 * changes (i.e. when it rolls over due to a programatic action via {@link #setDate} or
 * via user selection).
 *
 * @param 	{AjxListener}		listener		the listener
 */
DwtCalendar.prototype.addDateRangeListener = 
function(listener) {
	this.addListener(DwtEvent.DATE_RANGE, listener);
};

/**
 * Removes a date range listener.
 * 
 * @param 	{AjxListener}		listener		the listener
 */
DwtCalendar.prototype.removeDateRangeListener = 
function(listener) { 
	this.removeListener(DwtEvent.DATE_RANGE, listener);
};

/**
 * Sets the skip notify on page. This method notify (or not) selection when paging arrow buttons
 * are clicked.
 *
 * @param	{boolean}	skip		if <code>true</code>, do not notify selection
 */
DwtCalendar.prototype.setSkipNotifyOnPage = 
function(skip) {
	this._skipNotifyOnPage = skip;
};

/**
 * Gets the skip notify on page setting.
 * 
 * @return	{boolean}	<code>true</code>, do not notify selection
 */
DwtCalendar.prototype.getSkipNotifyOnPage = 
function() {
	return this._skipNotifyOnPage;
};

/**
 * Sets the date.
 * 
 * @param	{Date}	date	the date
 * @param	{boolean}	skipNotify		if <code>true</code>, do not notify selection
 * @param {boolean}	forceRollOver 	if <code>true</code>, then clicking on (or setting) the widget to a 
 *												date that is not part of the current month (i.e. one of 
 *												the grey prev or next month days) will result in the 
 *												widget rolling 	the date to that month.
 * @param	{boolean}	dblClick		if <code>true</code>, require a double click
 */
DwtCalendar.prototype.setDate =
function(date, skipNotify, forceRollOver, dblClick) {

	forceRollOver = (forceRollOver == null) ? this._forceRollOver : forceRollOver;
	
	// Check if the date is available for selection. Basically it is unless we are in
	// work week selection mode and <date> is not a working day
	//if (this._selectionMode == DwtCalendar.WORK_WEEK && !this._currWorkingDays[date.getDay()])
	//	return false;

	if(!date) {
		date = new Date();
	}
	var newDate = new Date(date.getTime());
	var oldDate = this._date;

	var layout = false;
	var notify = false;
	var cellId;

	if (this._date2CellId != null) {
		var idx = (newDate.getFullYear() * 10000) + (newDate.getMonth() * 100) + newDate.getDate();
		var cellId = this._date2CellId[idx];
		
		if (cellId) {
		 	if (cellId == this._selectedCellId)
		 		notify = true;

			var cell = document.getElementById(cellId);
			if (cell._dayType == DwtCalendar._THIS_MONTH)
				notify = true;
			else if (forceRollOver)
				notify = layout = true;
			else
				notify = true;
		} else {
			 notify = layout = true;
		}
	} else {
		notify = layout = true;
	}

	// update before layout, notify after layout
	if (notify) {
		if (this._date){
			// 5/13/2005 EMC -- I'm not sure why this was setting the hours to 0.
			// I think it should respect what the user passed in, and only change
			// the parts of the date that it is responsible for.
			//newDate.setHours(0,0,0,0);
			//handle daylight saving
			if(AjxDateUtil.isDayShifted(newDate)) {
				AjxDateUtil.rollToNextDay(newDate);
			}
			newDate.setHours(this._date.getHours(), this._date.getMinutes(), this._date.getSeconds(), 0);            
		}

		this._date = newDate;
		if (!layout && !this._readOnly) {
			this._setSelectedDate();
			this._setToday();
		}
	}

	if (layout) {
		this._layout();
	}

	if (notify && !skipNotify) {
		var type = dblClick ? DwtCalendar.DATE_DBL_CLICKED : DwtCalendar.DATE_SELECTED;
		this._notifyListeners(DwtEvent.SELECTION, type, this._date);
	}
	
	return true;
};

/**
 * Checks if the cell is selected.
 * 
 * @param	{string}	cellId			the cell id	
 * @return	{boolean}	<code>true</code> if the cell is the selected day
 */
DwtCalendar.prototype.isSelected =
function(cellId) {
	// if cellId is the selected day, then return true, else if we are NOT in
	// day selection mode (i.e. week/work week) then compute the row and index
	// of cellId and look it up in the week array to see if it is a selectable day
	if (cellId == this._selectedDayElId) {
		return true;
	} else if (this._selectionMode != DwtCalendar.DAY) {
		// If the cell is in the same row as the currently selected cell and it
		// is a selectable day (i.e. a working day in the case of work week),
		// then say it is selected
		var cellIdx = this._getDayCellIndex(cellId);
		if (Math.floor(cellIdx / 7) == Math.floor(this._getDayCellIndex(this._selectedDayElId) / 7)
			&& this._currWorkingDays[cellIdx % 7])
			return true;
	}
	return false;
};

/**
 * Gets the force roll over setting. Force roll over is occurs when a date that
 * is not part of the current month (i.e. one of the grey prev or next month
 * days) will result in the widget rolling 	the date to that month.
 * 
 * @return	{boolean}	<code>true</code> if force roll over is set
 */
DwtCalendar.prototype.getForceRollOver =
function() {
	return this._forceRollOver;
};

/**
 * Sets the force roll over setting. Force roll over is occurs when a date that
 * is not part of the current month (i.e. one of the grey prev or next month
 * days) will result in the widget rolling 	the date to that month.
 * 
 * @param	{boolean}	force		if <code>true</code>, force roll over
 */
DwtCalendar.prototype.setForceRollOver =
function(force) {
	if (force == null) { return; }
	
	if (this._forceRollOver != force) {
		this._forceRollOver = force;
		this._layout();
	}
};

/**
 * Gets the selection mode.
 * 
 * @return	{constant}		the selection mode
 */
DwtCalendar.prototype.getSelectionMode =
function() {
	return this._selectionMode;
};

/**
 * Sets the selection mode.
 * 
 * @return	{constant}		selectionMode		the selection mode
 */
DwtCalendar.prototype.setSelectionMode =
function(selectionMode) {
	if (this._selectionMode == selectionMode) { return; }

	this._selectionMode = selectionMode;
	if (selectionMode == DwtCalendar.WEEK) {
		this._currWorkingDays = DwtCalendar._FULL_WEEK;
	} else if (selectionMode == DwtCalendar.WORK_WEEK) {
		this._currWorkingDays = this._workingDays;
	}

	this._layout();
};

/**
 * Sets the working week.
 * 
 * @param	{array}	workingDaysArray		an array of days
 */
DwtCalendar.prototype.setWorkingWeek =
function(workingDaysArray) {
	// TODO Should really create a copy of workingDaysArray
	this._workingDays = this._currWorkingDays = workingDaysArray;
	
	if (this._selectionMode == DwtCalendar.WORK_WEEK) {
		DBG.println("FOO!!!");
		this._layout();
	}
};

/**
 * Enables/disables the highlight (i.e. "bolding") on the dates in <code>&lt;dates&gt;</code>.
 *
 * @param {object} dates associative array of {@link Date} objects for
 * which to enable/disable highlighting
 * @param {boolean}	enable 	if <code>true</code>, enable highlighting
 * @param {boolean}	clear 	if <code>true</code>, clear current highlighting
 */
DwtCalendar.prototype.setHilite =
function(dates, enable, clear) {
	if (this._date2CellId == null) { return; }

	var cell;
	var aDate;
	if (clear) {
		for (aDate in this._date2CellId) {
			cell = document.getElementById(this._date2CellId[aDate]);
			if (cell._isHilited) {
				cell._isHilited = false;
				this._setClassName(cell, DwtCalendar._NORMAL);
			}	
		}
	}

	var cellId;
	for (var i in dates) {
        // NOTE: Protect from prototype extensions.
        if (dates.hasOwnProperty(i)) {
            aDate = dates[i];
            cellId = this._date2CellId[aDate.getFullYear() * 10000 + aDate.getMonth() * 100 + aDate.getDate()];

            if (cellId) {
                cell = document.getElementById(cellId);
                if (cell._isHilited != enable) {
                    cell._isHilited = enable;
                    this._setClassName(cell, DwtCalendar._NORMAL);
                }
            }
        }
	}
};

/**
 * Gets the date.
 * 
 * @return	{Date}	the date
 */
DwtCalendar.prototype.getDate =
function() {
	return this._date;
};

/**
 * Sets the first date of week.
 * 
 * @param	{constant}		firstDayOfWeek		the first day of week
 */
DwtCalendar.prototype.setFirstDayOfWeek =
function(firstDayOfWeek) {
	for (var i = 0; i < 7; i++) {
		this._weekDays[i] = (i < firstDayOfWeek)
			? (6 - (firstDayOfWeek -i - 1))
			: (i - firstDayOfWeek);

		var dowCell = document.getElementById(this._getDOWCellId(i));
		dowCell.innerHTML = AjxDateUtil.WEEKDAY_SHORT[(firstDayOfWeek + i) % 7];
	}
    this._firstDayOfWeek = firstDayOfWeek
	this._layout();
};

/**
 * Gets the date range.
 * 
 * @return	{Object}		the range (<code>range.start</code> and <code>range.end</code>)
 */
DwtCalendar.prototype.getDateRange =
function () {
	return this._range;
};

DwtCalendar.prototype._getDayCellId =
function(cellId) {
	return ("c:" + cellId + ":" + this._uuid);
};

DwtCalendar.prototype._getDayCellIndex =
function(cellId) {
	return cellId.substring(2, cellId.indexOf(":", 3));
};

DwtCalendar.prototype._getDOWCellId =
function(cellId) {
	return ("w:" + cellId + ":" + this._uuid);
};

DwtCalendar.prototype._getWeekNumberCellId =
function(cellId) {
	return ("k:" + cellId + ":" + this._uuid);
};

DwtCalendar.prototype._getDaysInMonth =
function(mo, yr) {
	/* If we are not dealing with Feb, then simple lookup
	 * Leap year rules
	 *  1. Every year divisible by 4 is a leap year.
	 *  2. But every year divisible by 100 is NOT a leap year
	 *  3. Unless the year is also divisible by 400, then it is still a leap year.*/
	if (mo != 1) {
		return DwtCalendar._DAYS_IN_MONTH[mo];
	}

	if (yr % 4 != 0 || (yr % 100 == 0 && yr % 400 != 0)) {
		return 28;
	}

	return 29;
};

DwtCalendar.prototype._installListeners =
function() {
	this._setMouseEventHdlrs();
	this.addListener(DwtEvent.ONMOUSEOVER, new AjxListener(this, this._mouseOverListener));
	this.addListener(DwtEvent.ONMOUSEOUT, new AjxListener(this, this._mouseOutListener));
	this.addListener(DwtEvent.ONMOUSEDOWN, new AjxListener(this, this._mouseDownListener));
	this.addListener(DwtEvent.ONMOUSEUP, new AjxListener(this, this._mouseUpListener));
	this.addListener(DwtEvent.ONDBLCLICK, new AjxListener(this, this._doubleClickListener));
};

DwtCalendar.prototype._notifyListeners =
function(eventType, type, detail, ev) {
	if (!this.isListenerRegistered(eventType)) { return; }

	var selEv = DwtShell.selectionEvent;
	if (ev) {
		DwtUiEvent.copy(selEv, ev);
	} else {
		selEv.reset();
	}
	selEv.item = this;
	selEv.detail = detail;
	selEv.type = type;
	this.notifyListeners(eventType, selEv);
};

DwtCalendar.prototype._layout =
function() {
	if (this._date == null) { this._date = new Date(); }

	if (!this._calWidgetInited) {
		this._init();
	}

	var date = new Date(this._date.getTime());
	date.setDate(1);
	var year = date.getFullYear();
	var month  = date.getMonth();
	var firstDay = date.getDay();
	var daysInMonth = this._getDaysInMonth(month, year);
	var day = 1;
	var nextMoDay = 1;

	this._date2CellId = new Object();
	this._selectedDayElId = null;

	// Figure out how many days from the previous month we have to fill in
	// (see comment below)
	var lastMoDay, lastMoYear, lastMoMonth, nextMoMonth, nextMoYear;
	if (!this._hidePrevNextMo) {
		if (month != 0) {
			lastMoDay = this._getDaysInMonth(month - 1, year) - this._weekDays[firstDay] + 1;
			lastMoYear = year;
			lastMoMonth = month - 1;
			if (month != 11) {
				nextMoMonth = month + 1;
				nextMoYear = year;
			} else {
				nextMoMonth = 0;
				nextMoYear = year + 1;
			}
		} else {
			lastMoDay = this._getDaysInMonth(11, year - 1) - this._weekDays[firstDay] + 1;
			lastMoYear = year - 1;
			lastMoMonth = 11;
			nextMoMonth = 1;
			nextMoYear = year;
		}
	}

	for (var i = 0; i < 6; i++) {
		for (var j = 0; j < 7; j++) {
			var dayCell = document.getElementById(this._getDayCellId(i * 7 + j));

			if (dayCell._isHilited == null) {
				dayCell._isHilited = false;
			}

			if (day <= daysInMonth) {
				/* The following if statement deals with the first day of this month not being
				 * the first day of the week. In this case we must fill the preceding days with
				 * the final days of the previous month */
				if (i != 0 || j >= this._weekDays[firstDay]) {
					this._date2CellId[(year * 10000) + (month * 100) + day] = dayCell.id;
					dayCell._day = day;
					dayCell._month = month;
					dayCell._year = year;
					dayCell.innerHTML = day++;
					dayCell._dayType = DwtCalendar._THIS_MONTH;
					if (this._readOnly) {
						dayCell.style.fontFamily = "Arial";
						dayCell.style.fontSize = "10px";
					}
				} else {
					if (this._hidePrevNextMo) {
						dayCell.innerHTML = "";
					} else {
						this._date2CellId[(lastMoYear * 10000) + (lastMoMonth * 100) + lastMoDay] = dayCell.id;
						dayCell._day = lastMoDay;
						dayCell._month = lastMoMonth;
						dayCell._year = lastMoYear;
						dayCell.innerHTML = lastMoDay++;
						dayCell._dayType = DwtCalendar._PREV_MONTH;
					}
				}
			} else if (!this._hidePrevNextMo) {
				// Fill any remaining slots with days from next month
				this._date2CellId[(nextMoYear * 10000) + (nextMoMonth * 100) + nextMoDay] = dayCell.id;
				dayCell._day = nextMoDay;
				dayCell._month = nextMoMonth;
				dayCell._year = nextMoYear;
				dayCell.innerHTML = nextMoDay++;
				dayCell._dayType = DwtCalendar._NEXT_MONTH;
			}
			this._setClassName(dayCell, DwtCalendar._NORMAL);
		}

		if (this._showWeekNumber) {
			var kwCellId = this._getWeekNumberCellId('kw' + i * 7);
			var kwCell = document.getElementById(kwCellId);
			if (kwCell) {
				var firstDayCell = document.getElementById(this._getDayCellId(i * 7));
				kwCell.innerHTML = AjxDateUtil.getWeekNumber(new Date(firstDayCell._year, firstDayCell._month, firstDayCell._day), this._firstDayOfWeek, null, this._useISO8601WeekNo);
			}
		}
	}

	this._setTitle(month, year);

	// Compute the currently selected day
	if (!this._readOnly) {
		this._setSelectedDate();
		this._setToday();
	}
	
	this._setRange();
};

DwtCalendar.prototype._setRange =
function() {
	var cell = document.getElementById(this._getDayCellId(0));
	var start = new Date(cell._year, cell._month, cell._day, 0, 0, 0, 0);

	cell = document.getElementById(this._getDayCellId(DwtCalendar._LAST_DAY_CELL_IDX));
	
	var daysInMo = this._getDaysInMonth(cell._month, cell._year);
	var end;
	if (cell._day < daysInMo) {
		end = new Date(cell._year, cell._month, cell._day + 1, 0, 0, 0, 0);
	} else if (cell._month < 11) {
		end = new Date(cell._year, cell._month + 1, 1, 0, 0, 0, 0);
	} else {
		end = new Date(cell._year + 1, 0, 1, 0, 0, 0, 0);
	}

	if (this._range == null) {
		this._range = {};
	} else if (this._range.start.getTime() == start.getTime() && this._range.end.getTime() == end.getTime()) {
		return false;
	}

	this._range.start = start;
	this._range.end = end;

	// Notify any listeners
	if (!this.isListenerRegistered(DwtEvent.DATE_RANGE)) { return; }

	if (!this._dateRangeEvent) {
		this._dateRangeEvent = new DwtDateRangeEvent(true);
	}

	this._dateRangeEvent.item = this;
	this._dateRangeEvent.start = start;
	this._dateRangeEvent.end = end;
	this.notifyListeners(DwtEvent.DATE_RANGE, this._dateRangeEvent);
};

DwtCalendar.prototype._setToday =
function() {
	var cell;
	var today = new Date();
	var todayDay = today.getDate();

	if (!this._todayDay || this._todayDay != todayDay) {
		if (this._todayCellId != null) {
			cell = document.getElementById(this._todayCellId);
			cell._isToday = false;
			this._setClassName(cell, DwtCalendar._NORMAL);
		}

		this._todayCellId = this._date2CellId[(today.getFullYear() * 10000) + (today.getMonth() * 100) + todayDay];
		if (this._todayCellId != null) {
			cell = document.getElementById(this._todayCellId);
			cell._isToday = true;
			this._setClassName(cell, DwtCalendar._NORMAL);
		}
	}
};

DwtCalendar.prototype._setSelectedDate =
function() {
	var day = this._date.getDate();
	var month = this._date.getMonth();
	var year = this._date.getFullYear();
	var cell;

	if (this._selectedDayElId) {
		cell = document.getElementById(this._selectedDayElId);
		this._setClassName(cell, DwtCalendar._DESELECTED);
	}

	var cellId = this._date2CellId[(year * 10000) + (month * 100) + day];
	cell = document.getElementById(cellId);
	this._selectedDayElId = cellId;
	this._setClassName(cell, DwtCalendar._SELECTED);
};

DwtCalendar.prototype._setCellClassName = 
function(cell, className, mode) {
	if (cell._dayType != DwtCalendar._THIS_MONTH) {
		className += this._greyClassName;
	}

	if (this._selectionMode == DwtCalendar.DAY &&
		cell.id == this._selectedDayElId &&
		mode != DwtCalendar._DESELECTED)
	{
		className += this._selectedDayClassName;
	}
	else if (this._selectionMode != DwtCalendar.DAY &&
			 mode != DwtCalendar._DESELECTED &&
			 this._selectedDayElId != null)
	{
		var idx = this._getDayCellIndex(cell.id);
		if (Math.floor(this._getDayCellIndex(this._selectedDayElId) / 7) == Math.floor(idx / 7) &&
			this._currWorkingDays[idx % 7])
		{
			className += this._selectedDayClassName;
		}
	}

	if (cell._isHilited) {
		className += this._hiliteClassName;
	}

	if (cell._isToday) {
		className += this._todayClassName;
	}

	return className;
};

DwtCalendar.prototype._setClassName = 
function(cell, mode) {
	var className = "";
	
	if (mode == DwtCalendar._NORMAL) {
		className = this._origDayClassName;
	} else if (mode == DwtCalendar._HOVERED) {
		className = this._hoveredDayClassName;
	} else if (mode == DwtCalendar._ACTIVE) {
		className = this._activeDayClassName;
	} else if (mode == DwtCalendar._DESELECTED && this._selectionMode == DwtCalendar.DAY) {
		className = this._origDayClassName;
	} else if (this._selectionMode != DwtCalendar.DAY &&
			(mode == DwtCalendar._SELECTED || mode == DwtCalendar._DESELECTED))
	{
		// If we are not in day mode, then we need to highlite multiple cells
		// e.g. the whole week if we are in week mode
		var firstCellIdx = Math.floor(this._getDayCellIndex(this._selectedDayElId) / 7) * 7;

		for (var i = 0; i < 7; i++) {
			className = this._origDayClassName;
			var aCell = document.getElementById(this._getDayCellId(firstCellIdx++));
			aCell.className = this._setCellClassName(aCell, className, mode);
		}
		return;
	}

	cell.className = this._setCellClassName(cell, className, mode);
};

DwtCalendar.prototype._setTitle =
function(month, year) {
	var cell = document.getElementById(this._monthCell);
	var formatter = DwtCalendar.getMonthFormatter();
	var date = new Date(year, month);
	cell.innerHTML = formatter.format(date);
};

DwtCalendar.prototype._init =
function() {
	var html = new Array(100);
	var idx = 0;
	this._monthCell = "t:" + this._uuid;

	// Construct the header row with the prev/next year and prev/next month
	// icons as well as the month/year title cell
	html[idx++] =	"<table width=100%>";
	html[idx++] =		"<tr><td class='DwtCalendarTitlebar'>";
	html[idx++] =			"<table>";
	html[idx++] =				"<tr>";
	html[idx++] =					"<td align='center' class='";
	html[idx++] =						DwtCalendar._BUTTON_CLASS;
	html[idx++] =						"' id='b:py:";
	html[idx++] =						this._uuid;
	html[idx++] =						"'>";
	html[idx++] =						AjxImg.getImageHtml("FastRevArrowSmall", null, ["id='b:py:img:", this._uuid, "'"].join(""));
	html[idx++] =					"</td>";
	html[idx++] =					"<td align='center' class='";
	html[idx++] =						DwtCalendar._BUTTON_CLASS;
	html[idx++] =						"' id='b:pm:";
	html[idx++] =						this._uuid;
	html[idx++] =						"'>";
	html[idx++] =						AjxImg.getImageHtml("RevArrowSmall", null, ["id='b:pm:img:", this._uuid, "'"].join(""));
	html[idx++] =					"</td>";
	html[idx++] =					"<td class='DwtCalendarTitleCell' 'nowrap' style='width: 60%'><span class='";
	html[idx++] =						DwtCalendar._TITLE_CLASS;
	html[idx++] = 						"' id='";
	html[idx++] =						this._monthCell;
	html[idx++] =					"'></span></td>";
	html[idx++] =					"<td align='center' class='";
	html[idx++] =						DwtCalendar._BUTTON_CLASS;
	html[idx++] =						"' id='b:nm:";
	html[idx++] =						this._uuid;
	html[idx++] =						"'>";
	html[idx++] =						AjxImg.getImageHtml("FwdArrowSmall", null, ["id='b:nm:img:", this._uuid, "'"].join(""));
	html[idx++] =					"</td>";
	html[idx++] =					"<td align='center' class='";
	html[idx++] =						DwtCalendar._BUTTON_CLASS;
	html[idx++] =						"' id='b:ny:";
	html[idx++] =						this._uuid;
	html[idx++] =						"'>";
	html[idx++] =						AjxImg.getImageHtml("FastFwdArrowSmall", null, ["id='b:ny:img:", this._uuid, "'"].join(""));
	html[idx++] =					"</td>";
	html[idx++] =				"</tr>";
	html[idx++] =			"</table>";
	html[idx++] =		"</td></tr>";
	html[idx++] =	"<tr><td class='DwtCalendarBody'>";
	html[idx++] =		"<table width='100%' style='border-collapse:separate;' cellspacing='0'>";
	html[idx++] =			"<tr>";

	if (this._showWeekNumber) {
		html[idx++] = "<td class='DwtCalendarWeekNoTitle' width='14%' id='";
		html[idx++] = this._getWeekNumberCellId('kw');
		html[idx++] = "'>";
		html[idx++] = AjxMsg.calendarWeekTitle;
		html[idx++] = "</td>";
	}

	for (var i = 0; i < 7; i++) {
		html[idx++] = "<td class='DwtCalendarDow' width='";
		html[idx++] = (i < 5 ? "14%" : "15%");
		html[idx++] = "' id='";
		html[idx++] = this._getDOWCellId(i);
		html[idx++] = "'>&nbsp;</td>";
	}
	html[idx++] = "</tr>";

	for (var i = 0; i < 6; i++) {
		html[idx++] = "<tr>";
		if (this._showWeekNumber) {
			html[idx++] = "<td class='DwtCalendarWeekNo' id='" + this._getWeekNumberCellId('kw' + i * 7) + "'>&nbsp;</td>";
		}
		for (var j = 0; j < 7; j++) {
			html[idx++] = "<td id='";
			html[idx++] = this._getDayCellId(i * 7 + j);
			html[idx++] = "'>&nbsp;</td>";
		}
		html[idx++] ="</tr>";
	}

	html[idx++] = "</td></tr></table></table>";

	this.getHtmlElement().innerHTML = html.join("");
	if (!this._readOnly) {
		document.getElementById("b:py:img:" + this._uuid)._origClassName = AjxImg.getClassForImage("FastRevArrowSmall");
		document.getElementById("b:pm:img:" + this._uuid)._origClassName = AjxImg.getClassForImage("RevArrowSmall");
		document.getElementById("b:nm:img:" + this._uuid)._origClassName = AjxImg.getClassForImage("FwdArrowSmall");
		document.getElementById("b:ny:img:" + this._uuid)._origClassName = AjxImg.getClassForImage("FastFwdArrowSmall");
	}

	this._calWidgetInited = true;
};

/**
 * Sets the mouse over day callback.
 * 
 * @param	{AjxCallback}		callback		the callback
 */
DwtCalendar.prototype.setMouseOverDayCallback =
function(callback) {
	this._mouseOverDayCB = callback;
};

/**
 * Sets the mouse out day callback.
 * 
 * @param	{AjxCallback}		callback		the callback
 */
DwtCalendar.prototype.setMouseOutDayCallback =
function(callback) {
	this._mouseOutDayCB = callback;
};

/**
 * Gets the date value for the last cell that the most recent
 * Drag-and-drop operation occurred over. Typically it will be called by a DwtDropTarget
 * listener when an item is dropped onto the mini calendar
 * 
 * @return	{Date}		the date or <code>null</code> for none
 */
DwtCalendar.prototype.getDndDate =
function() {
	var dayCell = this._lastDndCell;
	if (dayCell) {
		return new Date(dayCell._year, dayCell._month, dayCell._day);
	}

	return null;
};

// Temp date used for callback in mouseOverListener
DwtCalendar._tmpDate = new Date();
DwtCalendar._tmpDate.setHours(0, 0, 0, 0);

DwtCalendar.prototype._mouseOverListener = 
function(ev) {
	var target = ev.target;
	if (target.id.charAt(0) == 'c') {
		this._setClassName(target, DwtCalendar._HOVERED);
		// If a mouse over callback has been registered, then call it to give it
		// chance do work like setting the tooltip content
		if (this._mouseOverDayCB) {
			DwtCalendar._tmpDate.setFullYear(target._year, target._month, target._day);
			this._mouseOverDayCB.run(this, DwtCalendar._tmpDate);
		}
	} else if (target.id.charAt(0) == 't') {
		// Dont activate title for now
		return;
	} else if (target.id.charAt(0) == 'b') {
		var img;
		if (target.firstChild == null) {
			img = target;
			AjxImg.getParentElement(target).className = DwtCalendar._BUTTON_HOVERED_CLASS;
		} else {
			target.className = DwtCalendar._BUTTON_HOVERED_CLASS;
			img = AjxImg.getImageElement(target);
		}
		img.className = img._origClassName;
	}

	ev._stopPropagation = true;
};

DwtCalendar.prototype._mouseOutListener = 
function(ev) {
	this.setToolTipContent(null);
	var target = ev.target;
	if (target.id.charAt(0) == 'c') {
		this._setClassName(target, DwtCalendar._NORMAL);
		if (this._mouseOutDayCB) {
			this._mouseOutDayCB.run(this);
		}
	} else if (target.id.charAt(0) == 'b') {
		var img;
		target.className = DwtCalendar._BUTTON_CLASS;
		if (target.firstChild == null) {
			img = target;
			AjxImg.getParentElement(target).className = DwtCalendar._BUTTON_CLASS;
		} else {
			target.className = DwtCalendar._BUTTON_CLASS;
			img = AjxImg.getImageElement(target);
		}
		img.className = img._origClassName;
	}
};

DwtCalendar.prototype._mouseDownListener = 
function(ev) {
	if (ev.button == DwtMouseEvent.LEFT) {
		var target = ev.target;
		if (target.id.charAt(0) == 'c') {
			this._setClassName(target, DwtCalendar._ACTIVE);
		} else if (target.id.charAt(0) == 't') {
			target.className = DwtCalendar._TITLE_ACTIVE_CLASS;
		} else if (target.id.charAt(0) == 'b') {
			var img;
			if (target.firstChild == null) {
				img = target;
				AjxImg.getParentElement(target).className = DwtCalendar._BUTTON_ACTIVE_CLASS;
			} else {
				target.className = DwtCalendar._BUTTON_ACTIVE_CLASS;
				img = AjxImg.getImageElement(target);
			}
			img.className = img._origClassName;
		} else if (target.id.charAt(0) == 'w') {
		}
	}
};

DwtCalendar.prototype._mouseUpListener = 
function(ev) {
	var target = ev.target;
	if (ev.button == DwtMouseEvent.LEFT) {
		if (target.id.charAt(0) == 'c') {
			// If our parent is a menu then we need to have it close
			if (this.parent instanceof DwtMenu)
				DwtMenu.closeActiveMenu();

            var sDate = new Date(target._year, target._month, target._day);
            if(sDate.getDate() != target._day) {
                sDate.setDate(target._day);                 
            }
			if (this.setDate(sDate)) { return; }

			this._setClassName(target, DwtCalendar._HOVERED);
		} else if (target.id.charAt(0) == 'b') {
			var img;
			if (target.firstChild == null) {
				img = target;
				AjxImg.getParentElement(target).className = DwtCalendar._BUTTON_HOVERED_CLASS;
			} else {
				target.className = DwtCalendar._BUTTON_HOVERED_CLASS;
				img = AjxImg.getImageElement(target);
			}
			img.className = img._origClassName;
			
			if (img.id.indexOf("py") != -1) {
				this._prevYear();
			} else if (img.id.indexOf("pm") != -1) {
				this._prevMonth();
			} else if (img.id.indexOf("nm") != -1) {
				this._nextMonth();
			} else {
				this._nextYear();
			}
		} else if (target.id.charAt(0) == 't') {
			// TODO POPUP MENU
			target.className = DwtCalendar._TITLE_HOVERED_CLASS;
			this.setDate(new Date(), this._skipNotifyOnPage);
			// If our parent is a menu then we need to have it close
			if (this.parent instanceof DwtMenu) {
				DwtMenu.closeActiveMenu();
			}
		}
	} else if (ev.button == DwtMouseEvent.RIGHT && target.id.charAt(0) == 'c') {
		this._notifyListeners(DwtEvent.ACTION, 0, new Date(target._year, target._month, target._day), ev);
	}
};

DwtCalendar.prototype._doubleClickListener =
function(ev) {
	var target = ev.target;
	if (this._selectionEvent) {
		this._selectionEvent.type = DwtCalendar.DATE_DBL_CLICKED;
	}
	if (target.id.charAt(0) == 'c') {
		// If our parent is a menu then we need to have it close
		if (this.parent instanceof DwtMenu) {
			DwtMenu.closeActiveMenu();
		}
		this.setDate(new Date(target._year, target._month, target._day), false, false, true)
	}
};

DwtCalendar.prototype._prevMonth = 
function(ev) {
	var d = new Date(this._date.getTime());
	this.setDate(AjxDateUtil.roll(d, AjxDateUtil.MONTH, -1), this._skipNotifyOnPage);
};

DwtCalendar.prototype._nextMonth = 
function(ev) {
	var d = new Date(this._date.getTime());
	this.setDate(AjxDateUtil.roll(d, AjxDateUtil.MONTH, 1), this._skipNotifyOnPage);
};

DwtCalendar.prototype._prevYear = 
function(ev) {
	var d = new Date(this._date.getTime());
	this.setDate(AjxDateUtil.roll(d, AjxDateUtil.YEAR, -1), this._skipNotifyOnPage);
};

DwtCalendar.prototype._nextYear = 
function(ev) {
	var d = new Date(this._date.getTime());
	this.setDate(AjxDateUtil.roll(d, AjxDateUtil.YEAR, 1), this._skipNotifyOnPage);
};

/**
 * Gets the date formatter.
 * 
 * @return	{AjxDateFormat}		the date formatter
 * 
 * @private
 */
DwtCalendar.getDateFormatter =
function() {
	if (!DwtCalendar._dateFormatter) {
		DwtCalendar._dateFormatter = new AjxDateFormat(AjxMsg.formatCalDate);
	}
	return DwtCalendar._dateFormatter;
};

/**
 * Gets the date long formatter.
 * 
 * @return	{AjxDateFormat}		the date formatter
 * 
 * @private
 */
DwtCalendar.getDateLongFormatter =
function() {
	if (!DwtCalendar._dateLongFormatter) {
		DwtCalendar._dateLongFormatter = new AjxDateFormat(AjxMsg.formatCalDateLong);
	}
	return DwtCalendar._dateLongFormatter;
};

/**
 * Gets the date full formatter.
 * 
 * @return	{AjxDateFormat}		the date formatter
 * 
 * @private
 */
DwtCalendar.getDateFullFormatter =
function() {
	if (!DwtCalendar._dateFullFormatter) {
		DwtCalendar._dateFullFormatter = new AjxDateFormat(AjxMsg.formatCalDateFull);
	}
	return DwtCalendar._dateFullFormatter;
};

/**
 * Gets the hour formatter.
 * 
 * @return	{AjxDateFormat}		the date formatter
 * 
 * @private
 */
DwtCalendar.getHourFormatter =
function() {
	if (!DwtCalendar._hourFormatter) {
		DwtCalendar._hourFormatter = new AjxMessageFormat(AjxMsg.formatCalHour);
	}
	return DwtCalendar._hourFormatter;
};

/**
 * Gets the day formatter.
 * 
 * @return	{AjxDateFormat}		the date formatter
 * 
 * @private
 */
DwtCalendar.getDayFormatter =
function() {
	if (!DwtCalendar._dayFormatter) {
		DwtCalendar._dayFormatter = new AjxDateFormat(AjxMsg.formatCalDay);
	}
	return DwtCalendar._dayFormatter;
};

/**
 * Gets the month formatter.
 * 
 * @return	{AjxDateFormat}		the date formatter
 * 
 * @private
 */
DwtCalendar.getMonthFormatter =
function() {
	if (!DwtCalendar._monthFormatter) {
		DwtCalendar._monthFormatter = new AjxDateFormat(AjxMsg.formatCalMonth);
	}
	return DwtCalendar._monthFormatter;
};

/**
 * Gets the short month formatter.
 * 
 * @return	{AjxDateFormat}		the date formatter
 * 
 * @private
 */
DwtCalendar.getShortMonthFormatter =
function() {
	if (!DwtCalendar._shortMonthFormatter) {
		DwtCalendar._shortMonthFormatter = new AjxDateFormat(AjxMsg.formatShortCalMonth);
	}
	return DwtCalendar._shortMonthFormatter;
};

DwtCalendar.prototype._dragEnter =
function(ev) {
};

DwtCalendar.prototype._dragHover =
function(ev) {
};

DwtCalendar.prototype._dragOver =
function(ev) {
	var target = ev.target;
	if (target.id.charAt(0) == 'c') {
		this._setClassName(target, DwtCalendar._HOVERED);
		this._lastDndCell = target;
	} else {
		this._lastDndCell = null;
	}
};

DwtCalendar.prototype._dragLeave =
function(ev) {
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtPropertyPage")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * Creates a property page.
 * @class
 * @constructor
 * This class represents a page (view) for working with properties. It provides ability to
 * keep track of any changes in the form fields on the page.
 * 
 * @author Greg Solovyev
 * 
 * @param	{hash}	params		a hash of parameters
 * 
 * @extends		DwtComposite
 */
DwtPropertyPage = function(params) {
	if (arguments.length == 0) return;
	params = Dwt.getParams(arguments, DwtPropertyPage.PARAMS);
	params.className = params.className || "DwtPropertyPage";
	DwtComposite.call(this, params);
	this._fieldIds = new Object();
	this._fildDivIds = new Object();
	this._isDirty = false;
	this._tabGroup = new DwtTabGroup(this.toString());
};

DwtPropertyPage.prototype = new DwtComposite;
DwtPropertyPage.prototype.constructor = DwtPropertyPage;

DwtPropertyPage.prototype.toString = function() {
	return "DwtPropertyPage";
};

DwtPropertyPage.PARAMS = DwtComposite.PARAMS;

/**
 * Sets the value of the dirty flag.
 * 
 * @param {boolean}	isD	
 * 
 * @private
 */
DwtPropertyPage.prototype.setDirty = 
function (isD) {
	this._isDirty = isD;
}

/**
 * @return boolean _isDirty flag
 * isDirty indicates whether the user changed any data on the page after the page was initialized
 * 
 * @private
 */
DwtPropertyPage.prototype.isDirty = 
function () {
	return this._isDirty;
}

DwtPropertyPage.prototype.getTabGroupMember =
function (){
	return this._tabGroup;
};

/**
 * @param field either key to the field ID in the _fieldIds or reference to the field
 * 
 * @private
 */
DwtPropertyPage.prototype._installOnKeyUpHandler = 
function(field, func) {
	if (!field)	return;
	
	var e = null;
	e = document.getElementById(this._fieldIds[field]);
	if (e) {
		Dwt.setHandler(e, DwtEvent.ONKEYUP, func ? func : this._onKeyUp);
		e._view = this;
		e._field = field;
	}
}

/**
 * @param field either key to the field ID in the _fieldIds or reference to the field
 * 
 * @private
 */
DwtPropertyPage.prototype._installOnClickHandler = 
function(field, func) {
	if (!field) return;
	
	var e = document.getElementById(this._fieldIds[field]);
	if (e) {
		Dwt.setHandler(e, DwtEvent.ONCLICK, func ? func : this._onClick);
		e._view = this;
		e._field = field;
	}
}

DwtPropertyPage.prototype._onClick =
function(ev) {
	this._view.setDirty(true);
	return true;
}

DwtPropertyPage.prototype._onKeyUp =
function(ev) {
	this._view.setDirty(true);
	return true;
}

/**
 * @param field either key to the field ID in the _fieldIds or reference to the field
 * 
 * @private
 */
DwtPropertyPage.prototype._installOnChangeHandler = 
function(field, func) {
	if (!field) return;
	
	var e = null;
	e = document.getElementById(this._fieldIds[field]);
	if(e) {
		Dwt.setHandler(e, DwtEvent.ONCHANGE, func ? func : this._onChange);
		e._view = this;
		e._field = field;
	}
}

DwtPropertyPage._onChange =
function(ev) {
	this._view.setDirty(true);
	return true;
}

DwtPropertyPage.prototype._onChange2 =
function(ev) {
	this.setDirty(true);
	return true;
}

DwtPropertyPage.prototype._addDwtSelectEntryRow =
function(field, title, html, idx, titleSize) {
	var tSize = "30ex";
	if(titleSize)
		tSize = titleSize;
		
	html[idx++] = "<tr valign='center'>";
	idx = this._addDwtSelectEntryCell(field, title, html, idx, tSize);
	html[idx++] = "</tr>";
	return idx;
}

DwtPropertyPage.prototype._addDwtSelectEntryCell =
function(field, title, html, idx, titleWidth) {
	var id = Dwt.getNextId();
	this._fieldIds[field] = id;
	if(title) {
		html[idx++] = "<td align='left' style='width:" + titleWidth + "'>";
		html[idx++] = AjxStringUtil.htmlEncode(title) + ":";
		html[idx++] = "</td>";
	}
	html[idx++] = "<td align='left'>";
	html[idx++] = "<div id='" + id + "'></div></td>";
	return idx;
}

DwtPropertyPage.prototype._addBoolEntryRow =
function(field, title, html, idx, titleWidth) {
	html[idx++] = "<tr valign='center'>";
	idx = this._addBoolEntryCell(field, title, html, idx, titleWidth);
	html[idx++] = "</tr>";
	return idx;
}

DwtPropertyPage.prototype._addBoolEntryCell =
function(field, title, html, idx, titleWidth) {
	var id = Dwt.getNextId();
	this._fieldIds[field] = id;
	var tWidth = "20ex";
	if(titleWidth)
		tWidth = titleWidth;	
		
	if(title) {
		html[idx++] = "<td style='width:" + tWidth + ";' align='left'>";
		html[idx++] = AjxStringUtil.htmlEncode(title) + ":";
		html[idx++] = "</td>";
	}
	html[idx++] = "<td align='left'>";
	html[idx++] = "<input type='checkbox' id='"+id+"'>";
	html[idx++] = "</td>";
	return idx;
}

DwtPropertyPage.prototype._addTextAreaEntryRow =
function(field, title, html, idx, noWrap) {
	var myWrap = "on";
	if(noWrap)
		myWrap = "off";
		
	var id = Dwt.getNextId();
	this._fieldIds[field] = id;
	html[idx++] = "<tr valign='center'>";
	html[idx++] = "<td align='left' style='width:60ex;'>";
	html[idx++] = AjxStringUtil.htmlEncode(title) + ":";
	html[idx++] = "</td></tr>";
	html[idx++] = "<tr valign='center'><td align='left' style='width:60ex;'><textarea wrap='" + myWrap + "' rows='8' cols ='60' id='";	
	html[idx++] = id;
	html[idx++] = "'/></textarea></td></tr>";
	return idx;
}

/**
 * _addEntryRow
 *	@param field - key of the field id in this._fieldIds
 *	@param title - title string. If title is specified a separate cell will be appended before the form field
 * title will be rendered within that cell
 *	@param html - reference to html array
 *	@param idx - current counter inside the html array
 *	@param type - type of the form field to create (<input type= )
 *	@param fldsize - size of the input field (this value will be assigned to the size property
 *	@param tailTitle - string that will be placed behind the form field
 *	@param titleWidth - width of the title cell
 * 
 * @private
 */
DwtPropertyPage.prototype._addEntryRow =
function(field, title, html, idx, type, fldsize, tailTitle, titleWidth, withAsteric) {
	html[idx++] = "<tr valign='center'>";
	idx = this._addEntryCell(field, title, html, idx, type, fldsize, tailTitle, titleWidth, withAsteric);
	html[idx++] = "</tr>";
	return idx;
}

/**
 * _addEntryCell
 *	@param field - key of the field id in this._fieldIds
 *	@param title - title string. If title is specified a separate cell will be appended before the form field
 * title will be rendered within that cell
 *	@param html - reference to html array
 *	@param idx - current counter inside the html array
 *	@param type - type of the form field to create (<input type= )
 *	@param fldsize - size of the input field (this value will be assigned to the size property
 *	@param tailTitle - string that will be placed behind the form field
 *	@param titleWidth - width of the title cell
 * 
 * @private
 */
DwtPropertyPage.prototype._addEntryCell =
function(field, title, html, idx, type, fldsize, tailTitle, titleWidth, withAsteric) {
	if (type == null) type = "text";
	if(fldsize == null) fldsize = 35;
	var tWidth = "20ex";
	if(titleWidth) 
		tWidth = titleWidth;
		
	var id = Dwt.getNextId();
	this._fieldIds[field] = id;
	if(title) {
		html[idx++] = "<td align='left' style='width:" + tWidth + ";'>";
		html[idx++] = AjxStringUtil.htmlEncode(title) + ":";
		html[idx++] = "</td>";
	}
	html[idx++] = "<td ";
	if(withAsteric) {
		html[idx++] = "class='redAsteric' ";		
	}
	html[idx++] = "	align='left'><input autocomplete='off' size='"+fldsize+"' type='"+type+"' id='";	
	html[idx++] = id;
	html[idx++] = "'";
	if(withAsteric) {
		html[idx++] = "/>*";		
	} else {
		html[idx++] = "/>&nbsp;";
	}
	if(tailTitle != null) {
		html[idx++]	= tailTitle;
	}
	html[idx++] = "</td>";
	return idx;
}

/**
 * Use this method to render HTML form
 * call all other rendering methods from this method.
 * 
 * @private
 */
DwtPropertyPage.prototype._createHTML = 
function () {
 //abstract method
}
}
if (AjxPackage.define("ajax.dwt.widgets.DwtTabView")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * Creates a tab view.
 * @constructor
 * @class
 * This class represents a tabbed view. {@link DwtTabView} manages the z-index of the contained tabs. 
 * 
 * @param {hash}			params			a hash of parameters
 * @param {DwtComposite}	parent			the parent widget
 * @param {string}			className		the CSS class
 * @param {constant}		posStyle		the positioning style (see {@link DwtControl})
 * @param {string}			id				an explicit ID to use for the control's HTML element
 * 
 * @author Greg Solovyev
 * 
 * @extends DwtComposite
 */
DwtTabView = function(params) {
	if (arguments.length == 0) return;
	params = Dwt.getParams(arguments, DwtListView.PARAMS);
	params.className = params.className || "ZTabView";
	params.posStyle = params.posStyle || DwtControl.ABSOLUTE_STYLE;
	DwtComposite.call(this, params);

	this._stateChangeEv = new DwtEvent(true);
	this._stateChangeEv.item = this;

	this._tabs = [];
	this._tabIx = 1;
	this._createHtml();

	var tabGroupId = [this.toString(), this._htmlElId].join(" ");
	this._tabGroup = new DwtTabGroup(tabGroupId);
	this._tabGroup.addMember(this._tabBar);
};

DwtTabView.PARAMS = ["parent", "className", "posStyle"];

DwtTabView.prototype = new DwtComposite;
DwtTabView.prototype.constructor = DwtTabView;

DwtTabView.prototype.isDwtTabView = true;
DwtTabView.prototype.toString = function() { return "DwtTabView"; };

DwtTabView.prototype.role = 'tablist';

// Constants

// Z-index consts for tabbed view contents are based on Dwt z-index consts
DwtTabView.Z_ACTIVE_TAB	= Dwt.Z_VIEW+10;
DwtTabView.Z_HIDDEN_TAB	= Dwt.Z_HIDDEN;
DwtTabView.Z_TAB_PANEL	= Dwt.Z_VIEW+20;
DwtTabView.Z_CURTAIN	= Dwt.Z_CURTAIN;

DwtTabView.prototype.TEMPLATE = "dwt.Widgets#ZTabView";


// Public methods


/**
 * Adds a state change listener.
 * 
 * @param {AjxListener}		listener		the listener
 */
DwtTabView.prototype.addStateChangeListener =
function(listener) {
	this._eventMgr.addListener(DwtEvent.STATE_CHANGE, listener);
};

/**
 * Removes a state change listener.
 * 
 * @param {AjxListener}		listener		the listener
 */
DwtTabView.prototype.removeStateChangeListener =
function(listener) {
	this._eventMgr.removeListener(DwtEvent.STATE_CHANGE, listener);
};

DwtTabView.prototype.getTabGroupMember = function() {
	return this._tabGroup;
};

/**
 * Adds a tab.
 * 
 * @param {string}						title					the text for the tab button
 * @param {DwtTabViewPage|AjxCallback}	tabViewOrCallback		an instance of the tab view page or callback that returns an instance of {@link DwtTabViewPage}
 *
 * @return {string}		key for the added tab	This key can be used to retrieve the tab using {@link #getTab}
 * 
 * @see		#getTab
 */
DwtTabView.prototype.addTab =
function (title, tabViewOrCallback, buttonId, index) {
	var tabKey = this._tabIx++;	

	// create tab entry
	this._tabs[tabKey] = {
		title: title,
		button: this._tabBar.addButton(tabKey, title, buttonId, index)
	};

	// add the page
	this.setTabView(tabKey, tabViewOrCallback);

	// show the first tab
	if (tabKey==1) {
		var tabView = this.getTabView(tabKey);
		if(tabView) {
			tabViewOrCallback.showMe();
		}
		this._currentTabKey = tabKey;		
		this.switchToTab(tabKey);
	}
	// hide all the other tabs
	else if (tabViewOrCallback && !(tabViewOrCallback instanceof AjxCallback)) {
		tabViewOrCallback.hideMe();
		Dwt.setVisible(tabViewOrCallback.getHtmlElement(), false);
	}

	this._tabBar.addSelectionListener(tabKey, new AjxListener(this, DwtTabView.prototype._tabButtonListener));

	return tabKey;
};

DwtTabView.prototype.enable =
function(enable) {
	for (var i in this._tabs) {
		var button = this._tabs[i].button;
		if (button) {
			button.setEnabled(enable);
		}
	}
};

/**
 * Gets the current tab.
 * 
 * @return {string}		the tab key
 */
DwtTabView.prototype.getCurrentTab =
function() {
	return this._currentTabKey;
};

/**
 * Gets the tab count.
 * 
 * @return {number}		the number of tabs
 */
DwtTabView.prototype.getNumTabs =
function() {
	return (this._tabs.length - 1);
};

/**
 * Gets the tab.
 * 
 * @param {string}		tabKey		the key for the tab
 *
 * @return {DwtTabViewPage}	the view tab
 * 
 * @see		#addTab
 */
DwtTabView.prototype.getTab =
function (tabKey) {
	return (this._tabs && this._tabs[tabKey])
		? this._tabs[tabKey]
		: null;
};

/**
 * Gets the tab bar.
 * 
 * @return {DwtTabBar}		the tab bar
 */
DwtTabView.prototype.getTabBar = function() {
	return this._tabBar;
};

/**
 * Gets the tab title.
 * 
 * @param {string}		tabKey		the tab key
 *
 * @return {string}		the title
 */
DwtTabView.prototype.getTabTitle =
function(tabKey) {
	return (this._tabs && this._tabs[tabKey])
		? this._tabs[tabKey]["title"]
		: null;
};

/**
 * Gets the tab button.
 * 
 * @param {string}		tabKey		the tab key
 *
 * @return {DwtTabButton}		the tab button
 */
DwtTabView.prototype.getTabButton =
function(tabKey) {
	return (this._tabs && this._tabs[tabKey])
		? this._tabs[tabKey]["button"]
		: null;
};

/**
 * Sets the tab view.
 * 
 * @param {string}						tabKey		the tab key
 * @param {DwtTabViewPage|AjxCallback}	tabView		 an instance of the tab view page or callback that returns an instance of {@link DwtTabViewPage}
 */
DwtTabView.prototype.setTabView =
function(tabKey, tabView) {
	var tab = this.getTab(tabKey);
	tab.view = tabView;
	if (tabView && !(tabView instanceof AjxCallback)) {
		this._pageEl.appendChild(tabView.getHtmlElement());
		tabView._tabKey = tabKey;
		if (tabKey == this._currentTabKey) {
			var tabGroup = tabView.getTabGroupMember();
			this._tabGroup.replaceMember(tab.tabGroup, tabGroup);
			tab.tabGroup = tabGroup;
		}
	}
};

/**
 * Gets the tab view.
 * 
 * @param {string}		tabKey		the tab key
 *
 * @return {DwtTabViewPage}		the tab view page
 */
DwtTabView.prototype.getTabView =
function(tabKey) {
	var tab = this.getTab(tabKey);
	var tabView = tab && tab.view;
	if (tabView instanceof AjxCallback) {
		var callback = tabView;
		tabView = callback.run(tabKey);
		this.setTabView(tabKey, tabView);
		var size = this._getTabSize();
		tabView.setSize(size.x, size.y);
		tabView.setAttribute('aria-labelledby', tab.button.getHTMLElId());
	}
	return tabView;
};

/**
 * Switches to the tab view.
 * 
 * @param {string}		tabKey		the tab key
 */
DwtTabView.prototype.switchToTab = 
function(tabKey) {
	var ntab = this.getTab(tabKey);
	if(ntab) {
		// remove old tab from tab-group
		var otab = this.getTab(this._currentTabKey);
		if (otab) {
			this._tabGroup.removeMember(otab.tabGroup);
		}
		// switch tab
		this._showTab(tabKey);
		this._tabBar.openTab(tabKey);
		// add new tab to tab-group
		if (!ntab.tabGroup && ntab.view) {
			ntab.tabGroup = ntab.view.getTabGroupMember();
		}
		this._tabGroup.addMember(ntab.tabGroup);
		// notify change
		if (this._eventMgr.isListenerRegistered(DwtEvent.STATE_CHANGE)) {
			this._eventMgr.notifyListeners(DwtEvent.STATE_CHANGE, this._stateChangeEv);
		}
	}
};

DwtTabView.prototype.setBounds =
function(x, y, width, height) {
	DwtComposite.prototype.setBounds.call(this, x, y, width, height);
	this._resetTabSizes(width, height);
};

DwtTabView.prototype.getActiveView =
function() {
	return this._tabs[this._currentTabKey].view;
};

DwtTabView.prototype.getKeyMapName =
function() {
	return DwtKeyMap.MAP_TAB_VIEW;
};

DwtTabView.prototype.resetKeyBindings =
function() {
	var kbm = this.shell.getKeyboardMgr();
	if (kbm.isEnabled()) {
		var kmm = kbm.__keyMapMgr;
		if (!kmm) { return; }
		var num = this.getNumTabs();
		var seqs = kmm.getKeySequences(DwtKeyMap.MAP_TAB_VIEW, "GoToTab");
		for (var k = 0; k < seqs.length; k++) {
			var ks = seqs[k];
			for (var i = 1; i <= num; i++) {
				var keycode = 48 + i;
				var newKs = ks.replace(/NNN/, keycode);
				kmm.setMapping(DwtKeyMap.MAP_TAB_VIEW, newKs, "GoToTab" + i);
			}
		}
		kmm.reloadMap(DwtKeyMap.MAP_TAB_VIEW);
	}
};

DwtTabView.prototype.handleKeyAction =
function(actionCode) {
	DBG.println(AjxDebug.DBG3, "DwtTabView.handleKeyAction");

	switch (actionCode) {

		case DwtKeyMap.NEXT_TAB:
			var curTab = this.getCurrentTab();
			if (curTab < this.getNumTabs()) {
				this.switchToTab(curTab + 1);
			}
			break;
			
		case DwtKeyMap.PREV_TAB:
			var curTab = this.getCurrentTab();
			if (curTab > 1) {
				this.switchToTab(curTab - 1);
			}
			break;
		
		default:
			// Handle action code like "GoToTab3"
			var m = actionCode.match(DwtKeyMap.GOTO_TAB_RE);
			if (m && m.length) {
				var idx = m[1];
				if ((idx <= this.getNumTabs()) && (idx != this.getCurrentTab())) {
					this.switchToTab(idx);
				}
			} else {
				return false;
			}
	}
	return true;
};


// Protected methods

DwtTabView.prototype._resetTabSizes =
function (width, height) {
	if (this._tabs && this._tabs.length) {
		for (var curTabKey in this._tabs) {
			var tabView = this._tabs[curTabKey].view;
			if (tabView && !(tabView instanceof AjxCallback)) {
				var contentHeight;
				contentHeight = contentHeight || height - Dwt.getSize(this._tabBarEl).y;
				tabView.resetSize(width, contentHeight);
			}	
		}
	}		
};

DwtTabView.prototype._getTabSize =
function() {
	var size = this.getSize();
	var width = size.x || this.getHtmlElement().clientWidth;
	var height = size.y || this.getHtmlElement().clientHeight;
	var tabBarSize = this._tabBar.getSize();
	var tabBarHeight = tabBarSize.y || this._tabBar.getHtmlElement().clientHeight;

	return new DwtPoint(width, (height - tabBarHeight));
};

DwtTabView.prototype._createHtml =
function(templateId) {
	this._createHtmlFromTemplate(templateId || this.TEMPLATE, {id:this._htmlElId});
};

DwtTabView.prototype._createHtmlFromTemplate =
function(templateId, data) {
	DwtComposite.prototype._createHtmlFromTemplate.call(this, templateId, data);

	this._tabBarEl = document.getElementById(data.id+"_tabbar");
	this._tabBar = new DwtTabBar(this);
	this._tabBar.reparentHtmlElement(this._tabBarEl);
	this._pageEl = document.getElementById(data.id+"_page");
};

DwtTabView.prototype._showTab = 
function(tabKey) {
	if (this._tabs && this._tabs[tabKey]) {
		this._currentTabKey = tabKey;
		this._hideAllTabs();						// hide all the tabs
		var tabView = this.getTabView(tabKey);		// make this tab visible
		if (tabView) {
			tabView.setVisible(true);
			tabView.showMe();
		}
	}
};

DwtTabView.prototype._hideAllTabs = 
function() {
	if (this._tabs && this._tabs.length) {
		for (var curTabKey in this._tabs) {
			var tabView = this._tabs[curTabKey].view;
			if (tabView && !(tabView instanceof AjxCallback)) {
				tabView.hideMe();
				//this._tabs[curTabKey]["view"].setZIndex(DwtTabView.Z_HIDDEN_TAB);
				Dwt.setVisible(tabView.getHtmlElement(), false);
			}	
		}
	}
};

DwtTabView.prototype._tabButtonListener = 
function (ev) {
	this.switchToTab(ev.item.getData("tabKey"));
};


//
// Class
//

/**
 * Creates a tab view page.
 * @constructor
 * @class
 * DwtTabViewPage abstract class for a page in a tabbed view.
 * Tab pages are responsible for creating their own HTML and populating/collecting
 * data to/from any form fields that they display.
 * 
 * @param {DwtComposite}	parent			the parent widget
 * @param {string}			className		the CSS class
 * @param {constant}		posStyle		the positioning style (see {@link DwtControl})
 * 
 * @extends DwtPropertyPage
 */
DwtTabViewPage = function(parent, className, posStyle, id) {
	if (arguments.length == 0) return;
	var params = Dwt.getParams(arguments, DwtTabViewPage.PARAMS);
	params.className = params.className || "ZTabPage";
	params.posStyle = params.posStyle || DwtControl.ABSOLUTE_STYLE;
	params.id = id || null;
	this._rendered = true; // by default UI creation is not lazy

	DwtPropertyPage.call(this, params);

	this._createHtml();
	this.getHtmlElement().style.overflowY = "auto";
	this.getHtmlElement().style.overflowX = "visible";
	if (params.contentTemplate) {
		this.getContentHtmlElement().innerHTML = AjxTemplate.expand(params.contentTemplate, this._htmlElId);
	}
};

DwtTabViewPage.prototype = new DwtPropertyPage;
DwtTabViewPage.prototype.constructor = DwtTabViewPage;

DwtTabViewPage.prototype.isDwtTabViewPage = true;
DwtTabViewPage.prototype.toString = function() { return "DwtTabViewPage"; };

DwtTabViewPage.prototype.role = 'tabpanel';


DwtTabViewPage.prototype.TEMPLATE = "dwt.Widgets#ZTabPage";

DwtTabViewPage.PARAMS = DwtPropertyPage.PARAMS.concat("contentTemplate");

// Public methods

/**
 * Gets the content HTML element.
 * 
 * @return {Element}	the element
 */
DwtTabViewPage.prototype.getContentHtmlElement =
function() {
	return this._contentEl || this.getHtmlElement();
};

/**
 * Shows the tab view page.
 * 
 */
DwtTabViewPage.prototype.showMe =
function() {
	this.setZIndex(DwtTabView.Z_ACTIVE_TAB);
	this.setAttribute('aria-selected', true);
	if (this.parent.getHtmlElement().offsetHeight > 80) { 						// if parent visible, use offsetHeight
		this._contentEl.style.height=this.parent.getHtmlElement().offsetHeight-80;
	} else {
		var parentHeight = parseInt(this.parent.getHtmlElement().style.height);	// if parent not visible, resize page to fit parent
		var units = AjxStringUtil.getUnitsFromSizeString(this.parent.getHtmlElement().style.height);
		if (parentHeight > 80) {
			this._contentEl.style.height = (Number(parentHeight-80).toString() + units);
		}
	}

	this._contentEl.style.width = this.parent.getHtmlElement().style.width;	// resize page to fit parent
};

/**
 * Hides the tab view page.
 */
DwtTabViewPage.prototype.hideMe = 
function() {
	this.setZIndex(DwtTabView.Z_HIDDEN_TAB);
	this.setAttribute('aria-selected', false);
};

/**
 * Resets the size.
 * 
 * @param {number|string}		newWidth		the width of the control (for example: 100, "100px", "75%", {@link Dwt.DEFAULT})
 * @param {number|string}		newHeight		the height of the control (for example: 100, "100px", "75%", {@link Dwt.DEFAULT})
 */
DwtTabViewPage.prototype.resetSize =
function(newWidth, newHeight) {
	this.setSize(newWidth, newHeight);
};


// Protected methods

DwtTabViewPage.prototype._createHtml =
function(templateId) {
	this._createHtmlFromTemplate(templateId || this.TEMPLATE, {id:this._htmlElId});
};

DwtTabViewPage.prototype._createHtmlFromTemplate =
function(templateId, data) {
	DwtPropertyPage.prototype._createHtmlFromTemplate.call(this, templateId, data);
	this._contentEl = document.getElementById(data.id+"_content") || this.getHtmlElement();
};


//
// Class
//

/**
 * Creates a tab bar.
 * @constructor
 * @class
 * This class represents the tab bar, which is effectively a tool bar.
 * 
 * @param {DwtComposite}		parent			the parent widget
 * @param {string}				tabCssClass		the tab CSS class
 * @param {string}				btnCssClass		the button CSS class
 * 
 * @extends DwtToolBar
 */
DwtTabBar = function(parent, tabCssClass, btnCssClass) {
	if (arguments.length == 0) return;

	this._buttons = [];
	this._btnStyle = btnCssClass || "ZTab"; 									// REVISIT: not used
	this._btnImage = null;
	this._currentTabKey = 1;
	var myClass = tabCssClass || "ZTabBar";

	DwtToolBar.call(this, {parent:parent, className:myClass, posStyle:DwtControl.STATIC_STYLE});

	//Temp solution for bug 55391 
	//It is caused by float attribute in the td. The best solution is just as the main tab. No td
	//wrap the div. And this modification shouldn't affect the subclasses DwtTabBarFloat, otherwise, the _CASE_ 
	//xform item will be affect.
	//To do: modify it as the same as main tab
	if(AjxEnv.isFirefox){
		if(this._prefixEl && this.constructor == DwtTabBar)
			this._prefixEl.style.cssFloat = "none";
	}
};

DwtTabBar.prototype = new DwtToolBar;
DwtTabBar.prototype.constructor = DwtTabBar;


// Constants

DwtTabBar.prototype.TEMPLATE = "dwt.Widgets#ZTabBar";


// Public methods

DwtTabBar.prototype.toString =
function() {
	return "DwtTabBar";
};

/**
 * Gets the current tab.
 * 
 * @return {string}		the tab key
 */
DwtTabBar.prototype.getCurrentTab =
function() {
	return this._currentTabKey;
};

/**
 * Adds a state change listener.
 * 
 * @param {AjxListener}		listener		the listener
 */
DwtTabBar.prototype.addStateChangeListener =
function(listener) {
	this._eventMgr.addListener(DwtEvent.STATE_CHANGE, listener);
};

/**
 * Removes a state change listener.
 * 
 * @param {AjxListener}		listener		the listener
 */
DwtTabBar.prototype.removeStateChangeListener = 
function(listener) {
	this._eventMgr.removeListener(DwtEvent.STATE_CHANGE, listener);
};

/**
 * Adds a selection listener.
 * 
 * @param {string}			tabKey		the id used to create tab button in {@link DwtTabBar.addButton}
 * @param {AjxListener}		listener	the listener
 */
DwtTabBar.prototype.addSelectionListener =
function(tabKey, listener) {
	this._buttons[tabKey].addSelectionListener(listener);
};

/**
 * Removes a selection listener.
 * 
 * @param {string}			tabKey		the id used to create tab button in {@link DwtTabBar.addButton}
 * @param {AjxListener}		listener	the listener
 */
DwtTabBar.prototype.removeSelectionListener =
function(tabKey, listener) {
	this._buttons[tabKey].removeSelectionListener(listener);
};

/**
 * Adds a button.
 * 
 * @param {string}		tabKey		the the tab key
 * @param {string}		tabTitle	the tab title
 * @param {string}		id			the id
 * @param {number}		index		the index
 *
 * @return {DwtTabButton}		the newly added button
 */
DwtTabBar.prototype.addButton =
function(tabKey, tabTitle, id, index) {
	var b = this._buttons[tabKey] = new DwtTabButton(this, id, index);
	
	this._buttons[tabKey].addSelectionListener(new AjxListener(this, DwtTabBar._setActiveTab));

	if (this._btnImage != null) {
		b.setImage(this._btnImage);
	}

	if (tabTitle != null) {
		b.setText(tabTitle);
	}

	b.setEnabled(true);
	b.setData("tabKey", tabKey);

	if (parseInt(tabKey) == 1) {
		this.openTab(tabKey, true);
	}

	// make sure that new button is selected properly
	var sindex = this.__getButtonIndex(this._currentTabKey);
	if (sindex != -1) {
		var nindex = this.__getButtonIndex(tabKey);
		if (nindex == sindex + 1) {
			Dwt.addClass(b.getHtmlElement(), DwtTabBar.SELECTED_NEXT);
		}
	}

	return b;
};

/**
 * Gets the button.
 * 
 * @param {string}		tabKey		the id used to create tab button in {@link DwtTabBar.addButton}
 *
 * @return {DwtTabButton}		the button
 */
DwtTabBar.prototype.getButton = 
function (tabKey) {
	return (this._buttons[tabKey])
		? this._buttons[tabKey]
		: null;
};

/**
 * Opens the tab.
 *
 * @param {string}		tabKey			the id used to create tab button in {@link DwtTabBar.addButton}
 * @param {boolean}		skipNotify		if <code>true</code>, do not notify listeners
 */
DwtTabBar.prototype.openTab = 
function(tabK, skipNotify) {
	this._currentTabKey = tabK;
	var cnt = this._buttons.length;

	for (var ix = 0; ix < cnt; ix ++) {
		if (ix==tabK) { continue; }

		var button = this._buttons[ix];
		if (button) {
			this.__markPrevNext(ix, false);
			button.setClosed();
		}
	}

	var button = this._buttons[tabK];
	if (button) {
		button.setOpen();
		this.__markPrevNext(tabK, true);
	}

	if (!skipNotify && this._eventMgr.isListenerRegistered(DwtEvent.STATE_CHANGE)) {
		this._eventMgr.notifyListeners(DwtEvent.STATE_CHANGE, this._stateChangeEv);
	}
};

/**
 * Greg Solovyev 1/4/2005 
 * changed ev.target.offsetParent.offsetParent to
 * lookup for the table up the elements stack, because the mouse down event may come from the img elements 
 * as well as from the td elements.
 * 
 * @private
 */
DwtTabBar._setActiveTab =
function(ev) {
	var tabK;
	if (ev && ev.item) {
		tabK=ev.item.getData("tabKey");
	} else if (ev && ev.target) {
		var elem = ev.target;
		while (elem.tagName != "TABLE" && elem.offsetParent )
			elem = elem.offsetParent;

		tabK = elem.getAttribute("tabKey");
		if (tabK == null)
			return false;
	} else {
		return false;
	}
	this.openTab(tabK);
};


//
// Class
//

/**
 * Creates a tab button (i.e. a tab in a tab view).
 * @constructor
 * @class
 * This class represents the tab in a tab view.
 * 
 * @param {DwtComposite}		parent			the parent widget
 * @param {string}				id				the id
 * @param {number}				index			the index
 * @param {string}				className		the style class name
 * 
 * @extends DwtButton
 */
DwtTabButton = function(parent, id, index, className) {
	if (arguments.length == 0) return;
	var tabStyle = className || "ZTab";
	DwtButton.call(this, {parent:parent, className:tabStyle, id:id, index:index});
};

DwtTabButton.prototype = new DwtButton;
DwtTabButton.prototype.constructor = DwtTabButton;

DwtTabButton.prototype.TEMPLATE = "dwt.Widgets#ZTab";

DwtTabButton.prototype.isDwtTabButton = true;
DwtTabButton.prototype.toString = function() { return "DwtTabButton"; };

DwtTabButton.prototype.role = 'tab';

// Public methods


/**
 * Changes the visual appearance to active tab.
 */
DwtTabButton.prototype.setOpen = 
function() {
	this._isSelected = true;
	this.setDisplayState(DwtControl.SELECTED);
};

/**
 * Changes the visual appearance to inactive tab.
 */
DwtTabButton.prototype.setClosed =
function() {
	this._isSelected = false;
	this.setDisplayState(DwtControl.NORMAL);
};

DwtTabButton.prototype.setDisplayState = function(state) {
	if (this._isSelected && state != DwtControl.SELECTED) {
		state = [ DwtControl.SELECTED, state ].join(" ");
	}
	DwtButton.prototype.setDisplayState.call(this, state);
};


/**
 * @class
 * @constructor
 * 
 * @param {DwtComposite}		parent			the parent widget
 * @param {string}				tabCssClass		the tab CSS class
 * @param {string}				btnCssClass		the button CSS class
 *
 * @extends DwtTabButton
 * 
 * @private
 */
DwtTabBarFloat = function(parent, tabCssClass, btnCssClass) {
	if (arguments.length == 0) return;
	DwtTabBar.call(this,parent,tabCssClass,btnCssClass)
};

DwtTabBarFloat.prototype = new DwtTabBar;
DwtTabBarFloat.prototype.constructor = DwtTabBarFloat;

DwtTabBarFloat.prototype.TEMPLATE = "dwt.Widgets#ZTabBarFloat";

/**
 * Adds a button.
 * 
 * @param {string}		tabKey			the the tab key
 * @param {string}		tabTitle		the tab title
 * @param {string}		id				the id
 * 
 * @return {DwtTabButton}		the newly added button
 */
DwtTabBarFloat.prototype.addButton =
function(tabKey, tabTitle, id) {
	var b = this._buttons[tabKey] = new DwtTabButtonFloat(this, id);
	
	this._buttons[tabKey].addSelectionListener(new AjxListener(this, DwtTabBar._setActiveTab));

	if (this._btnImage != null) {
		b.setImage(this._btnImage);
	}

	if (tabTitle != null) {
		b.setText(tabTitle);
	}

	b.setEnabled(true);
	b.setData("tabKey", tabKey);

	if (parseInt(tabKey) == 1) {
		this.openTab(tabKey, true);
	}

	// make sure that new button is selected properly
	var sindex = this.__getButtonIndex(this._currentTabKey);
	if (sindex != -1) {
		var nindex = this.__getButtonIndex(tabKey);
		if (nindex == sindex + 1) {
			Dwt.addClass(b.getHtmlElement(), DwtTabBar.SELECTED_NEXT);
		}
	}

	return b;
};

DwtTabButtonFloat = function(parent, id) {
	DwtTabButton.call(this, parent,id, undefined, "ZTab");
};

DwtTabButtonFloat.prototype = new DwtTabButton;
DwtTabButtonFloat.prototype.constructor = DwtTabButtonFloat;

DwtTabButtonFloat.prototype.TEMPLATE = "dwt.Widgets#ZTabFloat";
}
if (AjxPackage.define("ajax.dwt.widgets.DwtWizardDialog")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * Creates a new wizard dialog.
 * @constructor
 * @class
 * This class represents a reusable wizard dialog.
 * 
 * @param {DwtControl}	parent		the parent control
 * @param {string}	className		the CSS class name
 * @param {string}	title	the dialog title
 * @param {number}	w 		the content area width
 * @param {number}	h 		the content area height
 * 
 * @extends		DwtDialog
 * 
 * @private
 */
DwtWizardDialog = function(parent, className, title, w, h) {
	if (arguments.length == 0) { return; }
	className = className || "DwtDialog";
	
	var nextButton = new DwtDialog_ButtonDescriptor(DwtWizardDialog.NEXT_BUTTON, AjxMsg._next, DwtDialog.ALIGN_RIGHT, new AjxCallback(this, this.goNext));
	var prevButton = new DwtDialog_ButtonDescriptor(DwtWizardDialog.PREV_BUTTON, AjxMsg._prev, DwtDialog.ALIGN_RIGHT, new AjxCallback(this, this.goPrev));
	var finishButton = new DwtDialog_ButtonDescriptor(DwtWizardDialog.FINISH_BUTTON, AjxMsg._finish, DwtDialog.ALIGN_RIGHT, new AjxCallback(this, this.finishWizard));
	DwtDialog.call(this, {parent:parent, className:className, standardButtons:[DwtDialog.CANCEL_BUTTON],
						  extraButtons:[prevButton, nextButton, finishButton]});

	if (!w) {
		this._contentW = "80ex";
	} else {
		this._contentW = w;
	}
	
	if(!h) {
		this._contentH = "100ex";
	} else {
		this._contentH = h;
	}
	
	this._pages = new Array(); 
	this._pageIx = 1;
	this._currentPage = 1;
	this._progressDiv = document.createElement("div");
	this._progressDiv.style.position = DwtControl.STATIC_STYLE;
	this._pageDiv = document.createElement("div");
	this._pageDiv.className = "DwtWizardDialogPageDiv";
	this._pageDiv.style.width = this._contentW;
	this._pageDiv.style.height = this._contentH;
	this._progressBar = new DwtWizProgressBar(this);
	this._createContentHtml();
	this.setTitle(title);
}

DwtWizardDialog.prototype = new DwtDialog;
DwtWizardDialog.prototype.constructor = DwtWizardDialog;

//Z-index contants for the tabbed view contents are based on Dwt z-index constants
DwtWizardDialog.Z_ACTIVE_PAGE = Dwt.Z_VIEW+10;
DwtWizardDialog.Z_HIDDEN_PAGE = Dwt.Z_HIDDEN;
DwtWizardDialog.Z_TAB_PANEL = Dwt.Z_VIEW+20;
DwtWizardDialog.Z_CURTAIN = Dwt.Z_CURTAIN;

DwtWizardDialog.NEXT_BUTTON = 12;
DwtWizardDialog.PREV_BUTTON = 11;
DwtWizardDialog.FINISH_BUTTON = 13;

//public methods
DwtWizardDialog.prototype.toString = 
function () {
	return "DwtWizardDialog";
}

DwtWizardDialog.prototype.popdown = 
function () {
	DwtDialog.prototype.popdown.call(this);
	this._hideAllPages();
}

/*
 * Makes the dialog visible, and places it. Everything under the dialog will become veiled
 * if we are modal.
 *
 * @param loc	the desired location
 *//*
DwtWizardDialog.prototype.popup =
function(loc) {

	var thisZ = this._zIndex;
	if (this._mode == DwtDialog.MODAL) {
		// place veil under this dialog
		var dialogZ = this._shell._veilOverlay.dialogZ;
		var currentDialogZ = null;
		var veilZ;
		if (dialogZ.length)
			currentDialogZ = dialogZ[dialogZ.length - 1];
		if (currentDialogZ) {
			thisZ = currentDialogZ + 2;
			veilZ = currentDialogZ + 1;
		} else {
			thisZ = this._zIndex;
			veilZ = Dwt.Z_VEIL;
		}
		this._shell._veilOverlay.veilZ.push(veilZ);
		this._shell._veilOverlay.dialogZ.push(thisZ);
		Dwt.setZIndex(this._shell._veilOverlay, veilZ);
	}
	loc = this._loc = loc || this._loc; // use whichever has a value, local has precedence
	var sizeShell = this._shell.getSize();
	var sizeThis = this.getSize();
	var x, y;
	if (loc == null) {
		// if no location, go for the middle
		x = Math.round((sizeShell.x - sizeThis.x) / 2);
		y = Math.round((sizeShell.y - sizeThis.y) / 2);
	} else {
		x = loc.x;
		y = loc.y;
	}
	// try to stay within shell boundaries
	if ((x + sizeThis.x) > sizeShell.x)
		x = sizeShell.x - sizeThis.x;
	if ((y + sizeThis.y) > sizeShell.y)
		y = sizeShell.y - sizeThis.y;
	this.setLocation(x, y);
	
	this.setZIndex(thisZ);
}
*/

/*
* @param pageKey - key to the page to be shown. 
* pageKey is the value returned from @link DwtWizardDialog.prototype.addPage method
* This method is called by 
*	@link DwtWizardPage.prototype.switchToNextPage 
*	and 
*	@link DwtWizardPage.prototype.switchToPrevPage
*/
DwtWizardDialog.prototype.goPage = 
function(pageKey) {
	if(this._pages && this._pages[pageKey]) {
		this._currentPage = pageKey;
		this._showPage(pageKey);
		this._progressBar.showStep(pageKey);
		this._pages[pageKey].setActive();
	}
}

DwtWizardDialog.prototype.goNext = 
function() {
	var nextPageKey = this._currentPage + 1;
	if(this._pages && this._pages[this._currentPage]) {
		this._pages[this._currentPage].switchToNextPage(nextPageKey);
	}

}

DwtWizardDialog.prototype.goPrev = 
function() {
	var prevPageKey = this._currentPage - 1;
	if(this._pages && this._pages[this._currentPage]) {
		this._pages[this._currentPage].switchToPrevPage(prevPageKey);
	}
}

DwtWizardDialog.prototype.finishWizard = 
function() {
	this.popdown();	
}

/**
 * 
 * @param pageKey  the key for the page, returned from {@link #addPage}
 * @return {DwtPropertyPage}	the view tab
 * 
 * @private
 */
DwtWizardDialog.prototype.getPage =
function (pageKey) {
	if(this._pages && this._pages[pageKey])
		return this._pages[pageKey];
	else
		return null;
}

/**
 * @param {DwtPropertyPage}		wizPage 	the wizard page
 * @return - the key for the added page. This key can be used to retrieve the tab using {@link #getPage}
 * 
 * @private
*/
DwtWizardDialog.prototype.addPage =
function (wizPage, stepTitle) {
	var pageKey = this._pageIx++;	
	this._pages[pageKey] = wizPage;
	//add a step to the progress bar
/*	if(stepTitle == null)
 		stepTitle = pageKey;*/
	this._progressBar.addStep(pageKey, stepTitle);
	//add the page 
	this._pageDiv.appendChild(this._pages[pageKey].getHtmlElement());
	
	if(pageKey==1) //show the first tab 
		this._pages[pageKey].setZIndex(DwtWizardDialog.Z_ACTIVE_PAGE); 
	else {
		//hide all the other tabs
		this._pages[pageKey].setZIndex(DwtWizardDialog.Z_HIDDEN_PAGE); 
		Dwt.setVisible(this._pages[pageKey].getHtmlElement(), false);
	}
	return pageKey;
}

//private and protected methods

/**
 * method _createHtm
 * 
 * @private
 */
DwtWizardDialog.prototype._createContentHtml =
function () {

	this._table = document.createElement("table");
	this._table.border = 0;
	this._table.width = this._contentW;
	this._table.cellPadding = this._table.cellSpacing = 0;

	this._table.backgroundColor = DwtCssStyle.getProperty(this.parent.getHtmlElement(), "background-color");
	
	var row1; //_progressBar
	var col1;
	row1 = this._table.insertRow(0);
	row1.align = "left";
	row1.vAlign = "middle";
	
	col1 = row1.insertCell(row1.cells.length);
	col1.align = "left";
	col1.vAlign = "middle";
	col1.noWrap = true;	
	col1.width="100%";
	col1.className="DwtTabTable";
	col1.appendChild(this._progressBar.getHtmlElement());

	var rowSep;//separator
	var colSep;
	rowSep = this._table.insertRow(1);
	rowSep.align = "center";
	rowSep.vAlign = "middle";
	
	colSep = rowSep.insertCell(rowSep.cells.length);
	colSep.align = "left";
	colSep.vAlign = "middle";
	colSep.noWrap = true;	
	colSep.style.width = this._contentW;
	var sepDiv = document.createElement("div");
	sepDiv.className = "horizSep";
	sepDiv.style.width = this._contentW;
	sepDiv.style.height = "5px";
	colSep.appendChild(sepDiv);
	
	var row2; //page
	var col2;
	row2 = this._table.insertRow(2);
	row2.align = "left";
	row2.vAlign = "middle";
	
	col2 = row2.insertCell(row2.cells.length);
	col2.align = "left";
	col2.vAlign = "middle";
	col2.noWrap = true;	
	col2.width = this._contentW;
	col2.appendChild(this._pageDiv);

	this._getContentDiv().appendChild(this._table);
}

/**
 * Override addChild method. We need internal control over layout of the children in this class.
 * Child elements are added to this control in the _createHTML method.
 * @param child
 * 
 * @private
 */
DwtWizardDialog.prototype.addChild =
function(child) {
	this._children.add(child);
}

DwtWizardDialog.prototype._showPage = 
function(pageKey) {
	if(this._pages && this._pages[pageKey]) {
		//hide all the tabs
		this._hideAllPages();
		//make this tab visible
		this._pages[pageKey].showMe();
		//this._pages[pageKey].setZIndex(DwtWizardDialog.Z_ACTIVE_PAGE);
		Dwt.setVisible(this._pages[pageKey].getHtmlElement(), true);
	}
}

DwtWizardDialog.prototype._hideAllPages = 
function() {
	if(this._pages && this._pages.length) {
		for(var curPageKey in this._pages) {
			if(this._pages[curPageKey]) {
				this._pages[curPageKey].hideMe();
				//this._pages[curPageKey].setZIndex(DwtWizardDialog.Z_HIDDEN_PAGE);
				Dwt.setVisible(this._pages[curPageKey].getHtmlElement(), false);
			}	
		}
	}
}


/**
 * @class
 * @constructor
 * DwtWizardpage abstract class for a page in a wizard dialog
 * tab pages are responsible for creating there own HTML and populating/collecting 
 * data to/from any form fields that they display
 * 
 * @private
 */
DwtWizardPage = function(parent, className) {
	if (arguments.length == 0) return;
	var clsName = className || "DwtDialog";
	DwtPropertyPage.call(this, parent, className, DwtControl.ABSOLUTE_STYLE);
}

DwtWizardPage.prototype = new DwtTabViewPage;
DwtWizardPage.prototype.constructor = DwtWizardPage;

DwtWizardPage.prototype.toString = 
function() {
	return "DwtWizardPage";
}

/**
* setActive is called when the page is activated. 
**/
DwtWizardPage.prototype.setActive =
function () {

}

/**
* @param pageKey - key for the next page
* Checks if it is ok to leave go to the next page. 
* Default implementation does not check anything.
**/
DwtWizardPage.prototype.switchToNextPage = 
function (pageKey) {
	this.parent.goPage(pageKey);
}

/**
* @param pageKey - key for the previous page
* Checks if it is ok to leave go to the previous page. 
* Default implementation does not check anything.
**/
DwtWizardPage.prototype.switchToPrevPage = 
function (pageKey) {
	this.parent.goPage(pageKey);
}

DwtWizardPage.prototype.showMe = 
function() {
	this.setZIndex(DwtTabView.Z_ACTIVE_TAB);
	/*
	DBG.println(AjxDebug.DBG3, "DwtWizardPage.prototype.showMe");
	DBG.println(AjxDebug.DBG3, "this.parent.getHtmlElement().offsetHeight: " + this.parent.getHtmlElement().offsetHeight);		
	DBG.println(AjxDebug.DBG3, "this.parent.getHtmlElement().clientHeight: " + this.parent.getHtmlElement().clientHeight);				
	DBG.println(AjxDebug.DBG3, "this.parent.getHtmlElement().offsetWidth: " + this.parent.getHtmlElement().offsetWidth);		
	DBG.println(AjxDebug.DBG3, "this.parent.getHtmlElement().clientWidth: " + this.parent.getHtmlElement().clientWidth);				
	DBG.println(AjxDebug.DBG3, "this.parent._contentH: " + this.parent._contentH);					
	DBG.println(AjxDebug.DBG3, "this.parent._contentW: " + this.parent._contentW);		
	*/
	this.getHtmlElement().style.height = this.parent._contentH;
	this.getHtmlElement().style.width = this.parent._contentW;
	
}
/**
 * @class DwtWizProgressBar
 * @constructor
 * 
 * @param parent
 * 
 * @private
 */
DwtWizProgressBar = function(parent) {
	if (arguments.length == 0) return;
	DwtComposite.call(this, {parent:parent, className:"DwtWizProgressBar", posStyle:DwtControl.STATIC_STYLE});
	this._table = document.createElement("table");
	this._table.border = 0;
	this._table.cellPadding = 0;
	this._table.cellSpacing = 0;
	this.getHtmlElement().appendChild(this._table);
	this._table.backgroundColor = DwtCssStyle.getProperty(this.parent.getHtmlElement(), "background-color");
	this._stepsNumber = 0; //number of steps
	this._steps = new Array();
	this._lblHeader = new DwtStepLabel(this);
	this._lblHeader.setText("Step 0 of 0");
	this._lblHeader.setActive(true);
}


DwtWizProgressBar.prototype = new DwtComposite;
DwtWizProgressBar.prototype.constructor = DwtWizProgressBar;

DwtWizProgressBar.prototype.toString = 
function() {
	return "DwtWizProgressBar";
}

/**
* @param stepKey
**/
DwtWizProgressBar.prototype.showStep = 
function(stepKey) {
	var szLabelTxt = "Step " + stepKey + " of " + this._stepsNumber;
	if(this._steps[stepKey]) {
		szLabelTxt = szLabelTxt + ": " + this._steps[stepKey];
	}
	this._lblHeader.setText(szLabelTxt);
}

/**
* @param stepKey
* @param stepNumber
**/
DwtWizProgressBar.prototype.addStep =
function (stepKey, stepTitle) {
	this._steps[stepKey] = stepTitle;
	return (++this._stepsNumber);
}

DwtWizProgressBar.prototype.addChild =
function(child) {
	this._children.add(child);
	var row;
	var col;
	this._table.width = "100%";
	row = (this._table.rows.length != 0) ? this._table.rows[0]: this._table.insertRow(0);
	row.align = "center";
	row.vAlign = "middle";
		
	col = row.insertCell(row.cells.length);
	col.align = "center";
	col.vAlign = "middle";
	col.noWrap = true;
	col.appendChild(child.getHtmlElement());
}


/**
 * @class DwtStepLabel
 * @constructor
 * 
 * @param parent
 * 
 * @private
 */
DwtStepLabel = function(parent) {
	DwtLabel.call(this, {parent:parent, style:DwtLabel.ALIGN_CENTER, className:"DwtStepLabel"});
}

DwtStepLabel.prototype = new DwtLabel;
DwtStepLabel.prototype.constructor = DwtStepLabel;

DwtStepLabel.prototype.toString = 
function() {
	return "DwtStepLabel";
}

DwtStepLabel.prototype.setActive = 
function(isActive) {
	if (isActive) {
 		this._textCell.className="DwtStepLabelActive";
 	} else {
	 	this._textCell.className="DwtStepLabelInactive";
 	}
}

}
if (AjxPackage.define("ajax.dwt.widgets.DwtSelect")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * Creates a select element.
 * @constructor
 * @class
 * Widget to replace the native select element.
 * <p>
 * Note: Currently this does not support multiple selection.
 * 
 * @param {hash}	params		a hash of parameters
 * @param {DwtComposite}      params.parent		the parent widget
 * @param {array}      params.options 		a list of options. This can be either an array of {@link DwtSelectOption} or {String} objects.
 * @param {string}      params.className		the CSS class
 * @param {constant}      params.posStyle		the positioning style (see {@link DwtControl})
 * @param {boolean}      [layout=true]		layout to use: DwtMenu.LAYOUT_STACK, DwtMenu.LAYOUT_CASCADE or DwtMenu.LAYOUT_SCROLL. A value of [true] defaults to DwtMenu.LAYOUT_CASCADE and a value of [false] defaults to DwtMenu.LAYOUT_STACK.
 *        
 * @extends		DwtButton
 *
 * TODO: add option to keep options sorted by display text
 */
DwtSelect = function(params) {

	if (arguments.length == 0) { return; }

	params = Dwt.getParams(arguments, DwtSelect.PARAMS);
	params.className = params.className || "ZSelect";
	params.posStyle = params.posStyle || Dwt.STATIC_STYLE;
	this._legendId = params.legendId;
    DwtButton.call(this, params);

	var events = AjxEnv.isIE ? [DwtEvent.ONMOUSEDOWN, DwtEvent.ONMOUSEUP] :
							   [DwtEvent.ONMOUSEDOWN, DwtEvent.ONMOUSEUP, DwtEvent.ONMOUSEOVER, DwtEvent.ONMOUSEOUT];
	this._setEventHdlrs(events);
	this._hasSetMouseEvents = true;

    // initialize some variables
    this._currentSelectedOption = null;
    this._options = new AjxVector();
    this._optionValuesToIndices = {};
    this._selectedValue = this._selectedOption = null;
	this._maxRows = params.maxRows || 0;
	this._layout = params.layout;
    this._congruent = params.congruent;
    this._hrCount = 0;

    // add options
    var options = params.options;
    if (options) {
        for (var i = 0; i < options.length; ++i) {
            this.addOption(options[i]);
        }
    }

    // setup display
    this.setDropDownImages("SelectPullDownArrow",			// normal
                           "SelectPullDownArrowDis",		// disabled
                           "SelectPullDownArrow",			// hover
                           "SelectPullDownArrow");			// down

    // add listeners
    this._menuCallback = new AjxListener(this, this._createMenu);
    this.setMenu(this._menuCallback, true);
};

DwtSelect.PARAMS = ["parent", "options", "style", "className", "layout"];

DwtSelect.prototype = new DwtButton;
DwtSelect.prototype.constructor = DwtSelect;

DwtSelect.prototype.isDwtSelect = true;
DwtSelect.prototype.toString = function() { return "DwtSelect"; };

DwtSelect.prototype.role = 'combobox';

//
// Constants
//

/**
 * This template is only used for the auto-sizing of the select width.
 * 
 * @private
 */
DwtSelect._CONTAINER_TEMPLATE = "dwt.Widgets#ZSelectAutoSizingContainer";

//
// Data
//

// static

/**
 * This keeps track of all instances out there
 * 
 * @private
 */
DwtSelect._objectIds = [null];

// templates

DwtSelect.prototype.TEMPLATE = "dwt.Widgets#ZSelect";

//
// Public methods
//

// static

DwtSelect.getObjectFromElement =
function(element) {
	return element && element.dwtObj
		? AjxCore.objectWithId(element.dwtObj) : null;
};

// other

/**
 * Adds an option.
 * 
 * @param {string|DwtSelectOption|DwtSelectOptionData}		option			a {String} for the option value or the {@link DwtSelectOption} object
 * @param {boolean}	[selected]		indicates whether option should be the selected option
 * @param {Object}	value			if the option parameter is a {@link DwtSelectOption}, this will override the value already set in the option.
 * @param {String}  image	(optional)
 * @return 	{number} a handle to the newly added option
 *
 * TODO: support adding at an index
 */
DwtSelect.prototype.addOption =
function(option, selected, value, image) {

	if (!option) { return -1; }
	image = image || null;

	var opt = null;
	var val = null;
    var id = null;
	if (typeof(option) == 'string') {
		val = value != null ? value : option;
		opt = new DwtSelectOption(val, selected, option, this, null, image);
	} else {
		if (option instanceof DwtSelectOption) {
			opt = option;
			if (value) {
				opt.setValue(value);
			}
			selected = opt.isSelected();
		} else if(option instanceof DwtSelectOptionData || option.value != null) {
			val = value != null ? value : option.value;
			opt = new DwtSelectOption(val, option.isSelected, option.displayValue, this, null, option.image, option.selectedValue, false, option.extraData, option.id);
			selected = Boolean(option.isSelected);
            id = option.id;
		} else {
			return -1;
		}
	}

	this._options.add(opt);
	if (this._options.size() == 1 || selected) {
		this._setSelectedOption(opt);
	}

	// Insert the option into the table that's below the button.
	// This is what gives the button the same size as the select menu.
	var table = this._pseudoItemsEl;
	var row = table.insertRow(-1);
	var cell = row.insertCell(-1);
	cell.className = 'ZSelectPseudoItem';
	cell.innerHTML = [
        "<div class='ZWidgetTitle'>",
            AjxStringUtil.htmlEncode(opt.getDisplayValue()),
        "</div>"
    ].join("");

	this.fixedButtonWidth(); //good to call always to prevent future bugs due to the vertical space.

	// Register listener to create new menu.
	this.setMenu(this._menuCallback, true);

    // return the index of the option.
    this._optionValuesToIndices[opt.getValue()] = this._options.size() - 1;
    return (this._options.size() - 1);
};

DwtSelect.prototype.addHR =
function() {
    opt = new DwtSelectOption("hr" + this._hrCount.toString(), false, "", this, null, null, null, true);
    this._hrCount++;
	this._options.add(opt);
};

/**
 * Removes an option.
 *
 * @param {DwtSelectOption}		option			option to remove
 *
 * @return {number} index of the option that was removed, or -1 if there was an error
 */
DwtSelect.prototype.removeOption =
function(option) {

	if (!option) { return -1; }

	// Register listener to create new menu.
	this.setMenu(this._menuCallback, true);

	this._options.remove(option);
	var size = this._options.size();

	var value = option.getValue();
	var index = this._optionValuesToIndices[value];
	if (index != null) {
		this._pseudoItemsEl.deleteRow(index);
		if (this._selectedOption == option) {
			if (size > 0) {
				var newSelIndex = (index >= size) ? size - 1 : index;
				this._setSelectedOption(this._options.get(newSelIndex));
			}
			this.removeAttribute('aria-activedescendant');
		}
		this.fixedButtonWidth(); //good to call always to prevent future bugs due to the vertical space.
	}

	delete this._optionValuesToIndices[value];
	for (var i = index; i < size; i++) {
		var option = this._options.get(i);
		this._optionValuesToIndices[option.getValue()] = i;
	}

	return index;
};

/**
 * Removes an option based on its value.
 *
 * @param {string}		value			value of the option to remove
 *
 * @return {number} index of the option that was removed, or -1 if there was an error
 */
DwtSelect.prototype.removeOptionWithValue =
function(value) {

	var option = this.getOptionWithValue(value);
	return option ? this.removeOption(option) : -1;
};

DwtSelect.prototype.popup =
function() {
	var menu = this.getMenu();
	if (!menu) { return; }

	var selectElement = this._selectEl;
	var selectBounds = Dwt.getBounds(selectElement);
    
    // since buttons are often absolutely positioned, and menus aren't, we need x,y relative to window
	var verticalBorder = (selectElement.style.borderLeftWidth == "") ? 0 : parseInt(selectElement.style.borderLeftWidth);
	var horizontalBorder = (selectElement.style.borderTopWidth == "") ? 0 : parseInt(selectElement.style.borderTopWidth);
	horizontalBorder += (selectElement.style.borderBottomWidth == "") ? 0 : parseInt(selectElement.style.borderBottomWidth);

    var selectLocation = Dwt.toWindow(selectElement, 0, 0);
    var x = selectLocation.x + verticalBorder;
    var y = selectLocation.y + selectBounds.height + horizontalBorder;
    menu.popup(0, x, y);
    if (this._currentSelectedOption) {
        menu.setSelectedItem(this._currentSelectedOption.getItem());
    }
};

/**
 * Renames an option.
 *
 * @param {Object}	value		the value of the option to rename
 * @param {string}	newValue	the new display value
 */
DwtSelect.prototype.rename =
function(value, newValue) {

	var option = this.getOptionWithValue(value);
	if (!option) { return; }
	option._displayValue = newValue;

	if (this._selectedOption && (this._selectedOption._value == value))	{
		this.setText(AjxStringUtil.htmlEncode(newValue));
	}

	// Register listener to create new menu.
	this.setMenu(this._menuCallback, true);
};

/**
 * Enables or disables an option.
 *
 * @param {Object}	value		the value of the option to enable/disable
 * @param {boolean}	enabled		if <code>true</code>, enable the option
 */
DwtSelect.prototype.enableOption =
function(value, enabled) {
	var option = this.getOptionWithValue(value);
	if (!option) { return; }
	if (option.enabled != enabled) {
		option.enabled = enabled;
		var item = option.getItem();
		if (item) {
			item.setEnabled(enabled);
		}
	}
};

/**
 * Clears the options.
 * 
 */
DwtSelect.prototype.clearOptions =
function() {
	var opts = this._options.getArray();
	for (var i = 0; i < opts.length; ++i) {
		opts[i] = null;
	}
	this._options.removeAll();
	this._optionValuesToIndices = null;
	this._optionValuesToIndices = [];
	this._selectedValue = null;
	this._selectedOption = null;
	this._currentSelectedOption = null;
	if (this._pseudoItemsEl) {
		try {
			this._pseudoItemsEl.innerHTML = ""; //bug 81504
		}
		catch (e) {
			//do nothing - this happens in IE for some reason. Stupid IE. "Unknown runtime error".
		}
	}
};

/**
 * Sets the select name.
 * 
 * @param	{string}	name		the name
 */
DwtSelect.prototype.setName =
function(name) {
	this._name = name;
};

/**
 * Gets the select name.
 * 
 * @return	{string}	the name
 */
DwtSelect.prototype.getName =
function() {
	return this._name;
};

/**
 * Sets the selected value.
 * 
 * @param	{Object}	optionValue		the value of the option to select
 */
DwtSelect.prototype.setSelectedValue =
function(optionValue) {
    var index = this._optionValuesToIndices[optionValue];
    if (index != null) {
        this.setSelected(index);
    }
};

/**
 * Sets the option as the selected option.
 * 
 * @param {number}	optionHandle 	a handle to the option
 * 
 * @see		#addOption
 */
DwtSelect.prototype.setSelected =
function(optionHandle) {
    var optionObj = this.getOptionWithHandle(optionHandle);
	this.setSelectedOption(optionObj);
};

/**
 * Gets the option count.
 * 
 * @return	{number}	the option count
 */
DwtSelect.prototype.getOptionCount =
function() {
	return this._options.size();
};

/**
 * Gets the options.
 * 
 * @return	{AjxVector}		a vector of {@link DwtSelectOption} objects
 */
DwtSelect.prototype.getOptions =
function() {
	return this._options;
};

/**
 * Gets the option .
 * 
 * @param {number}	optionHandle 	a handle to the option
 * @return	{DwtSelectOption}	the option
 * @see		#addOption
 */
DwtSelect.prototype.getOptionWithHandle =
function(optionHandle) {
	return this._options.get(optionHandle);
};

DwtSelect.prototype.getOptionAtIndex = DwtSelect.prototype.getOptionWithHandle;

/**
 * Gets the index for a given value.
 * 
 * @param	{Object}	value		the value
 * @return	{number}		the index
 */
DwtSelect.prototype.getIndexForValue =
function(value) {
	return this._optionValuesToIndices[value];
};

/**
 * Gets the option for a given value.
 * 
 * @param	{Object}	optionValue		the value
 * @return	{DwtSelectOption}		the option
 */
DwtSelect.prototype.getOptionWithValue =
function(optionValue) {
	var index = this._optionValuesToIndices[optionValue];
	var option = null;
    if (index != null) {
        option = this.getOptionWithHandle(index);
    }
	return option;
};

/**
 * Sets the selected option.
 * 
 * @param	{Object}	optionObj		the object
 */
DwtSelect.prototype.setSelectedOption =
function(optionObj) {
	if (optionObj) {
		this._setSelectedOption(optionObj);
	}
};

/**
 * Gets the selected value.
 * 
 * @return	{Object}	the value
 */
DwtSelect.prototype.getValue =
function() {
    return this._selectedValue;
};

/**
 * Gets the selected option.
 * 
 * @return	{DwtSelectOption}	the selected option
 */
DwtSelect.prototype.getSelectedOption =
function() {
	return this._selectedOption;
};

/**
 * Gets the selected option index.
 * 
 * @return	{number}	the selected option index
 */
DwtSelect.prototype.getSelectedIndex =
function() {
	return this.getIndexForValue(this.getValue());
};

/**
 * Adds a change listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
DwtSelect.prototype.addChangeListener =
function(listener) {
    this.addListener(DwtEvent.ONCHANGE, listener);
};

/**
 * Gets the count of options.
 * 
 * @return	{number}	the count
 */
DwtSelect.prototype.size =
function() {
	return this._options.size();
};

/**
 * Disables the select.
 */
DwtSelect.prototype.disable =
function() {
	this.setEnabled(false);
};

/**
 * Enables the select.
 */
DwtSelect.prototype.enable =
function() {
	this.setEnabled(true);
};

DwtSelect.prototype.setImage =
function(imageInfo) {
	// dont call DwtButton base class!
	DwtLabel.prototype.setImage.call(this, imageInfo);
};

DwtSelect.prototype.setText =
function(text) {
	// dont call DwtButton base class!
	DwtLabel.prototype.setText.call(this, text);
};

DwtSelect.prototype.dispose =
function() {
	this._selectEl = null;
	if (this._pseudoItemsEl) {
		this._pseudoItemsEl.outerHTML = "";
		this._pseudoItemsEl = null;
	}
	this._containerEl = null;

	DwtButton.prototype.dispose.call(this);

	if (this._internalObjectId) {
		DwtSelect._unassignId(this._internalObjectId);
	}
};

//
// Protected methods
//

// static

DwtSelect._assignId =
function(anObject) {
    var myId = DwtSelect._objectIds.length;
    DwtSelect._objectIds[myId]= anObject;
    return myId;
};

DwtSelect._getObjectWithId =
function(anId) {
    return DwtSelect._objectIds[anId];
};

DwtSelect._unassignId =
function(anId) {
    DwtSelect._objectIds[anId] = null;
};

// other

/* use this in case you want the button to take as little space as needed, and not be aligned with the size of the drop-down.
	Especially useful in cases where we mess up the button (remove the text) such as in ZmFreeBusySchedulerView 
 */
DwtSelect.prototype.dynamicButtonWidth = 
function() {
	this._isDynamicButtonWidth = true; //if this is set, set this so fixedButtonWidth doesn't change this.
	this._selectEl.style.width = "auto"; //set to default in case fixedButtonWidth was called before setting it explicitely.
	this._pseudoItemsEl.style.display =  "none";
};

/*
 * Use this in case you want the select to be as wide as the widest option and
 * the options hidden so they don't overflow outside containers.
 */
DwtSelect.prototype.fixedButtonWidth =
function(){
	if (this._isDynamicButtonWidth) {
		return;
	}
	this._pseudoItemsEl.style.display = "block"; //in case this function was called before. This will fix the width of the _selectEl to match the options.
    var elm = this._selectEl;
	var width = elm.offsetWidth;
	//offsetWidth is 0 if some parent (ancestor) has display:none which is the case only in Prefs pages when the select is setup.
	//don't set width to 0px in this case as it acts inconsistent - filling the entire space. Better to keep it just dynamic.
	if (width) {
		elm.style.width = width + "px";
	}
    this._pseudoItemsEl.style.display = "none";
};

DwtSelect.prototype._createHtmlFromTemplate =
function(templateId, data) {
    // wrap params
    var containerTemplateId = DwtSelect._CONTAINER_TEMPLATE;
    var containerData = {
        id: data.id,
        selectTemplateId: templateId || this.TEMPLATE,
        selectData: data
    };

    // generate html
    DwtButton.prototype._createHtmlFromTemplate.call(this, containerTemplateId, containerData);
    this._selectEl = document.getElementById(data.id+"_select_container");
    this._pseudoItemsEl = document.getElementById(data.id+"_pseudoitems_container");
	// this has to be block for it to affect the layout. it is not seen because its visibility hidden for the TDs
	// inside, and also "overflow:hidden" (so mouse over the hidden stuff does not highlight)
	this._pseudoItemsEl.style.display = "block";
    // set classes
    var el = this._containerEl = this.getHtmlElement();
    this._selectEl.className = el.className;
    Dwt.addClass(el, "ZSelectAutoSizingContainer");
    this.removeAttribute("style");
	if (this._legendId) {
		this.setAttribute('aria-labelledby', [ this._legendId, this._textEl.id ].join(' '));
	}
};

DwtSelect.prototype._createMenu = function() {

    var menu = new DwtSelectMenu(this);
    var mi;
    for (var i = 0, len = this._options.size(); i < len; ++i) {
	    var option = this._options.get(i);
        if (option._hr) {
            mi = new DwtMenuItem({parent:menu, style:DwtMenuItem.SEPARATOR_STYLE});
            mi.setEnabled(false);
        } else {
            var mi = new DwtSelectMenuItem(menu, option.id || Dwt.getNextId(menu._htmlElId + '_option_'));
            var image = option.getImage();
            if (image) {
                mi.setImage(image);
            }
            var text = option.getDisplayValue();
            if (text) {
                mi.setText(AjxStringUtil.htmlEncode(text));
            }
            mi.setEnabled(option.enabled);

            mi.addSelectionListener(new AjxListener(this, this._handleOptionSelection));
            mi._optionIndex = i;
        }
        mi._optionIndex = i;
		option.setItem(mi);
    }

	// Accessibility
	var select = this;
	menu.addPopupListener(function() {
		select.setAttribute('aria-expanded', true);
	});
	menu.addPopdownListener(function() {
		select.setAttribute('aria-expanded', false);
		select.removeAttribute('aria-activedescendant');
	});

	return menu;
};

DwtSelect.prototype._handleOptionSelection =
function(ev) {
	var menuItem = ev.item;
	var optionIndex = menuItem._optionIndex;
	var opt = this._options.get(optionIndex);
	var oldValue = this.getValue();
	this._setSelectedOption(opt);

	// notify our listeners
    var args = new Object();
    args.selectObj = this;
    args.newValue = opt.getValue();
    args.oldValue = oldValue;
    var event = DwtUiEvent.getEvent(ev);
    event._args = args;
    this.notifyListeners(DwtEvent.ONCHANGE, event);
};

DwtSelect.prototype._setSelectedOption =
function(option) {
	var displayValue = option.getSelectedValue() || option.getDisplayValue();
	var image = option.getImage();
	if (this._selectedOption != option) {
 		if (displayValue) {
 			this.setText(AjxStringUtil.htmlEncode(displayValue));
 		}
 		this.setImage(image);
		this._selectedValue = option._value;
		this._selectedOption = option;
	}
    this._updateSelection(option);

    this.autoResize();
};

DwtSelect.prototype.autoResize =
function() {
    /* bug: 21041 */
    var divElId = this.getHtmlElement();
    AjxTimedAction.scheduleAction(new AjxTimedAction(this,
        function(){
            var divEl = document.getElementById(divElId.id);
            if (divEl) {
                divEl.style.width = divEl.childNodes[0].offsetWidth || "auto"; // offsetWidth doesn't work in IE if the element or one of its parents has display:none
            }
    }, 200));
};

DwtSelect.prototype._updateSelection = 
function(newOption) {
	var currOption = this._currentSelectedOption;

	if (currOption) {
		currOption.deSelect();
	}
	this._currentSelectedOption = newOption;
	if (!newOption) {
		return;
	}
	newOption.select();
	var menu = this.getMenu(true);
	if (!menu) {
		return;
	}
	menu.setSelectedItem(newOption.getItem());
};

// Call this function to update the rendering of the element
// Firefox sometimes renders the element incorrectly on certain DOM updates, so this function rectifies that
DwtSelect.prototype.updateRendering = 
function() {
	var scrollStyle = this.getScrollStyle();
	this.setScrollStyle(scrollStyle == Dwt.VISIBLE ? Dwt.CLIP : Dwt.VISIBLE);
	var reset = function() {
					try {
						this.setScrollStyle(scrollStyle);
					} catch(e) {}
				};
	var resetAction = new AjxTimedAction(this, reset);
	AjxTimedAction.scheduleAction(resetAction, 4);
};

// Accessibility - select has role of 'combobox', so 'aria-owns' is used instead of 'aria-haspopup'
DwtSelect.prototype._menuAdded = function(menu) {
	this.setAttribute('aria-owns', menu._htmlElId);
};

// Accessibility - with a role of 'combobox' we need to maintain 'aria-activedescendant'
DwtSelect.prototype._menuItemSelected = function(menuItem) {
	this.setAttribute('aria-activedescendant', menuItem._htmlElId);
};


//
// Class
//

/**
 * Greg Solovyev 2/2/2004 added this class to be able to create a list of options 
 * before creating the DwtSelect control. This is a workaround an IE bug, that 
 * causes IE to crash with error R6025 when DwtSelectOption object are added to empty DwtSelect
 * @class
 * @constructor
 * 
 * @private
 */
DwtSelectOptionData = function(value, displayValue, isSelected, selectedValue, image, id, extraData) {
	if (value == null || displayValue == null) { return null; }

	this.value = value;
	this.displayValue = displayValue;
	this.isSelected = isSelected;
	this.selectedValue = selectedValue;
	this.image = image;
	this.extraData = extraData;
    this.id = id || Dwt.getNextId();
};

//
// Class
//

/**
 * Creates a select option.
 * @constructor
 * @class
 * This class encapsulates the option object that the {@link DwtSelect} widget uses. 
 *
 * @param {String}	value this is the value for the object, it will be returned in any onchange event
 * @param {Boolean}	selected whether or not the option should be selected to start with
 * @param {String}	displayValue the value that the user will see (HTML encoding will be done on this value internally)
 * @param {DwtSelect}	owner 	not used
 * @param {String}	optionalDOMId		not used
 * @param {String}	[selectedValue] 	the text value to use when this value is the currently selected value
 * @param {Boolean}	hr                  True => This option will be usd to create a unselectable horizontal rule
 * @param {Object} extraData  map of extra name/value pairs
 */
DwtSelectOption = function(value, selected, displayValue, owner, optionalDOMId, image, selectedValue, hr, extraData, id) {
	this._value = value;
	this._selected = selected;
	this._displayValue = displayValue;
	this._image = image;
	this._selectedValue = selectedValue;
    this._hr = hr;
	this._extraData = extraData;

	this.id = id;

	this._internalObjectId = DwtSelect._assignId(this);
	this.enabled = true;
};

DwtSelectOption.prototype.toString =
function() {
    return "DwtSelectOption";
};

/**
 * Sets the item.
 * 
 * @param	{DwtSelectMenuItem}	menuItem		the menu item
 */
DwtSelectOption.prototype.setItem = 
function(menuItem) {
	this._menuItem = menuItem;
};

/**
 * Gets the item.
 * 
 * @return	{DwtSelectMenuItem}	the menu item
 */
DwtSelectOption.prototype.getItem = 
function(menuItem) {
	return this._menuItem;
};

/**
 * Gets the display value.
 * 
 * @return	{String}	the display value
 */
DwtSelectOption.prototype.getDisplayValue = 
function() {
	return this._displayValue;
};

/**
 * Gets the image.
 * 
 * @return	{String}	the image
 */
DwtSelectOption.prototype.getImage = 
function() {
	return this._image;
};

/**
 * Gets the selected value.
 * 
 * @return	{String}	the selected value
 */
DwtSelectOption.prototype.getSelectedValue =
function() {
	return this._selectedValue;
};

/**
 * Gets the value.
 * 
 * @return	{String}	the value
 */
DwtSelectOption.prototype.getValue = 
function() {
	return this._value;
};

/**
 * Sets the value.
 * 
 * @param	{String|Number}	stringOrNumber	the value
 */
DwtSelectOption.prototype.setValue = 
function(stringOrNumber) {
	this._value = stringOrNumber;
};

/**
 * Selects the option.
 */
DwtSelectOption.prototype.select = 
function() {
	this._selected = true;
};

/**
 * De-selects the option.
 */
DwtSelectOption.prototype.deSelect = 
function() {
	this._selected = false;
};

/**
 * Checks if the option is selected.
 * 
 * @return	{Boolean}	<code>true</code> if the option is selected
 */
DwtSelectOption.prototype.isSelected = 
function() {
	return this._selected;
};

/**
 * Gets the id.
 * 
 * @return	{String}	the id
 */
DwtSelectOption.prototype.getIdentifier = 
function() {
	return this._internalObjectId;
};

DwtSelectOption.prototype.getExtraData =
function(key) {
	return this._extraData && this._extraData[key];
};



/**
 * Creates a select menu.
 * @constructor
 * @class
 * This class represents a select menu.
 * 
 * @param	{DwtComposite}	parent		the parent
 * 
 * @extends		DwtMenu
 */
DwtSelectMenu = function(parent) {
    DwtMenu.call(this, {parent:parent, style:DwtMenu.DROPDOWN_STYLE, className:"DwtMenu", layout:parent._layout,
        maxRows:parent._maxRows, congruent:parent._congruent,
        id:Dwt.getNextId(parent.getHTMLElId() + "_Menu_")});
// Dwt.getNextId should be removed once Bug 66510 is fixed
};
DwtSelectMenu.prototype = new DwtMenu;
DwtSelectMenu.prototype.constructor = DwtSelectMenu;

DwtSelectMenu.prototype.TEMPLATE = "dwt.Widgets#ZSelectMenu";

DwtSelectMenu.prototype.toString =
function() {
    return "DwtSelectMenu";
};

/**
 * Creates a select menu item.
 * @constructor
 * @class
 * This class represents a menu item.
 * 
 * @param	{DwtComposite}	parent		the parent
 * 
 * @extends 	DwtMenuItem
 */
DwtSelectMenuItem = function(parent, id) {
    DwtMenuItem.call(this, {parent:parent, style:DwtMenuItem.SELECT_STYLE, className:"ZSelectMenuItem", id: id});
};
DwtSelectMenuItem.prototype = new DwtMenuItem;
DwtSelectMenuItem.prototype.constructor = DwtSelectMenuItem;

DwtSelectMenuItem.prototype.TEMPLATE = "dwt.Widgets#ZSelectMenuItem";

DwtSelectMenuItem.prototype.isDwtSelectMenuItem = true;
DwtSelectMenuItem.prototype.toString = function() { return "DwtSelectMenuItem"; };

DwtSelectMenuItem.prototype.role = 'option';

DwtLabel.prototype._textSet = function(text) {};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtAlert")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

//
// Constructor
//

/**
 * Constructs a control that alerts the user to important information.
 * @class
 * This class represents an alert.
 * 
 * @param {DwtComposite}	parent    the parent container for this control
 * @param {string}	[className="DwtAlert"] the CSS class for this control
 * @param {Dwt.STATIC_STYLE|Dwt.ABSOLUTE_STYLE|Dwt.RELATIVE_STYLE|Dwt.FIXED_STYLE}	[posStyle] 	the position style of this control
 * 
 * @extends		DwtControl
 */
DwtAlert = function(parent, className, posStyle) {
	if (arguments.length == 0) return;
	className = className || "DwtAlert";
	posStyle = posStyle || DwtControl.STATIC_STYLE;
	DwtControl.call(this, {parent:parent, className:className, posStyle:posStyle});
	this._alertStyle = DwtAlert.INFORMATION;
	this._createHtml();
}

DwtAlert.prototype = new DwtControl;
DwtAlert.prototype.constructor = DwtAlert;

//
// Constants
//
/**
 * Defines the "information" style.
 */
DwtAlert.INFORMATION = 0;
/**
 * Defines the "warning" style.
 */
DwtAlert.WARNING = 1;
/**
 * Defines the "critical" style.
 */
DwtAlert.CRITICAL = 2;

/**
 * Defines the "success" style
 */
DwtAlert.SUCCESS = 3;

DwtAlert._ICONS = [
    AjxImg.getClassForImage("Information_32"),
    AjxImg.getClassForImage("Warning_32"),
    AjxImg.getClassForImage("Critical_32"),
    AjxImg.getClassForImage("Success")
];
DwtAlert._CLASSES = [
    "DwtAlertInfo",
    "DwtAlertWarn",
    "DwtAlertCrit",
    "DwtAlertWarn"    // Reuse for Success
];

DwtAlert._RE_ICONS = new RegExp(DwtAlert._ICONS.join("|"));
DwtAlert._RE_CLASSES = new RegExp(DwtAlert._CLASSES.join("|"));

//
// Data
//

DwtAlert.prototype.TEMPLATE = "dwt.Widgets#DwtAlert";

//
// Public methods
//

/**
 * Sets the style.
 * 
 * @param	{DwtAlert.INFORMATION|DwtAlert.WARNING|DwtAlert.CRITICAL|DwtAlert.SUCCESS}	style		the style
 */
DwtAlert.prototype.setStyle = function(style) {
	this._alertStyle = style || DwtAlert.INFORMATION;
	if (this._iconDiv) {
		Dwt.delClass(this._iconDiv, DwtAlert._RE_ICONS, DwtAlert._ICONS[this._alertStyle]);
	}
	Dwt.delClass(this.getHtmlElement(), DwtAlert._RE_CLASSES, DwtAlert._CLASSES[this._alertStyle]);
};

/**
 * Gets the style.
 * 
 * @return	{DwtAlert.INFORMATION|DwtAlert.WARNING|DwtAlert.CRITICAL|DwtAlert.SUCCESS}		the style
 */
DwtAlert.prototype.getStyle = function() {
	return this._alertStyle;
};

/**
 * Sets the icon visibility.
 * 
 * @param	{boolean}	visible		if <code>true</code>, the icon is visible
 */
DwtAlert.prototype.setIconVisible = function(visible) {
	if (this._iconDiv) {
		Dwt.setVisible(this._iconDiv, visible);
	}
};

/**
 * Gets the icon visibility.
 * 
 * @return	{boolean}	<code>true</code> if the icon is visible
 */
DwtAlert.prototype.getIconVisible = function() {
	return this._iconDiv ? Dwt.getVisible(this._iconDiv) : false;
};

/**
 * Sets the title.
 * 
 * @param	{string}	title	the title
 */
DwtAlert.prototype.setTitle = function(title) {
	this._alertTitle = title;
	if (this._titleDiv) {
		this._titleDiv.innerHTML = title || "";
	}
};

/**
 * Gets the title.
 * 
 * @return	{string}	the title
 */
DwtAlert.prototype.getTitle = function() {
	return this._alertTitle;
};

DwtAlert.prototype.setContent = function(content) {
	this._alertContent = content;
	if (this._contentDiv) {
		this._contentDiv.innerHTML = content || "";
	}
};
DwtAlert.prototype.getContent = function() {
	return this._alertContent;
};

DwtAlert.prototype.setDismissContent = function (dwtElement) {
    if (this._dismissDiv) {
        dwtElement.reparentHtmlElement(this._dismissDiv.id) ;
    }
}

//
// DwtControl methods
//

DwtAlert.prototype.getTabGroupMember = function() {
	// NOTE: This control is not tabbable
	return null;
};

//
// Protected methods
//

/**
 * @private
 */
DwtAlert.prototype._createHtml = function(templateId) {
	var data = { id: this._htmlElId };
	this._createHtmlFromTemplate(templateId || this.TEMPLATE, data);
};

/**
 * @private
 */
DwtAlert.prototype._createHtmlFromTemplate = function(templateId, data) {
	DwtControl.prototype._createHtmlFromTemplate.apply(this, arguments);
	this._iconDiv = document.getElementById(data.id+"_icon");
	this._titleDiv = document.getElementById(data.id+"_title");
	this._contentDiv = document.getElementById(data.id+"_content");
    this._dismissDiv = document.getElementById(data.id+"_dismiss") ;
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtText")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * Creates a text control.
 * @constructor
 * @class
 * This class represents a container for a piece of text.
 * 
 * @author Ross Dargahi
 * 
 * @param {hash}	params		a hash of parameters
 * @param {DwtComposite}      parent	the parent widget
 * @param {string}      className		CSS class
 * @param {constant}      posStyle		the positioning style (see {@link DwtControl})
 * @param {string}      id			an explicit ID to use for the control's HTML element
 * 
 * @extends		DwtControl
 */
DwtText = function(params) {
	if (arguments.length == 0) return;
	params = Dwt.getParams(arguments, DwtText.PARAMS);
	params.className = params.className || "DwtText";

	if (Dwt.hasClass(params, 'FakeAnchor')) {
		this.role = 'link';
	}

	DwtControl.call(this, params);

	// we start out empty, so suppress focus
	this.noTab = true;
};

DwtText.PARAMS = ["parent", "className", "posStyle"];

DwtText.prototype = new DwtControl;
DwtText.prototype.constructor = DwtText;

DwtText.prototype.isDwtText = true;
DwtText.prototype.toString = function() { return "DwtText"; };


/**
 * Sets the text.
 * 
 * @param	{string}	text		the text
 */
DwtText.prototype.setText =
function(text) {
	// only appear in tab order when we have text
	this.noTab = !text;

	if (!this._textNode) {
		 this._textNode = document.createTextNode(text);
		 this.getHtmlElement().appendChild(this._textNode);
	} else {
		try { // IE mysteriously throws an error sometimes, but still does the right thing
			this._textNode.data = text;
		} catch (e) {}
	}

	// this is largely redundant, but helps ensure screen readers read aloud
	// text in toolbars
	this.setAttribute('aria-label', text);
};

/**
 * Gets the text.
 * 
 * @return	{string}	the text
 */
DwtText.prototype.getText =
function() {
	return this._textNode ? this._textNode.data : "";
};

/**
 * Gets the text node.
 * 
 * @return	{Object}	the node
 */
DwtText.prototype.getTextNode =
function() {
	return this._textNode;
};

DwtText.prototype._focus = function() {
	this.setDisplayState(DwtControl.FOCUSED);
};

DwtText.prototype._blur = function() {
	this.setDisplayState(DwtControl.NORMAL);
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtIframe")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * Creates an iframe.
 * @class
 * This class represents a simple event proxy. Creates an IFRAME, inserts the given html into it and
 * forwards any events to the parent widget, translating mouse coordinates in
 * between.
 *
 * @param {hash}	params		a hash of parameters:
 *
 * @param   {DwtComposite}		parent	                the parent
 * @param   {string}	        html 	                the HTML code to be inserted in the IFRAME.  There will be
 *   slight modifications to it (i.e. the margins and paddings of the HTML
 *   element will be set to 0, also any margins for BODY).
 * @param   {boolean}		    noscroll 	            if <code>true</code>, do not show the scroll bars
 * @param   {string}	        posStyle	            the position style (see {@link DwtControl})
 * @param   {AjxCallback}	    processHtmlCallback		the callback that will be called
 *   immediately after the HTML code was inserted. A reference to the document object will be passed
 * @param   {boolean}	        useKbMgmt	            if <code>true</code>, participate in keyboard management
 * @param   {string}            title                   title for the IFRAME
 * 
 * @author Mihai Bazon
 * 
 * @extends		DwtControl
 */
DwtIframe = function(params) {
	params.posStyle = params.posStyle || DwtControl.STATIC_STYLE;
	params.className = params.className || "DwtIframe";
	DwtControl.call(this, params);
	this._styles = params.styles;
	this._noscroll = params.noscroll;
	this._iframeID = params.id ? DwtId.getIframeId(params.id) : Dwt.getNextId();
	this._onLoadHandler = params.onload;	
	this._processHtmlCallback = params.processHtmlCallback;
	this._hidden = params.hidden;
	this._title = params.title;

	if (!this._createFrame(params.html)) {
		this.initFailed = true;
		return;	// this object is still returned
	}
	
	if (params.useKbMgmt) {
		var iframe = this.getIframe();
		var idoc = Dwt.getIframeDoc(iframe);
		var doc = AjxEnv.isIE ? idoc : iframe.contentWindow;
		Dwt.setHandler(doc, DwtEvent.ONKEYDOWN, DwtKeyboardMgr.__keyDownHdlr);
		Dwt.setHandler(doc, DwtEvent.ONKEYUP, DwtKeyboardMgr.__keyUpHdlr);
		Dwt.setHandler(doc, DwtEvent.ONKEYPRESS, DwtKeyboardMgr.__keyPressHdlr);
	}
};

DwtIframe.prototype = new DwtControl;
DwtIframe.prototype.constructor = DwtIframe;

DwtIframe.prototype.isDwtIframe = true;
DwtIframe.prototype.toString = function() { return "DwtIframe"; };

/**
 * Gets the iframe.
 * 
 * @return	{Element}	the iframe
 */
DwtIframe.prototype.getIframe = function() {
	return document.getElementById(this._iframeID);
};

DwtIframe.prototype.getInputElement = function() {
	return this.getIframe();
};

/**
 * Gets the iframe window document.
 * 
 * @return	{Document}		the document
 */
DwtIframe.prototype.getDocument = function() {
	return this.getIframe().contentWindow.document;
};

/**
 * Notifies the parent widget's listeners. The event is not directly propagated to the parent's raw event handler.
 *
 * @private
 */
DwtIframe.prototype._rawEventHandler = function(ev) {

	var iframe = this.getIframe();
	var win = iframe.contentWindow;
	if (AjxEnv.isIE) {
		ev = win.event;
	}

	var dw;
	// This probably sucks.
	if (/mouse|context|click|select/i.test(ev.type)) {
		dw = new DwtMouseEvent(true);
	}
	else {
		dw = new DwtUiEvent(true);
	}
	dw.setFromDhtmlEvent(ev);

	// Notify since the manager doesn't know about events in the iframe's document
	if (ev.type == "mousedown" || ev.type == "mousewheel") {
		DwtOutsideMouseEventMgr.forwardEvent(ev);
	}

	// HACK! who would have know.. :-(
	// perhaps we need a proper mapping
	var type = dw.type.toLowerCase();
	if (!/^on/.test(type)) {
		type = "on" + type;
	}
	// translate event coordinates
	var pos = this.getLocation();

	// What I can tell for sure is that we don't want the code below for IE
	// and we want it for Gecko, but I can't be sure of other browsers..
	// Let's assume they follow Gecko.  Seems mostly a trial and error
	// process :(
	if (!AjxEnv.isIE) {
		var doc = win.document;
		var sl = doc.documentElement.scrollLeft || ( doc.body ? doc.body.scrollLeft : 0); 
		var st = doc.documentElement.scrollTop || ( doc.body ? doc.body.scrollTop : 0 );
		pos.x -= sl;
		pos.y -= st;
	}

	dw.docX += pos.x;
	dw.docY += pos.y;
	dw.elementX += pos.x;
	dw.elementY += pos.y;

//   	window.status = dw.type + " doc(" + dw.docX + ", " + dw.docY + ") " +
//   		" element(" + dw.elementX + ", " + dw.elementY + ") " +
//  		" stopPropagation: " + dw._stopPropagation + ", " +
//  		" returnValue: " + dw._returnValue;

	var capture = DwtMouseEventCapture.getCaptureObj();
	capture = capture && dw.button != DwtMouseEvent.RIGHT; // ignore capture if it's right-click
	if (AjxEnv.isIE || !capture) {
        // TODO: handle all events generically by calling handlers instead of listeners
        if (type === DwtEvent.ONFOCUS || type === DwtEvent.ONBLUR) {
            DwtControl.__HANDLER[type].call(null, dw, type, this.parent);
        }
        else {
            // notify listeners
            DwtEventManager.notifyListeners(type, dw);
            this.parent.notifyListeners(type, dw);
        }
	} else {
		// Satisfy object that holds the mouse capture.

		// the following is DOM2, not supported by IE
		var fake = document.createEvent("MouseEvents");
		fake.initMouseEvent(ev.type,
				    true, // can bubble
				    true, // cancellable
				    document.defaultView, // the view
				    0, // event detail ("click count")
				    ev.screenX, // screen X
				    ev.screenY, // screen Y
				    dw.docX, // clientX, but translated to page
				    dw.docY, // clientY, translated
				    ev.ctrlKey, // key status...
				    ev.altKey,
				    ev.shiftKey,
				    ev.metaKey,
				    ev.button,
				    ev.relatedTarget);
		document.body.dispatchEvent(fake);
		// capture[DwtIframe._captureEvents[dw.type]](fake);
	}

	dw.setToDhtmlEvent(ev);
	return dw._returnValue;
};

// map event names to the handler name in a DwtMouseEventCapture object
// DwtIframe._captureEvents = { mousedown : "_mouseDownHdlr",
// 			     mousemove : "_mouseMoveHdlr",
// 			     mouseout  : "_mouseOutHdlr",
// 			     mouseover : "_mouseOverHdlr",
// 			     mouseup   : "_mouseUpHdlr" };

DwtIframe._forwardEvents = [ DwtEvent.ONCHANGE,
			     DwtEvent.ONCLICK,
			     DwtEvent.ONCONTEXTMENU,
			     DwtEvent.ONDBLCLICK,
			     DwtEvent.ONFOCUS,
			     DwtEvent.ONKEYDOWN,
			     DwtEvent.ONKEYPRESS,
			     DwtEvent.ONKEYUP,
			     DwtEvent.ONMOUSEDOWN,
			     DwtEvent.ONMOUSEENTER,
			     DwtEvent.ONMOUSELEAVE,
			     DwtEvent.ONMOUSEMOVE,
			     DwtEvent.ONMOUSEOUT,
			     DwtEvent.ONMOUSEOVER,
			     DwtEvent.ONMOUSEUP,
			     DwtEvent.ONSELECTSTART ];

DwtIframe.prototype._createFrame = function(html) {
	var myId = this.getHTMLElId();

	// this is an inner function so that we can access the object (self).
	// it shouldn't create a memory leak since it doesn't directly "see"
	// the iframe variable (it's protected below)
	function rawHandlerProxy(ev) {
		var myElement = document.getElementById(myId);
		var self = DwtControl.findControl(myElement);		
		return self._rawEventHandler(ev);
	};

	// closure: protect the reference to the iframe node here.
	return (function() {
		var iframe, tmp = [], i = 0, idoc;
		var myElement = document.getElementById(myId);
		var self = DwtControl.findControl(myElement);

		if (!self) {
			return false;
		}
		
		tmp[i++] = "<iframe";
		if (self._noscroll) {
			tmp[i++] = " scrolling='no'";
		}
		if (self._hidden) {
			tmp[i++] = " style='visibility:hidden'";
		}
		if (self._title) {
			tmp[i++] = " title='" + AjxStringUtil.encodeQuotes(AjxStringUtil.htmlEncode(self._title)) + "'";
		}
		tmp[i++] = " frameborder='0' width='100%' id='";
		tmp[i++] = self._iframeID;
		tmp[i++] = "' name='"+ self._iframeID + "'";
		if(self._onLoadHandler){
			tmp[i++] = " onload='" + self._onLoadHandler + "'";
		}
		tmp[i++] = " src='javascript:\"\";' ></iframe>";
		self.setContent(tmp.join(''));

		// Bug 7523: @import url() lines will make Gecko report
		// document.body is undefined until "onload" (unacceptable) so
		// we drop these lines now.
		html = html.replace(/(<style[^>]*>)[\s\t\u00A0]*((.|\n)*?)[\s\t\u00A0]*<\x2fstyle>/mgi,
				    function(s, p1, p2) {
					    return p1 + p2.replace(/@import.*?(;|[\s\t\u00A0]*$)/gi, "") + "</style>";
				    });
        html = AjxStringUtil.checkForCleanHtml(html, ZmMailMsgView.TRUSTED_TAGS, ZmMailMsgView.UNTRUSTED_ATTRS).html;
		iframe = self.getIframe();
		idoc = Dwt.getIframeDoc(iframe);
		idoc.open();
		if (self._styles) {
			idoc.write([ "<style type='text/css'>", self._styles, "</style>" ].join(""));
		}
		idoc.write(html);
		idoc.close();
		// if we're not giving a break, we can safely do any postprocessing
		// here.  I.e. if we want to drop backgroundImage-s, it's safe to do it
		// here because the browser won't have a chance to load them.
		if (self._processHtmlCallback) {
			self._processHtmlCallback.run(idoc);
		}

		// if we have margins, the translated coordinates won't be OK.
		// it's best to remove them.  THE way to have some spacing is
		// to set padding on the body element.
		tmp = idoc.documentElement.style;
		tmp.margin = tmp.padding = "0";
		if (idoc.body) {
			idoc.body.style.margin = "0";
		}

		// set language in IFRAME <html> element
		var htmlEl = idoc.firstChild && idoc.firstChild.tagName && idoc.firstChild.tagName.toLowerCase() === 'html' ? idoc.firstChild : null,
			langAttr = htmlEl && htmlEl.getAttribute('lang');
		if (htmlEl && !langAttr) {
			htmlEl.setAttribute('lang', window.appLang);
		}

		// assign event handlers
		tmp = DwtIframe._forwardEvents;
		if (!AjxEnv.isIE) {
			idoc = iframe.contentWindow;
		}
		for (i = tmp.length; --i >= 0;) {
			idoc[tmp[i]] = rawHandlerProxy;
		}

		// catch browser context menus
		// idoc[DwtEvent.ONCONTEXTMENU] = DwtShell._preventDefaultPrt;
		
		return true;
	})();
};

DwtIframe.prototype._resetEventHandlers = function() {
	var self = this;

	// this is an inner function so that we can access the object (self).
	// it shouldn't create a memory leak since it doesn't directly "see"
	// the iframe variable (it's protected below)
	function rawHandlerProxy(ev) { return self._rawEventHandler(ev); };

	// closure: protect the reference to the iframe node here.
	(function() {
		var iframe, tmp = [], i = 0, idoc;
		iframe = self.getIframe();
		idoc = Dwt.getIframeDoc(iframe);

		// assign event handlers
		tmp = DwtIframe._forwardEvents;
		if (!AjxEnv.isIE)
			idoc = iframe.contentWindow;
			
			
		for (i = tmp.length; --i >= 0;){
			idoc[tmp[i]] = rawHandlerProxy;
		}

		// catch browser context menus
		// idoc[DwtEvent.ONCONTEXTMENU] = DwtShell._preventDefaultPrt;
	})();
};

DwtIframe.prototype.setSrc =
function(src){

    src = src || 'javascript:\"\";'
    var iframe = this.getIframe();
    iframe.src = src;
};

DwtIframe.prototype.setIframeContent =
function(html){    
    var iDoc = this.getDocument();
	if (iDoc.body) {
        iDoc.body.innerHTML = html;
	}
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtPropertySheet")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * 
 * @private
 */
DwtPropertySheet = function(parent, className, posStyle, labelSide) {
	if (arguments.length == 0) return;
	className = className || "DwtPropertySheet";
	DwtComposite.call(this, {parent:parent, className:className, posStyle:posStyle});

	this._labelSide = labelSide || DwtPropertySheet.DEFAULT;

	this._propertyIdCount = 0;
	this._propertyList = [];
	this._propertyMap = {};

	this._tabGroup = new DwtTabGroup(this.toString());

	this._tableEl = document.createElement("TABLE");
	// Cellspacing needed for IE in quirks mode
	this._tableEl.cellSpacing = 6;

	var element = this.getHtmlElement();
	element.appendChild(this._tableEl);
	this._setAllowSelection();
}

DwtPropertySheet.prototype = new DwtComposite;
DwtPropertySheet.prototype.constructor = DwtPropertySheet;

DwtPropertySheet.prototype.toString = 
function() {
	return "DwtPropertySheet";
}

// Constants

DwtPropertySheet.RIGHT = "right";
DwtPropertySheet.LEFT = "left";
DwtPropertySheet.DEFAULT = DwtPropertySheet.LEFT;

// Data

DwtPropertySheet.prototype._labelCssClass = "Label";
DwtPropertySheet.prototype._valueCssClass = "Field";

// Public methods

/**
 * Adds a property.
 *
 * @param label [string] The property label. The value is used to set the
 *				inner HTML of the property label cell.
 * @param value The property value. If the value is an instance of DwtControl
 *				the element returned by <code>getHtmlElement</code> is used;
 *				if the value is an instance of Element, it is added directly;
 *				anything else is set as the inner HTML of the property value
 *				cell.
 * @param required [boolean] Determines if the property should be marked as
 *				   required. This is denoted by an asterisk next to the label.
 */
DwtPropertySheet.prototype.addProperty = function(label, value, required) {

	var index = this._tableEl.rows.length;

	var row = this._tableEl.insertRow(-1);
	row.vAlign = this._vAlign ? this._vAlign : "top";

	var labelId = Dwt.getNextId(),
		valueId = Dwt.getNextId(),
		tabValue;   // element or control that can be a tab group member

	if (this._labelSide == DwtPropertySheet.LEFT) {
		this._insertLabel(row, label, required, labelId, valueId);
		tabValue = this._insertValue(row, value, required, labelId, valueId);
	}
	else {
		this._insertValue(row, value, required, labelId, valueId);
		tabValue = this._insertLabel(row, label, required, labelId, valueId);
	}

	var id = this._propertyIdCount++;
	var property = {
		id:         id,
		index:      index,
		row:        row,
		visible:    true,
		labelId:    labelId,
		valueId:    valueId,
		tabValue:   tabValue
	};
	this._propertyList.push(property);
	this._propertyMap[id] = property;
	return id;
};

DwtPropertySheet.prototype._insertLabel = function(row, label, required, labelId, valueId) {

	var labelCell = row.insertCell(-1);
	labelCell.className = this._labelCssClass;
	labelCell.id = labelId;
	labelCell.setAttribute("for", valueId);
	if (this._labelSide != DwtPropertySheet.LEFT) {
		labelCell.width = "100%";
		labelCell.style.textAlign = "left";
	}
	labelCell.innerHTML = label;
	if (required) {
		var asterisk = this._tableEl.ownerDocument.createElement("SUP");
		asterisk.innerHTML = "*";
		labelCell.insertBefore(asterisk, labelCell.firstChild);
	}
};

DwtPropertySheet.prototype._insertValue = function(row, value, required, labelId, valueId) {

	var valueCell = row.insertCell(-1);
	valueCell.className = this._valueCssClass;
	valueCell.id = valueId;

	if (!value) {
		valueCell.innerHTML = "&nbsp;";
	}
	else if (value.isDwtControl) {
		valueCell.appendChild(value.getHtmlElement());
		this._tabGroup.addMember(value);
		var input = value.getInputElement && value.getInputElement();
		if (input) {
			input.setAttribute('aria-labelledby', labelId);
		}
	}
	else if (value.nodeType == AjxUtil.ELEMENT_NODE) {
		valueCell.appendChild(value);
		this._addTabGroupMemberEl(valueCell);
		value.setAttribute('aria-labelledby', labelId);
	}
	else {
		valueCell.innerHTML = String(value);
		this._addTabGroupMemberEl(valueCell);
		valueCell.setAttribute('aria-labelledby', labelId);
		value = valueCell;
	}

	return value;
};

/**
 * Add element's leaf children to tabgroup.
 *
 * @param element HTML element.
 */
DwtPropertySheet.prototype._addTabGroupMemberEl = function(element, isTabStop) {

	var obj = this;

	// recursive function to add leaf nodes
	function addChildren(el) {
		if (el.children.length > 0) {
			AjxUtil.foreach(el.children, function(child){
				addChildren(child);
			});
		}
		else {
			if (AjxUtil.isBoolean(isTabStop)) {
				obj.noTab = !isTabStop;
			}
			else {
				// add leaf to tabgroup
				obj._makeFocusable(el);
				obj._tabGroup.addMember(el);
			}
		}
	}

	addChildren(element, isTabStop);
};

DwtPropertySheet.prototype.getTabGroupMember = function() {
	return this._tabGroup;
};

DwtPropertySheet.prototype.getProperty = function(id) {
	return this._propertyMap[id];
};

DwtPropertySheet.prototype.removeProperty = function(id) {
	var prop = this._propertyMap[id];
	if (prop) {
		var propIndex = prop.index;
		if (prop.visible) {
			var tableIndex = this.__getTableIndex(propIndex);
			var row = this._tableEl.rows[tableIndex];
			row.parentNode.removeChild(row);
		}
		prop.row = null;
		for (var i = propIndex + 1; i < this._propertyList.length; i++) {
			this._propertyList[i].index--;
		}
		this._propertyList.splice(propIndex, 1);
		delete this._propertyMap[id];
	}
};

DwtPropertySheet.prototype.setPropertyVisible = function(id, visible) {

	var prop = this._propertyMap[id];
	if (prop && prop.visible !== visible) {
		prop.visible = visible;
		Dwt.setVisible(this._tableEl.rows[prop.index], visible);
		var tabValue = prop.tabValue;
		if (tabValue.isDwtControl) {
			tabValue.noTab = !visible;
		}
		else {
			this._addTabGroupMemberEl(tabValue, !visible)
		}
	}
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtGrouper")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * 
 * @private
 */
DwtGrouper = function(parent, className, posStyle) {
	if (arguments.length == 0) return;
	className = className || "DwtGrouper";
	posStyle = posStyle || DwtControl.STATIC_STYLE;
	DwtComposite.call(this, {parent:parent, posStyle:posStyle});

	this._labelEl = document.createElement("LEGEND");
	this._labelEl.id = Dwt.getNextId();
	this._insetEl = document.createElement("DIV");
	this._borderEl = document.createElement("FIELDSET");
	this._borderEl.appendChild(this._labelEl);
	this._borderEl.appendChild(this._insetEl);

	this._tabGroup = new DwtTabGroup(this.toString());

	var element = this.getHtmlElement();
	element.appendChild(this._borderEl);
}

DwtGrouper.prototype = new DwtComposite;
DwtGrouper.prototype.constructor = DwtGrouper;

// Public methods

DwtGrouper.prototype.setLabel = function(htmlContent) {
	Dwt.setVisible(this._labelEl, Boolean(htmlContent));
	// HACK: undo block display set by Dwt.setVisible
	this._labelEl.style.display = "";
	this._labelEl.innerHTML = htmlContent ? htmlContent : "";
};

DwtGrouper.prototype.setContent = function(htmlContent) {
	var element = this._insetEl;
	element.innerHTML = htmlContent;
	var inputElements = element.getElementsByTagName('input');
	for (var i=0; i < inputElements.length; i++) {
		this._tabGroup.addMember(inputElements[i]);
	}
};

DwtGrouper.prototype.setElement = function(htmlElement) {
	var element = this._insetEl;
	Dwt.removeChildren(element);
	element.appendChild(htmlElement);
};

DwtGrouper.prototype.setView = function(control) {
	this.setElement(control.getHtmlElement());
};

DwtGrouper.prototype.getInsetHtmlElement = function() {
	return this._insetEl;
};

DwtGrouper.prototype.getTabGroupMember = function(){
	return this._tabGroup;
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtProgressBar")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * Creates a progress bar.
 * @constructor
 * @class
 * This class represents a progress bar.
 * 
 * @param {DwtComposite}	parent    the parent container
 * @param {string}	className the CSS class name
 * @param {constant}	posStyle  the position style (see {@link DwtControl})
 * 
 * @author Greg Solovyev
 * 
 * @extends		DwtComposite
 */
DwtProgressBar = function(parent, className, posStyle) {
	if (arguments.length == 0) return;
	posStyle = posStyle || DwtControl.STATIC_STYLE;
	DwtComposite.call(this, {parent:parent, posStyle:posStyle});
	this._maxValue = 100;
	this._value = 0;
	this._quotabarDiv = null;
	this._quotausedDiv = null;	

	this._progressBgColor = null;// "#66cc33";	//	MOW: removing this so the color can be skinned
												// 		set the color in the class "quotaused"
	this._progressCssClass = "quotaused";
	
	this._wholeBgColor = null;
	this._wholeCssClass = "quotabar";	
	this._createHTML();
}

DwtProgressBar.prototype = new DwtComposite;
DwtProgressBar.prototype.constructor = DwtProgressBar;


//
// Public methods
//

/**
 * Sets the progress background color.
 * 
 * @param	{string}	var		the color
 */
DwtProgressBar.prototype.setProgressBgColor = 
function(val) {
	this._progressBgColor = val;
}

/**
 * Sets the whole background color.
 * 
 * @param	{string}	var		the color
 */
DwtProgressBar.prototype.setWholeBgColor = 
function(val) {
	this._wholeBgColor = val;
}

/**
 * Sets the progress CSS class.
 * 
 * @param	{string}	var		the color
 */
DwtProgressBar.prototype.setProgressCssClass = 
function(val) {
	this._progressCssClass = val;
}

/**
 * Sets the whole CSS class.
 * 
 * @param	{string}	var		the color
 */
DwtProgressBar.prototype.setWholeCssClass = 
function(val) {
	this._wholeCssClass = val;
}

/**
 * Sets the process CSS style.
 * 
 * @param	{string}	var		the color
 */
DwtProgressBar.prototype.setProgressCssStyle = 
function(val) {
	this._progressCssStyle = val;
}

/**
 * Sets the while CSS style.
 * 
 * @param	{string}	var		the color
 */
DwtProgressBar.prototype.setWholeCssStyle  = 
function(val) {
	this._wholeCssStyle = val;
}

/**
 * Sets the progress value.
 * 
 * @param	{number}		val		the value
 */
DwtProgressBar.prototype.setValue = 
function(val) {
	this._value = parseInt(val);
	var percent;

	if(this._value == this._maxValue)
		percent = 100;
	else 
		percent = Math.min(Math.round((this._value / this._maxValue) * 100), 100);	

	if(isNaN(percent))
		percent = "0";
			
	if(!this._quotabarDiv) {
		this._quotabarDiv = document.createElement("div")
		if(this._wholeCssClass)
			this._quotabarDiv.className = this._wholeCssClass;

		if(this._wholeBgColor)
			this._quotabarDiv.backgroundColor = this._wholeBgColor;
		
		this._cell.appendChild(this._quotabarDiv);
	}
	if(!this._quotausedDiv) {
		this._quotausedDiv = document.createElement("div")
		if(this._progressCssClass)
			this._quotausedDiv.className = this._progressCssClass;
			
		if(this._progressBgColor)
			this._quotausedDiv.style.backgroundColor = this._progressBgColor;
			
		this._quotabarDiv.appendChild(this._quotausedDiv);			
	}	

	this._quotausedDiv.style.width = percent + "%";
}

/**
 * Sets the value by percentage.
 * 
 * @param	{string}		percent		the value as a percentage (for example: "10%")
 */
DwtProgressBar.prototype.setValueByPercent =
function (percent){
	this.setMaxValue(100);
	this.setValue (percent.replace(/\%/gi, ""));
}

/**
 * Gets the value.
 * 
 * @return	{number}	the value
 */
DwtProgressBar.prototype.getValue = 
function() {
	return this._value;
}

/**
 * Gets the maximum value.
 * 
 * @return	{number}	the maximum value
 */
DwtProgressBar.prototype.getMaxValue = 
function() {
	return this._maxValue;
}

/**
 * Sets the maximum value.
 * 
 * @param	{number}	val		the maximum value
 */
DwtProgressBar.prototype.setMaxValue = 
function(val) {
	this._maxValue = parseInt(val);
}

/**
 * Sets the label.
 * 
 * @param	{string}		text		the label
 * @param	{boolean}		isRightAlign	if <code>true</code>, if the label is right aligned
 */
DwtProgressBar.prototype.setLabel =
function( text, isRightAlign) {
	var labelNode = document.createTextNode(text);
	var position = isRightAlign ? -1 : 0;
	var labelCell = this._row.insertCell(position) ;
	labelCell.appendChild (labelNode);
}

//
// Protected methods
//

DwtProgressBar.prototype._createHTML = 
function() {
	this._table = document.createElement("table");
	this._table.border = this._table.cellpadding = this._table.cellspacing = 0;	

	this._row = this._table.insertRow(-1);

	//if(AjxEnv.isLinux)
		//this._row.style.lineHeight = 13;
	
	this._cell = this._row.insertCell(-1);
	
	this.getHtmlElement().appendChild(this._table);
}
}
if (AjxPackage.define("ajax.dwt.widgets.DwtPropertyEditor")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * Generic Property Editor Widget.
 *
 * @author Mihai Bazon
 *
 * See initProperties() below
 * 
 * @extends		DwtComposite
 * @private
 */
DwtPropertyEditor = function(parent, useDwtInputField, className, posStyle, deferred) {
	if (arguments.length > 0) {
		if (!className)
			className = "DwtPropertyEditor";
		DwtComposite.call(this, {parent:parent, className:className, posStyle:posStyle, deferred:deferred});
		this._useDwtInputField = useDwtInputField != null ? useDwtInputField : true;
		this._schema = null;
		this._init();
	}
};

DwtPropertyEditor.MSG_TIMEOUT = 4000; // 4 seconds should be plenty

DwtPropertyEditor.MSG = {
	// Now these 2 are kind of pointless...
	// We should allow a message in the prop. object.
	mustMatch     : "This field does not match validators: REGEXP",
	mustNotMatch  : "This field matches anti-validators: REGEXP" // LOL
};

DwtPropertyEditor.prototype = new DwtComposite;
DwtPropertyEditor.prototype.constructor = DwtPropertyEditor;

DwtPropertyEditor.prototype.toString = function() { return "DwtPropertyEditor"; }

DwtPropertyEditor.prototype._init = function() {
	var div = document.createElement("div");
	div.id = this._relDivId = Dwt.getNextId();
	div.style.position = "relative";
	var table = document.createElement("table");
	table.id = this._tableId = Dwt.getNextId();
	table.cellSpacing = table.cellPadding = 0;
	table.appendChild(document.createElement("tbody"));
	div.appendChild(table);
	this.getHtmlElement().appendChild(div);
	this.maxLabelWidth = 0;
	this.maxFieldWidth = 0;
	this._setMouseEventHdlrs();
	this._onMouseDown = new AjxListener(this, this._onMouseDown);
	this.addListener(DwtEvent.ONMOUSEDOWN, this._onMouseDown);
};

DwtPropertyEditor.prototype.getRelDiv = function() {
	return document.getElementById(this._relDivId);
};

DwtPropertyEditor.prototype.getTable = function() {
	return document.getElementById(this._tableId);
};

DwtPropertyEditor.prototype._onMouseDown = function(event) {
	var target = event.target;
	var tag = target.tagName.toLowerCase();
	if (tag == "input") {
		event._stopPropagation = false;
		event._returnValue = true;
		return true;
	}
	if (this._currentInputField && !this._currentInputField.onblur()) {
		event._stopPropagation = true;
		event._returnValue = false;
		return false;
	}
	try {
		while (target && tag != "tr") {
			target = target.parentNode;
			tag = target.tagName.toLowerCase();
		}
		if (target && target.__msh_doMouseDown)
			target.__msh_doMouseDown(event);
	} catch(ex) {};
};

/**
 * Call this function to retrieve an object that contains all properties,
 * indexed by name.  Any "struct" property will map to an object that contains
 * its child properties.
 *
 * For the sample schema below (see comments on initProperties()), we would
 * retrieve an object like this (dots represent the edited value, or the
 * initial value if the property wasn't modified):
 *
 *  {
 *    userName : ... ,
 *    address  : {
 *                  street   : ... ,
 *                  country  : ... ,
 *               },
 *    age      : ... ,
 *    birthday : ...
 *  }
 */
DwtPropertyEditor.prototype.getProperties = function() {
	if (this._currentInputField)
		// make sure we get the value
		this._currentInputField.onblur();
	function rec(schema) {
		var prop = {}, tmp, n = schema.length;
		for (var i = 0; i < n; ++i) {
			tmp = schema[i];
			if (tmp.type == "struct")
				prop[tmp.name] = rec(tmp.children);
			else
				prop[tmp.name] = tmp.value;
		}
		return prop;
	};
	return rec(this._schema);
};

DwtPropertyEditor.prototype.validateData = function() {
	var valid = true;
	function rec(schema) {
		var tmp, n = schema.length;
		for (var i = 0; i < n; ++i) {
			tmp = schema[i];
			if (tmp.type == "struct")
				rec(tmp.children);
			else if (!tmp._validate())
				valid = false;
		}
	};
	rec(this._schema);
	return valid;
};

/** This function will initialize the Property Editor with a given schema and
 * property set.
 *
 *  @param schema - declares which properties/types are allowed; see below
 *  @param parent - parent schema, for subproperties
 *
 * "schema" is an object that maps property names to property declaration.
 * Here's an example of what I have in mind:
 *
 *  [
 *    {
 *      label        : "User Name",
 *      id           : "userName",
 *      type         : "string",
 *      value        : "",
 *      minLength    : 4,
 *      maxLength    : 8,
 *      mustMatch    : /^[a-z][a-z0-9_]+$/i,
 *      mustNotMatch : /^(admin|root|guest)$/i
 *    },
 *    {
 *      label     : "Address",
 *      id        : "address",
 *      type      : "struct",
 *      children  : [ // this is a nested schema definition
 *              { label : "Street", id: "street", type: "string" },
 *              { label  : "Country",
 *                id     : "country",
 *                type   : "enum",
 *                item : [
 							{ label : "US", value : "US" },
 							{ label : "UK", value : "UK" },
 							{ label : "KR", value : "KR" }
 						 ] 
 				}
 *      ]
 *    },
 *    {
 *      label     : "Age",
 *      id        : "age",
 *      type      : "integer",
 *      minValue  : 18,
 *      maxValue  : 80
 *    },
 *    {
 *      label     : "Birthday",
 *      id        : "birthday",
 *      type      : "date",
 *      minValue  : "YYYY/MM/DD"  // can we restrict the DwtCalendar?
 *    }
 *  ]
 *
 * The types we will support for now are:
 *
 *   - "number" / "integer" : Allows floating point numbers or integers only.
 *     Properties: "minValue", "maxValue".
 *
 *   - "string" : Allows any string to be inserted.  "minLength", "maxLength",
 *     "mustMatch", "mustNotMatch".
 *
 *   - "password" : Same as "string", only it's not displayed.
 *
 *   - "enum" : One of the strings listed in the value.
 *
 *   - "boolean" : Checkbox that yields string value of "true" and "false".
 *
 *   - "struct" : Composite property; doesn't have a value by itself, but has
 *     child properties (the "children" array) that are defined in the same way
 *     as a toplevel property.
 *
 * All types except "struct" will allow a "value" property which is expected
 * to be of a valid type that matches all validating properties (such as
 * minLength, etc.).  The value of this property will be displayed initially
 * when the widget is constructed.
 *
 * Also, all types will support a "readonly" property.
 */
DwtPropertyEditor.prototype.initProperties = function(schema, parent) {
	if (parent == null) {
		this._schema = schema;
		parent = null;
	}
	for (var i = 0; i < schema.length; ++i)
		this._createProperty(schema[i], parent);
};

DwtPropertyEditor.prototype._createProperty = function(prop, parent) {
	var level = parent ? parent._level + 1 : 0;
	var tr = this.getTable().firstChild.appendChild(document.createElement("tr"));

	// Initialize the "prop" object with some interesting attributes...
	prop._parent = parent;
	prop._level = level;
	prop._rowElId = tr.id = Dwt.getNextId();
	prop._propertyEditor = this;

	// ... and methods.
	for (var i in DwtPropertyEditor._prop_functions)
		prop[i] = DwtPropertyEditor._prop_functions[i];

	prop._init();

	// indent if needed
	tr.className = "level-" + level;

	if (prop.visible == "false")
		tr.className += " invisible";

	if (prop.readonly)
		tr.className += " readonly";

	if (prop.type != "struct") {
		tr.className += " " + prop.type;

		// this is a simple property, create a label and value cell.
		var tdLabel = document.createElement("td");
		tdLabel.className = "label";
		
		if(prop.type=="checkboxgroup"){
			tdLabel.className+=" grouplabel";
		}
		
		tr.appendChild(tdLabel);
		var html = AjxStringUtil.htmlEncode(prop.label || prop.name);
		if (prop.required)
			html += "<span class='DwtPropertyEditor-required'>*</span>";
		tdLabel.innerHTML = html;
		var tdField = document.createElement("td");
		tdField.className = "field";
		tr.appendChild(tdField);

		switch (prop.type) {
			case "boolean" : this._createCheckbox(prop, tdField); break;
		    case "enum"    : this._createDropDown(prop, tdField); break;
		    case "date"    : this._createCalendar(prop, tdField); break;
   		    case "checkboxgroup"	:	this._createCheckBoxGroup(prop,tdField); break;		    
		    default        :
			if (this._useDwtInputField)
				this._createInputField(prop, tdField);
			else {
				tdField.innerHTML = prop._makeDisplayValue();
				tr.__msh_doMouseDown = DwtPropertyEditor.simpleClosure(prop._edit, prop);
			}
			break;
		}

		prop._fieldCellId = tdField.id = Dwt.getNextId();
		// prop._labelCellId = tdLabel.id = Dwt.getNextId();

		if (tdLabel.offsetWidth > this.maxLabelWidth)
			this.maxLabelWidth = tdLabel.offsetWidth;
		if (tdField.offsetWidth > this.maxFieldWidth)
			this.maxFieldWidth = tdField.offsetWidth;
	} else {
		var td = document.createElement("td");
		td.colSpan = 2;
		tr.appendChild(td);
		td.className = "label";
		tr.className += " expander-collapsed";
		td.innerHTML = [ "<div>", AjxStringUtil.htmlEncode(prop.label), "</div>" ].join("");
		this.initProperties(prop.children, prop);
		tr.__msh_doMouseDown = DwtPropertyEditor.simpleClosure(prop._toggle, prop);
	}

	// collapsed by default
	if (level > 0) {
		tr.style.display = "none";
		parent._hidden = true;
	}
};

// <FIXME: this will create problems when the first property is a "struct">
DwtPropertyEditor.prototype.setFixedLabelWidth = function(w) {
	try {
		this.getTable().rows[0].cells[0].style.width = (w || this.maxLabelWidth) + "px";
	} catch(ex) {};
};

DwtPropertyEditor.prototype.setFixedFieldWidth = function(w) {
	try {
		this.getTable().rows[0].cells[1].style.width = (w || this.maxFieldWidth) + "px";
	} catch(ex) {};
};
// </FIXME>

DwtPropertyEditor.prototype._setCurrentMsgDiv = function(div) {
	this._currentMsgDiv = div;
	this._currentMsgDivTimer = setTimeout(
		DwtPropertyEditor.simpleClosure(this._clearMsgDiv, this),
		DwtPropertyEditor.MSG_TIMEOUT);
};

DwtPropertyEditor.prototype._clearMsgDiv = function() {
	try {
		this._stopMsgDivTimer();
	} catch(ex) {};
	var div = this._currentMsgDiv;
	if (div) {
		div.parentNode.removeChild(div);
		this._currentMsgDiv = div = null;
		this._currentMsgDivTimer = null;
	}
};

DwtPropertyEditor.prototype._stopMsgDivTimer = function() {
	if (this._currentMsgDivTimer) {
		clearTimeout(this._currentMsgDivTimer);
		this._currentMsgDivTimer = null;
	}
};

// This is bad.  We're messing with internals.  I think there should be an
// option in DwtComposite to specify the element where to add the child, rather
// than simply getHtmlElement().appendChild(child).
DwtPropertyEditor.prototype.addChild = function(child) {
	if (!this._currentFieldCell)
		DwtComposite.prototype.addChild.call(this, child);
	else {
		this._children.add(child);
		this._currentFieldCell.appendChild(child.getHtmlElement());
	}
};

DwtPropertyEditor.prototype._createCheckbox = function(prop, target) {

	var checkbox = document.createElement("input");
	checkbox._prop = prop;
	checkbox.id = prop.name;
	checkbox.type = 'checkbox';
	
	if (checkbox.attachEvent) {
		checkbox.attachEvent("onclick",prop._onCheckboxChange);
	}
    else if (checkbox.addEventListener) {
		checkbox.addEventListener("click", prop._onCheckboxChange, false);			
	}
	
	this._children.add(checkbox);
	target.appendChild(checkbox);
    if (prop.value == 'true')
		checkbox.checked = prop.value;
};

DwtPropertyEditor.prototype._createCheckBoxGroup = function(prop, target) {
	
	var div = document.createElement("div");
	div._prop = prop;
	div.id = prop.name;
	//div._prop._checkBox = [];
	prop._checkBox = [];
	div.appendChild(document.createTextNode(prop.value));
	
	var table = document.createElement("table");
	table.id = Dwt.getNextId();
	table.border=0;
	table.cellSpacing = table.cellPadding = 0;
	table.appendChild(document.createElement("tbody"));
	
	
	for(var i=0;i<prop.checkBox.length;i++){
	var tr = document.createElement("tr");

	var tdField1 = document.createElement("td");
	tdField1.className = "field";	
	var checkBox = this._createCheckboxForGroup(prop,prop.checkBox[i],tdField1);
	tr.appendChild(tdField1);
	
	checkBox._label = prop.checkBox[i].label;
	
	var tdField2 = document.createElement("td");
	tdField2.className = "field";
	tdField2.appendChild(document.createTextNode(prop.checkBox[i].label));
	tr.appendChild(tdField2);
	
	table.firstChild.appendChild(tr);	

//	div._prop._checkBox[i]=checkBox;
	prop._checkBox[i]=checkBox;
	}
	
	div.appendChild(table);
	
	this._children.add(div);
	target.appendChild(div);
	return div;
};

DwtPropertyEditor.prototype._createCheckboxForGroup = function(parent_prop,prop, target) {
	var checkbox = document.createElement("input");
	checkbox._prop = parent_prop;
	checkbox.id = prop.name;
	checkbox.type = 'checkbox';
	if (prop.value == 'true')
		checkbox.checked = prop.value;
		if (checkbox.attachEvent) {
		    checkbox.attachEvent("onclick", parent_prop._onCheckboxGroupChange);
		}
        else if (checkbox.addEventListener) {
		    checkbox.addEventListener("click", parent_prop._onCheckboxGroupChange, false);
		}
	this._children.add(checkbox);
	target.appendChild(checkbox);
	return checkbox;
};


DwtPropertyEditor.prototype._createDropDown = function(prop, target) {
	this._currentFieldCell = target;
	var item, sel,
		i       = 0,
		options = [],
		items   = prop.item;
	while (item = items[i])
		options[i++] = new DwtSelectOption(item.value,
						   item.value == prop.value,
						   item.label);
	prop._select = sel = new DwtSelect({parent:this, options:options});
	sel.addChangeListener(new AjxListener(prop, prop._onSelectChange));
	sel.addListener(DwtEvent.ONMOUSEDOWN, this._onMouseDown);
	this._currentFieldCell = null;
};

DwtPropertyEditor.prototype._createCalendar = function(prop, target) {
	this._currentFieldCell = target;
	var btn = new DwtButton({parent:this});
	this._currentFieldCell = null;

	btn.setText(prop._makeDisplayValue());
	var menu = new DwtMenu({parent:btn, style:DwtMenu.CALENDAR_PICKER_STYLE});
	menu.setAssociatedObj(btn);
	var cal = new DwtCalendar({parent:menu});
	var date = new Date();
	date.setTime(prop.value);
	cal.setDate(date);
	cal.setSize(150, "auto");
	cal.addSelectionListener(new AjxListener(prop, prop._onCalendarSelect));
	btn.setMenu(menu);

	prop._dateButton = btn;
	prop._dateCalendar = cal;
};

DwtPropertyEditor.DWT_INPUT_FIELD_TYPES = {
	"string"    : DwtInputField.STRING,
	"password"  : DwtInputField.PASSWORD,
	"integer"   : DwtInputField.INTEGER,
	"number"    : DwtInputField.FLOAT
};

DwtPropertyEditor.prototype._createInputField = function(prop, target) {
	this._currentFieldCell = target;
	var type = DwtPropertyEditor.DWT_INPUT_FIELD_TYPES[prop.type]
		|| DwtInputField.STRING;
	var field = new DwtInputField({parent: this, type: type, initialValue: prop.value, maxLen: prop.maxLength, rows: prop.rows});
	if (type == DwtInputField.INTEGER || type == DwtInputField.FLOAT) {
		field.setValidNumberRange(prop.minValue || null,
					  prop.maxValue || null);
		if (prop.decimals != null)
			field.setNumberPrecision(prop.decimals);
	}
	if (type == DwtInputField.STRING || type == DwtInputField.PASSWORD)
		field.setValidStringLengths(prop.minLength, prop.maxLength);
	if (prop.required)
		field.setRequired(true);
	this._currentFieldCell = null;
	prop._inputField = field;
	field.setValue(prop.value);
	if (prop.readonly)
		field.setReadOnly(true);
	field.setValidationCallback(new AjxCallback(prop, prop._onDwtInputFieldValidated));
};

// these will be merged to each prop object that comes in the schema
DwtPropertyEditor._prop_functions = {

	_init : function() {
		this.type != null || (this.type = "string");
		this.value != null || (this.value = "");
		this._initialVal = this.value;

		if (this.type == "date") {
			if (!this.value) {
// 				var tmp = new Date();
// 				tmp.setHours(0);
// 				tmp.setMinutes(0);
// 				tmp.setSeconds(0);
				this.value = new Date().getTime();
			}
			if (!this.format)
				this.format = AjxDateUtil.getSimpleDateFormat().toPattern();
		}
	},

	_modified : function() {
		return this._initialVal != this.value;
	},

	_getRowEl : function() {
		return document.getElementById(this._rowElId);
	},

	_makeDisplayValue : function() {
		var val = this._getValue();
		switch (this.type) {
		    case "password" :
			val = val.replace(/./g, "*");
			break;
		    case "date" :
			var date = new Date();
			date.setTime(val);
			val = AjxDateFormat.format(this.format, date);
			break;
		}
		if (val == "")
			val = "<br />";
		else
			val = AjxStringUtil.htmlEncode(String(val));
		return val;
	},

	_display : function(visible) {
		var
			c = this.children,
			d = visible ? "" : "none";
		if (c) {
			var i = c.length;
			while (--i >= 0) {
				c[i]._getRowEl().style.display = d;
				if (!visible)
					c[i]._display(false);
			}
			this._hidden = !visible;

			// change the class name accordingly
			var tr = this._getRowEl();
			tr.className = tr.className.replace(
				/expander-[^\s]+/,
				visible ? "expander-expanded" : "expander-collapsed");
		}
	},

	_toggle : function() { this._display(this._hidden); },

	_edit : function() {
		// Depending on the type, this should probably create different
		// fields for editing.  For instance, in a "date" property we
		// would want a calendar, while in a "list" property we would
		// want a drop-down select box.

		if (this.readonly)
			return;

		switch (this.type) {
		    case "string" :
		    case "number" :
		    case "integer" :
		    case "password" :
			setTimeout(
				DwtPropertyEditor.simpleClosure(
					this._createInputField, this), 50);
			break;

// 		    default :
// 			alert("We don't support this type yet");
		}
	},

	_createInputField : function() {
		var	pe     = this._propertyEditor;
		var td     = document.getElementById(this._fieldCellId);
		var canvas = pe.getRelDiv();
		var input  = document.createElement("input");

		input.className = "DwtPropertyEditor-input " + this.type;
		input.setAttribute("autocomplete", "off");

		input.type = this.type == "password"
			? "password"
			: "text";

		var left = td.offsetLeft, top = td.offsetTop;
		if (AjxEnv.isGeckoBased) {
			--left;
			--top;
		}
		input.style.left = left + "px";
		input.style.top = top + "px";
		input.style.width = td.offsetWidth + 1 + "px";
		input.style.height = td.offsetHeight + 1 + "px";

		input.value = this._getValue();

		canvas.appendChild(input);
		input.focus();

		input.onblur = DwtPropertyEditor.simpleClosure(this._saveInput, this);
		input.onkeydown = DwtPropertyEditor.simpleClosure(this._inputKeyPress, this);

		this._propertyEditor._currentInputField = this._inputField = input;
		if (!AjxEnv.isGeckoBased)
			input.select();
		else
			input.setSelectionRange(0, input.value.length);
	},

	_getValue : function() {
		return this.value || "";
	},

	_checkValue : function(val) {
		var empty = val == "";

		if (empty) {
			if (!this.required)
				return val;
			this._displayMsg(AjxMsg.valueIsRequired);
			return null;
		}

		if (this.maxLength != null && val.length > this.maxLength) {
			this._displayMsg(AjxMessageFormat.format(AjxMsg.stringTooLong, this.maxLength));
			return null;
		}

		if (this.minLength != null && val.length < this.minLength) {
			this._displayMsg(AjxMessageFormat.format(AjxMsg.stringTooShort, this.minLength));
			return null;
		}

		if (this.mustMatch && !this.mustMatch.test(val)) {
			this._displayMsg(this.msg_mustMatch ||
					 DwtPropertyEditor.MSG.mustMatch.replace(
						 /REGEXP/, this.mustMatch.toString()));
			return null;
		}

		if (this.mustNotMatch && this.mustNotMatch.test(val)) {
			this._displayMsg(this.msg_mustNotMatch ||
					 DwtPropertyEditor.MSG.mustNotMatch.replace(
						 /REGEXP/, this.mustNotMatch.toString()));
			return null;
		}

		switch (this.type) {
		    case "integer" :
		    case "number" :
			var n = new Number(val);
			if (isNaN(n)) {
				this._displayMsg(AjxMsg.notANumber);
				return null;
			}
			if (this.type == "integer" && Math.round(n) != n) {
				this._displayMsg(AjxMsg.notAnInteger);
				return null;
			}
			if (this.minValue != null && n < this.minValue) {
				this._displayMsg(AjxMessageFormat.format(AjxMsg.numberLessThanMin, this.minValue));
				return null;
			}
			if (this.maxValue != null && n > this.maxValue) {
				this._displayMsg(AjxMessageFormat.format(AjxMsg.numberMoreThanMax, this.maxValue));
				return null;
			}
			val = n;
			if (this.type == "number" && this.decimals != null) {
				var str = val.toString();
				var pos = str.indexOf(".");
				if (pos == -1)
					pos = str.length;
				val = val.toPrecision(pos + this.decimals);
			}
			break;
		}
		return val;
	},

	_displayMsg : function(msg) {
		var x, y, w, h;
		var pe  = this._propertyEditor;
		var div = pe._currentMsgDiv;

		if (!div) {
			div = document.createElement("div");
			div.className = "DwtPropertyEditor-ErrorMsg";
			pe.getRelDiv().appendChild(div);
		} else
			pe._stopMsgDivTimer();
		div.style.visibility = "hidden";
		div.innerHTML = AjxStringUtil.htmlEncode(msg);
		// position & size
		var table = pe.getTable();
		w = table.offsetWidth; // padding & border!
		if (!AjxEnv.isIE)
			w -= 12;
		x = table.offsetLeft;
		div.style.left = x + "px";
		div.style.width = w + "px";
		h = div.offsetHeight;
		var td = document.getElementById(this._fieldCellId);
		y = td.offsetTop + td.offsetHeight;
		if (y + h > table.offsetTop + table.offsetHeight)
			y = td.offsetTop - h;
		div.style.top = y + "px";
		div.style.visibility = "";
		pe._setCurrentMsgDiv(div);
	},

	_saveInput : function() {
		var input = this._inputField;
		var val = this._checkValue(input.value);
		if (val != null) {
			this._setValue(val);
			input.onblur = input.onkeyup = input.onkeydown = input.onkeypress = null;
			var td = document.getElementById(this._fieldCellId);
			td.innerHTML = this._makeDisplayValue();
			this._inputField = null;
			this._propertyEditor._currentInputField = null;
			this._propertyEditor._clearMsgDiv();
			input.parentNode.removeChild(input);
			return true;
		} else {
			if (input.className.indexOf(" DwtPropertyEditor-input-error") == -1)
				input.className += " DwtPropertyEditor-input-error";
			input.focus();
			return false;
		}
	},

	_inputKeyPress : function(ev) {
		ev || (ev = window.event);
		var input = this._inputField;
		if (ev.keyCode == 13) {
			this._saveInput();
		} else if (ev.keyCode == 27) {
			input.value = this._getValue();
			this._saveInput();
		} else {
			this._propertyEditor._clearMsgDiv();
			input.className = input.className.replace(/ DwtPropertyEditor-input-error/, "");
		}
	},

	_onCheckboxChange : function(ev) {
		ev || (ev = window.event);
		var el = AjxEnv.isIE ? ev.srcElement : ev.target;
		el._prop._setValue(el.checked ? "true" : "false");
	},

	_onSelectChange : function() {
		this._setValue(this._select.getValue());
	},

	_onCheckboxGroupChange	:	function(ev) {
		ev || (ev = window.event);
		var el = AjxEnv.isIE ? ev.srcElement : ev.target;
		var chkBxs=el._prop._checkBox;
		var val = [];
		for(var i=0;i<chkBxs.length;i++){
			if(chkBxs[i].checked){
				val.push(chkBxs[i]._label);
			}
		}
		el._prop._setValue(val);
	},	

	_onCalendarSelect : function() {
		this._setValue(this._dateCalendar.getDate().getTime());
		this._dateButton.setText(this._makeDisplayValue());
	},

	_onDwtInputFieldValidated : function(dwtField, validated, value) {
		if (validated)
			this._setValue(value);
	},

	_setValue : function(val) {
		this.value = val;
		var tr = this._getRowEl();
		tr.className = tr.className.replace(/ dirty/, "");
		if (this._modified())
			tr.className += " dirty";
	},

	_validate : function() {
		if (this._inputField) {
			if (this._inputField instanceof DwtInputField)
				return this._inputField.validate();
			else
				return this._inputField.onblur();
		} else
			return true;
	}
};

// Since we don't like nested functions...
DwtPropertyEditor.simpleClosure = function(func, obj) {
	return function() { return func.call(obj, arguments[0]); };
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtConfirmDialog")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * Creates a confirmation dialog.
 * @class
 * This class represents a confirmation dialog.
 * 
 * @param {DwtComposite}	parent  the parent widget (the shell)
 * @param {string}		className  the CSS class
 * 
 * @extends		DwtDialog
 */
DwtConfirmDialog = function(parent, className, id, buttons, extraButtons) {
	if (arguments.length == 0) return;

    if(!buttons){
	buttons = [ DwtDialog.YES_BUTTON, DwtDialog.NO_BUTTON, DwtDialog.CANCEL_BUTTON ];
    }
	DwtDialog.call(this, {parent:parent, className:className || "DwtConfirmDialog", title:AjxMsg.confirmTitle, standardButtons:buttons, id:id, extraButtons:extraButtons});
	
	this._questionDiv = document.createElement("DIV");
	this._questionDiv.className = "DwtConfirmDialogQuestion";
	this._getContentDiv().appendChild(this._questionDiv);
	
	this.registerCallback(DwtDialog.YES_BUTTON, this._handleYesButton, this);
	this.registerCallback(DwtDialog.NO_BUTTON, this._handleNoButton, this);
	this.registerCallback(DwtDialog.CANCEL_BUTTON, this._handleCancelButton, this);
}
DwtConfirmDialog.prototype = new DwtDialog;
DwtConfirmDialog.prototype.constructor = DwtConfirmDialog;

DwtConfirmDialog.prototype.toString =
function() {
	return "DwtConfirmDialog";
};


// Public methods

/**
 * Pops up the confirmation dialog. The caller passes in the confirmation
 * question and callbacks for the Yes, No, and Cancel buttons.
 * <p>
 * <strong>Note:</strong>
 * If the callback for the No button is not specified, the confirmation
 * dialog assumes that the caller is only concerned with a Yes response
 * and hides the (presumably) extraneous Cancel button.
 * 
 * @param	{string}	questionHtml		the question HTML
 * @param	{AjxCallback}	yesCallback		the "yes" button callback
 * @param	{AjxCallback}	noCallback		the "no" button callback
 * @param	{AjxCallback}	cancelCallback		the "cancel" button callback
 * @param	{DwtPoint}	loc			the location
 */
DwtConfirmDialog.prototype.popup = 
function(questionHtml, yesCallback, noCallback, cancelCallback, loc) {
	this._questionDiv.innerHTML = questionHtml || "";
	
	this._yesCallback = yesCallback;
	this._noCallback = noCallback;
	this._cancelCallback = cancelCallback;
	
	this.setButtonVisible(DwtDialog.CANCEL_BUTTON, Boolean(noCallback));
	
	DwtDialog.prototype.popup.call(this, loc);
};

DwtConfirmDialog.prototype.popdown =
function() {
	this._yesCallback = this._noCallback = this._cancelCallback = null;
	DwtDialog.prototype.popdown.call(this);
};

// Protected methods

DwtConfirmDialog.prototype._handleYesButton =
function(ev) {
	if (this._yesCallback) this._yesCallback.run(ev);
	this.popdown();
};

DwtConfirmDialog.prototype._handleNoButton =
function(ev) {
	if (this._noCallback) this._noCallback.run(ev);
	this.popdown();
};

DwtConfirmDialog.prototype._handleCancelButton =
function(ev) {
	if (this._cancelCallback) this._cancelCallback.run(ev);
	this.popdown();
};

DwtConfirmDialog.prototype._getSeparatorTemplate =
function() {
	return "";
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtChooser")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * Creates a control that allows the user to select items from a list, and
 * places the selected items in another list.
 * @constructor
 * @class
 * This class creates and manages a control that lets the user
 * select items from a list. Two lists are maintained, one with items to select 
 * from, and one that contains the selected items. Between them are buttons 
 * to shuffle items back and forth between the two lists.
 * <p>
 * There are two types of buttons: one or more transfer buttons move items from
 * the source list to the target list, and the remove button moves items from the
 * target list to the source list. The client can specify its transfer buttons.
 * If no specification is given, there will be a single transfer button called 
 * "Add".</p>
 * <p>
 * The parent must implement search(columnItem, ascending) if column sorting
 * is supported. It should also create a subclass of {@link DwtChooser} which returns
 * the appropriate source and target list views, themselves subclasses of
 * {@link DwtChooserListView}. Those subclasses must implement _getHeaderList() and
 * _createItemHtml(item).</p>
 * <p>
 * There are two different layout styles, horizontal (with the list views at the
 * left and right) and vertical (with the list views at the top and bottom). There
 * are two different selection styles, single and multiple, which control how many
 * items may appear in the target list view. There are two different transfer modes:
 * one where items are copied between lists, and one where they're moved.</p>
 *
 * @author Conrad Damon
 *
 * @param	{hash}		params		a hash of parameters
 * @param {DwtComposite}	params.parent			the containing widget
 * @param {string}	params.className		the CSS class
 * @param {string}	params.slvClassName	the CSS class for source list view
 * @param {string}	params.tlvClassName	the CSS class for target list view
 * @param {array}	params.buttonInfo		the id/label pairs for transfer buttons
 * @param {DwtChooser.HORIZ_STYLE|DwtChooser.VERT_STYLE}	params.layoutStyle	the layout style (vertical or horizontal)
 * @param {DwtChooser.SINGLE_SELECT|DwtChooser.MULTI_SELECT}	params.selectStyle	the multi-select (default) or single-select
 * @param {constant}	params.mode			the items are moved or copied
 * @param {boolean}	params.noDuplicates	if <code>true</code>, prevent duplicates in target list
 * @param {number}	params.singleHeight	the height of list view for single select style
 * @param {number}	params.listSize		the list width (if {@link DwtChooser.HORIZ_STYLE}) or height (if {@link DwtChooser.VERT_STYLE})
 * @param {boolean}	params.sourceEmptyOk	if <code>true</code>, do not show "No Results" in source list view
 * @param {boolean}	params.allButtons		if <code>true</code>, offer "Add All" and "Remove All" buttons
 * @param {boolean}	params.hasTextField	if <code>true</code>, create a text field for user input
 * 
 * @extends		DwtComposite
 */
DwtChooser = function(params) {

	if (arguments.length == 0) return;
	DwtComposite.call(this, params.parent, params.className);

	this._slvClassName = params.slvClassName;
	this._tlvClassName = params.tlvClassName;
	this._layoutStyle = params.layoutStyle ? params.layoutStyle : DwtChooser.HORIZ_STYLE;
	this._selectStyle = params.selectStyle ? params.selectStyle : DwtChooser.MULTI_SELECT;
	this._mode = params.listStyle ? params.listStyle : DwtChooser.MODE_MOVE;
	this._noDuplicates = (params.noDuplicates !== false);
	this._singleHeight = params.singleHeight ? params.singleHeight : 45; // 45 = header row + row with icon
	this._listSize = params.listSize;
	this._sourceEmptyOk = params.sourceEmptyOk;
	this._allButtons = params.allButtons;
	this._hasTextField = params.hasTextField;

	this._handleButtonInfo(params.buttonInfo);
	this._mode = params.mode ? params.mode :
						this._hasMultiButtons ? DwtChooser.MODE_COPY : DwtChooser.MODE_MOVE;

	this._createHtml();
	this._initialize();
	
	var parentSz = params.parent.getSize();
	var listWidth = params.listWidth || parentSz.x;
	var listHeight = params.listHeight || parentSz.y;
	if (listWidth && listHeight) {
		this.resize(listWidth, listHeight);
	}

};

DwtChooser.prototype = new DwtComposite;
DwtChooser.prototype.constructor = DwtChooser;
DwtChooser.prototype.isFocusable = true;
DwtChooser.prototype.role = 'listbox';

// Consts

// layout style
/**
 * Defines a "horizontal" layout style.
 */
DwtChooser.HORIZ_STYLE	= 1;
/**
 * Defines a "vertical" layout style.
 */
DwtChooser.VERT_STYLE	= 2;

// number of items target list can hold
/**
 * Defines a "single" select.
 */
DwtChooser.SINGLE_SELECT	= 1;
/**
 * Defines a "multi" select.
 */
DwtChooser.MULTI_SELECT		= 2;

// what happens to source items during transfer
DwtChooser.MODE_COPY	= 1;
DwtChooser.MODE_MOVE	= 2;

DwtChooser.REMOVE_BTN_ID = "__remove__";
DwtChooser.ADD_ALL_BTN_ID = "__addAll__";
DwtChooser.REMOVE_ALL_BTN_ID = "__removeAll__";

DwtChooser.prototype.toString = 
function() {
	return "DwtChooser";
};

/**
 * Sets the given list view with the given list. Defaults to source view.
 *
 * @param {AjxVector|Array|Object|Hash}	items			a list of items or hash of lists
 * @param {DwtChooserListView.SOURCE|DwtChooserListView.TARGET}	view			the view to set
 * @param {boolean}	clearOtherView	if <code>true</code>, clear out other view
 */
DwtChooser.prototype.setItems =
function(items, view, clearOtherView) {
	view = view ? view : DwtChooserListView.SOURCE;
	this._reset(view);
	this.addItems(items, view, true);
	this._selectFirst(view);
	if (clearOtherView) {
		this._reset((view == DwtChooserListView.SOURCE) ? DwtChooserListView.TARGET : DwtChooserListView.SOURCE);
	}
};	
	
/**
 * Gets a copy of the items in the given list. If that's the target list and 
 * there are multiple transfer buttons, then a hash with a vector for each one
 * is returned. Otherwise, a single vector is returned. Defaults to target view.
 *
 * @param {DwtChooserListView.SOURCE|DwtChooserListView.TARGET}	view			the view to set
 * @return	{AjxVector|array|Object|hash}		the item(s)
 */
DwtChooser.prototype.getItems =
function(view) {
	view = view ? view : DwtChooserListView.TARGET;
	if (view == DwtChooserListView.SOURCE) {
		return this.sourceListView.getList().clone();
	} else {	
		if (this._hasMultiButtons) {
			var data = {};
			for (var i in this._data) {
				data[i] = this._data[i].clone();
			}
			return data;
		} else {
			return this._data[this._buttonInfo[0].id].clone();
		}
	}
};

/**
 * Adds items to the given list view.
 *
 * @param {AjxVector|array|Object|hash}	items			a list of items or hash of lists
 * @param {DwtChooserListView.SOURCE|DwtChooserListView.TARGET}	view			the view to set
 * @param {boolean}	skipNotify	if <code>true</code>, do not notify listeners
 * @param {string}	id			the button ID
 */
DwtChooser.prototype.addItems =
function(items, view, skipNotify, id) {
	view = view ? view : DwtChooserListView.SOURCE;
	var list = (items instanceof AjxVector) ? items.getArray() : (items instanceof Array) ? items : [items];
	if (view == DwtChooserListView.SOURCE) {
		for (var i = 0; i < list.length; i++) {
			this._addToSource(list[i], null, skipNotify);
		}
	} else {
		var data;
		if (this._selectStyle == DwtChooser.SINGLE_SELECT) {
			this.targetListView._resetList();
			list = (list.length > 0) ? [list[0]] : list;
		}
		for (var i = 0; i < list.length; i++) {
			this._addToTarget(list[i], id, skipNotify);
//			if (this._selectStyle == DwtChooser.SINGLE_SELECT) {
//				return;
//			}
		}
	}
	if (view == DwtChooserListView.SOURCE) {
		var list = this.sourceListView.getList();
		this._sourceSize = list ? list.size() : 0;
	}
};

/**
 * Removes items from the given list view.
 *
 * @param {AjxVector|array|Object|hash}	list			a list of items or hash of lists
 * @param {DwtChooserListView.SOURCE|DwtChooserListView.TARGET}	view			the view to set
 * @param {boolean}	skipNotify	if <code>true</code>, do not notify listeners
 */
DwtChooser.prototype.removeItems =
function(list, view, skipNotify) {
	list = (list instanceof AjxVector) ? list.getArray() : (list instanceof Array) ? list : [list];
	for (var i = 0; i < list.length; i++) {
		(view == DwtChooserListView.SOURCE) ? this._removeFromSource(list[i], skipNotify) : this._removeFromTarget(list[i], skipNotify);
	}
};

/**
 * Moves or copies items from the source list to the target list, paying attention
 * to current mode.
 *
 * @param {AjxVector|array|Object|hash}	list			a list of items or hash of lists
 * @param {string}	id			the ID of the transfer button that was used
 * @param {boolean}	skipNotify	if <code>true</code>, do not notify listeners
 */
DwtChooser.prototype.transfer =
function(list, id, skipNotify) {
	id = id ? id : this._activeButtonId;
	this._setActiveButton(id);
	if (this._mode == DwtChooser.MODE_MOVE) {
		if (this._selectStyle == DwtChooser.SINGLE_SELECT) {
			var tlist = this.targetListView.getList();
			if (tlist && tlist.size()) {
				this.remove(tlist, true);
			}
		}
		this.removeItems(list, DwtChooserListView.SOURCE, true);
	}
	this.addItems(list, DwtChooserListView.TARGET, skipNotify);
	this.sourceListView.deselectAll();
};

/**
 * Removes items from target list, paying attention to current mode. Also handles button state.
 *
 * @param {AjxVector|array|Object|hash}	list			a list of items or hash of lists
 * @param {boolean}	skipNotify	if <code>true</code>, do not notify listeners
 */
DwtChooser.prototype.remove =
function(list, skipNotify) {
	list = (list instanceof AjxVector) ? list.getArray() : (list instanceof Array) ? list : [list];
	if (this._mode == DwtChooser.MODE_MOVE) {
		for (var i = 0; i < list.length; i++) {
			var index = this._getInsertionIndex(this.sourceListView, list[i]);
			this.sourceListView.addItem(list[i], index, true);
		}
		this._sourceSize = list ? list.length : 0;
	}
	this.removeItems(list, DwtChooserListView.TARGET);
};

/**
 * Sets the select style to the given style. Performs a resize
 * in order to adjust the layout, and changes the label on the transfer button if it's
 * the default one.
 *
 * @param {DwtChooser.SINGLE_SELECT|DwtChooser.MULTI_SELECT}	style		the style single or multiple select
 * @param {boolean}	noResize	if <code>true</code>, do not perform resize
 */
DwtChooser.prototype.setSelectStyle =
function(style, noResize) {
	if (style == this._selectStyle) return;
	
	this._selectStyle = style;
	if (this._defLabel) {
		var button = this._button[this._buttonInfo[0].id];
		button.setText((style == DwtChooser.SINGLE_SELECT) ? AjxMsg.select : AjxMsg.add);
	}
	if (!noResize) {
		var curSz = this.getSize();
		this.resize(curSz.x, curSz.y);
	}
	
	// "Add All" and "Remove All" buttons only shown if MULTI_SELECT
	if (this._allButtons) {
		this._addAllButton.setVisible(style == DwtChooser.MULTI_SELECT);
		this._removeAllButton.setVisible(style == DwtChooser.MULTI_SELECT);
		this._enableButtons();
	}

	// if we're going from multi to single, preserve only the first target item
	if (style == DwtChooser.SINGLE_SELECT) {
		var list = this.targetListView.getList();
		var a = list ? list.clone().getArray() : null;
		if (a && a.length) {
			this._reset(DwtChooserListView.TARGET);
			this.addItems(a[0], DwtChooserListView.TARGET, true);
			this.targetListView.deselectAll();
			if (a.length > 1 && this._mode == DwtChooser.MODE_MOVE) {
				this.addItems(a.slice(1), DwtChooserListView.SOURCE, true);
			}
			this._enableButtons();
		}
	}
	
	this.sourceListView.setMultiSelect(style == DwtChooser.MULTI_SELECT);
	this.targetListView.setMultiSelect(style == DwtChooser.MULTI_SELECT);
};

/**
 * Resets one or both list views, and the buttons. Defaults to resetting both list views.
 *
 * @param {DwtChooser.SINGLE_SELECT|DwtChooser.MULTI_SELECT}	style		the style single or multiple select
 */
DwtChooser.prototype.reset =
function(view) {
	this._reset(view);
	this._setActiveButton(this._buttonInfo[0].id); // make first button active by default
	this._enableButtons();
	if (this._hasTextField) {
		this._textField.setValue("");
	}
};

/**
 * Resets one or both list views. Defaults to resetting both list views.
 *
 * @param {DwtChooser.SINGLE_SELECT|DwtChooser.MULTI_SELECT}	style		the style single or multiple select
 * 
 * @private
 */
DwtChooser.prototype._reset =
function(view) {
	// clear out source list view and related data
	if (!view || view == DwtChooserListView.SOURCE) {
		this.sourceListView._resetList();
	}

	// clear out target list view and related data
	if (!view || view == DwtChooserListView.TARGET) {
		this.targetListView._resetList();
		for (var i in this._data) {
			this._data[i].removeAll();
		}
	}
};

/**
 * Adds a state change listener.
 *
 * @param {AjxListener}		listener	a listener
 */
DwtChooser.prototype.addStateChangeListener = 
function(listener) {
	this.targetListView.addStateChangeListener(listener);
};

/**
 * Removes a state change listener.
 *
 * @param {AjxListener}		listener	a listener
 */
DwtChooser.prototype.removeStateChangeListener = 
function(listener) {
	this.targetListView.removeStateChangeListener(listener);
};

/**
 * Gets the source <code>&lt;divgt;</code> that contains the source list view.
 * 
 * @return	{Element}		the element
 */
DwtChooser.prototype.getSourceListView = 
function() {
	return document.getElementById(this._sourceListViewDivId);
};

/**
 * Gets the source <code>&lt;div&gt;</code> that contains the buttons
 * 
 * @return	{Element}		the element
 */
DwtChooser.prototype.getButtons = 
function() {
	return document.getElementById(this._buttonsDivId);
};

/**
 * Gets the source <code>&lt;div&gt;</code> that contains the target list view.
 * 
 * @return	{Element}		the element
 */
DwtChooser.prototype.getTargetListView = 
function() {
	return document.getElementById(this._targetListViewDivId);
};

/**
 * Gets the text input field.
 * 
 * @return	{DwtInputField}		the text input field
 */
DwtChooser.prototype.getTextField =
function() {
	return this._textField;
};

/**
 * Creates the HTML framework, with placeholders for elements which are created later.
 * 
 * @private
 */
DwtChooser.prototype._createHtml = 
function() {

	this._sourceListViewDivId	= Dwt.getNextId();
	this._targetListViewDivId	= Dwt.getNextId();
	this._buttonsDivId			= Dwt.getNextId();
	this._removeButtonDivId		= Dwt.getNextId();
	if (this._allButtons) {
		this._addAllButtonDivId		= Dwt.getNextId();
		this._removeAllButtonDivId	= Dwt.getNextId();
	}
	if (this._hasTextField) {
		this._textFieldTdId = Dwt.getNextId();
	}

	var html = [];
	var idx = 0;
	
	if (this._layoutStyle == DwtChooser.HORIZ_STYLE) {
		// start new table for list views
		html[idx++] = "<table>";
		html[idx++] = "<tr>";

		// source list
		html[idx++] = "<td id='";
		html[idx++] = this._sourceListViewDivId;
		html[idx++] = "'></td>";

		// transfer buttons
		html[idx++] = "<td valign='middle' id='";
		html[idx++] = this._buttonsDivId;
		html[idx++] = "'>";
		if (this._allButtons) {
			html[idx++] = "<div id='";
			html[idx++] = this._addAllButtonDivId;
			html[idx++] = "'></div><br>";
		}
		for (var i = 0; i < this._buttonInfo.length; i++) {
			var id = this._buttonInfo[i].id;
			html[idx++] = "<div id='";
			html[idx++] = this._buttonDivId[id];
			html[idx++] = "'></div><br>";
		}
		// remove button
		html[idx++] = "<br><div id='";
		html[idx++] = this._removeButtonDivId;
		html[idx++] = "'></div>";
		if (this._allButtons) {
			html[idx++] = "<br><div id='";
			html[idx++] = this._removeAllButtonDivId;
			html[idx++] = "'></div><br>";
		}
		html[idx++] = "</td>";

		// target list
		html[idx++] = "<td id='";
		html[idx++] = this._targetListViewDivId;
		html[idx++] = "'></td>";

		html[idx++] = "</tr>";
		
		if (this._hasTextField) {
			html[idx++] = "<tr><td>";
			html[idx++] = "<table width=100%><tr><td style='white-space:nowrap; width:1%'>";
			html[idx++] = AjxMsg.add;
			html[idx++] = ":</td><td id='";
			html[idx++] = this._textFieldTdId;
			html[idx++] = "'></td></tr></table>";
			html[idx++] = "</td><td>&nbsp;</td><td>&nbsp;</td></tr>";
		}

		html[idx++] = "</table>";
	} else {
		// source list
		html[idx++] = "<div id='";
		html[idx++] = this._sourceListViewDivId;
		html[idx++] = "'></div>";

		// transfer buttons
		html[idx++] = "<div align='center' id='";
		html[idx++] = this._buttonsDivId;
		html[idx++] = "'>";
		html[idx++] = "<table class='ZPropertySheet' cellspacing='6'><tr>";
		if (this._allButtons) {
			html[idx++] = "<td id='";
			html[idx++] = this._addAllButtonDivId;
			html[idx++] = "'></td>";
		}
		for (var i = 0; i < this._buttonInfo.length; i++) {
			var id = this._buttonInfo[i].id;
			html[idx++] = "<td id='";
			html[idx++] = this._buttonDivId[id];
			html[idx++] = "'></td>";
		}
		// remove button
		html[idx++] = "<td id='";
		html[idx++] = this._removeButtonDivId;
		html[idx++] = "'></td>";
		if (this._allButtons) {
			html[idx++] = "<td id='";
			html[idx++] = this._removeAllButtonDivId;
			html[idx++] = "'></td>";
		}
		html[idx++] = "</tr></table></div>";

		// target list
		html[idx++] = "<div id='";
		html[idx++] = this._targetListViewDivId;
		html[idx++] = "'></div>";
	}

	this.getHtmlElement().innerHTML = html.join("");
};

/*
* Takes button info and sets up various bits of internal data for later use.
*/
DwtChooser.prototype._handleButtonInfo =
function(buttonInfo) {

	if (!buttonInfo) {
		this._defLabel = (this._selectStyle == DwtChooser.SINGLE_SELECT) ? AjxMsg.select : AjxMsg.add;
		buttonInfo = [ { label: this._defLabel } ];
	}
	this._buttonInfo = buttonInfo;

	// create IDs for button elements and their containers
	this._buttonDivId = {};
	this._buttonId = {};
	if (this._buttonInfo.length == 1) {
		if (!this._buttonInfo[0].id) {
			this._buttonInfo[0].id = Dwt.getNextId("DwtChooserButtonInfo_");
		}
		this._activeButtonId = this._buttonInfo[0].id;
	}
	for (var i = 0; i < this._buttonInfo.length; i++) {
		var id = this._buttonInfo[i].id;
		this._buttonDivId[id] = Dwt.getNextId("DwtChooserButtonDiv_");
		this._buttonId[id] = Dwt.getNextId("DwtChooserButton_");
	}
	this._hasMultiButtons = (this._buttonInfo.length > 1);
};

/**
 * Creates and places elements into the DOM.
 * 
 * @private
 */
DwtChooser.prototype._initialize =
function() {

	// create and add transfer buttons
	var buttonListener = new AjxListener(this, this._transferButtonListener);
	this._button = {};
	this._buttonIndex = {};
	this._data = {};
	for (var i = 0; i < this._buttonInfo.length; i++) {
		var id = this._buttonInfo[i].id;
		this._button[id] = this._setupButton(id, this._buttonId[id], this._buttonDivId[id], this._buttonInfo[i].label);
		this._button[id].addSelectionListener(buttonListener);
		this._buttonIndex[id] = i;
		this._data[id] = new AjxVector();
	}

	// create and add source list view
	this.sourceListView = this._createSourceListView();
	this._addListView(this.sourceListView, this._sourceListViewDivId);
	this.sourceListView.addSelectionListener(new AjxListener(this, this._sourceListener));

	// create and add target list view
	this.targetListView = this._createTargetListView();
	this._addListView(this.targetListView, this._targetListViewDivId);
	this.targetListView.addSelectionListener(new AjxListener(this, this._targetListener));

	// create and add the remove button
	this._removeButtonId = Dwt.getNextId("DwtChooserRemoveButton_");
	this._removeButton = this._setupButton(DwtChooser.REMOVE_BTN_ID, this._removeButtonId, this._removeButtonDivId, AjxMsg.remove);
	this._removeButton.addSelectionListener(new AjxListener(this, this._removeButtonListener));

	if (this._allButtons) {
		// create and add "Add All" and "Remove All" buttons
		this._addAllButtonId = Dwt.getNextId();
		this._addAllButton = this._setupButton(DwtChooser.ADD_ALL_BTN_ID, this._addAllButtonId, this._addAllButtonDivId, AjxMsg.addAll);
		this._addAllButton.addSelectionListener(new AjxListener(this, this._addAllButtonListener));
		this._removeAllButtonId = Dwt.getNextId();
		this._removeAllButton = this._setupButton(DwtChooser.REMOVE_ALL_BTN_ID, this._removeAllButtonId, this._removeAllButtonDivId, AjxMsg.removeAll);
		this._removeAllButton.addSelectionListener(new AjxListener(this, this._removeAllButtonListener));
		if (this._selectStyle == DwtChooser.SINGLE_SELECT) {
			this._addAllButton.setVisible(false);
			this._removeAllButton.setVisible(false);
		}
	}

	if (this._hasTextField) {
		var params = {parent: this, type: DwtInputField.STRING};
		this._textField = new DwtInputField(params);
		this._textField.reparentHtmlElement(this._textFieldTdId);
		this._textField._chooser = this;
		this._textField.setHandler(DwtEvent.ONKEYUP, DwtChooser._onKeyUp);
		Dwt.setSize(this._textField.getInputElement(), "100%", Dwt.DEFAULT);
	}

	if (this._selectStyle == DwtChooser.SINGLE_SELECT) {
		this.sourceListView.setMultiSelect(false);
		this.targetListView.setMultiSelect(false);
	}
};

DwtChooser.prototype.getTabGroupMember =
function() {
	var tg = new DwtTabGroup(this.toString());
	tg.addMember(this.sourceListView);
	for (var i = 0; i < this._buttonInfo.length; i++) {
		tg.addMember(this._button[this._buttonInfo[i].id]);
	}
	tg.addMember(this._removeButton);
	if (this._addAllButton) {
		tg.addMember(this._addAllButton);
		tg.addMember(this._removeAllButton);
	}
	if (this._hasTextField) {
		tg.addMember(this._textField);
	}
	tg.addMember(this.targetListView);
	return tg;
};

/**
 * Returns a source list view object.
 * 
 * @private
 */
DwtChooser.prototype._createSourceListView =
function() {
	return new DwtChooserListView(this, DwtChooserListView.SOURCE, this._slvClassName);
};

/**
 * Returns a target list view object.
 * 
 * @private
 */
DwtChooser.prototype._createTargetListView =
function() {
	return new DwtChooserListView(this, DwtChooserListView.TARGET, this._tlvClassName);
};

/**
 * Adds a list view into the DOM and sets its size to fit in its container.
 *
 * @param listView		[DwtChooserListView]	the list view
 * @param listViewDivId	[string]				ID of container DIV
 * 
 * @private
 */
DwtChooser.prototype._addListView =
function(listView, listViewDivId) {
	var listDiv = document.getElementById(listViewDivId);
 	listDiv.appendChild(listView.getHtmlElement());
	listView.setUI(null, true); // renders headers and empty list
	listView._initialized = true;
};

/**
 * Sizes the list views based on the given available width and height.
 *
 * @param {number}	width	the width (in pixels)
 * @param {number}	height	the height (in pixels)
 */
DwtChooser.prototype.resize =
function(width, height) {
	if (!width || !height) return;
	if (width == Dwt.DEFAULT && height == Dwt.DEFAULT) return;

	var buttonsDiv = document.getElementById(this._buttonsDivId);
	var btnSz = Dwt.getSize(buttonsDiv);
	var w, sh, th;
	if (this._layoutStyle == DwtChooser.HORIZ_STYLE) {
		w = this._listSize ? this._listSize : (width == Dwt.DEFAULT) ? width : Math.floor(((width - btnSz.x) / 2) - 12);
		sh = th = height;
	} else {
		w = width;
		if (this._selectStyle == DwtChooser.SINGLE_SELECT) {
			sh = this._listSize ? this._listSize : (height == Dwt.DEFAULT) ? height : height - btnSz.y - this._singleHeight - 30;
			th = (height == Dwt.DEFAULT) ? height : height - btnSz.y - sh - 30;
		} else {
			sh = th = this._listSize ? this._listSize : (height == Dwt.DEFAULT) ? height : Math.floor(((height - btnSz.y) / 2) - 12);
		}
	}
	this.sourceListView.setSize((w == Dwt.DEFAULT) ? w : w+2, sh);
	this.targetListView.setSize((w == Dwt.DEFAULT) ? w : w+2, th);
};

/**
 * Creates a transfer or remove button.
 *
 * @param {string}	id					the button ID
 * @param {string}	buttonId			the ID of button element
 * @param {string}	buttonDivId		the ID of DIV that contains button
 * @param {string}	label				the button text
 * 
 * @private
 */
DwtChooser.prototype._setupButton =
function(id, buttonId, buttonDivId, label) {
	var button = new DwtButton({parent:this, id:buttonId});
	button.setText(label);
	button.id = buttonId;
	button._buttonId = id;

	var buttonDiv = document.getElementById(buttonDivId);
	buttonDiv.appendChild(button.getHtmlElement());

	return button;
};

// Listeners

/**
 * Single-click selects an item, double-click adds selected items to target list.
 *
 * @param {DwtEvent}	ev		the click event
 * 
 * @private
 */
DwtChooser.prototype._sourceListener =
function(ev) {
	if (ev.detail == DwtListView.ITEM_DBL_CLICKED) {
		// double-click performs transfer
		this.transfer(this.sourceListView.getSelection(), this._activeButtonId);
		this.sourceListView.deselectAll();
	} else if (this._activeButtonId == DwtChooser.REMOVE_BTN_ID) {
		// single-click activates appropriate transfer button if needed
		var id = this._lastActiveTransferButtonId ? this._lastActiveTransferButtonId : this._buttonInfo[0].id;
		this._setActiveButton(id);
	}
	this.targetListView.deselectAll();
	this._enableButtons();
};

/**
 * Single-click selects an item, double-click removes it from the target list.
 *
 * @param {DwtEvent}		ev		the click event
 * 
 * @private
 */
DwtChooser.prototype._targetListener =
function(ev) {
	if (ev.detail == DwtListView.ITEM_DBL_CLICKED) {
		this.remove(this.targetListView.getSelection());
	} else {
		this._setActiveButton(DwtChooser.REMOVE_BTN_ID);
		this.sourceListView.deselectAll();
		this._enableButtons();
	}
};

/**
 * Clicking a transfer button moves selected items to the target list.
 *
 * @param {DwtEvent}		ev		the click event
 * 
 * @private
 */
DwtChooser.prototype._transferButtonListener =
function(ev) {
	var button = DwtControl.getTargetControl(ev);
	var id = button._buttonId;
	var sel = this.sourceListView.getSelection();
	if (sel && sel.length) {
		this.transfer(sel, id);
		this._enableButtons();
	} else {
		var email = this._getEmailFromText();
		if (email) {
			this.transfer([email], id);
		} else {
			this._setActiveButton(id);
		}
	}
};

/**
 * Clicking the remove button removes selected items from the target list.
 *
 * @param {DwtEvent}		ev		the click event
 * 
 * @private
 */
DwtChooser.prototype._removeButtonListener =
function(ev) {
	this.remove(this.targetListView.getSelection());
	var list = this.targetListView.getList();
	if (list && list.size()) {
		this._selectFirst(DwtChooserListView.TARGET);
	} else {
		this._enableButtons();
	}
};

/**
 * Populates the target list with all items.
 *
 * @param {DwtEvent}		ev		the click event
 * 
 * @private
 */
DwtChooser.prototype._addAllButtonListener =
function(ev) {
	this.transfer(this.sourceListView.getList().clone());
	this._selectFirst(DwtChooserListView.TARGET);
};

/**
 * Clears the target list.
 *
 * @param {DwtEvent}		ev		the click event
 * 
 * @private
 */
DwtChooser.prototype._removeAllButtonListener =
function(ev) {
	this.remove(this.targetListView.getList().clone());
	this._selectFirst(DwtChooserListView.SOURCE);
};



// Miscellaneous methods

/**
 * Enable/disable buttons as appropriate.
 *
 * @private
 */
DwtChooser.prototype._enableButtons =
function(sForce, tForce) {
	var sourceList = this.sourceListView.getList();
	var targetList = this.targetListView.getList();
	var sourceEnabled = (sForce || (this.sourceListView.getSelectionCount() > 0));
	for (var i = 0; i < this._buttonInfo.length; i++) {
		var id = this._buttonInfo[i].id;
		this._button[id].setEnabled(sourceEnabled);
	}
	var targetEnabled = (tForce || (this.targetListView.getSelectionCount() > 0));
	this._removeButton.setEnabled(targetEnabled);

	if (this._allButtons && (this._selectStyle == DwtChooser.MULTI_SELECT)) {
		var sourceSize = sourceList ? sourceList.size() : 0;
		var targetSize = targetList ? targetList.size() : 0;
		this._addAllButton.setEnabled(sourceSize > 0);
		this._removeAllButton.setEnabled(targetSize > 0);
	}
};

/**
 * Selects the first item in the given list view.
 *
 * @param {constant}	view	the source or target
 * 
 * @private
 */
DwtChooser.prototype._selectFirst =
function(view, index) {
	var listView = (view == DwtChooserListView.SOURCE) ? this.sourceListView : this.targetListView;
	var list = listView.getList();
	if (list && list.size() > 0) {
		listView.setSelection(list.get(0));
	}
};

/**
 * Makes a button "active" (the default for double-clicks). Done by
 * manipulating the style class. The active/non-active class is set as the
 * "_origClassName" so that activation/triggering still work. This only
 * applies if there are multiple transfer buttons.
 *
 * @param {string}	id		the ID of button to make active
 * 
 * @private
 */
DwtChooser.prototype._setActiveButton =
function(id) {
	if (!this._hasMultiButtons) {
		return;
	}
	if (id != this._activeButtonId) {
		var buttonId = (this._activeButtonId == DwtChooser.REMOVE_BTN_ID) ? this._removeButtonId : this._buttonId[this._activeButtonId];
		if (buttonId) {
			var oldButton = DwtControl.findControl(document.getElementById(buttonId));
			if (oldButton) {
				oldButton.setDisplayState(DwtControl.NORMAL);
			}
		}
		buttonId = (id == DwtChooser.REMOVE_BTN_ID) ? this._removeButtonId : this._buttonId[id];
		var button = DwtControl.findControl(document.getElementById(buttonId));
		if (button) {
			button.setDisplayState(DwtControl.DEFAULT);
		}
		this._activeButtonId = id;
		if (id != DwtChooser.REMOVE_BTN_ID) {
			this._lastActiveTransferButtonId = id;
		}
	}
};

/**
 * Returns true if the list contains the item. Default implementation is identity.
 *
 * @param {Object}	item	the item
 * @param {AjxVector}	list	the list to check against
 * 
 * @private
 */
DwtChooser.prototype._isDuplicate =
function(item, list) {
	return list.contains(item);
};

/**
 * Adds an item to the end of the source list.
 *
 * @param {Object}	item		the item to add
 * @param {boolean}	skipNotify	if <code>true</code>, don't notify listeners
 * 
 * @private
 */
DwtChooser.prototype._addToSource =
function(item, index, skipNotify) {
	if (!item) return;
	if (!item._chooserIndex) {
		var list = this.sourceListView.getList();
		item._chooserIndex = list ? list.size() + 1 : 1;
	}
	this.sourceListView.addItem(item, index, skipNotify);
};

/**
 * Adds an item to the target list. If there are multiple transfer buttons, it keeps
 * the items grouped depending on which button was used to move them.
 *
 * @param {Object}	item		the item to add
 * @param {string}	id			the ID of the transfer button that was used
 * @param {boolean}	skipNotify	if <code>true</code>, don't notify listeners
 * 
 * @private
 */
DwtChooser.prototype._addToTarget =
function(item, id, skipNotify) {
	if (!item) return;
	id = id ? id : this._activeButtonId;
	if (this._noDuplicates && this._data[id] && this._isDuplicate(item, this._data[id])) {
		return;
	}

	// item is being added to target list with multiple transfer buttons,
	// so we need to clone it on second and subsequent transfers
	var list = this.targetListView.getList();
	if (list && list.contains(item) && item.clone) {
		var newItem = item.clone();
		newItem.id = Dwt.getNextId();
		item = newItem;
	}

	var idx = null;
	if (this._hasMultiButtons) {
		// get a list of all the items in order
		list = [];
		for (var i = 0; i < this._buttonInfo.length; i++) {
			list = list.concat(this._data[this._buttonInfo[i].id].getArray());
		}
		// find the first item with a higher button index
		var buttonIdx = this._buttonIndex[id];
		for (idx = 0; idx < list.length; idx++) {
			var testButtonIdx = this._buttonIndex[list[idx]._buttonId];
			if (testButtonIdx > buttonIdx) {
				break;
			}
		}
	}

	item._buttonId = id;
	item.id = item.id || Dwt.getNextId();
	this._data[id].add(item);
	this.targetListView.addItem(item, idx, skipNotify);
};

/**
 * Removes an item from the source list.
 *
 * @param {Object}	item		the item to remove
 * @param {boolean}	skipNotify	if <code>true</code>, don't notify listeners
 * 
 * @private
 */
DwtChooser.prototype._removeFromSource =
function(item, skipNotify) {
	if (!item) return;
	var list = this.sourceListView.getList();
	if (!list) return;
	if (!list.contains(item)) return;

	this.sourceListView.removeItem(item, skipNotify);
};

/**
 * Removes an item from the target list.
 *
 * @param {Object}	item		the item to remove
 * @param {boolean}	skipNotify	if <code>true</code>, don't notify listeners
 * 
 * @private
 */
DwtChooser.prototype._removeFromTarget =
function(item, skipNotify) {
	if (!item) return;
	var list = this.targetListView.getList();
	if (!list) return;
	if (!list.contains(item)) return;

	this._data[item._buttonId].remove(item);
	this.targetListView.removeItem(item, skipNotify);
};

DwtChooser.prototype._getInsertionIndex =
function(view, item) {
	var list = view.getList();
	if (!list) return null;
	var a = list.getArray();
	for (var i = 0; i < a.length; i++) {
		if (item._chooserIndex && a[i]._chooserIndex && (a[i]._chooserIndex >= item._chooserIndex)) {
			return i;
		}
	}
	return null;
};

DwtChooser.prototype._getEmailFromText =
function() {
	if (this._hasTextField) {
		var text = this._textField.getValue();
		var email = AjxEmailAddress.parse(text);
		if (email) {
			email.id = Dwt.getNextId();
			return email;
		}
	}
};

DwtChooser._onKeyUp =
function(ev) {
	var el = DwtUiEvent.getTarget(ev);
	var obj = DwtControl.findControl(el);	// DwtInputField
	var chooser = obj._chooser;
	var key = DwtKeyEvent.getCharCode(ev);
	if (DwtKeyEvent.IS_RETURN[key]) {
		var email = chooser._getEmailFromText();
		if (email) {
			chooser.transfer([email], chooser._activeButtonId);
			el.value = "";
		}
	}
	chooser._enableButtons(el.value.length);
};

/**
 * Creates a chooser list view.
 * @constructor
 * @class
 * This base class represents a list view which contains items that can be transferred from it
 * (source) or to it (target). Subclasses should implement  _getHeaderList(),
 * _sortColumn(), and _createItemHtml().
 *
 * @param {hash}	params		a hash of parameters
 * @param {DwtComposite}      params.parent		the containing widget
 * @param {constant}      params.type			the source or target
 * @param {string}      params.className		the CSS class
 * @param {constant}      params.view			the context for use in creating IDs
 * 
 * @extends		DwtListView
 */
DwtChooserListView = function(params) {
	
	if (arguments.length == 0) return;
	params = Dwt.getParams(arguments, DwtChooserListView.PARAMS);
	params.className = params.className || "DwtChooserListView";
	params.headerList = this._getHeaderList(parent);
	DwtListView.call(this, params);

	this.type = params.type;
	this._chooserParent = params.parent.parent;

    // create a drag source so that dragging a column header will trigger mouse capture
    this._dragSrc = new DwtDragSource(Dwt.DND_DROP_MOVE);
    this.setDragSource(this._dragSrc);
};

DwtChooserListView.PARAMS = ["parent", "type", "className", "view"];

/**
 * Defines the "source" list view type.
 */
DwtChooserListView.SOURCE = 1;
/**
 * Defines the "target" list view type.
 */
DwtChooserListView.TARGET = 2;

DwtChooserListView.prototype = new DwtListView;
DwtChooserListView.prototype.constructor = DwtChooserListView;

DwtChooserListView.prototype._getHeaderList = function() {};

DwtChooserListView.prototype.toString = 
function() {
	return "DwtChooserListView";
};

/*
* Override to handle empty results set. Always omit the "No Results" message if
* this is a target list view, or if we've been told to ignore it in the source view.
*/
DwtChooserListView.prototype.setUI =
function(defaultColumnSort, noResultsOk) {
	noResultsOk = noResultsOk ? noResultsOk : ((this.type == DwtChooserListView.TARGET) ||
												this.parent._sourceEmptyOk);
	DwtListView.prototype.setUI.call(this, defaultColumnSort, noResultsOk);
};

/**
 * DwtListView override to ignore right-clicks in list view.
 *
 * @param {Element}	clickedEl		the element that was clicked
 * @param {DwtEvent}	ev				the click event
 * 
 * @private
 */
DwtChooserListView.prototype._itemClicked = 
function(clickedEl, ev) {
	// Ignore right-clicks, we don't support action menus
	if (!ev.shiftKey && !ev.ctrlKey && ev.button == DwtMouseEvent.RIGHT) {
		return;
	} else {
		DwtListView.prototype._itemClicked.call(this, clickedEl, ev);
	}
};

/**
 * Called when a column header has been clicked.
 *
 * @param {string}	columnItem		the ID for column that was clicked
 * @param {boolean}	ascending		if <code>true</code>, sort in ascending order
 * 
 * @private
 */
DwtChooserListView.prototype._sortColumn = 
function(columnItem, ascending) {
	this._chooserParent.search(columnItem, ascending);
};

DwtChooserListView.prototype._getHeaderSashLocation =
function() {

	var el = this.getHtmlElement();
	if (Dwt.getPosition(el) == Dwt.ABSOLUTE_STYLE) {
		return DwtListView.prototype._getHeaderSashLocation.call(this);
	}

	var thisLoc = Dwt.toWindow(el, 0, 0);
	var contLoc = Dwt.toWindow(this._chooserParent.getHtmlElement(), 0, 0);
	if (!this._tmpPoint) {
		this._tmpPoint = new DwtPoint();
	}
	this._tmpPoint.x = thisLoc.x - contLoc.x;
	this._tmpPoint.y = thisLoc.y - contLoc.y;

	return this._tmpPoint;
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtSpinner")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only
/**
 * Creates a spinner control.
 * @constructor
 * @class
 * Represents a entry field for entering numeric values.  Has 2 arrow buttons
 * that can be used to increment or decrement the current value with a step
 * that can be specified.
 *
 * <h4>CSS</h4>
 * <ul>
 * <li><code>DwtSpinner</code>              -- a table that contains the spinner elements
 * <li><code>DwtSpinner-inputCell</code>    -- the TD that holds the input field
 * <li><code>DwtSpinner-btnCell</code>      -- a DIV holding the 2 arrow buttons
 * <li><code>DwtSpinner-upBtn</code>        -- the DIV button for increment operation
 * <li><code>DwtSpinner-downBtn</code>      -- the DIV button for decrement operation
 * <li><code>DwtSpinner-up-pressed</code>   -- upBtn while pressed
 * <li><code>DwtSpinner-down-pressed</code> -- downBtn while pressed
 * <li><code>DwtSpinner-disabled</code>     -- the table gets this class added when the widget is disabled
 * </ul>
 * 
 * @param	{hash}	params		a hash of parameters
 * @param {DwtComposite} params.parent 	the parent widget
 * @param {string} params.className the class name for the containing DIV (see {@link DwtControl})
 * @param {string} params.posStyle 	the positioning style (see {@link DwtControl})
 * @param {number} params.max 	the maximum value
 * @param {number} params.min 	the minimum value
 * @param {number} params.size 	size of the input field, as in <code>&lt;input size="X"&gt;</code>
 * @param {number} params.value the original value of the input field
 * @param {number} params.maxLen the maximum length of the text in the input field
 * @param {number} params.step 	the amount to add or substract when the arrow buttons are pressed
 * @param {number} [params.decimals=0] Number of decimal digits.  Specify 0 to allow only
 *                 integers (default). Pass <code>null</code> to allow float numbers but
 *                 not enforce decimals.
 * @param {string} [params.align="right"] 	the align of the input field text (see <code>dwt.css</code>)
 *
 * @author Mihai Bazon
 * 
 * @extends DwtControl
 */
DwtSpinner = function(params) {
	if (arguments.length == 0) return;
	DwtControl.call(this, { parent        : params.parent,
                                className     : params.className,
                                posStyle      : params.posStyle,
                                parentElement : params.parentElement
                              });

	// setup arguments
	this._maxValue      = params.max  != null ? params.max  : null;
	this._minValue      = params.min  != null ? params.min  : null;
	this._fieldSize     = params.size != null ? params.size : 3;
	this._origValue     = params.value     || 0;
	this._maxLen        = params.maxLen    || null;
	this._step          = params.step      || 1;
	this._decimals      = 'decimals' in params ? params.decimals : 0;
	this._align         = params.align     || null;

	// timerFunc is a closure that gets called upon timeout when the user
	// presses and holds the mouse button
	this._timerFunc = AjxCallback.simpleClosure(this._timerFunc, this);

	// upon click and hold we capture mouse events
	this._btnPressCapture = new DwtMouseEventCapture({
		targetObj:this,
		id:"DwtSpinner",
		mouseUpHdlr:AjxCallback.simpleClosure(this._stopCapture, this)
	});

	this._createElements();
};

DwtSpinner.prototype = new DwtControl;
DwtSpinner.prototype.constructor = DwtSpinner;

DwtSpinner.INIT_TIMER = 250;
DwtSpinner.SLOW_TIMER = 125;
DwtSpinner.FAST_TIMER = 33;

DwtSpinner.prototype._createElements = function() {
	var div = this.getHtmlElement();
	var id = Dwt.getNextId();
	this._idField = id;
	this._idUpButton = id + "-up";
	this._idDownButton = id + "-down";
	var html = [ "<table class='DwtSpinner' cellspacing='0' cellpadding='0'>",
		     "<tr><td rowspan='2' class='DwtSpinner-inputCell'>", "<input id='", id, "' autocomplete='off' />", "</td>",
		     "<td unselectable id='", this._idUpButton, "' class='DwtSpinner-upBtn'><div class='ImgUpArrowSmall'>&nbsp;</div></td>",
		     "</tr><tr>",
		     "<td unselectable id='", this._idDownButton, "' class='DwtSpinner-downBtn'><div class='ImgDownArrowSmall'>&nbsp;</div></td>",
		     "</tr></table>" ];


// 		     "<td><div class='DwtSpinner-btnCell'>",
// 		     "<div unselectable class='DwtSpinner-upBtn' id='", this._idUpButton, "'><div class='ImgUpArrowSmall'>&nbsp;</div></div>",
// 		     "<div unselectable class='DwtSpinner-downBtn' id='", this._idDownButton, "'><div class='ImgDownArrowSmall'>&nbsp;</div></div>",
// 		     "</div></td></tr></table>" ];
	div.innerHTML = html.join("");

	var b1 = this._getUpButton();
	b1.onmousedown = AjxCallback.simpleClosure(this._btnPressed, this, "Up");
	var b2 = this._getDownButton();
	b2.onmousedown = AjxCallback.simpleClosure(this._btnPressed, this, "Down");
// 	if (AjxEnv.isIE) {
// 		b1.ondblclick = b1.onmousedown;
// 		b2.ondblclick = b2.onmousedown;
//	}
// 	if (AjxEnv.isIE && b1.offsetHeight == 1) {
// 		// we must correct button heights for IE
// 		div = b1.parentNode;
// 		var td = div.parentNode;
// 		div.style.height = td.offsetHeight + "px";
// // 		b1.style.height = b2.style.height = td.offsetHeight / 2 + "px";
// // 		b2.style.top = "";
// // 		b2.style.bottom = "0px";
// 	}
	var input = this.getInputElement();
	if (this._maxLen)
		input.maxLength = this._maxLen;
	if (this._fieldSize)
		input.size = this._fieldSize;
	if (this._align)
		input.style.textAlign = this._align;
	if (this._origValue != null)
		this.setValue(this._origValue);

	input.onblur = AjxCallback.simpleClosure(this.setValue, this, null);
	input[(AjxEnv.isIE || AjxEnv.isOpera) ? "onkeydown" : "onkeypress"]
		= AjxCallback.simpleClosure(this.__onKeyPress, this);
};

DwtSpinner.prototype._getValidValue = function(val) {
	var n = parseFloat(val);
	if (isNaN(n) || n == null)
		n = this._lastValidValue; // note that this may be string
	if (n == null)
		n = this._minValue || 0;
	if (this._minValue != null && n < this._minValue)
		n = this._minValue;
	if (this._maxValue != null && n > this._maxValue)
		n = this._maxValue;
	// make sure it's a number
	n = parseFloat(n);
	if (this._decimals != null)
		n = n.toFixed(this._decimals);
	this._lastValidValue = n;
	return n;
};

/**
 * Gets the input element.
 * 
 * @return	{Element}	the element
 */
DwtSpinner.prototype.getInputElement = function() {
	return document.getElementById(this._idField);
};

DwtSpinner.prototype._getUpButton = function() {
	return document.getElementById(this._idUpButton);
};

DwtSpinner.prototype._getDownButton = function() {
	return document.getElementById(this._idDownButton);
};

DwtSpinner.prototype._getButton = function(direction) {
	switch (direction) {
	    case "Up"   : return this._getUpButton();
	    case "Down" : return this._getDownButton();
	}
};

DwtSpinner.prototype._setBtnState = function(dir, disabled) {
	var btn = this._getButton(dir);
	if (disabled) {
		Dwt.addClass(btn, "DwtSpinner-" + dir + "-disabled");
		btn.firstChild.className = "Img" + dir + "ArrowSmallDis";
	} else {
		Dwt.delClass(btn, "DwtSpinner-" + dir + "-disabled");
		btn.firstChild.className = "Img" + dir + "ArrowSmall";
	}
};

/**
 * Gets the value.
 * 
 * @return	{number}	the value
 */
DwtSpinner.prototype.getValue = function() {
	return parseFloat(this._getValidValue(this.getInputElement().value));
};

/**
 * Sets the value.
 * 
 * @param	{number}	val		the value
 */
DwtSpinner.prototype.setValue = function(val) {
	if (val == null)
		val = this.getInputElement().value;
	val = this._getValidValue(val);
	this.getInputElement().value = val;
	val = parseFloat(val);
	this._setBtnState("Down", this._minValue != null && this._minValue == val);
	this._setBtnState("Up", this._maxValue != null && this._maxValue == val);
};

DwtSpinner.prototype.setEnabled = function(enabled) {
	DwtControl.prototype.setEnabled.call(this, enabled);
	this.getInputElement().disabled = !enabled;
	var table = this.getHtmlElement().firstChild;
	if (!enabled)
		Dwt.addClass(table, "DwtSpinner-disabled");
	else
		Dwt.delClass(table, "DwtSpinner-disabled");
};

DwtSpinner.prototype._rotateVal = function(direction) {
	var val = this.getValue();
	switch (direction) {
	    case "Up"   : val += this._step; break;
	    case "Down" : val -= this._step; break;
	}
	this.setValue(val);
};

DwtSpinner.prototype._btnPressed = function(direction) {
	if (!this.getEnabled())
		return;
	Dwt.addClass(this._getButton(direction), "DwtSpinner-" + direction + "-pressed");
	this._direction = direction;
	this._rotateVal(direction);
	this._btnPressCapture.capture();
	this._timerSteps = 0;
	this._timer = setTimeout(this._timerFunc, DwtSpinner.INIT_TIMER);
};

DwtSpinner.prototype._timerFunc = function() {
	var v1 = this.getValue();
	this._rotateVal(this._direction);
	var v2 = this.getValue();
	this._timerSteps++;
	var timeout = this._timerSteps > 4 ? DwtSpinner.FAST_TIMER : DwtSpinner.SLOW_TIMER;
	if (v1 != v2)
		this._timer = setTimeout(this._timerFunc, timeout);
	else
		this._stopCapture();
};

DwtSpinner.prototype._stopCapture = function() {
	if (this._timer)
		clearTimeout(this._timer);
	this._timer = null;
	this._timerSteps = null;
	var direction = this._direction;
	Dwt.delClass(this._getButton(direction), "DwtSpinner-" + direction + "-pressed");
	this._direction = null;
	this._btnPressCapture.release();
	var input = this.getInputElement();
	input.focus();
	Dwt.setSelectionRange(input, 0, input.value.length);
};

DwtSpinner.prototype.__onKeyPress = function(ev) {
	if (AjxEnv.isIE)
		ev = window.event;
	var dir = null;
	switch (ev.keyCode) {
	    case 38:
		dir = "Up";
		break;
	    case 40:
		dir = "Down";
		break;
	}
	if (dir) {
		this._rotateVal(dir);
		var input = this.getInputElement();
		Dwt.setSelectionRange(input, 0, input.value.length);
	}
};

DwtSpinner.prototype.focus = function() {
	this.getInputElement().focus();
};

DwtSpinner.prototype.select = function() {
	var input = this.getInputElement();
	input.focus();
	Dwt.setSelectionRange(input, 0, input.value.length);
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtButtonColorPicker")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * Creates a button
 * @constructor
 * @class
 * This class ntegrates {@link DwtButton} with a popup {@link DwtColorPicker}. This class is useful to
 * present a color picker button with an integrated drop-down for choosing from
 * a color palette. You can use addSelectionListener to register a handler
 * that will get called when a new color is selected.  Inspect "ev.detail" to
 * retrieve the color (guaranteed to be in #RRGGBB format).
 * <p>
 * The button also features a DIV that displays the currently selected color.
 * Upon clicking that DIV, the color will be cleared (in this event, ev.detail
 * will be the empty string in your selection listener).  Note you must call
 * showColorDisplay() in order for this DIV to be displayed.
 * <p>
 * All constructor arguments are passed forward to the {@link DwtButton} constructor.
 *
 * @extends DwtButton
 * @author Mihai Bazon
 * 
 * @param {hash}	params		a hash of parameters
 * @param  {DwtComposite}     params.parent		the parent widget
 * @param  {constant}     params.style			the button style
 * @param  {string}     params.className		the CSS class
 * @param  {constant}     params.posStyle		the positioning style
 * @param  {string}     params.id			the ID to use for the control's HTML element
 * @param  {number}     params.index 		the index at which to add this control among parent's children
 * @param  {boolean}     params.allowColorInput if <code>true</code>, allow a text field to allow user to input their customized RGB value
 * @param  {boolean}     params.noFillLabel	if <code>true</code>, do not fill label
 * 
 * @extends		DwtButton
 */
DwtButtonColorPicker = function(params) {
    if (arguments.length == 0) { return; }
	params = Dwt.getParams(arguments, DwtButtonColorPicker.PARAMS);
	params.actionTiming = DwtButton.ACTION_MOUSEUP;
    DwtButton.call(this, params);

	// WARNING: we pass boolean instead of a DwtDialog because (1) we don't
	// have a dialog right now and (2) DwtMenu doesn't seem to make use of
	// this parameter in other ways than to establish the zIndex.  That's
	// unnecessarily complex :-(
	var m = new DwtMenu({parent:this, style:DwtMenu.COLOR_PICKER_STYLE});
	this.setMenu(m);
	var cp = new DwtColorPicker(m, null, null, params.noFillLabel, params.allowColorInput);
	cp.addSelectionListener(new AjxListener(this, this._colorPicked));
    this.__colorPicker = cp ;    //for xform item _DWT_COLORPICKER_
	// no color initially selected
	this.__color = "";
};

DwtButtonColorPicker.PARAMS = ["parent", "style", "className", "posStyle", "id", "index", "noFillLabel", "allowColorInput"];

DwtButtonColorPicker.prototype = new DwtButton;
DwtButtonColorPicker.prototype.constructor = DwtButtonColorPicker;

//
// Constants
//

DwtButtonColorPicker._RGB_RE = /rgb\(([0-9]{1,3}),\s*([0-9]{1,3}),\s*([0-9]{1,3})\)/;

DwtButtonColorPicker._hexdigits = [ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' ];

//
// Data
//

//MOW:  DwtButtonColorPicker.prototype.TEMPLATE = "dwt.Widgets#ZButtonColorPicker";

//
// Public methods
//

/**
 * Utility function that converts the given integer to its hexadecimal representation.
 *
 * @param {number}		n 		the number to convert
 * @param {number}		[pad] 	the number of digits in the final number (zero-padded if required)
 * @return	{string}	the hexadecimal representation
 */
DwtButtonColorPicker.toHex =
function(n, pad) {
	var digits = [];
	while (n) {
		var d = DwtButtonColorPicker._hexdigits[n & 15];
		digits.push(d);
		n = n >> 4;
	}
	if (pad != null) {
		pad -= digits.length;
		while (pad-- > 0)
			digits.push('0');
	}
	digits.reverse();
	return digits.join("");
};

/**
 * Shows the color display. Call this function to display a DIV that shows the currently
 * selected color. This DIV also has the ability to clear the current color.
 * 
 * @param	{boolean}	disableMouseOver		if <code>true</code>, disable the mouse over
 */
DwtButtonColorPicker.prototype.showColorDisplay =
function(disableMouseOver) {
    if (!this._colorEl) return;

    if (!disableMouseOver) {
		this._colorEl.onmouseover = DwtButtonColorPicker.__colorDisplay_onMouseOver;
		this._colorEl.onmouseout = DwtButtonColorPicker.__colorDisplay_onMouseOut;
		this._colorEl.onmousedown = DwtButtonColorPicker.__colorDisplay_onMouseDown;
	}
};

/**
 * Gets the color.
 * 
 * @return {string}		the currently selected color
 */
DwtButtonColorPicker.prototype.getColor =
function() {
	return this.__color;
};

/**
 * Set the current color.
 *
 * @param {string} color 		the desired color. Pass the empty string "" to clear the selection.
 */ 
DwtButtonColorPicker.prototype.setColor =
function(color) {
	// let's make sure we keep it in #RRGGBB format
	var rgb = color.match(DwtButtonColorPicker._RGB_RE);
	if (rgb) {
		color = "#" +
			DwtButtonColorPicker.toHex(parseInt(rgb[1]), 2) +
			DwtButtonColorPicker.toHex(parseInt(rgb[2]), 2) +
			DwtButtonColorPicker.toHex(parseInt(rgb[3]), 2);
	}
	this.__color = color;
    var colorEl = this._colorEl;
    if (colorEl)
		colorEl.style.backgroundColor = color;
};

//
// Protected methods
//

DwtButtonColorPicker.prototype._createHtmlFromTemplate = function(templateId, data) {
    DwtButton.prototype._createHtmlFromTemplate.call(this, templateId, data);

	// set the color display bit inside the title of the widget
	var displayHtml = AjxTemplate.expand('dwt.Widgets#ZButtonColorDisplay', data);
	this.setText(displayHtml);

    this._colorEl = document.getElementById(data.id+"_color");
};


// override "_setMinWidth" since that doesn't apply for this type of button
DwtButtonColorPicker.prototype._setMinWidth = function() {}


/// Protected function that is called when a color is chosen from the popup
/// DwtColorPicker.  Sets the current color to the chosen one and calls the
/// DwtButton's selection handlers if any.
DwtButtonColorPicker.prototype._colorPicked = function(ev) {

	var color = ev.detail || '#000000';
	this.__color = this.__detail = color;
    var colorEl = this._colorEl;
    if (colorEl) {
		colorEl.style.backgroundColor = color;
	}
	if (this.isListenerRegistered(DwtEvent.SELECTION)) {
		var selEv = DwtShell.selectionEvent;
		// DwtUiEvent.copy(selEv, ev);
		selEv.item = this;
		selEv.detail = color;
		this.notifyListeners(DwtEvent.SELECTION, selEv);
	}
};

//
// Private methods
//

/// When the color display DIV is hovered, we show a small "X" icon to suggest
/// the end user that the selected color can be cleared.
DwtButtonColorPicker.prototype.__colorDisplay_onMouseOver =
function(ev, div) {
	if (!this.getEnabled())
		return;
	Dwt.addClass(div, "ImgDisable");
};

DwtButtonColorPicker.prototype.__colorDisplay_onMouseOut =
function(ev, div) {
	if (!this.getEnabled())
		return;
	Dwt.delClass(div, "ImgDisable");
};

/// Clears the selected color.  This function is called when the color display
/// DIV is clicked.
DwtButtonColorPicker.prototype.__colorDisplay_onMouseDown =
function(ev, div) {
	if (!this.getEnabled())
		return;
	var dwtev = DwtShell.mouseEvent;
	dwtev.setFromDhtmlEvent(ev);
	this.__color = this.__detail = div.style.backgroundColor = "";

 	if (this.isListenerRegistered(DwtEvent.SELECTION)) {
 		var selEv = DwtShell.selectionEvent;
 		// DwtUiEvent.copy(selEv, ev);
 		selEv.item = this;
 		selEv.detail = "";
 		this.notifyListeners(DwtEvent.SELECTION, selEv);
 	}

	dwtev._stopPropagation = true;
	dwtev._returnValue = false;
	dwtev.setToDhtmlEvent(ev);
	return false;
};

// static event dispatchers

DwtButtonColorPicker.__colorDisplay_onMouseOver =
function(ev) {
	var obj = DwtControl.getTargetControl(ev);
	obj.__colorDisplay_onMouseOver(ev, this);
};

DwtButtonColorPicker.__colorDisplay_onMouseOut =
function(ev) {
	var obj = DwtControl.getTargetControl(ev);
	obj.__colorDisplay_onMouseOut(ev, this);
};

DwtButtonColorPicker.__colorDisplay_onMouseDown =
function(ev) {
	var obj = DwtControl.getTargetControl(ev);
	obj.__colorDisplay_onMouseDown(ev, this);
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtMessageComposite")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * Creates a composite that is populated from a message pattern.
 * @constructor
 * @class
 * This class allows you to create a composite that is populated from
 * a message pattern and inserts controls at the appropriate places.
 * For example, say that the message <code>MyMsg.repeatTimes</code> is
 * defined as the following:
 * <pre>
 * MyMsg.repeatTimes = "Repeat: {0} times";
 * </pre>
 * and you want to replace "{0}" with an input field or perhaps a
 * drop-down menu that enumerates a specific list of choices as part of
 * the application. To do this, you just create a
 * {@link DwtMessageComposite} and set the message format, like so:
 * <pre>
 * var comp = new DwtMessageComposite(parent);
 * comp.setFormat(MyMsg.repeatTimes);
 * </pre>
 * <p>
 * The message composite instantiates an {@link AjxMessageFormat}
 * from the specified message pattern. Then, for each segment it creates
 * static text or a {@link DwtInputField} for replacement segments
 * such as "{0}".
 * <p>
 * To have more control over the controls that are created and inserted
 * into the resulting composite, you can pass a callback object to the
 * method. Each time that a replacement segment is found in the
 * message pattern, the callback is called with the following parameters:
 * <ul>
 * <li>a reference to this message composite object;
 * <li>a reference to the segment object.
 * <li>the index at which the segment was found in the message pattern; and
 * </ul>
 * The segment object will be an instance of
 * <code>AjxMessageFormat.MessageSegment</code> and has the following
 * methods of interest:
 * <ul>
 * <li>toSubPattern
 * <li>getIndex
 * <li>getType
 * <li>getStyle
 * <li>getSegmentFormat
 * </ul>
 * <p>
 * The callback can use this information to determine whether or not
 * a custom control should be created for the segment. If the callback
 * returns <code>null</code>, a standard {@link DwtInputField} is
 * created and inserted. Note: if the callback returns a custom control,
 * it <em>must</em> be an instance of {@link AjxControl}.
 * <p>
 * Here is an example of a message composite created with a callback
 * that generates a custom control for each replacement segment:
 * <pre>
 * function createCustomControl(parent, segment, i) {
 *     return new DwtInputField(parent);
 * }
 *
 * var compParent = ...;
 * var comp = new DwtMessageComposite(compParent);
 *
 * var message = MyMsg.repeatTimes;
 * var callback = new AjxCallback(null, createCustomControl);
 * comp.setFormat(message, callback);
 * </pre>
 *
 * @author Andy Clark
 *
 * @param {Object}		params		hash of params:
 * @param {DwtComposite}	parent    the parent widget.
 * @param {string}	className 	the CSS class
 * @param {constant}	posStyle  		the position style (see {@link DwtControl})
 * @param {DwtComposite}	parent    the parent widget.
 * @param {string}	format   the message that defines the text and controls within this composite control
 * @param {AjxCallback}	[controlCallback]   the callback to create UI components (only used with format specified)
 * @param {AjxCallback}	[hintsCallback]   the callback to provide display hints for the container element of the UI component (only used with format specified)
 * 
 * @extends		DwtComposite
 */
DwtMessageComposite = function(params) {
	if (arguments.length == 0) return;

	params = Dwt.getParams(arguments, DwtMessageComposite.PARAMS);

	if (!params.className) {
		params.className = "DwtMessageComposite";
	}

	DwtComposite.call(this, params);

	this._tabGroup = new DwtTabGroup("DwtMessageComposite");

	if (params.format) {
		this.setFormat(params.format,
		               params.controlCallback,
		               params.hintsCallback);
	}
}

DwtMessageComposite.PARAMS = ['parent', 'className', 'posStyle'];

DwtMessageComposite.prototype = new DwtComposite;
DwtMessageComposite.prototype.constructor = DwtMessageComposite;
DwtMessageComposite.prototype.isDwtMessageComposite = true;

DwtMessageComposite.prototype.toString =
function() {
	return "DwtMessageComposite";
}

// Public methods

/**
 * Sets the format.
 * 
 * @param {string}	message   the message that defines the text and controls that comprise this composite
 * @param {AjxCallback}	[callback]   the callback to create UI components
 * @param {AjxCallback}	[hintsCallback]   the callback to provide display hints for the container element of the UI component
 */
DwtMessageComposite.prototype.setFormat =
function(message, callback, hintsCallback) {
    // create formatter
    this._formatter = new AjxMessageFormat(message);
    this._controls = {};

    // create HTML
    var id = this._htmlElId;
    this.getHtmlElement().innerHTML = "<table class='DwtCompositeTable' border='0' cellspacing='0' cellpadding='0'><tr valign='center'></tr></table>";
    var row = this.getHtmlElement().firstChild.rows[0];

    var segments = this._formatter.getSegments();
    for (var i = 0; i < segments.length; i++) {
        var segment = segments[i];
        var isMsgSegment = segment instanceof AjxMessageFormat.MessageSegment;

        var cid = [id,i].join("_");
        var cell = document.createElement('TD');

        cell.id = cid;
        cell.className = 'DwtCompositeCell';
        row.appendChild(cell);

        if (isMsgSegment) {
            cell.className += ' MessageControl' + segment.getIndex();
            var control = callback ? callback.run(this, segment, i) : null;
            if (!control) {
                control = new DwtInputField({parent:this, parentElement: cell});
            } else {
                control.reparentHtmlElement(cell);
            }
            this._tabGroup.addMember(control.getTabGroupMember());
            if (hintsCallback) {
                var hints = hintsCallback.run(this, segment, i);

                AjxUtil.hashUpdate(control.getHtmlElement(), hints, true);
            }

            var sindex = segment.getIndex();
            this._controls[sindex] = this._controls[sindex] || control;
        }
        else {
            control = new DwtText({parent:this, parentElement: cell});
            control.setText(segment.toSubPattern());
            this._tabGroup.addMember(control);
        }
    }
};

/**
 * Gets the format.
 * 
 * @return	{string}	the format
 */
DwtMessageComposite.prototype.format = function() {
    var args = [];
    for (var sindex in this._controls) {
        args[sindex] = this._controls[sindex].getValue();
    }
    return this._formatter.format(args);
};

DwtMessageComposite.prototype.getTabGroupMember = function() {
	return this._tabGroup;
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtRadioButtonGroup")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only


/**
 * Creates a radio button group.
 * @constructor
 * @class
 * This class implements a group of radio buttons
 *
 * @param {hash} [radios] 	a hash whose keys are the ids of the radio button elements
 * 		and whose values are the values associated with those buttons
 * @param {string} [selectedId]	the id of the button to select initially
 * 
 * TODO: this really should be a DwtComposite
 * 
 * @private
 */
DwtRadioButtonGroup = function(radios, selectedId) {
	this._radios = {};
	this._radioButtons = {};
	this._values = {};
	this._value2id = {};
	this._eventMgr = new AjxEventMgr();
	
	for (var id in radios) {
		this.addRadio(id, radios[id], (id == selectedId));
	}
};

DwtRadioButtonGroup.prototype.toString =
function() {
	return "DwtRadioButtonGroup";
};

//
// Data
//

DwtRadioButtonGroup.prototype._enabled = true;
DwtRadioButtonGroup.prototype._visible = true;

//
// Public methods
//

DwtRadioButtonGroup.prototype.addSelectionListener = function(listener) {
	return this._eventMgr.addListener(DwtEvent.SELECTION, listener);
};

DwtRadioButtonGroup.prototype.removeSelectionListener = function(listener) {
	return this._eventMgr.removeListener(DwtEvent.SELECTION, listener);
};

DwtRadioButtonGroup.prototype.setEnabled = function(enabled) {
	this._enabled = enabled;
	for (var id in this._radios) {
		this._radios[id].disabled = !enabled;
	}
};
DwtRadioButtonGroup.prototype.isEnabled = function() {
	return this._enabled;
};

DwtRadioButtonGroup.prototype.setVisible = function(visible) {
	this._visible = visible;
	for (var id in this._radioButtons) {
		this._radioButtons[id].setVisible(visible);
	}
	for (var id in this._radios) {
		Dwt.setVisible(this._radios[id], visible);
	}
};
DwtRadioButtonGroup.prototype.isVisible = function() {
	return this._visible;
};

DwtRadioButtonGroup.prototype.addRadio =
function(id, radioButtonOrValue, selected) {
	var isRadioButton = radioButtonOrValue instanceof DwtRadioButton;
	var radioButton = isRadioButton ? radioButtonOrValue : null;
	var value = radioButton ? radioButton.getValue() : radioButtonOrValue;

	this._values[id] = value;
	this._value2id[value] = id;
	var element = document.getElementById(id);
	this._radios[id] = element;
	this._radioButtons[id] = radioButton;
	var handler = AjxCallback.simpleClosure(this._handleClick, this);
	Dwt.setHandler(element, DwtEvent.ONCLICK, handler);
   	element.checked = selected;
    if (selected) {
    	this._selectedId = id;
    }
};

DwtRadioButtonGroup.prototype.getRadioByValue = function(value) {
	var id = this._value2id[value];
	return this._radios[id];
};

DwtRadioButtonGroup.prototype.getRadioButtonByValue = function(value) {
	var id = this._value2id[value];
	return this._radioButtons[id];
};

DwtRadioButtonGroup.prototype.setSelectedId =
function(id, skipNotify) {
	if (id != this._selectedId) {
		var el = document.getElementById(id);
		if (!el) return;
		el.checked = true;
		this._selectedId = id;
		if (!skipNotify) {
			var selEv = DwtShell.selectionEvent;
			selEv.reset();
			this._notifySelection(selEv);
		}
	}
};

DwtRadioButtonGroup.prototype.setSelectedValue =
function(value, skipNotify) {
	var id = this._valueToId(value);
	this.setSelectedId(id, skipNotify);
};

DwtRadioButtonGroup.prototype.getSelectedId =
function() {
	return this._selectedId;
};

DwtRadioButtonGroup.prototype.getSelectedValue =
function() {
	return this._values[this._selectedId];
};

DwtRadioButtonGroup.prototype.getValue =
function() {
	return this.getSelectedValue();
};

DwtRadioButtonGroup.prototype.getData =
function(key) {
	var selectedRadio = !AjxUtil.isUndefined(this._selectedId) && this._radioButtons[this._selectedId];
	if (selectedRadio) {
		return selectedRadio.getData(key);
	}
	// return undefined;
}

//
// Protected methods
//

DwtRadioButtonGroup.prototype._valueToId =
function(value) {
	for (var id in this._values) {
		if (this._values[id] == value) {
			return id;
		}
		if (value === true && this._values[id] == "true") {
			return id;
		}
		if (value === false && (this._values[id] == "false" || this._values[id] == "")) {
			return id;
		}
	}
	return null;
};

DwtRadioButtonGroup.prototype._notifySelection = 
function(selEv) {
    selEv.item = this;
    selEv.detail = { id: this._selectedId, value: this._values[this._selectedId] };
    this._eventMgr.notifyListeners(DwtEvent.SELECTION, selEv);
};

DwtRadioButtonGroup.prototype._handleClick = 
function(event) {
	event = DwtUiEvent.getEvent(event);

	var target = DwtUiEvent.getTarget(event);
	if (target && target.nodeName.match(/label/i)) {
        target = document.getElementById(target.getAttribute(AjxEnv.isIE ? "htmlFor" : "for"));
    }

	var id = target.id;
	// NOTE: When you use the arrows on radio button groups in FF,
	//       the radio button that is being unselected is the target
	//       of the event. So we need to check to see if this target
	//       is the one that is checked.
	if (!target.checked) {
		for (id in this._radios) {
			if (this._radios[id].checked) {
				break;
			}
		}
	}
	if (id != this._selectedId) {
		this._selectedId = id;
	    var selEv = DwtShell.selectionEvent;
	    DwtUiEvent.copy(selEv, event);
		this._notifySelection(selEv);
	}
};
}
if (AjxPackage.define("ajax.dwt.widgets.DwtForm")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * Creates a form.
 * @class
 * This class represents a form.
 * 
 * @param	{hash}	params		a hash of parameters
 * 
 * @extends		DwtComposite
 * 
 * @private
 */
DwtForm = function(params) {
	if (arguments.length == 0) return;
	params = Dwt.getParams(arguments, DwtForm.PARAMS);
	params.className = params.className || "DwtForm";
	DwtComposite.apply(this, arguments);
	this.setScrollStyle(DwtControl.SCROLL);

	// data
	this._tabGroup = new DwtTabGroup(this._htmlElId);

	// context
	this._context = {
		set: AjxCallback.simpleClosure(this.set, this),
		get: AjxCallback.simpleClosure(this.get, this)
	};

	// construct form
	this._dirty = {};
	this._ignore = {};
	this._invalid = {};
	this._errorMessages = {};
	this.setModel(params.model);
	this.setForm(params.form);
	this.reset();
};
DwtForm.prototype = new DwtComposite;
DwtForm.prototype.constructor = DwtForm;

DwtForm.prototype.toString = function() {
	return "DwtForm";
};

//
// Constants
//

DwtForm.PARAMS = DwtControl.PARAMS.concat("form", "model");

//
// Public methods
//

/**
 * Sets the value.
 * 
 * @param	{string}	id	the id
 * @param	{string}	value		the value
 * @param	{boolean}	force		if <code>true</code>, to force update
 */
DwtForm.prototype.setValue = function(id, value, force) {
	if (typeof id != "string") id = String(id);
	if (id.match(/\./) || id.match(/\[/)) {
		var parts = id.replace(/\[(\d+)\](\.)?/,".$1$2").split(".");
		var control = this.getControl(parts[0]);
		if (Dwt.instanceOf(control, "DwtForm")) {
			control.setValue(parts.slice(1).join("."), value, force);
		}
		return;
	}
	var item = this._items[id];
	if (!item) return;
	if (!force && value == item.value) return;
	this._setModelValue(id, value);
	this._setControlValue(id, value);
};

/**
 * Gets the value.
 * 
 * @param	{string}	id	the id
 * @param	{string}	defaultValue		the default value
 * @return	{string}	the value
 */
DwtForm.prototype.getValue = function(id, defaultValue) {
	if (typeof id !== "string") {
		id = String(id);
	}
	if (id.match(/\./) || id.match(/\[/)) {
		var parts = id.replace(/\[(\d+)\](\.)?/,".$1$2").split(".");
		var control = this.getControl(parts[0]);
		if (Dwt.instanceOf(control, "DwtForm")) {
			return control.getValue(parts.slice(1).join("."));
		}
		return null;
	}
	var item = this._items[id];
	if (!item) {
		return;
	}
	if (item.getter) {
		return this._call(item.getter) || defaultValue;
	}
	var value = this._getControlValue(id);
    if (value == null) {
		value = item.value;
	}

    //added <|| ""> because ... if value="" than it always returns defaultValue which could be undefined.
	return value || defaultValue || "";
};

/**
 * Gets the control for the item.
 * 
 * @param	{string}	id		the id
 * @return	{DwtControl}	the control
 */
DwtForm.prototype.getControl = function(id) {
	if (typeof id != "string") id = String(id);
	var item = this._items[id];
	return item && item.control;
};

/**
 * Checks if the id is relevant (meaning: is visible and is enabled).
 * 
 * @param	{string}	id 		the id
 * @return	 {boolean}	<code>true</code> if the item is relevant
 */
DwtForm.prototype.isRelevant = function(id) {
	return this.isVisible(id) && this.isEnabled(id);
};

DwtForm.prototype.getTabGroupMember = function() {
	return this._tabGroup;
};

// control methods

/**
 * Sets the label.
 * 
 * @param	{string}	id 		the id
 * @param	{string}	label 		the label
 */
DwtForm.prototype.setLabel = function(id, label) {
	var item = this._items[id];
	if (!item) return;
	if (label == this.getLabel(id)) return;
	var control = item.control;
	if (!control) return;
	if (control.setLabel) { control.setLabel(label); return; }
	if (control.setText) { control.setText(label); return; }
};

/**
 * Sets the image.
 *
 * @param	{string}	id 		the id
 * @param	{string}	image 	the image
 * @param	{string}	altText	alternate text for non-visual users
 */
DwtForm.prototype.setImage = function(id, image, altText) {
	var item = this._items[id];
	if (!item) {
		return;
	}
	var control = item.control;
	if (!control) {
		return;
	}
	control.setImage(image, null, altText);
};


/**
 * Gets the label.
 * 
 * @param	{string}	id 		the id
 * @return	{string}	the label
 */
DwtForm.prototype.getLabel = function(id) {
	var item = this._items[id];
	var control = item && item.control;
	if (control) {
		if (control.getLabel) return control.getLabel();
		if (control.getText) return control.getText();
	}
	return "";
};

DwtForm.prototype.setVisible = function(id, visible) {
	// set the form's visibility
	if (arguments.length == 1) {
		DwtComposite.prototype.setVisible.call(this, arguments[0]);
		return;
	}
	// set control's visibility
	var item = this._items[id];
	var control = item && item.control;
	if (!control) return;
	if (control.setVisible) {
		control.setVisible(visible);
	}
	else {
		Dwt.setVisible(control, visible);
	}
	// if there's a corresponding "*_row" element
	var el = document.getElementById([this._htmlElId, id, "row"].join("_"));
	if (el) {
		Dwt.setVisible(el, visible);
	}
};

DwtForm.prototype.isVisible = function(id) {
	// this form's visibility
	if (arguments.length == 0) {
		return DwtComposite.prototype.isVisible.call(this);
	}
	// control's visibility
	var item = this._items[id];
	var control = item && item.control;
	if (!control) return false;
	if (control.getVisible) return control.getVisible();
	if (control.isVisible) return control.isVisible();
	return  Dwt.getVisible(control);
};

/**
 * Sets the enabled flag.
 * 
 * @param	{string}	id 		the id
 * @param	{boolean}	enabled		if <code>true</code>, the item is enabled
 */
DwtForm.prototype.setEnabled = function(id, enabled) {
	// set the form enabled
	if (arguments.length == 1) {
		DwtComposite.prototype.setEnabled.call(this, arguments[0]);
		return;
	}
	// set the control enabled
	var item = this._items[id];
	var control = item && item.control;
	if (!control) return;
	if (control.setEnabled) {
		control.setEnabled(enabled);
	}
	else {
		control.disabled = !enabled;
	}
};

/**
 * Checks if the item is enabled.
 * 
 * @param	{string}	id 		the id
 * @return	{boolean}	<code>true</code> if the item is enabled
 */
DwtForm.prototype.isEnabled = function(id) {
	// this form enabled?
	if (arguments.length == 0) {
		return DwtComposite.prototype.isEnabled.call(this);
	}
	// the control enabled?
	var item = this._items[id];
	var control = item && item.control;
	if (!control) return false;
	if (control.isEnabled) return control.isEnabled();
	if (control.getEnabled) return control.getEnabled();
	return  !control.disabled;
};

/**
 * Sets the valid flag.
 * 
 * @param	{string}	id 		the id
 * @param	{boolean}	valid		if <code>true</code>, the item is valid
 */
DwtForm.prototype.setValid = function(id, valid) {
	if (typeof(id) == "boolean") {
		valid = arguments[0];
		for (id in this._items) {
			this.setValid(id, valid);
		}
		return;
	}
	if (valid) {
		delete this._invalid[id]; 
	}
	else {
		this._invalid[id] = true;
	}
};

/**
 * Checks if the item is valid.
 * 
 * @param	{string}	id 		the id
 * @return	{boolean}	<code>true</code> if the item is valid
 */
DwtForm.prototype.isValid = function(id) {
	if (arguments.length == 0 || AjxUtil.isUndefined(id)) {
		for (var id in this._invalid) {
			return false;
		}
		return true;
	}
	return !(id in this._invalid);
};

/**
 * Sets the error message.
 * 
 * @param	{string}	id 		the id
 * @param	{string}	message	the message
 */
DwtForm.prototype.setErrorMessage = function(id, message) {
	if (!id || id == "") {
		this._errorMessages = {};
		return;
	}
	if (!message) {
		delete this._errorMessages[id]; 
	} else {
		this._errorMessages[id] = message;
	}
};

/**
 * Gets the error message.
 * 
 * @param	{string}	id 		the id
 * @return	{string|array}	the message(s)
 */
DwtForm.prototype.getErrorMessage = function(id) {
	if (arguments.length == 0) {
		var messages = {};
		for (var id in this._invalid) {
			messages[id] = this._errorMessages[id];
		}
		return messages;
	}
	return this._errorMessages[id];
};

DwtForm.prototype.getInvalidItems = function() {
	return AjxUtil.keys(this._invalid);
};

DwtForm.prototype.setDirty = function(id, dirty, skipNotify) {
	if (typeof id == "boolean") {
		dirty = arguments[0];
		for (id in this._items) {
			this.setDirty(id, dirty, true);
		}
		if (!skipNotify && this._ondirty) {
			this._call(this._ondirty, ["*"]);
		}
		return;
	}
	if (dirty) {
		this._dirty[id] = true;
	}
	else {
		delete this._dirty[id]; 
	}
	if (!skipNotify && this._ondirty) {
		var item = this._items[id];
		if (!item.ignore || !this._call(item.ignore)) {
			this._call(this._ondirty, [id]);
		}
	}
};
DwtForm.prototype.isDirty = function(id) {
	if (arguments.length == 0) {
		for (var id in this._dirty) {
			var item = this._items[id];
			if (item.ignore && this._call(item.ignore)) {
				continue;
			}
			return true;
		}
		return false;
	}
	var item = this._items[id];
	return item.ignore && this._call(item.ignore) ? false : id in this._dirty;
};
DwtForm.prototype.getDirtyItems = function() {
	// NOTE: This avoids needing a closure
	DwtForm.__acceptDirtyItem.form = this;
	return AjxUtil.keys(this._dirty, DwtForm.__acceptDirtyItem);
};
DwtForm.__acceptDirtyItem = function(id) {
	var form = arguments.callee.form;
	var item = form._items[id];
	return !item.ignore || !form._call(item.ignore);
};

DwtForm.prototype.setIgnore = function(id, ignore) {
	if (typeof id == "boolean") {
		this._ignore = {};
		return;
	}
	if (ignore) {
		this._ignore[id] = true;
		return;
	}
	delete this._ignore[id];
};
DwtForm.prototype.isIgnore = function(id) {
	return id in this._ignore;
};

// convenience control methods

DwtForm.prototype.set = function(id, value) {
	this.setValue(id, value, true);
	this.update();
};
DwtForm.prototype.get = DwtForm.prototype.getValue;

// properties

DwtForm.prototype.setModel = function(model, reset) {
	this._context.model = this.model = model;
};

DwtForm.prototype.setForm = function(form) {
	this._context.form = this.form = form;
	this._createHtml(form.template);
};

// form maintenance

DwtForm.prototype.validate = function(id) {
	if (arguments.length == 0) {
		this.setValid(true);
		for (var id in this._items) {
			this._validateItem(id);
		}
		return this.isValid();
	}
	return this._validateItem(id);
};

DwtForm.prototype._validateItem = function(id) {
	if (!id) return true;
	var item = this._items[id];
	if (!item) return true;
	try {
		var value = this.getValue(id);
		var outcome = item.validator ? item.validator(value) : ((item.control && item.control.validator) ? item.control.validator(value) : true);
		// the validator may return false to signify that the validation failed (but preferably throw an error with a message)
		// it may return true to signify that the field validates
		// It also may return a string or hash (truthy) that we may put into the value field (for normalization of data; e.g. if 13/10/2009 is transformed to 1/10/2010 by the validator)
		this.setValid(id, Boolean(outcome) || outcome === "");
		if (AjxUtil.isString(outcome) || AjxUtil.isObject(outcome)) {
			this._setControlValue(id, outcome); // Set display value
			item.value = item.setter ? this._call(item.setter, [outcome]) : outcome; // Set model value
			var dirty = !Boolean(this._call(item.equals, [item.value,item.ovalue]));
			this.setDirty(id, dirty);
		}
	}
	catch (e) {
		this.setErrorMessage(id, AjxUtil.isString(e) ? e : e.message);
		this.setValid(id, false);
	}
	return !(id in this._invalid);
};

DwtForm.prototype.reset = function(useCurrentValues) {
	// init state
	this._dirty = {};
	this._ignore = {};
	this._invalid = {};
	for (var id in this._items) {
		var item = this._items[id];
		if (item.control instanceof DwtForm) {
			item.control.reset(useCurrentValues);
		}
		var itemDef = this._items[id].def;
		if (!itemDef) continue;
		this._initControl(itemDef, useCurrentValues);
	}
	// update values
	this.update();
	for (var id in this._items) {
		var item = this._items[id];
		item.ovalue = item.value;
	}
	// clear state
	this.validate();
    this.setDirty(false);
	// call handler
	if (this._onreset) {
		this._call(this._onreset);
	}
};

DwtForm.prototype.update = function() {
	// update all the values first
	for (var id in this._items) {
		var item = this._items[id];
		if (item.control instanceof DwtForm) {
			item.control.update();
		}
		if (item.getter) {
			this.setValue(id, this._call(item.getter));
		}
	}
	// now set visible/enabled/ignore based on values
	for (var id in this._items) {
		var item = this._items[id];
		if (item.visible) {
			this.setVisible(id, Boolean(this._call(item.visible)));
		}
		if (item.enabled) {
			this.setEnabled(id, Boolean(this._call(item.enabled)));
		}
		if (item.ignore) {
			this.setIgnore(id, Boolean(this._call(item.ignore)));
		}
	}
	// call handler
	if (this._onupdate) {
		this._call(this._onupdate);
	}
};

//
// Protected methods
//

DwtForm.prototype._setModelValue = function(id, value) {
	var item = this._items[id];
	item.value = item.setter ? this._call(item.setter, [value]) : value;
	var dirty = !Boolean(this._call(item.equals, [item.value,item.ovalue]));
	this.setDirty(id, dirty);
	this.validate(id);
	return dirty;
};

DwtForm.prototype._setControlValue = function(id, value) {
	var control = this._items[id].control;
	if (control) {
		// TODO: display value
		if (control instanceof DwtCheckbox || control instanceof DwtRadioButton) {
			control.setSelected(value);
			return;
		}
		if (control instanceof DwtMenuItem && control.isStyle(DwtMenuItem.CHECK_STYLE)) {
			control.setChecked(value, true);
			return;
		}
		if (control.setSelectedValue) { control.setSelectedValue(value); return; }
		if (control.setValue) { control.setValue(value); return; }
		if (control.setText && !(control instanceof DwtButton)) { control.setText(value); return; }
		if (!(control instanceof DwtControl)) {
			// TODO: support other native form elements like select
			if (control.type == "checkbox" || control == "radio") {
				control.checked = value;
			}
			else {
				// TODO: handle error setting form input value
				control.value = value;
			}
			return;
		}
	}
};
DwtForm.prototype._getControlValue = function(id) {
	var control = this._items[id].control;
	if (control) {
		if (control instanceof DwtCheckbox || control instanceof DwtRadioButton) {
			return control.isSelected();
		}
		if (control.getSelectedValue) {
			return control.getSelectedValue();
		}
		if (control.getValue) {
			return control.getValue();
		}
		if (control.getText && !(control instanceof DwtButton)) {
			return control.getText();
		}
		if (!(control instanceof DwtControl)) {
			if (control.type == "checkbox" || control == "radio") return control.checked;
			return control.value;
		}
	}
};

DwtForm.prototype._deleteItem = function(id) {
	delete this._items[id];
	delete this._dirty[id];
	delete this._invalid[id];
	delete this._ignore[id];
};

// utility

DwtForm.prototype._call = function(func, args) {
	if (func) {
		if (args) return func.apply(this, args);
		// NOTE: Hack for IE which barfs with null args on apply
		return func.call(this);
	}
};

// html creation

DwtForm.prototype._createHtml = function(templateId) {
	this._createHtmlFromTemplate(templateId || this.TEMPLATE, { id: this._htmlElId });
};

DwtForm.prototype._createHtmlFromTemplate = function(templateId, data) {
	DwtComposite.prototype._createHtmlFromTemplate.apply(this, arguments);

	// initialize state
	var tabIndexes = [];
	this._items = {};
	this._tabGroup.removeAllMembers();
	this._onupdate = null;
	this._onreset = null;
	this._ondirty = null;

	// create form
	var form = this.form;
	if (form && form.items) {
		// create controls
		this._registerControls(form.items, null, tabIndexes);
		// create handlers
		this._onupdate = DwtForm.__makeFunc(form.onupdate);
		this._onreset = DwtForm.__makeFunc(form.onreset);
		this._ondirty = DwtForm.__makeFunc(form.ondirty);
	}

	// add links to list of tabIndexes
	var links = this.getHtmlElement().getElementsByTagName("A");
	for (var i = 0; i < links.length; i++) {
		var link = links[i];
		if (!link.href || link.getAttribute("notab") == "true") continue;
        var controlId = link.id && link.id.substr(this.getHTMLElId().length+1);
		if (this._items[controlId]) continue;
		tabIndexes.push({
			tabindex:	link.getAttribute("tabindex") || Number.MAX_VALUE,
			control:	link
		});
	}

	// add controls to tab group
	tabIndexes.sort(DwtForm.__byTabIndex);
	for (var i = 0; i < tabIndexes.length; i++) {
		var control = tabIndexes[i].control;
		var member = (control.getTabGroupMember && control.getTabGroupMember()) || control;
		this._tabGroup.addMember(member);
	}
};

DwtForm.prototype._registerControls = function(itemDefs, parentDef,
                                               tabIndexes, params,
                                               parent, defaultType) {
	for (var i = 0; i < itemDefs.length; i++) {
		this._registerControl(itemDefs[i], parentDef, tabIndexes, params, parent, defaultType);
	}
};

DwtForm.prototype._registerControl = function(itemDef, parentDef,
                                              tabIndexes, params,
                                              parent, defaultType) {
	// create item entry
	var id = itemDef.id || [this._htmlElId, Dwt.getNextId()].join("_");
	var item = this._items[id] = {
		id:			id, // for convenience
		def:		itemDef,
		parentDef:	parentDef,
		equals:		DwtForm.__makeFunc(itemDef.equals) || DwtForm.__equals,
		getter:		DwtForm.__makeGetter(itemDef),
		setter:		DwtForm.__makeSetter(itemDef),
		value:		itemDef.value,
		visible:	DwtForm.__makeFunc(itemDef.visible),
		enabled:	DwtForm.__makeFunc(itemDef.enabled),
		validator:	DwtForm.__makeFunc(itemDef.validator),
		ignore:		DwtForm.__makeFunc(itemDef.ignore),
		control:	itemDef.control
	};
	// NOTE: This is used internally for indexing of rows
	if (itemDef.aka) {
		this._items[id].aka = itemDef.aka;
		this._items[itemDef.aka] = item;
	}

	// is control already created?
	var control = item.control;
	if (control) {
		return control;
	}

	// create control
	parent = parent || this;
	var type = itemDef.type = itemDef.type || defaultType;
	var isMenu = (parentDef && parentDef.menu == itemDef);
	var element = document.getElementById([parent._htmlElId,id].join("_"));
	if (Dwt.instanceOf(type, "DwtRadioButtonGroup")) {
		// create control
		control = new window[type]({});
		item.control = control;

		// add children
		var nparams = {
			name:  [parent._htmlElId, id].join("_"),
			value: itemDef.value
		};
		if (itemDef.items) {
			for (var i = 0; i < itemDef.items.length; i++) {
				var radioItemDef = itemDef.items[i];
				var checked = radioItemDef.checked || radioItemDef.value == itemDef.value;
				var radio = this._registerControl(radioItemDef, itemDef, tabIndexes, nparams, parent, "DwtRadioButton");
				this._items[radioItemDef.id].value = checked;
				if (radio) {
					control.addRadio(radio.getInputElement().id, radio, checked);
					// handlers
					var handler = DwtForm.__makeFunc(radioItemDef.onclick || itemDef.onclick);
					radio.addSelectionListener(new AjxListener(this, this._radio2group2model, [radioItemDef.id, id, handler]));
					// HACK: Work around fact that the DwtRadioButtonGroup overwrites
					//       the radio button input element's onclick handler.
					DwtForm.__hack_fixRadioButtonHandler(radio);
				}
			}
		}
	}
	else if (type) {
		if (Dwt.instanceOf(type, "DwtInputField")) {
			item.value = item.value || "";
		}
		if (Dwt.instanceOf(type, "DwtFormRows")) {
		    item.equals = DwtFormRows.__equals;
		}
		if (element || isMenu) {
			control = item.control = this._createControl(itemDef, parentDef, tabIndexes, params, parent, defaultType);
		}
	}
	else if (element) {
		this._attachElementHandlers(itemDef, parentDef, tabIndexes, parent, element);
		control = item.control = element;
		if (itemDef.items) {
			this._registerControls(itemDef.items, itemDef, tabIndexes, null, parent, null);
		}
	}
	if (element && control instanceof DwtControl) {
		control.replaceElement(element);
	}
	if (element && control instanceof DwtInputField) {
		control.getInputElement().id += "_input";
		control.setHandler(DwtEvent.ONPASTE, this._onPaste.bind(this, id));
	}

	// add to list of tab indexes
	if (itemDef.notab == null) {
		itemDef.notab = element && element.getAttribute("notab") == "true";
	}
	if (tabIndexes && control && !itemDef.notab && !(control instanceof DwtRadioButtonGroup)) {
		tabIndexes.push({
			tabindex:	(element && element.getAttribute("tabindex")) || Number.MAX_VALUE,
			control:	control
		});
	}

	// clean up
	if (control instanceof DwtListView) {
		item.getter = item.getter || AjxCallback.simpleClosure(this.__list_getValue, this, id);
		item.setter = item.setter || AjxCallback.simpleClosure(this.__list_setValue, this, id);
	}

	// return control
	return control;
};


DwtForm.prototype._onPaste = function(id, evt) {
	// Delay the value processing - the paste text will not be applied to the control till after this event
	AjxTimedAction.scheduleAction(new AjxTimedAction(this, this._applyPasteInput, [id]), 100);
};

DwtForm.prototype._applyPasteInput = function(id, value) {
	this._setModelValue(id, this._getControlValue(id));
}


DwtForm.prototype._attachElementHandlers = function(itemDef, parentDef, tabIndexes, parent, element) {
	var id = itemDef.id;
	var name = element.nodeName.toLowerCase();
	var type = element.type;
	if (type == "checkbox" || type == "radio") {
		var parentId;
		if (type == "radio") {
			parentId = element.name;
			if (!this._items[parentId]) this._items[parentId] = { id: parentId };
			if (element.checked) {
				this._items[parentId].value = element.value;
			}
		}
		// checked
		var onclick = element.onclick ;
		var handler = DwtForm.__makeFunc(itemDef.onclick);
		element.onclick = AjxCallback.simpleClosure(this._htmlInput_checked, this, id, parentId, handler, onclick);
	}
	else if (name == "select") {
		// map selectedIndex to value of option
		var onchange = element.onchange;
		var handler = DwtForm.__makeFunc(itemDef.onchange);
		element.onchange = AjxCallback.simpleClosure(this._htmlSelect_selectedIndex, this, id, handler, onchange);
	}
	else if (name == "button" || name == "a" || 
	         type == "button" || type == "reset" || type == "submit") {
		// checked
		var onclick = element.onclick ;
		var handler = DwtForm.__makeFunc(itemDef.onclick);
		element.onclick = AjxCallback.simpleClosure(this._htmlElement, this, id, handler, onclick);
	}
	else if (name == "textarea" || name == "input") { // type == "text" ||  || type == "file" || type == "password") {
		// value
		var onchange = element.onchange;
		var handler = DwtForm.__makeFunc(itemDef.onchange);
		element.onchange = AjxCallback.simpleClosure(this._htmlInput_value, this, id, handler, onchange);
	}
	// TODO: attach other handlers
	return element;
};

DwtForm.prototype._createControl = function(itemDef, parentDef,
                                            tabIndexes, params,
                                            parent, defaultType) {
	var id = itemDef.id || [this._htmlElId, Dwt.getNextId()].join("_");
	var type = itemDef.type = itemDef.type || defaultType;
	params = params ? AjxUtil.createProxy(params) : {};
	params.id = params.id || [this._htmlElId, id].join("_");
	params.parent = parent || this;
	params.template = itemDef.template || params.template;
	params.className = itemDef.className || params.className;

	// constructor params for radio buttons
	var isRadioButton = Dwt.instanceOf(type, "DwtRadioButton");
	var isCheckBox = Dwt.instanceOf(type, "DwtCheckbox");
	if (isRadioButton || isCheckBox) {
		params.name = itemDef.name || params.name;
        params.value = itemDef.value || params.value;
		params.checked = itemDef.checked != null ? itemDef.checked : params.checked;
	}

	// constructor params for input fields
	var isTextField = Dwt.instanceOf(type, "DwtInputField");
	if (isTextField) {
		params.type = itemDef.password ? DwtInputField.PASSWORD : null;
		params.size = itemDef.cols;
		params.rows = itemDef.rows;
	}

	var isTabPage = Dwt.instanceOf(type, "DwtTabViewPage");
	if (isTabPage) {
		params.contentTemplate = itemDef.template;
		delete itemDef.template;
	}

    var isTree = Dwt.instanceOf(type, "DwtTree");
    if (isTree) {
        params.style = itemDef.style;
    }

	// add extra params
	params.formItemDef = itemDef;
	if (itemDef.params) {
		for (var p in itemDef.params) {
			params[p] = itemDef.params[p];
		}
	}

	// create control
	var control = new window[type](params);

	// init select
	if (control instanceof DwtSelect) {
		var options = itemDef.items;
		if (options) {
			for (var i = 0; i < options.length; i++) {
				var option = options[i];
				// convert to format that DwtSelect#addOption recognizes
				option.displayValue = option.label || option.value;
				control.addOption(option);
			}
		}
		var handler = DwtForm.__makeFunc(itemDef.onchange);
		control.addChangeListener(new AjxListener(this, this._control2model, [id, handler]));
	}

	// init button, menu item
	else if (control instanceof DwtButton || control instanceof DwtMenuItem) {
		if (itemDef.label) { control.setText(itemDef.label); }
		if (itemDef.image) { control.setImage(itemDef.image, null, itemDef.imageAltText); }
		if (itemDef.menu) {
			var isMenu = Dwt.instanceOf(itemDef.menu.type || "DwtMenu", "DwtMenu");
			var menu;
			if (isMenu) {
				menu = this._registerControl(itemDef.menu, itemDef, null, null, control, "DwtMenu");
			}
			else {
				menu = new DwtMenu({parent:control});
				var style = Dwt.instanceOf(itemDef.menu.type, "DwtCalendar") ?
							DwtMenu.CALENDAR_PICKER_STYLE : DwtMenu.GENERIC_WIDGET_STYLE;
				this._registerControl(itemDef.menu, itemDef, null, { style: style }, menu);
			}
			control.setMenu(menu);
		}
		var parentId;
		if (parent instanceof DwtToolBar || parent instanceof DwtMenu) {
			parentId = parentDef.id;
		}
		// handlers
		var handler = DwtForm.__makeFunc(itemDef.onclick || (parentDef && parentDef.onclick));
		control.addSelectionListener(new AjxListener(this, this._item2parent, [id, parentId, handler]));
	}

	// init checkbox, radio button
	else if (control instanceof DwtCheckbox && !(control instanceof DwtRadioButton)) {
		var handler = DwtForm.__makeFunc(itemDef.onclick);
		control.addSelectionListener(new AjxListener(this, this._control2model, [id, handler]));
	}

	// init input field
	else if (control instanceof DwtInputField) {
		var changehandler = DwtForm.__makeFunc(itemDef.onchange);
		var onkeyup = AjxCallback.simpleClosure(this._input2model2handler, this, id, changehandler);
		control.addListener(DwtEvent.ONKEYUP, onkeyup);
        if (AjxEnv.isFirefox){
            var onkeydown = this._onkeydownhandler.bind(this, id, changehandler);
            control.addListener(DwtEvent.ONKEYDOWN, onkeydown);
        }
		var blurhandler = DwtForm.__makeFunc(itemDef.onblur);
        if (blurhandler) {
		    var onblur = AjxCallback.simpleClosure(this._input2model2handler, this, id, blurhandler);
		    control.addListener(DwtEvent.ONBLUR, onblur);
        }

		itemDef.tooltip = itemDef.tooltip || itemDef.hint;
		control.setHint(itemDef.hint);
		control.setLabel(itemDef.label || itemDef.tooltip);
	}

	// init list
	else if (control instanceof DwtListView) {
		control.addSelectionListener(new AjxListener(this, this._handleListSelection, [id]));
	}

	// init menu
	else if (control instanceof DwtMenu) {
		if (itemDef.items) {
			var menuItemDefs = itemDef.items;
			for (var i = 0; i < menuItemDefs.length; i++) {
				var menuItemDef = menuItemDefs[i];
				if (menuItemDef.type == DwtMenuItem.SEPARATOR_STYLE) {
					new DwtMenuItem({parent:control, style:DwtMenuItem.SEPARATOR_STYLE});
					continue;
				}
				this._registerControl(menuItemDef, itemDef, null, null, control, "DwtMenuItem");
			}
		}
	}

	// init tabs
	else if (control instanceof DwtTabView) {
		var pageDefs = itemDef.items;
		if (pageDefs) {
			this._registerControls(pageDefs, itemDef, null, null, control, "DwtTabViewPage");
		}
	}

	// init tab page
	else if (control instanceof DwtTabViewPage && parent instanceof DwtTabView) {
		var key = parent.addTab(itemDef.label, control);
		if (itemDef.image) {
			parent.getTabButton(key).setImage(itemDef.image, null, itemDef.imageAltText);
		}
		if (itemDef.items) {
			this._registerControls(itemDef.items, itemDef, tabIndexes, null, control);
		}
	}

	// init toolbar
	else if (control instanceof DwtToolBar) {
		var toolbarItemDefs = itemDef.items;
		if (toolbarItemDefs) {
			for (var i = 0; i < toolbarItemDefs.length; i++) {
				var toolbarItemDef = toolbarItemDefs[i];
				if (toolbarItemDef.type == DwtToolBar.SPACER) {
					control.addSpacer(toolbarItemDef.size);
					continue;
				}
				if (toolbarItemDef.type == DwtToolBar.SEPARATOR) {
					control.addSeparator(toolbarItemDef.className);
					continue;
				}
				if (toolbarItemDef.type == DwtToolBar.FILLER) {
					control.addFiller(toolbarItemDef.className);
					continue;
				}
				this._registerControl(toolbarItemDef, itemDef, null, null, control, "DwtToolBarButton");
			}
		}
	}
	else if (control instanceof DwtCalendar) {
		if (itemDef.onselect instanceof AjxListener) {
			control.addSelectionListener(itemDef.onselect);
		}
	}

	// TODO: other controls (e.g. combobox, listview, slider, spinner, tree)

	// init anonymous composites
	else if (control instanceof DwtComposite) {
		if (itemDef.items) {
			this._registerControls(itemDef.items, itemDef, tabIndexes, null, control);
		}
	}

    // size control
    if (itemDef.width || itemDef.height) {
        if (control instanceof DwtInputField) {
            Dwt.setSize(control.getInputElement(), itemDef.width, itemDef.height);
        }
        else {
            control.setSize(itemDef.width, itemDef.height);
        }
    }

	if (itemDef.tooltip) {
		control.setToolTipContent(itemDef.tooltip);
	}

	// return control
	return control;
};

DwtForm.prototype._onkeydownhandler  = function(id, changehandler){
    setTimeout(this._input2model2handler.bind(this, id, changehandler), 500);
};

DwtForm.prototype._initControl = function(itemDef, useCurrentValues) {
	var id = itemDef.id;
	if (itemDef.label) this.setLabel(id, itemDef.label);
	var item = this._items[id];
	if (useCurrentValues) {
		item.ovalue = item.value;
	}
	else if (itemDef.value) {
		if (Dwt.instanceOf(itemDef.type, "DwtRadioButton")) {
			item.ovalue = item.value = item.control && item.control.isSelected();
		}
		else {
			this.setValue(id, itemDef.value, true);
			item.ovalue = item.value;
		}
	}
	else {
		item.ovalue = null;
	}
	if (typeof itemDef.enabled == "boolean") this.setEnabled(id, itemDef.enabled);
	if (typeof itemDef.visible == "boolean") this.setVisible(id, itemDef.visible);
};

// html handlers

DwtForm.prototype._htmlElement = function(id, formHandler, elementHandler, evt) {
	if (formHandler) {
		this._call(formHandler, [id]);
	}
	if (elementHandler) {
		elementHandler(evt);
	}
};

DwtForm.prototype._htmlInput_checked = function(id, parentId, handler, onclick, evt) {
	var control = this.getControl(id);
	var checked = control.checked;
	this._setModelValue(id, checked);
	if (parentId && checked) {
		this._setModelValue(parentId, control.value);
	}
	this.update();
	this._htmlElement(id, handler, onclick, evt);
};

DwtForm.prototype._htmlInput_value = function(id, handler, onchange, evt) {
	this._setModelValue(id, this.getControl(id).value);
	this.update();
	this._htmlElement(id, handler, onchange, evt);
};

DwtForm.prototype._htmlSelect_selectedIndex = function(id, handler, onchange, evt) {
	var select = this.getControl(id);
	this._setModelValue(id, select.options[select.selectedIndex].value);
	this.update();
	this._htmlElement(id, handler, onchange, evt);
};

// dwt handlers

DwtForm.prototype._control2model = function(id, handler) {
	this._setModelValue(id, this._getControlValue(id));
	this.update();
	if (handler) {
		this._call(handler, [id]);
	}
};

DwtForm.prototype._radio2group2model = function(radioId, groupId, handler) {
	this._setModelValue(groupId, this.getControl(radioId).getValue());
	this._setModelValue(radioId, this._getControlValue(radioId));
	this.update();
	if (handler) {
		this._call(handler, [radioId]);
	}
};

DwtForm.prototype._input2model2handler = function(id, handler) {
	this._setModelValue(id, this._getControlValue(id));
	this.update();
	if (handler) {
		this._call(handler, [id]);
	}
};

DwtForm.prototype._item2parent = function(itemId, parentId, handler) {
	var control = this.getControl(itemId);
	var itemDef = this._items[itemId].def;
	if (control instanceof DwtButtonColorPicker || (itemDef.menu && !itemDef.onclick)) {
		control._toggleMenu(); // HACK: button should have public API
	}
	else if (parentId) {
		this._setModelValue(parentId, this._getControlValue(itemId) || itemId);
		this.update();
	}
	if (handler) {
		this._call(handler, [itemId]);
	}
};

DwtForm.prototype._handleListSelection = function(id, evt) {
	this.update();
};

// setters and getters

DwtForm.prototype.__list_getValue = function(id) {
	return this.getControl(id).getSelection();
};
DwtForm.prototype.__list_setValue = function(id, value) {
	this.getControl(id).setSelection(value);
};

//
// Private functions
//

// code generation

DwtForm.__makeGetter = function(item) {
	var getter = item.getter;
	if (getter) return DwtForm.__makeFunc(getter);

	var ref = item.ref;
	if (!ref) return null;

	var parts = ref.split(".");
	var body = [
		"var context = this.model;"
	];
	for (var i = 0; i < parts.length; i++) {
		var name = parts[i];
		var fname = DwtForm.__makeFuncName(name);
		if (i == parts.length - 1) break;
		body.push(
			"context = context && (context.",fname," ? context.",fname,"() : context.",name,");"
		);
	}
	body.push(
		"var value = context ? (context.",fname," ? context.",fname,"() : context.",name,") : this._items.",name,".value;",
		"return value !== undefined ? value : defaultValue;"
	);
	return new Function("defaultValue", body.join(""));
};

DwtForm.__makeSetter = function(item) {
	var setter = item.setter;
	if (setter) return DwtForm.__makeFunc(setter);

	var ref = item.ref;
	if (!ref) return null;

	var parts = ref.split(".");
	var body = [
		"var context = this.model;"
	];
	for (var i = 0; i < parts.length; i++) {
		var isLast = i == parts.length - 1;
		var name = parts[i];
		var fname = DwtForm.__makeFuncName(name, isLast ? "set" : "get");
		if (isLast) break;
		body.push(
			"context = context && (context.",fname," ? context.",fname,"() : context.",name,");"
		);
	}
	body.push(
		"if (context) {",
			"if (context.",fname,") {",
				"context.",fname,"(value);",
			"}",
			"else {",
				"context.",name," = value;",
			"}",
		"}"
	);
	return new Function("value", body.join("\n"));
};

DwtForm.__makeFuncName = function(name, prefix) {
	return [prefix||"get",name.substr(0,1).toUpperCase(),name.substr(1)].join("");
};

DwtForm.__makeFunc = function(value) {
	if (value == null) return null;
	if (typeof value == "function" && !(value instanceof RegExp)) return value;
	var body = [
		"with (this._context) {",
			"return (",value,");",
		"}"
	].join("");
	return new Function(body);
};

DwtForm.__equals = function(a, b) {
	return a == b;
};

// Array.sort

DwtForm.__byTabIndex = function(a, b) {
	return a.tabindex - b.tabindex;
};

// hacks

DwtForm.__hack_fixRadioButtonHandler = function(radio) {
	var handlers = [radio.getInputElement().onclick, DwtCheckbox.__handleClick];
	var handler = function(evt) {
		for (var i = 0; i < handlers.length; i++) {
			var func = handlers[i];
			if (func) {
				func(evt);
			}
		}
	};
	Dwt.setHandler(radio.getInputElement(), DwtEvent.ONCLICK, handler);
};

//
// Class: DwtFormRows
//

// TODO: tab-group

/**
 * 
 * @extends		DwtForm
 * 
 * @private
 */
DwtFormRows = function(params) {
	if (arguments.length == 0) return;
	this._itemDef = params.formItemDef || {};
	params.className = params.className || "DwtFormRows";
	DwtForm.call(this, {
		id:params.id, parent:params.parent,
		form:{}, template:this._itemDef.template
	});

	// init state
	this._rowsTabGroup = new DwtTabGroup(this._htmlElId);

	// save state
	this._rowDef = this._itemDef.rowitem || {};
	this._equals = DwtForm.__makeFunc(this._rowDef.equals) || DwtForm.__equals;
	this._rowCount = 0;
	this._minRows = this._itemDef.minrows || 1;
	this._maxRows = this._itemDef.maxrows || Number.MAX_VALUE;
	if (this._itemDef.rowtemplate) {
		this.ROW_TEMPLATE = this._itemDef.rowtemplate;
	}

	// add default rows
	var itemDefs = this._itemDef.items || [];
	for (var i = 0; i < itemDefs .length; i++) {
		this.addRow(itemDefs[i]);
	}

	// add empty rows to satisfy minimum row count
	for ( ; i < this._minRows; i++) {
		this.addRow();
	}

	// remember listeners
	this._onaddrow = DwtForm.__makeFunc(this._itemDef.onaddrow);
	this._onremoverow = DwtForm.__makeFunc(this._itemDef.onremoverow);
};
DwtFormRows.prototype = new DwtForm;
DwtFormRows.prototype.constructor = DwtFormRows;

DwtFormRows.prototype.toString = function() {
	return "DwtFormRows";
};

// Data

DwtFormRows.prototype.TEMPLATE = "dwt.Widgets#DwtFormRows";
DwtFormRows.prototype.ROW_TEMPLATE = "dwt.Widgets#DwtFormRow";

// Public methods

DwtFormRows.prototype.getTabGroupMember = function() {
	return this._rowsTabGroup;
};

DwtFormRows.prototype.setValue = function(array) {
	if (arguments.length > 1) {
		DwtForm.prototype.setValue.apply(this, arguments);
		return;
	}
	// adjust row count
	var min = Math.max(array.length, this._minRows);
	for (var i = this._rowCount; i > min; i--) {
		this.removeRow(i-1);
	}
	var max = Math.min(array.length, this._maxRows);
	for (var i = this._rowCount; i < max; i++) {
		this.addRow();
	}
	// initialize values
	for (var i = 0; i < max; i++) {
		this.setValue(String(i), array[i], true);
	}
	for (var i = array.length; i < this._rowCount; i++) {
		this.setValue(String(i), null, true);
	}
};

DwtFormRows.prototype.getValue = function() {
	if (arguments.length > 0) {
		return DwtForm.prototype.getValue.apply(this, arguments);
	}
	var array = new Array(this._rowCount);
	for (var i = 0; i < this._rowCount; i++) {
		array[i] = this.getValue(String(i));
	}
	return array;
};

DwtFormRows.prototype.getRowCount = function() {
	return this._rowCount;
};

DwtFormRows.prototype.addRow = function(itemDef, index) {
	if (this._rowCount >= this._maxRows) {
		return;
	}
	itemDef = itemDef || (this._rowDef && AjxUtil.createProxy(this._rowDef));
	if (!itemDef) {
		return;
	}

	if (index == null) index = this._rowCount;

	// move other rows "up"
	for (var i = this._rowCount - 1; i >= index; i--) {
		var oindex = i, nindex = i+1;
		var item = this._items[oindex];
		item.aka = String(nindex);
		delete this._items[oindex];
		this._items[item.aka] = item;
		this._setControlIds(item.id, item.aka);
	}

	// initialize definition
	itemDef.id = itemDef.id || Dwt.getNextId();
	itemDef.aka = String(index);
	this._rowCount++;

	// create row html
	var data = { id: [this.getHTMLElId(), itemDef.id].join("_") };
	var rowHtml = AjxTemplate.expand(this.ROW_TEMPLATE, data);

	var rowsEl = this._rowsEl;
	rowsEl.appendChild(Dwt.toDocumentFragment(rowHtml, data.id+"_row"));
	var rowEl = rowsEl.lastChild;
	if (index != this._rowCount - 1) {
		rowsEl.insertBefore(rowEl, rowsEl.childNodes[index]);
	}

	// create controls
	var tabIndexes = [];
	var rowControl = this._registerControl(itemDef, null, tabIndexes);

	var addDef = this._itemDef.additem ? AjxUtil.createProxy(this._itemDef.additem) : { image: "Add", tooltip: ZmMsg.addRow };
	addDef.id = addDef.id || itemDef.id+"_add";
	addDef.visible = "this.getRowCount() < this.getMaxRows()";
	addDef.ignore = true;
	var addButton = this._registerControl(addDef,null,tabIndexes,null,null,"DwtButton");
	if (!addDef.onclick) {
		addButton.addSelectionListener(new AjxListener(this, this._handleAddRow, [itemDef.id]));
	}

	var removeDef = this._itemDef.removeitem ? AjxUtil.createProxy(this._itemDef.removeitem) : { image: "Remove", tooltip: ZmMsg.removeRow };
	removeDef.id = removeDef.id || itemDef.id+"_remove";
	removeDef.visible = "this.getRowCount() > this.getMinRows()";
	removeDef.ignore = true;
	var removeButton = this._registerControl(removeDef,null,tabIndexes,null,null,"DwtButton");
	if (!removeDef.onclick) {
		removeButton.addSelectionListener(new AjxListener(this, this._handleRemoveRow, [itemDef.id]));
	}

	// remember where we put it
	var item = this._items[itemDef.id];
	item._rowEl = rowEl;
	item._addId= addDef.id;
	item._removeId = removeDef.id;

	// set control identifiers
	this._setControlIds(item.id, index);

	// create tab group for row
	var tabGroup = new DwtTabGroup(itemDef.id);
	tabIndexes.sort(DwtForm.__byTabIndex);
	for (var i = 0; i < tabIndexes.length; i++) {
		var control = tabIndexes[i].control;
		tabGroup.addMember(control.getTabGroupMember() || control);
	}

	// add to tab group
	if (index == this._rowCount - 1) {
		this._rowsTabGroup.addMember(tabGroup);
	}
	else {
		var indexItemDef = this._items[String(index+1)];
		this._rowsTabGroup.addMemberBefore(tabGroup, DwtTabGroup.getByName(indexItemDef.id));
	}

	// update display and notify handler
	this.update();
	if (this._onaddrow) {
		this._call(this._onaddrow, [index]);
	}

	return rowControl;
};

DwtFormRows.prototype.removeRow = function(indexOrId) {
	if (this._rowCount <= this._minRows) {
		return;
	}

	var item = this._items[indexOrId];

	// this only recognizes if a properly accessible widgets (i.e. those that
	// receive browser focus) had focus
	var hadFocus = Dwt.isAncestor(item._rowEl, document.activeElement);

	// delete item at specified index
	if (item.control instanceof DwtControl) {
		this.removeChild(item.control);
	}
	delete this._items[item.aka];
	this._deleteItem(item.id);

	// delete add item
	var addItem = this._items[item._addId];
	if (addItem) {
		this.removeChild(addItem.control);
		this._deleteItem(addItem.id);
	}

	// delete remove item
	var removeItem = this._items[item._removeId];
	if (removeItem) {
		this.removeChild(removeItem.control);
		this._deleteItem(removeItem.id);
	}

	// shift everything down one, removing old last row
	var fromIndex = Number(item.aka);
	for (var i = fromIndex + 1; i < this._rowCount; i++) {
		var oindex = i, nindex = i-1;
		this._items[nindex] = this._items[oindex];
		this._items[nindex].aka = String(nindex);
		this._setControlIds(this._items[nindex].id, this._items[nindex].aka);
	}
	this._deleteItem(String(--this._rowCount));

	// remove row element
	var rowEl = item._rowEl;
	rowEl.parentNode.removeChild(rowEl);
	delete item._rowEl;

	// remove from tab group
	var tabGroup = DwtTabGroup.getByName(item.id);
	this._rowsTabGroup.removeMember(tabGroup);

	// update display and notify handler
	this.update();

	if (hadFocus) {
		var otherItem = this._items[item.aka] || this._items[this._rowCount - 1];
		otherItem.control.getTabGroupMember().focus();
	}

	if (this._onremoverow) {
		this._call(this._onremoverow, [Number(item.aka)]);
	}
};

DwtFormRows.prototype.getMinRows = function() {
	return this._minRows;
};
DwtFormRows.prototype.getMaxRows = function() {
	return this._maxRows;
};
DwtFormRows.prototype.getRowCount = function() {
	return this._rowCount;
};

DwtFormRows.prototype.getIndexForRowId = function(rowId) {
	var children = this._rowsEl.childNodes;
	for (var i = 0; i < children.length; i++) {
		if (children[i].id == [this._htmlElId,rowId,"row"].join("_")) {
			return i;
		}
	}
	return -1;
};

DwtFormRows.__equals = function(a,b) {
	if (a === b) return true;
	if (!a || !b || a.length != b.length) return false;
	for (var i = 0; i < a.length; i++) {
		if (!this._call(this._equals, [a[i],b[i]])) {
			return false;
		}
	}
	return true;
};

// Protected methods

/** Override to set child controls' identifiers. */
DwtFormRows.prototype._setControlIds = function(rowId, index) {
	var id = [this.getHTMLElId(), index].join("_");
	var item = this._items[rowId];
	this._setControlId(item && item.control, id);
	var addButton = this._items[item._addId];
	this._setControlId(addButton && addButton.control, id+"_add");
	var removeButton = this._items[item._removeId];
	this._setControlId(removeButton && removeButton.control, id+"_remove");
	// TODO: update parentid attribute of children
};

DwtFormRows.prototype._setControlId = function(control, id) {
	if (!control) return;
	if (control instanceof DwtControl) {
		control.setHtmlElementId(id);
	}
	else {
		control.id = id;
	}
};

DwtFormRows.prototype._handleAddRow = function(rowId) {
	if (this.getRowCount() < this.getMaxRows()) {
		var index = this.getIndexForRowId(rowId) + 1;
		this.addRow(null, index);
	}
};

DwtFormRows.prototype._handleRemoveRow = function(rowId) {
	this.removeRow(rowId);
};

// DwtForm methods

DwtFormRows.prototype._setModelValue = function(id, value) {
	if (DwtForm.prototype._setModelValue.apply(this, arguments)) {
		this.parent.setDirty(this._itemDef.id, true);
	}
};

// DwtControl methods

DwtFormRows.prototype._createHtmlFromTemplate = function(templateId, data) {
	DwtForm.prototype._createHtmlFromTemplate.apply(this, arguments);
	this._rowsEl = document.getElementById(this._htmlElId+"_rows");
};


}
if (AjxPackage.define("ajax.dwt.widgets.DwtComboBox")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
 * Creates a combo box.
 * @constructor
 * @class
 * This class represents a combo box.
 *
 * @author Dave Comfort
 * 
 * @param {hash}	params		a hash of parameters
 * @param {DwtComposite}      parent		the parent widget
 * @param {boolean}	useLabel		Set to true if the value should be shown in a DwtLabel. Defaults to false, showing it in a DwtInputField.
 * @param {hash}	inputParams		params for the input (see {@link DwtInputField} or {@link DwtLabel})
 * @param {string}      className		the CSS class
 * @param {constant}      posStyle		the positioning style (see {@link DwtControl})
 * @param {int}     maxRows         The number of maxRows needed in drop down(see {@link DwtMenu})
 * @param {constant} layout         The layout of the drop down(see {@link DwtMenu})
 * @param {boolean} autoScroll    Set to true if auto scroll to the input text is needed. Defaults to false.
 * 
 * @extends		DwtComposite
 */
DwtComboBox = function(params) {
    if (arguments.length == 0) { return; }
	params = Dwt.getParams(arguments, DwtComboBox.PARAMS);
    params.className = params.className || "DwtComboBox";
    DwtComposite.call(this, params);
    
    this.input = null;
	this._menu = null;
    this._button = null;
    
    this._textToValue = {}; // Map of text strings to their values.
    this._valueToText = {};
    this._valueToItem = {};
	this._size = 0;

    this._hasMenuCallback = true;
	this._menuItemListenerObj = new AjxListener(this, this._menuItemListener);

    this._inputParams = params.inputParams;
	this._useLabel = Boolean(params.useLabel);
	this._maxRows = params.maxRows;
	this._layout = params.layout;
	this._autoScroll = params.autoScroll || false;
    this._createHtml();
};

DwtComboBox.PARAMS = ["parent", "inputParams", "className", "posStyle", "dialog"];

DwtComboBox.prototype = new DwtComposite;
DwtComboBox.prototype.constructor = DwtComboBox;

DwtComboBox.prototype.isDwtComboBox = true;
DwtComboBox.prototype.toString = function() { return "DwtComboBox"; };

//
// Data
//

DwtComboBox.prototype.TEMPLATE = "dwt.Widgets#DwtComboBox";

//
// Public methods
//

DwtComboBox.prototype.getTabGroupMember = function() {
	return this._tabGroup;
};

/**
 * Adds the change listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
DwtComboBox.prototype.addChangeListener = function(listener) {
	this.addListener(DwtEvent.ONCHANGE, listener);
};

/**
 * Removes the change listener.
 * 
 * @param	{AjxListener}	listener		the listener
 */
DwtComboBox.prototype.removeChangeListener = function(listener) {
	this.removeListener(DwtEvent.ONCHANGE, listener);
};

/**
 * Adds an entry to the combo box list.
 * 
 * @param {string}	text		the user-visible text for the entry
 * @param {string}	value		the value for the entry
 * @param {boolean}	selected	if <code>true</code>, the entry is selected
 */
DwtComboBox.prototype.add =
function(text, value, selected) {
	this._textToValue[text] = value;
    this._valueToText[value] = text;
    if (!this._hasMenuCallback) {
		var menu = this._button.getMenu();
    	this._createMenuItem(menu, text);
	}
	if (selected) {
		this.setText(text);
	}
	this._size++;
	this._updateButton();
};

/**
 * Removes the specified value from the list.
 *
 * @param	{string}	value		the value
 */
DwtComboBox.prototype.remove = function(value) {
    var item = this._valueToItem[value];
    if (item) {
        this._button.getMenu().removeChild(item);
        var text = this._valueToText[value];
        delete this._textToValue[text];
        delete this._valueToText[value];
        delete this._valueToItem[value];
        if (this.getText() == text) {
            this.setText("");
        }
		this._size--;
		this._updateButton();
	}
};

/**
 * Removes all the items in the list.
 * 
 */
DwtComboBox.prototype.removeAll = function() {
    this._button.setMenu(new AjxCallback(this, this._createMenu), true);
    this._hasMenuCallback = true;

    this._textToValue = {};
    this._valueToText = {};
    this._valueToItem = {};
	this._size = 0;
	this._updateButton();
};

/**
 * Gets the value of the currently selected entry. If the entry
 * is one that was not added via the add method (that is, if it was
 * typed in by the user) then <code>null</code> is returned.
 * 
 * @return	{string}	the value
 */
DwtComboBox.prototype.getValue =
function() {
	var text = this.getText();
	return this._textToValue[text];
};

/**
 * Sets the value.
 * 
 * @param	{string}	value		the value
 */
DwtComboBox.prototype.setValue = function(value) {
	var text = this._valueToText[value];
	this.setText(text || value);
};

/**
 * Gets the text of the currently selected entry.
 * 
 * @return	{string}	the text
 */
DwtComboBox.prototype.getText =
function() {
	return this._useLabel ? this.input.getText() : this.input.getValue();
};

/**
 * Sets the selected text.
 * 
 * @param	{string}	text		the text
 */
DwtComboBox.prototype.setText =
function(text) {
	if (this._useLabel)
		this.input.setText(text);
	else
		this.input.setValue(text);
};

DwtComboBox.prototype.setEnabled =
function(enabled) {
	if (enabled != this._enabled) {
		DwtComposite.prototype.setEnabled.call(this, enabled);
		this.input.setEnabled(enabled);
		this._button.setEnabled(enabled);
    }
};

DwtComboBox.prototype.focus = function() {
    return this.input.focus();
};

DwtComboBox.prototype.popdown = function() {
	if (this._menu)
		this._menu.popdown();
};

//
// Protected methods
//

DwtComboBox.prototype._createMenu =
function() {
	var params = {parent:this};
	if (this._maxRows) {
		params.maxRows = this._maxRows;
	}
	if (this._layout) {
		params.layout = this._layout;
	}
    var menu = this._menu = new DwtMenu(params);
    for (var i in this._textToValue) {
    	var item = this._createMenuItem(menu, i);
        var value = this._textToValue[i];
        this._valueToItem[value] = item;
    }
	this._hasMenuCallback = false;
	return menu;
};

DwtComboBox.prototype._createMenuItem =
function(menu, text) {
	var item = new DwtMenuItem({parent:menu});
	item.setText(text);
	item.addSelectionListener(this._menuItemListenerObj);
	if (!this._menuWidth) {
		this._menuWidth = this.getW() - 10; // 10 is some fudge factor that lines up the menu right.
	}
    item.getHtmlElement().style.minWidth = this._menuWidth;
    return item;
};

DwtComboBox.prototype._menuItemListener =
function(ev) {
	var menuItem = ev.dwtObj;
	var ovalue = this.getText();
	var nvalue = menuItem.getText();
	this.setText(nvalue);
	this._menu.popdown();

	// notify our listeners
	var event = DwtUiEvent.getEvent(ev);
	event._args = { selectObj: this, newValue: nvalue, oldValue: ovalue };
	this.notifyListeners(DwtEvent.ONCHANGE, event);

	if (!this._useLabel) {
	    var input = this.input.getInputElement();
	    input.focus();
	    input.select();
	}
};

DwtComboBox.prototype._handleKeyDown = function(ev) {
	var keycode = DwtKeyEvent.getCharCode(ev);

	this.__ovalue = this.getText();

	return true;
};

DwtComboBox.prototype._handleKeyUp = function(ev) {
	// propagate event to DwtInputField
	DwtInputField._keyUpHdlr(ev);
	// notify our listeners
	var event = DwtUiEvent.getEvent(ev);
	var newValue = this.getText();
	event._args = { selectObj: this, newValue: newValue, oldValue: this.__ovalue };
	this.notifyListeners(DwtEvent.ONCHANGE, event);
	if (this._menu && this._autoScroll && newValue != this.__ovalue) {
		//if auto scroll is on then scroll to the index which starts with
		//the value in input field
		var index = 0;
		for (var text in this._textToValue) {
			if (text.indexOf(newValue) == 0) {
				this._menu.scrollToIndex(index);
				break;
			}
			index++;
		}
	}
	return true;
};

DwtComboBox.prototype._updateButton =
function() {
	this._button.setVisible(this._size > 0);
};

DwtComboBox.prototype._createHtml = function(templateId) {
    var data = { id: this._htmlElId };
    this._createHtmlFromTemplate(templateId || this.TEMPLATE, data);
};

DwtComboBox.prototype._createHtmlFromTemplate = function(templateId, data) {
    DwtComposite.prototype._createHtmlFromTemplate.call(this, templateId, data);

	var inputParams = this._inputParams || {};
	inputParams.parent = this;
	inputParams.size = inputParams.size || 40;
	delete this._inputParams;
    
	this.input = (this._useLabel ?
	              new DwtLabel(inputParams) : new DwtInputField(inputParams));
    this.input.replaceElement(data.id + "_input");
	this.input.setHandler(DwtEvent.ONKEYDOWN, AjxCallback.simpleClosure(this._handleKeyDown, this));
	this.input.setHandler(DwtEvent.ONKEYUP, AjxCallback.simpleClosure(this._handleKeyUp, this));

    this._button = new DwtComboBoxButton({parent:this});
	this._button.setMenu(new AjxListener(this, this._createMenu), true);
    this._button.replaceElement(data.id + "_button");
	this._updateButton();

	this._tabGroup = new DwtTabGroup(this._htmlElId);
	this._tabGroup.addMember(this.input);
	this._tabGroup.addMember(this._button);
};

/**
 * The input field inherits the id for accessibility purposes.
 * 
 * @private
 */
DwtComboBox.prototype._replaceElementHook =
function(oel, nel, inheritClass, inheritStyle) {
	DwtComposite.prototype._replaceElementHook.apply(this, arguments);
	// set input settings
	if (oel.size) {
		var el = (this._useLabel ?
		          this.input.getHtmlElement() :
		          this.input.getInputElement());
		el.size = oel.size;
	}
	if (oel.title) {
		this.input.setHint(oel.title);
	}
};

//
// Classes
//

/**
 * DwtComboBoxButton: Stylizable button just for use in combo boxes.
 * 
 * @param {hash}	params		a hash of parameters
 * @param {DwtComposite}       params.parent		the parent widget
 * @param	{string}       params.className		the CSS class
 * 
 * @extends		DwtButton
 * @private
 */
DwtComboBoxButton = function(params) {
	params = Dwt.getParams(arguments, DwtComboBoxButton.PARAMS);
	params.posStyle = Dwt.RELATIVE_STYLE;
	DwtButton.call(this, params);
}

DwtComboBoxButton.prototype = new DwtButton;
DwtComboBoxButton.prototype.constructor = DwtComboBoxButton;

DwtComboBoxButton.prototype.toString =
function() {
    return "DwtComboBoxButton";
};

DwtComboBoxButton.PARAMS = ["parent", "className"];

// Data

DwtComboBoxButton.prototype.TEMPLATE = "dwt.Widgets#DwtComboBoxButton"

}
if (AjxPackage.define("ajax.dwt.widgets.DwtTimeSelect")) {
// SPDX-FileCopyrightText: 2022 Synacor, Inc.
// SPDX-FileCopyrightText: 2022 Zextras <https://www.zextras.com>
//
// SPDX-License-Identifier: AGPL-3.0-only

/**
* Creates up to three separate DwtSelects for the time (hour, minute, am|pm)
* Showing the AM|PM select widget is dependent on the user's locale
* 
* @author Parag Shah
*
* @param parent		[DwtComposite]	the parent widget
* @param id			[string]*		an ID that is propagated to component select objects
 *
 * @private
*/
DwtTimeSelect = function(parent, id) {
	DwtComposite.call(this, {parent:parent, className: 'DwtTimeSelect'});

	this.id = id;
	this._isLocale24Hour = true;
	this._createSelects();
};

// IDs for types of time selects
DwtTimeSelect.START	= 1;
DwtTimeSelect.END	= 2;

// IDs for time select components
DwtTimeSelect.HOUR	= 1;
DwtTimeSelect.MINUTE	= 2;
DwtTimeSelect.AMPM	= 3;

DwtTimeSelect.getDateFromFields =
function(hours, minutes, ampm, date) {
	hours = Number(hours);
	if (ampm) {
		if (ampm == "AM" || ampm === 0) {
			hours = (hours == 12) ? 0 : hours;
		} else if (ampm == "PM" || ampm == 1) {
			hours = (hours < 12) ? hours + 12 : hours;
		}
	}
	date = date ? date : new Date();
	date.setHours(hours, Number(minutes), 0, 0);
	return date;
};

DwtTimeSelect.parse =
function(timeString) {
    var date;
	var lTimeString = timeString.toLowerCase();
	if (lTimeString === AjxMsg.midnight.toLowerCase() || lTimeString === AjxMsg.noon.toLowerCase()) {
		date = new Date();
		date.setMinutes(0);
		date.setSeconds(0);
		date.setHours(lTimeString === AjxMsg.noon.toLowerCase() ? 12 : 0);
	} else {
		var timeFormatter = AjxDateFormat.getTimeInstance(AjxDateFormat.SHORT);    
		date = timeFormatter.parse(timeString) || AjxDateFormat.parseTime(timeString);
	}
    return date;
};

DwtTimeSelect.format =
function(date) {
	if (date.getHours() == 0 && date.getMinutes() == 0) {
		return AjxMsg.midnight;
	} else if (date.getHours() == 12 && date.getMinutes() == 0) {
		return AjxMsg.noon;
	} else {
		return AjxDateFormat.getTimeInstance(AjxDateFormat.SHORT).format(date);
	}
};

/**
* Adjust an appt's start or end based on changes to the other one. If the user changes
* the start time, change the end time so that the appt duration is maintained. If the
* user changes the end time, we leave things alone.
*
* @param ev					[Event]				UI event from a DwtSelect
* @param startSelect		[DwtTimeSelect]		start time select
* @param endSelect			[DwtTimeSelect]		end time select
* @param startDateField		[element]			start date field
* @param endDateField		[element]			end date field
*/
DwtTimeSelect.adjustStartEnd =
function(ev, startSelect, endSelect, startDateField, endDateField) {
	var select = ev._args.selectObj;
	var startDate = AjxDateUtil.simpleParseDateStr(startDateField.value);
	var endDate = AjxDateUtil.simpleParseDateStr(endDateField.value);
	var startDateOrig = startDateField.value;
	var endDateOrig = endDateField.value;
	if (select.id == DwtTimeSelect.START) {
		var hours = (select.compId == DwtTimeSelect.HOUR) ? ev._args.oldValue : startSelect.getHours();
		var minutes = (select.compId == DwtTimeSelect.MINUTE) ? ev._args.oldValue : startSelect.getMinutes();
		var ampm = (select.compId == DwtTimeSelect.AMPM) ? ev._args.oldValue : startSelect.getAmPm();
		var oldStartDateMs = DwtTimeSelect.getDateFromFields(hours, minutes, ampm, startDate).getTime();
		var newStartDateMs = DwtTimeSelect.getDateFromFields(startSelect.getHours(), startSelect.getMinutes(), startSelect.getAmPm(), startDate).getTime();
		var oldEndDateMs = DwtTimeSelect.getDateFromFields(endSelect.getHours(), endSelect.getMinutes(), endSelect.getAmPm(), endDate).getTime();
		var delta = oldEndDateMs - oldStartDateMs;
		if (!delta) return null;
		var newEndDateMs = newStartDateMs + delta;
		var newEndDate = new Date(newEndDateMs);
		endSelect.set(newEndDate);
		endDateField.value = AjxDateUtil.simpleComputeDateStr(newEndDate);
		if (endDateField.value != endDateOrig) {
			return endDateField;
		}
	} else {
		return null;
	}
};

/**
 * Returns true if the start date/time is before the end date/time.
 *
 * @param ss				[DwtTimeSelect]		start time select
 * @param es				[DwtTimeSelect]		end time select
 * @param startDateField	[element]			start date field
 * @param endDateField		[element]			end date field
 */
DwtTimeSelect.validStartEnd =
function(startDateField, endDateField, ss, es) {
	var startDate = AjxDateUtil.simpleParseDateStr(startDateField.value);
	var endDate = AjxDateUtil.simpleParseDateStr(endDateField.value);

    if (startDate && endDate) {
        if((startDate.valueOf() > endDate.valueOf())){
            return false;
        }
        // bug fix #11329 - dont allow year to be more than the earth will be around :]
		if (startDate.getFullYear() > 9999 || endDate.getFullYear() > 9999) {
			return false;
		}
        if(ss && es){
            var startDateMs = DwtTimeSelect.getDateFromFields(ss.getHours(), ss.getMinutes(), ss.getAmPm(), startDate).getTime();
            var endDateMs = DwtTimeSelect.getDateFromFields(es.getHours(), es.getMinutes(), es.getAmPm(), endDate).getTime();
            if (startDateMs > endDateMs) {
                return false;
            }
        }
    } else {
		return false;
	}
	return true;
};

DwtTimeSelect.prototype = new DwtComposite;
DwtTimeSelect.prototype.constructor = DwtTimeSelect;
DwtTimeSelect.prototype.isDwtTimeSelect = true;

DwtTimeSelect.prototype.toString = function() {
    return 'DwtTimeSelect';
};

/**
* Sets the time select according to the given date.
*
* @param date	[Date]		a Date object
*/
DwtTimeSelect.prototype.set = 
function(date) {

	var hourIdx = 0, minuteIdx = 0, amPmIdx = 0;
	var isLocale24Hour = this.isLocale24Hour();

	var hours = date.getHours();
	if (!isLocale24Hour && hours > 12) {
		hourIdx = hours - 13;
	} else if (!isLocale24Hour && hours == 0) {
		hourIdx = this.getHourSelectSize() - 1;
	} else {
		hourIdx = isLocale24Hour ? hours : hours - 1;
	}

	minuteIdx = Math.floor(date.getMinutes() / 5);

	if (!isLocale24Hour) {
		amPmIdx = (date.getHours() >= 12) ? 1 : 0;
	}

	this.setSelected(hourIdx, minuteIdx, amPmIdx);
};


/**
 * Returns a date object with the hours and minutes set based on
 * the values of this time select.
 *
 * @param date [Date] Optional. If specified, the hour and minute
 *                    values will be set on the specified object;
 *                    else, a new <code>Date</code> object is created.
 */
DwtTimeSelect.prototype.getValue =
function(date) {
	return (DwtTimeSelect.getDateFromFields(this.getHours(), this.getMinutes(), this.getAmPm(), date));
};

DwtTimeSelect.prototype.getHours =
function() {
	return this._hourSelect.getValue();
};

DwtTimeSelect.prototype.getMinutes =
function() {
	return this._minuteSelect.getValue();
};

DwtTimeSelect.prototype.getAmPm =
function() {
	return this._amPmSelect ? this._amPmSelect.getValue() : null;
};

DwtTimeSelect.prototype.setSelected = 
function(hourIdx, minuteIdx, amPmIdx) {
	this._hourSelect.setSelected(hourIdx);
	this._minuteSelect.setSelected(minuteIdx);
	if (!this._isLocale24Hour) {
		this._amPmSelect.setSelected(amPmIdx);
	}
};

DwtTimeSelect.prototype.addChangeListener = 
function(listener) {
	this._hourSelect.addChangeListener(listener);
	this._minuteSelect.addChangeListener(listener);
	if (this._amPmSelect)
		this._amPmSelect.addChangeListener(listener);
};

DwtTimeSelect.prototype.isLocale24Hour = 
function() {
	return this._isLocale24Hour;
};

DwtTimeSelect.prototype.getHourSelectSize = 
function() {	
	return this._hourSelect.size();
};

DwtTimeSelect.prototype.getMinuteSelectSize = 
function() {	
	return this._minuteSelect.size();
};

DwtTimeSelect.prototype.getSelectedHourIdx = 
function() {
	return this._hourSelect.getSelectedIndex();
};

DwtTimeSelect.prototype.getSelectedMinuteIdx = 
function() {
	return this._minuteSelect.getSelectedIndex();
};

DwtTimeSelect.prototype.getSelectedAmPmIdx = 
function() {
	return this._amPmSelect ? this._amPmSelect.getSelectedIndex() : 0;
};

DwtTimeSelect.prototype.setEnabled =
function(enabled) {
   DwtComposite.prototype.setEnabled.call(this, enabled);

   this._hourSelect.setEnabled(enabled);
   this._minuteSelect.setEnabled(enabled);
   if (this._amPmSelect) this._amPmSelect.setEnabled(enabled);
};

DwtTimeSelect.prototype._createSelects =
function() {
	this._hourSelectId = Dwt.getNextId();
	this._minuteSelectId = Dwt.getNextId();
	this._amPmSelectId = Dwt.getNextId();

	// get the time formatter for the user's locale
	var timeFormatter = AjxDateFormat.getTimeInstance(AjxDateFormat.SHORT);
	var hourSegmentIdx = 0;
	var minuteSegmentIdx = 0;

	var html = [];
	var i = 0;

	html[i++] = "<table border=0 cellpadding=0 cellspacing=0><tr>";

	// walk time formatter's segments array to render each segment part in the right order
	for (var j = 0; j < timeFormatter._segments.length; j++) {
		var segmentStr = timeFormatter._segments[j]._s;

		if (timeFormatter._segments[j] instanceof AjxFormat.TextSegment) {
			var trimStr = AjxStringUtil.trim(segmentStr);
			if (trimStr.length) {
				html[i++] = "<td class='TextPadding ZmFieldLabel'>"
				html[i++] = segmentStr;
				html[i++] = "</td>";
			}
		} else if (segmentStr.charAt(0) == "h" || segmentStr.charAt(0) == "H") {
			hourSegmentIdx = j;
			html[i++] = "<td width=42 id='"
			html[i++] = this._hourSelectId;
			html[i++] = "'></td>";
		} else if (segmentStr.charAt(0) == "m") {
			minuteSegmentIdx = j;
			html[i++] = "<td width=42 id='"
			html[i++] = this._minuteSelectId;
			html[i++] = "'></td>";
		} else if (segmentStr == "a") {	
			this._isLocale24Hour = false;
			html[i++] = "<td width=42 id='"
			html[i++] = this._amPmSelectId;
			html[i++] = "'></td>";
		}
	}
	
	html[i++] = "</tr></table>";

	// append html template to DOM
	this.getHtmlElement().innerHTML = html.join("");

	// init vars for adding hour DwtSelect
	var now = new Date();
	var start = this._isLocale24Hour ? 0 : 1;
	var limit = this._isLocale24Hour ? 24 : 13;

	// create new DwtSelect for hour slot
	this._hourSelect = new DwtSelect({parent:this});
	this._hourSelect.id = this.id;
	this._hourSelect.compId = DwtTimeSelect.HOUR;
	for (var i = start; i < limit; i++) {
		now.setHours(i);
		var label = timeFormatter._segments[hourSegmentIdx].format(now);
		this._hourSelect.addOption(label, false, i);
	}
	this._hourSelect.reparentHtmlElement(this._hourSelectId);
	delete this._hourSelectId;

	// create new DwtSelect for minute slot
	this._minuteSelect = new DwtSelect({parent:this});
	this._minuteSelect.id = this.id;
	this._minuteSelect.compId = DwtTimeSelect.MINUTE;
	for (var i = 0; i < 60; i = i + 5) {
		now.setMinutes(i);
		var label = timeFormatter._segments[minuteSegmentIdx].format(now);
		this._minuteSelect.addOption(label, false, i);
	}
	this._minuteSelect.reparentHtmlElement(this._minuteSelectId);
	delete this._minuteSelectId;

	// if locale is 12-hour time, add AM|PM DwtSelect
	if (!this._isLocale24Hour) {
		this._amPmSelect = new DwtSelect({parent:this});
		this._amPmSelect.id = this.id;
		this._amPmSelect.compId = DwtTimeSelect.AMPM;
		this._amPmSelect.addOption(I18nMsg["periodAm"], false, "AM");
		this._amPmSelect.addOption(I18nMsg["periodPm"], false, "PM");
		this._amPmSelect.reparentHtmlElement(this._amPmSelectId);
		delete this._amPmSelectId;
	}
};

/**
* Creates up to three separate DwtSelects for the time (hour, minute, am|pm)
* Showing the AM|PM select widget is dependent on the user's locale
*
* @author Parag Shah
*
* @param parent		[DwtComposite]	the parent widget
* @param id			[string]*		an ID that is propagated to component select objects
 *
 * @private
*/
DwtTimeInput = function(parent, id, parentElement, interval) {
    var params = {parent:parent, id: "DwtTimeInput", className: 'DwtTimeInput'};
    if(parentElement) {
        params.parentElement = parentElement;
    }
	DwtComposite.call(this, params);

    this._interval = interval || DwtTimeInput.FIFTEEN_MIN_INTERVAL;
	this.id = id;
	this._isLocale24Hour = true;
	this._createSelects();
    this._useTextInput = true;
};

DwtTimeInput.THIRTY_MIN_INTERVAL = 30;
DwtTimeInput.FIFTEEN_MIN_INTERVAL = 15;

// IDs for types of time selects
DwtTimeInput.START	= 1;
DwtTimeInput.END	= 2;

// IDs for time select components
DwtTimeInput.HOUR	= 1;
DwtTimeInput.MINUTE	= 2;
DwtTimeInput.AMPM	= 3;

DwtTimeInput.ROWS	= 8; // Show 8 rows at a time
DwtTimeInput.DEFAULT_TOP_ROW	= 8; // Make row 8 (8 AM) the initial topmost visible row unless overridden

DwtTimeInput.getDateFromFields =
function(timeStr, date) {
    var formattedDate = DwtTimeSelect.parse(timeStr);
    date = date || new Date();
    date.setHours(formattedDate.getHours(), formattedDate.getMinutes(), 0, 0);
    return date;
};

/**
* Adjust an appt's start or end based on changes to the other one. If the user changes
* the start time, change the end time so that the appt duration is maintained. If the
* user changes the end time, we leave things alone.
*
* @param ev					[Event]				UI event from a DwtSelect
* @param startSelect		[DwtTimeInput]		start time select
* @param endSelect			[DwtTimeInput]		end time select
* @param startDateField		[element]			start date field
* @param endDateField		[element]			end date field
* @param dateInfo		    [object]			date info used to calculate the old time before changing this
* @param id		            [string]			an ID which got changed 
*/
DwtTimeInput.adjustStartEnd =
function(ev, startSelect, endSelect, startDateField, endDateField, dateInfo, id) {
    var startDate = AjxDateUtil.simpleParseDateStr(startDateField.value);
    var endDate = AjxDateUtil.simpleParseDateStr(endDateField.value);
    var startDateOrig = startDateField.value;
    var endDateOrig = endDateField.value;
    if (id == DwtTimeInput.START) {
        var timeStr = dateInfo ? dateInfo.startTimeStr : startSelect.getTimeString();
        var oldStartDateMs = DwtTimeInput.getDateFromFields(timeStr, startDate).getTime();
        var newStartDateMs = DwtTimeInput.getDateFromFields(startSelect.getTimeString(), startDate).getTime();
        var oldEndDateMs = DwtTimeInput.getDateFromFields(endSelect.getTimeString(), endDate).getTime();

        var delta = oldEndDateMs - oldStartDateMs;
        if (!delta) return null;

        var newEndDateMs = newStartDateMs + delta;
        var newEndDate = new Date(newEndDateMs);

        startSelect.set(new Date(newStartDateMs));
        endSelect.set(newEndDate);
        endDateField.value = AjxDateUtil.simpleComputeDateStr(newEndDate);

        if (endDateField.value != endDateOrig) {
            return endDateField;
        }
    } else if (id == DwtTimeInput.END){
        var timeStr = dateInfo ? dateInfo.endTimeStr : endSelect.getTimeString();
        var oldEndDateMs = DwtTimeInput.getDateFromFields(timeStr, endDate).getTime();
        var newEndDateMs = DwtTimeInput.getDateFromFields(endSelect.getTimeString(), endDate).getTime();
        var oldStartDateMs = DwtTimeInput.getDateFromFields(startSelect.getTimeString(), startDate).getTime();

        var delta = oldEndDateMs - oldStartDateMs;
        if (!delta) return null;

        //adjust start date only when the end date falls earlier than start date
        if(newEndDateMs < oldStartDateMs) {
            var newStartDateMs = newEndDateMs - delta;
            var newStartDate = new Date(newStartDateMs);

            startSelect.set(newStartDate);
            endSelect.set(new Date(newEndDateMs));
            startDateField.value = AjxDateUtil.simpleComputeDateStr(newStartDate);
            endDateField.value = AjxDateUtil.simpleComputeDateStr(new Date(newEndDateMs));
        }

        if (startDateField.value != startDateOrig) {
            return startDateField;
        }

    } else {
        return null;
    }
};

/**
 * Returns true if the start date/time is before the end date/time.
 *
 * @param ss				[DwtTimeInput]		start time select
 * @param es				[DwtTimeInput]		end time select
 * @param startDateField	[element]			start date field
 * @param endDateField		[element]			end date field
 */
DwtTimeInput.validStartEnd =
function(startDateField, endDateField, ss, es) {
	var startDate = AjxDateUtil.simpleParseDateStr(startDateField.value);
	var endDate = AjxDateUtil.simpleParseDateStr(endDateField.value);

	if (startDate && endDate) {
		if((startDate.valueOf() > endDate.valueOf())) {
			return false;
		}
		// bug fix #11329 - dont allow year to be more than the earth will be around :]
		if (startDate.getFullYear() > 9999 || endDate.getFullYear() > 9999) {
			return false;
		}
		if (ss && es) {
			var startTime = ss.getTimeString();
			var endTime = es.getTimeString();
			if (startTime && endTime) {
				var startDateMs = DwtTimeInput.getDateFromFields(startTime, startDate).getTime();
				var endDateMs = DwtTimeInput.getDateFromFields(endTime, endDate).getTime();
				if (startDateMs > endDateMs) {
					return false;
				}
			}
		}
	} else {
		return false;
	}
	return true;
};

DwtTimeInput.prototype = new DwtComposite;
DwtTimeInput.prototype.constructor = DwtTimeInput;
DwtTimeInput.prototype.isDwtTimeInput = true;

DwtTimeInput.prototype.toString = function() {
    return 'DwtTimeInput';
};

/**
* Sets the time select according to the given date.
*
* @param date	[Date]		a Date object
*/
DwtTimeInput.prototype.set =
function(date) {
    var timeStr = DwtTimeSelect.format(date);
    this._originalTimeStr = timeStr;
    this._timeSelectInput.setValue(timeStr);
    this._scrollToValue(timeStr);
};

/**
* Sets the time string after validating it
*
* @param date	[Date]		a Date object
*/
DwtTimeInput.prototype.setValue =
function(str) {
    //sets only if the date is valid
    var date = DwtTimeSelect.parse(str);
    if (!date) str = "";
    this._originalTimeStr = str;
    this._timeSelectInput.setValue(str);
    this._scrollToValue(str);
};

DwtTimeInput.prototype._scrollToValue =
function(str) {
    var index = this.getTimeIndex(str);
    if (index !== null)
        this._hoursSelectMenu.setSelectedItem(index);
};

/**
 * Returns a date object with the hours and minutes set based on
 * the values of this time picker.
 *
 * @param date [Date] Optional. If specified, the hour and minute
 *                    values will be set on the specified object;
 *                    else, a new <code>Date</code> object is created.
 */
DwtTimeInput.prototype.getValue =
function(date) {
	//return (DwtTimeInput.getDateFromFields(this.getHours(), this.getMinutes(), this.getAmPm(), date));
    var d = DwtTimeSelect.parse(this._timeSelectInput.getValue());
	if(!d) {
		d = new Date();
	}
    date = date || new Date();
    //daylight saving time
    if(AjxDateUtil.isDayShifted(date)) {
        AjxDateUtil.rollToNextDay(date);
    }
	
    date.setHours(d.getHours(), d.getMinutes(), 0, 0);
    return date;
};

DwtTimeInput.prototype.getHours =
function() {
    var d = this.getValue();
    return d ? d.getHours() : null;
};

DwtTimeInput.prototype.getMinutes =
function() {
    var d = this.getValue();
    return d ? d.getMinutes() : null;
};

DwtTimeInput.prototype.addChangeListener =
function(listener) {
    this._changeListener = listener;
    var callback = AjxCallback.simpleClosure(this.handleTimeChange, this, listener);
    this._timeSelectInput.setHandler(DwtEvent.ONBLUR, callback);
};

DwtTimeInput.prototype.handleTimeChange =
function(listener, ev) {
    //restore old value if the new time is not in correct format
    var str = this._timeSelectInput.getValue();
    var d = DwtTimeSelect.parse(str);
    if(!d) {
        //TODO: Try to guess the time 
        /*var newDate = this.correctTimeString(str, DwtTimeSelect.parse(this._originalTimeStr));
        this.setValue(DwtTimeSelect.format(newDate) || "");*/
        this.setValue(this._originalTimeStr);
    } else {
        this._scrollToValue(str);
    }

    listener.run(ev, this.id);
};

DwtTimeInput.prototype.correctTimeString =
function(val, originalDate) {

    var segments = val.split(":");

    if(!segments) return originalDate;

    var hrs = (segments.length && segments[0] != null) ? parseInt(segments[0].replace(/\D/g, "")) : null;
    var mins = (segments.length > 1 && segments[1]!= null) ? parseInt(segments[1].replace(/\D/g, "")) : 0;

    if(!hrs) hrs = (hrs == 0) ? 0 : originalDate.getHours();
    if(!mins) mins = 0;

    originalDate.setHours(hrs, mins, 0, 0);

    return originalDate;

};

DwtTimeInput.prototype.isLocale24Hour =
function() {
	return this._isLocale24Hour;
};

DwtTimeInput.prototype.setEnabled =
function(enabled) {
   DwtComposite.prototype.setEnabled.call(this, enabled);
   this._timeSelectInput.setEnabled(enabled);
   this._timeSelectBtn.setEnabled(enabled);
};


DwtTimeInput.prototype._timeButtonListener =
function(ev) {
	var timeFormatter = AjxDateFormat.getTimeInstance(AjxDateFormat.SHORT);
	var defaultTopMenuItem;
    if(!this._menuItemsAdded) {
        var j,
            k,
            mi,
            smi,
            text,
            maxMinutesItem,
            minutesSelectMenu,
            now = new Date(),
            timeSelectButton = this._timeSelectBtn,
            menuSelectionListener = new AjxListener(this, this._timeSelectionListener);

        for (j = 0; j < 24; j++) {
            now.setHours(j);
            now.setMinutes(0);

            mi = new DwtMenuItem({parent: this._hoursSelectMenu, style: DwtMenuItem.NO_STYLE});
            text = timeFormatter.format(now); // Regular formatter, returns the I18nMsg formatted time
            this.putTimeIndex(text, j);

			if (j==0 || j==12) {
                text = DwtTimeSelect.format(now); // Specialized formatter, returns AjxMsg.midnight for midnight and AjxMsg.noon for noon
                this.putTimeIndex(text, j); // Both should go in the indexer
            }

            mi.setText(text);
            mi.setData("value", j*60);
            if (menuSelectionListener) mi.addSelectionListener(menuSelectionListener);
            if (j == DwtTimeInput.DEFAULT_TOP_ROW) defaultTopMenuItem = mi;

            maxMinutesItem = 60 / this._interval;
            minutesSelectMenu = new DwtMenu({parent:mi, style:DwtMenu.DROPDOWN_CENTERV_STYLE, layout:DwtMenu.LAYOUT_CASCADE, maxRows:maxMinutesItem, congruent: true});
            mi.setMenu(minutesSelectMenu, true);
            mi.setSelectableWithSubmenu(true);
			minutesSelectMenu.dontStealFocus(true);
			for (k = 1; k < maxMinutesItem; k++) {
                now.setMinutes(k*this._interval);
                smi = new DwtMenuItem({parent: minutesSelectMenu, style: DwtMenuItem.NO_STYLE});
                smi.setText(timeFormatter.format(now));
                smi.setData("value", j*60 + k*this._interval);
                if (menuSelectionListener) smi.addSelectionListener(menuSelectionListener);
            }
        }
        this._hoursSelectMenu.setWidth(timeSelectButton.getW() + this._timeSelectInput.getW());

        this._menuItemsAdded = true;
    }
	ev.item.popup();
	if (defaultTopMenuItem) {
		this._hoursSelectMenu.scrollToItem(defaultTopMenuItem);
	}
	this._scrollToValue(timeFormatter.format(this.getValue()));
};

DwtTimeInput.prototype._timeSelectionListener =
function(ev) {
    if(ev.item && ev.item instanceof DwtMenuItem){
       this._timeSelectInput.setValue(ev.item.getText());
       this._timeSelectValue = ev.item.getData("value");
       if(this._changeListener) this._changeListener.run(ev, this.id);
       return;
    }
};

DwtTimeInput.prototype.getTimeString =
function() {
    //validate and returns only valid time string
    var date = DwtTimeSelect.parse(this._timeSelectInput.getValue());
    return date ? this._timeSelectInput.getValue() : "";    
};

DwtTimeInput.prototype.getInputField =
function() {
    return this._timeSelectInput;
};

DwtTimeInput.prototype.getTabGroupMember =
function() {
    return this._tabGroup;
};

DwtTimeInput.prototype.putTimeIndex =
function(text, value) {
    this._timeIndex[text.replace(/\:\d\d/, ":00").replace(/\s/,"").toLowerCase()] = value;
};

DwtTimeInput.prototype.getTimeIndex =
function(text) {
    if (!text) return null;
    var index = this._timeIndex[text.replace(/\:\d\d/, ":00").replace(/\s/,"").toLowerCase()];
    return (index || index===0) ? index : null;
};

DwtTimeInput.prototype._createSelects =
function() {
	var label = (this.id === DwtTimeSelect.START ? ZmMsg.startTime :
	             this.id === DwtTimeSelect.END ? ZmMsg.endTime :
	             ZmMsg.time);

	// get the time formatter for the user's locale

	this.getHtmlElement().innerHTML = AjxTemplate.expand("calendar.Appointment#ApptTimeInput", {id: this._htmlElId});

    var inputId = Dwt.getNextId("DwtTimeInputSelect_");
    if (this.id && this.id == DwtTimeSelect.START) {
       inputId += "_startTimeInput";
    }
    else if (this.id && this.id == DwtTimeSelect.END) {
        inputId += "_endTimeInput";
    }
    //create time select input field
    var params = {
        parent: this,
        parentElement: (this._htmlElId + "_timeSelectInput"),
        type: DwtInputField.STRING,
        label: label,
        errorIconStyle: DwtInputField.ERROR_ICON_NONE,
        validationStyle: DwtInputField.CONTINUAL_VALIDATION,
        inputId: inputId,
	    id: Dwt.getNextId("DwtTimeInputField_")
    };

    this._timeSelectInput = new DwtInputField(params);
    var timeInputEl = this._timeSelectInput.getInputElement();
    Dwt.setSize(timeInputEl, "80px", "2rem");
    timeInputEl.typeId = this.id;
    //listeners
    var buttonListener = new AjxListener(this, this._timeButtonListener);
    var buttonId = this._htmlElId + "_timeSelectBtn";
    //create time select drop down button
    var timeSelectButton = this._timeSelectBtn = new DwtButton({parent:this});
    timeSelectButton.addDropDownSelectionListener(buttonListener);

    timeSelectButton.setData(Dwt.KEY_ID, buttonId);
    timeSelectButton.setSize("20");
    timeSelectButton.setAttribute('aria-label', label);
    
    this._timeIndex = {};
    // create menu for button
    this._hoursSelectMenu = new DwtMenu({parent:timeSelectButton, style:DwtMenu.DROPDOWN_STYLE, layout:DwtMenu.LAYOUT_SCROLL, maxRows:DwtTimeInput.ROWS});
    timeSelectButton.setMenu(this._hoursSelectMenu, true, false, false, true);
    this._menuItemsAdded = false;
    timeSelectButton.reparentHtmlElement(buttonId);

    this._tabGroup = new DwtTabGroup(this.getHTMLElId());
    this._tabGroup.addMember(this._timeSelectInput);
    this._tabGroup.addMember(timeSelectButton);
};
}
}
if (AjxPackage.define("dwt.Widgets")) {
AjxTemplate.register("dwt.Widgets#DwtAlert", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<table role=\"presentation\" width=100%><tr><td width=1%><div id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_icon' style='margin-right:5px;'></div></td><td width=99%><table role=\"presentation\"><tr><td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_title' class='DwtAlertTitle'></td></tr><tr><td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_content' class='DwtAlertContent'></td></tr></table></td><td width=1%><div id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_dismiss' style='margin-left:5px;'></div></td></tr></table>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#DwtAlert"
}, false);
AjxTemplate.register("dwt.Widgets", AjxTemplate.getTemplate("dwt.Widgets#DwtAlert"), AjxTemplate.getParams("dwt.Widgets#DwtAlert"));

AjxTemplate.register("dwt.Widgets#DwtCheckbox", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<table role=\"presentation\" class='ZCheckboxTable'><tr><td><label id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_text_left' for='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_input' class='Text' style='text-align:right'></label></td><td><input id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_input' name='";
	buffer[_i++] = data["name"];
	buffer[_i++] = "' value='";
	buffer[_i++] = data["value"];
	buffer[_i++] = "' type='";
	buffer[_i++] = data["type"];
	buffer[_i++] = "' aria-labelledby='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_text_left ";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_text_right'></td><td><label id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_text_right' for='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_input' class='Text' style='text-align:left'></label></td></tr></table>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#DwtCheckbox"
}, false);

AjxTemplate.register("dwt.Widgets#DwtBaseDialog", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<div class='DwtDialog WindowOuterContainer'><table role=\"presentation\"><tr id='";
	buffer[_i++] = data["dragId"];
	buffer[_i++] = "'><td class='minWidth'>";
	buffer[_i++] = data["icon"];
	buffer[_i++] = "</td><td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_title' class='DwtDialogTitle'>";
	buffer[_i++] = data["title"];
	buffer[_i++] = "</td><td class='minWidth'><div class='";
	buffer[_i++] = data["closeIcon2"];
	buffer[_i++] = "'></div></td><td class='minWidth'><div class='";
	buffer[_i++] = data["closeIcon1"];
	buffer[_i++] = "'></div></td></tr><tr><td class='WindowInnerContainer' colspan='4'><div id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_content' class='DwtDialogBody'></div>";
	 if (data.controlsTemplateId) { 
	buffer[_i++] =  AjxTemplate.expand(data.controlsTemplateId, data) ;
	 } 
	buffer[_i++] = "</td></tr></table></div>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"width": "20",
	"id": "dwt.Widgets#DwtBaseDialog",
	"height": "32"
}, false);

AjxTemplate.register("dwt.Widgets#DwtDialogControls", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<div class='horizSep' id=\"";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_buttonsSep\"></div><div id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_buttons' class='DwtDialogButtonBar'>";
	 if (AjxEnv.isNav) { 
	buffer[_i++] = "<input type='button' id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_focus' style='height:0px;width:0px;display:none;'>";
	 } 
	buffer[_i++] = "</div>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#DwtDialogControls"
}, false);

AjxTemplate.register("dwt.Widgets#DwtSemiModalDialog", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<div class='DwtDialog LightWindowOuterContainer'><table role=\"presentation\" style='cursor:move;'><tr id='";
	buffer[_i++] = data["dragId"];
	buffer[_i++] = "'><td class='minWidth'>";
	buffer[_i++] = data["icon"];
	buffer[_i++] = "</td><td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_title' class='DwtDialogTitle'>";
	buffer[_i++] = data["title"];
	buffer[_i++] = "</td><td class='minWidth'><div class='";
	buffer[_i++] = data["closeIcon2"];
	buffer[_i++] = "'></div></td><td class='minWidth'><div class='";
	buffer[_i++] = data["closeIcon1"];
	buffer[_i++] = "'></div></td></tr><tr><td class='LightWindowInnerContainer full_size' colspan='4'><div id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_content' class='DwtDialogBody'></div><div class='horizSep'></div><div id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_buttons' class='DwtDialogButtonBar'>";
	 if (AjxEnv.isNav) { 
	buffer[_i++] = "<input type='button' id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_focus' style='height:0px;width:0px;display:none;'>";
	 } 
	buffer[_i++] = "</div></td></tr></table></div>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"width": "20",
	"id": "dwt.Widgets#DwtSemiModalDialog",
	"height": "32"
}, false);

AjxTemplate.register("dwt.Widgets#DwtToolTip", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<div id='tooltipContents' class='DwtToolTipBody'></div>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"width": "5",
	"id": "dwt.Widgets#DwtToolTip",
	"height": "5"
}, false);

AjxTemplate.register("dwt.Widgets#DwtVerticalSash", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<div class='DwtVerticalSash'><div class='VSashContainer'><div class='VSashThumb ImgVSash_thumb'></div></div></div>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"width": "0",
	"id": "dwt.Widgets#DwtVerticalSash",
	"height": "0"
}, false);

AjxTemplate.register("dwt.Widgets#DwtHorizontalSash", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<div class='DwtHorizontalSash'><div class='HSashContainer'><div class='HSashThumb ImgHSash_thumb'></div></div></div>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"width": "0",
	"id": "dwt.Widgets#DwtHorizontalSash",
	"height": "0"
}, false);

AjxTemplate.register("dwt.Widgets#DwtMissingSoundPlayer", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<table role=\"presentation\" class='DwtMissingSoundPlayer'><tr><td nowrap class='ImgCritical'>&nbsp;</td><td nowrap>";
	buffer[_i++] =  ZmMsg.missingPlugin ;
	buffer[_i++] = "</td></tr></table>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#DwtMissingSoundPlayer"
}, false);

AjxTemplate.register("dwt.Widgets#DwtVerticalSlider", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<div id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_button' class='DwtThumb DwtSliderThumb'><div class='DwtSliderThumbBorder'><div class='ImgVerticalSliderThumb'></div></div></div>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#DwtVerticalSlider",
	"class": "DwtSlider DwtVerticalSlider"
}, false);

AjxTemplate.register("dwt.Widgets#DwtHorizontalSlider", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<div id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_button' class='DwtThumb DwtSliderThumb'><div class='DwtSliderThumbBorder'><div class='ImgHorizontalSliderThumb'></div></div></div>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#DwtHorizontalSlider",
	"class": "DwtSlider DwtHorizontalSlider"
}, false);

AjxTemplate.register("dwt.Widgets#ZLabel", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<table role=\"presentation\" class='ZWidgetTable ZLabelBorder'><tr><td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_left_icon'  \tclass='ZLeftIcon ZWidgetIcon'></td><td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_title'\t\tclass='ZWidgetTitle'></td><td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_right_icon' \tclass='ZRightIcon ZWidgetIcon'></td></tr></table>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZLabel",
	"class": "ZWidget"
}, false);

AjxTemplate.register("dwt.Widgets#ZButton", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	 var buttonClass = data.buttonClass || "Button"; 
	buffer[_i++] = "<table role=\"presentation\" class='ZWidgetTable Z";
	buffer[_i++] = buttonClass;
	buffer[_i++] = "Table Z";
	buffer[_i++] = buttonClass;
	buffer[_i++] = "Border' style='table-layout:auto;' cellspacing='0'><tr><td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_left_icon'  \tclass='ZLeftIcon ZWidgetIcon'></td><td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_title'\t\tclass='ZWidgetTitle'></td><td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_right_icon' \tclass='ZRightIcon ZWidgetIcon'></td><td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_dropdown' \tclass='ZDropDown'></td></tr></table>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZButton",
	"class": "ZWidget"
}, false);

AjxTemplate.register("dwt.Widgets#ZImageOnlyButton", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<div id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_left_icon'></div>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZImageOnlyButton",
	"class": "ZWidget"
}, false);

AjxTemplate.register("dwt.Widgets#ZToolbarButton", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	 data.buttonClass = data.buttonClass || "ToolbarButton" 
	buffer[_i++] =  AjxTemplate.expand("#ZButton", data) ;

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZToolbarButton",
	"class": "ZWidget"
}, false);

AjxTemplate.register("dwt.Widgets#ZBorderlessButton", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	 var buttonClass = data.buttonClass || "Button"; 
	buffer[_i++] = "<table role=\"presentation\" class='ZWidgetTable Z";
	buffer[_i++] = buttonClass;
	buffer[_i++] = "Table' style='table-layout:auto;'><tr><td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_left_icon'  \tclass='ZLeftIcon ZWidgetIcon'></td><td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_title'\t\tclass='ZWidgetTitle'></td><td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_right_icon' \tclass='ZRightIcon ZWidgetIcon'></td><td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_dropdown' \tclass='ZDropDown'></td></tr></table>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZBorderlessButton",
	"class": "ZWidget"
}, false);

AjxTemplate.register("dwt.Widgets#ZLinkButton", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	 if (data.noDropDown) { 
	buffer[_i++] = "<a href='javascript:;' onclick='return false;' id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_title'></a>";
	 }
		   else { 
	buffer[_i++] = "<table role=\"presentation\" class='DwtLinkButtonTable' style='table-layout:auto;'><tr><td class='ZWidgetTitle'><a href='javascript:;' onclick='return false;' id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_title'></a></td><td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_dropdown' class='DwtLinkButtonDropDownArrowTd'><div class='DwtLinkButtonDropDownArrow'><center><div class='DwtLinkButtonDropDownArrowRow' style='width:7px;'>&nbsp;</div><div class='DwtLinkButtonDropDownArrowRow' style='width:5px;'>&nbsp;</div><div class='DwtLinkButtonDropDownArrowRow' style='width:3px;'>&nbsp;</div><div class='DwtLinkButtonDropDownArrowRow' style='width:1px;'>&nbsp;</div></center></div></td></tr></table>";
	 } 

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZLinkButton",
	"class": "ZWidget"
}, false);

AjxTemplate.register("dwt.Widgets#ZButtonColorDisplay", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<div id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_color' class='DwtButtonColorPicker-display' unselectable></div>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZButtonColorDisplay"
}, false);

AjxTemplate.register("dwt.Widgets#DwtComboBox", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<table role=\"presentation\"><tr><td width=*><div id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_input'></div></td><td><div id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_button'></div></td></tr></table>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#DwtComboBox",
	"class": "DwtComboBox"
}, false);

AjxTemplate.register("dwt.Widgets#DwtComboBoxButton", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	 var buttonClass = data.buttonClass || "Button"; 
	buffer[_i++] = "<table role=\"presentation\" class='Z";
	buffer[_i++] = buttonClass;
	buffer[_i++] = "Border'><tr><td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_dropdown' class='ZDropDown'></td></tr></table>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#DwtComboBoxButton",
	"class": "ZWidget"
}, false);

AjxTemplate.register("dwt.Widgets#ZTabView", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<div id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_tabbar'></div><div id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_page'></div>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZTabView",
	"class": "ZWidget"
}, false);

AjxTemplate.register("dwt.Widgets#ZTabBar", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<table role=\"presentation\" width='100%'><tr valign='bottom' id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_items'>";
	buffer[_i++] =  AjxTemplate.expand("#ZTabBarPrefix", data) ;
	buffer[_i++] =  AjxTemplate.expand("#ZTabBarSuffix", data) ;
	buffer[_i++] = "</tr></table>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZTabBar",
	"class": "ZWidget"
}, false);

AjxTemplate.register("dwt.Widgets#ZTabBarPrefix", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_prefix'><div class='ZTabBarPrefix'></div></td>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZTabBarPrefix"
}, false);

AjxTemplate.register("dwt.Widgets#ZTabBarSuffix", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_suffix' width='100%'><div class='ZTabBarSuffix'></div></td>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZTabBarSuffix"
}, false);

AjxTemplate.register("dwt.Widgets#ZTab", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	 var buttonClass = data.buttonClass || "Tab" 
	buffer[_i++] = "<table role=\"presentation\" id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_select' class='Z";
	buffer[_i++] = buttonClass;
	buffer[_i++] = "Table Z";
	buffer[_i++] = buttonClass;
	buffer[_i++] = "Border ZWidgetTable ZWidgetBorder'><tr><td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_left_icon' class='ZLeftIcon ZWidgetIcon'></td><td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_title' class='ZWidgetTitle'></td><td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_right_icon' class='ZRightIcon ZWidgetIcon'></td></tr></table>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZTab",
	"class": "ZWidget"
}, false);

AjxTemplate.register("dwt.Widgets#ZTabBarFloat", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<div id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_items'>";
	buffer[_i++] =  AjxTemplate.expand("#ZTabBarPrefixFloat", data) ;
	buffer[_i++] =  AjxTemplate.expand("#ZTabBarSuffixFloat", data) ;
	buffer[_i++] = "</div>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZTabBarFloat",
	"class": "ZWidget"
}, false);

AjxTemplate.register("dwt.Widgets#ZTabBarPrefixFloat", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<div id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_prefix' class='ZTabBarPrefix'>&nbsp;</div>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZTabBarPrefixFloat"
}, false);

AjxTemplate.register("dwt.Widgets#ZTabBarSuffixFloat", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<div id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_suffix' class='ZTabBarSuffix'>&nbsp;</div>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZTabBarSuffixFloat"
}, false);

AjxTemplate.register("dwt.Widgets#ZTabFloat", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	 var buttonClass = data.buttonClass || "Tab" 
	buffer[_i++] = "<table role=\"presentation\" id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_select' class='Z";
	buffer[_i++] = buttonClass;
	buffer[_i++] = "Table Z";
	buffer[_i++] = buttonClass;
	buffer[_i++] = "Border ZWidgetBorder'><tr><td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_left_icon' class='ZLeftIcon ZWidgetIcon'></td><td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_title' class='ZWidgetTitle'></td><td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_right_icon' class='ZRightIcon ZWidgetIcon'></td></tr></table>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZTabFloat",
	"class": "ZWidget"
}, false);

AjxTemplate.register("dwt.Widgets#ZTabPage", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZTabPage",
	"class": "ZWidget"
}, false);

AjxTemplate.register("dwt.Widgets#ZSelectAutoSizingContainer", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<table role=\"presentation\"><tr><td id=\"";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_select_container\">";
	buffer[_i++] =  AjxTemplate.expand(data.selectTemplateId, data.selectData) ;
	buffer[_i++] = "</td></tr><tr><td><table role=\"presentation\" id=\"";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_pseudoitems_container\"></table></td></tr></table>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZSelectAutoSizingContainer"
}, false);

AjxTemplate.register("dwt.Widgets#ZSelect", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] =  AjxTemplate.expand("#ZButton", data) ;

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZSelect",
	"class": "ZWidget"
}, false);

AjxTemplate.register("dwt.Widgets#ZSelectMenu", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] =  AjxTemplate.expand("#ZMenu", data) ;

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZSelectMenu",
	"class": "ZWidget"
}, false);

AjxTemplate.register("dwt.Widgets#ZSelectMenuItem", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] =  AjxTemplate.expand("#ZMenuItem", data) ;

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZSelectMenuItem",
	"class": "ZWidget"
}, false);

AjxTemplate.register("dwt.Widgets#ZToolbar", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<table role=\"presentation\" class='ZToolbarTable'><tr id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_items'>";
	buffer[_i++] =  AjxTemplate.expand("#ZToolbarPrefix", data) ;
	buffer[_i++] =  AjxTemplate.expand("#ZToolbarSuffix", data) ;
	buffer[_i++] = "</tr></table>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZToolbar",
	"class": "ZWidget"
}, false);

AjxTemplate.register("dwt.Widgets#ZToolbarPrefix", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZToolbarPrefix"
}, false);

AjxTemplate.register("dwt.Widgets#ZToolbarSuffix", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZToolbarSuffix"
}, false);

AjxTemplate.register("dwt.Widgets#ZToolbarItem", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<table role=\"presentation\"><tr><td id='";
	buffer[_i++] = data["itemId"];
	buffer[_i++] = "'></td></tr></table>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZToolbarItem"
}, false);

AjxTemplate.register("dwt.Widgets#ZToolbarSeparator", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<table role=\"presentation\"><tr><td id='";
	buffer[_i++] = data["itemId"];
	buffer[_i++] = "' class='ZToolbarSeparator'>&nbsp;</td></tr></table>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZToolbarSeparator"
}, false);

AjxTemplate.register("dwt.Widgets#ZToolbarSpacer", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<table role=\"presentation\"><tr><td id='";
	buffer[_i++] = data["itemId"];
	buffer[_i++] = "' class='ZToolbarSpacer'>&nbsp;</td></tr></table>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZToolbarSpacer"
}, false);

AjxTemplate.register("dwt.Widgets#ZToolbarFiller", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<table role=\"presentation\"><tr><td id='";
	buffer[_i++] = data["itemId"];
	buffer[_i++] = "' class='ZToolbarFiller' width='100%'>&nbsp;</td></tr></table>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZToolbarFiller"
}, false);

AjxTemplate.register("dwt.Widgets#ZField", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<input id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_field' class='ZFieldInput'>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZField",
	"class": "ZWidget"
}, false);

AjxTemplate.register("dwt.Widgets#ZTreeItem", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<div class='";
	buffer[_i++] = data["divClassName"];
	buffer[_i++] = "' id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_div'><table role=\"presentation\" id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_table' style=\"table-layout:fixed; width:100%\"><tr><td style=\"width:20px\" align=center nowrap id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_nodeCell'></td>";
	 if (data.isCheckedStyle) { 
	buffer[_i++] = "<td style=\"width:20px\" nowrap id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_checkboxCell' class=\"ZTreeItemCheckboxCell\"><div class=\"ZTreeItemCheckbox\" id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_checkbox'><div class=\"ZTreeItemCheckboxImg\" id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_checkboxImg'>";
	buffer[_i++] =  AjxImg.getImageHtml("MenuCheck") ;
	buffer[_i++] = "</div></div></td>";
	 } 
	buffer[_i++] = "<td style=\"width:20px\" nowrap class='imageCell' id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_imageCell'></td><td nowrap class='";
	buffer[_i++] = data["textClassName"];
	buffer[_i++] = "' id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_textCell'></td><td class='imageCell' id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_extraCell'></td></tr></table></div>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZTreeItem"
}, false);

AjxTemplate.register("dwt.Widgets#ZHeaderTreeItem", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<div class='";
	buffer[_i++] = data["divClassName"];
	buffer[_i++] = "' id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_div'><table role=\"presentation\" id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_table'><tr>";
	 if (!data.noNodeCell) { 
	buffer[_i++] = "<td align=center nowrap id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_nodeCell'></td>";
	 } 
	buffer[_i++] = "<td nowrap class='imageCell' id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_imageCell'></td><td nowrap class='";
	buffer[_i++] = data["textClassName"];
	buffer[_i++] = "' id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_textCell' width=\"100%\"></td><td class='";
	buffer[_i++] = data["textClassName"];
	buffer[_i++] = " FakeAnchor' id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_optCell'><div id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_optButton'/></td></tr></table></div>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZHeaderTreeItem"
}, false);

AjxTemplate.register("dwt.Widgets#ZAccordion", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<div id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_div'><table role=\"presentation\" class='ZAccordionTable ZWidget' id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_accordion_table'></table></div>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZAccordion"
}, false);

AjxTemplate.register("dwt.Widgets#ZAccordionItem", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<div id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_header_";
	buffer[_i++] = data["itemNum"];
	buffer[_i++] = "' class='ZAccordionHeader'><table role=\"presentation\" class='ZAccordionHeaderBorder ZWidgetTable'><tr><td><div class='";
	buffer[_i++] = data["icon"];
	buffer[_i++] = "' id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_icon_";
	buffer[_i++] = data["itemNum"];
	buffer[_i++] = "'></div></td><td><div class='ZAccordionTitle' id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_title_";
	buffer[_i++] = data["itemNum"];
	buffer[_i++] = "'>";
	buffer[_i++] = data["title"];
	buffer[_i++] = "</div></td><td><div class='ImgAccordionClosed' id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_status_";
	buffer[_i++] = data["itemNum"];
	buffer[_i++] = "'></div></td></tr></table></div><div class='ZAccordionBody' id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_body_";
	buffer[_i++] = data["itemNum"];
	buffer[_i++] = "'></div>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZAccordionItem"
}, false);

AjxTemplate.register("dwt.Widgets#DwtTabView", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<table role=\"presentation\" width='100%' backgroundColor='";
	buffer[_i++] = data["bgcolor"];
	buffer[_i++] = "'><tr align='left' valign='middle'><td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_tabs' class='DwtTabTable' nowrap align='left' valign='middle' width='100%'></td></tr></table>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#DwtTabView"
}, false);

AjxTemplate.register("dwt.Widgets#DwtTabBar", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<!-- TODO -->";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#DwtTabBar"
}, false);

AjxTemplate.register("dwt.Widgets#DwtTabSpacer", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<table role=\"presentation\" width='100%'><tr></tr><tr></tr><tr><td><div class='ImgTabSpacer'></div></td></tr></table>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#DwtTabSpacer"
}, false);

AjxTemplate.register("dwt.Widgets#ZMenu", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<div id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_container' class='ZMenuBorder'></div>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZMenu",
	"class": "ZWidget"
}, false);

AjxTemplate.register("dwt.Widgets#ZMenuItem", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<table role=\"presentation\" class='ZWidgetTable ZMenuItemTable ZMenuItemBorder'><tr><td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_check' class='ZCheckIcon'><div></div></td><td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_left_icon' class='ZLeftIcon ZWidgetIcon'></td><td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_title' class='ZWidgetTitle'></td><td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_dropdown' class='ZDropDown'><div></div></td></tr></table>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZMenuItem",
	"class": "ZWidget"
}, false);

AjxTemplate.register("dwt.Widgets#ZMenuItemSeparator", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<table role=\"presentation\" class='ZWidgetTable ZMenuItemTable ZMenuItemBorder ZMenuItemSeparatorBorder'><tr><td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_title' class='ZWidgetTitle'><div class='ZMenuItem-Separator'></div></td></tr></table>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZMenuItemSeparator",
	"class": "ZWidget"
}, false);

AjxTemplate.register("dwt.Widgets#ZMenuItemBlankCheck", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<div class='ZMenuItem-BlankCheck'></div>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZMenuItemBlankCheck"
}, false);

AjxTemplate.register("dwt.Widgets#ZMenuItemBlankIcon", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<div class='ZMenuItem-BlankIcon'></div>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZMenuItemBlankIcon"
}, false);

AjxTemplate.register("dwt.Widgets#ZMenuItemBlankCascade", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<div class='ZMenuItem-BlankCascade'></div>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#ZMenuItemBlankCascade"
}, false);

AjxTemplate.register("dwt.Widgets#DwtListView-NoResults", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<table role=\"presentation\" width='100%'><tr><td class='NoResults'>\n";
	buffer[_i++] = "\t\t\t\t";
	buffer[_i++] = data["message"];
	buffer[_i++] = "\n";
	buffer[_i++] = "\t\t\t</td></tr></table>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#DwtListView-NoResults"
}, false);

AjxTemplate.register("dwt.Widgets#DwtPasswordField", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<table role=\"presentation\"><tr><td><div id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_input'></div></td><td><div id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_show_password'></div></td></tr></table>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#DwtPasswordField"
}, false);

AjxTemplate.register("dwt.Widgets#DwtFormRows", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<table role=\"presentation\" class=\"ZPropertySheet\" cellspacing=\"6\"><tbody id=\"";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_rows\" tabindex=\"100\"></tbody></table>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#DwtFormRows"
}, false);

AjxTemplate.register("dwt.Widgets#DwtFormRow", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<table role=\"presentation\"><tr id=\"";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_row\" class=\"DwtFormRow\"><td><div id=\"";
	buffer[_i++] = data["id"];
	buffer[_i++] = "\" tabindex=\"100\"></div></td><td><div id=\"";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_add\" class=\"DwtFormRowAdd\" tabindex=\"200\"></div></td><td><div id=\"";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_remove\" class=\"DwtFormRowRemove\" tabindex=\"300\"></div></td></tr></table>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#DwtFormRow"
}, false);

AjxTemplate.register("dwt.Widgets#DwtColorPicker", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<div id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_colors'><div class='Text'>";
	buffer[_i++] = AjxMsg.colorsStandard;
	buffer[_i++] = "</div><div class='Colors First'><div class='Color' style='background-color:";
	buffer[_i++] = AjxMsg.colorRed;
	buffer[_i++] = ";'></div><div class='Color' style='background-color:";
	buffer[_i++] = AjxMsg.colorOrange;
	buffer[_i++] = ";'></div><div class='Color' style='background-color:";
	buffer[_i++] = AjxMsg.colorYellow;
	buffer[_i++] = ";'></div><div class='Color' style='background-color:";
	buffer[_i++] = AjxMsg.colorGreen;
	buffer[_i++] = ";'></div><div class='Color' style='background-color:";
	buffer[_i++] = AjxMsg.colorCyan;
	buffer[_i++] = ";'></div><div class='Color' style='background-color:";
	buffer[_i++] = AjxMsg.colorBlue;
	buffer[_i++] = ";'></div><div class='Color' style='background-color:";
	buffer[_i++] = AjxMsg.colorPurple;
	buffer[_i++] = ";'></div><div class='Color' style='background-color:";
	buffer[_i++] = AjxMsg.colorPink;
	buffer[_i++] = ";'></div><div class='Color' style='background-color:white;'></div><div class='Color' style='background-color:black;'></div></div><div class='Text'>";
	buffer[_i++] = AjxMsg.colorsCustom;
	buffer[_i++] = "</div><div class='Colors First'><div class='Color' style='background-color:#ff8686;'></div><div class='Color' style='background-color:#ff9966;'></div><div class='Color' style='background-color:#ffff99;'></div><div class='Color' style='background-color:#ccffcc;'></div><div class='Color' style='background-color:#ccffff;'></div><div class='Color' style='background-color:#99ccff;'></div><div class='Color' style='background-color:#ccccff;'></div><div class='Color' style='background-color:#ffccff;'></div><div class='Color' style='background-color:#ededed;'></div><div class='Color' style='background-color:#808080;'></div></div><div class='Colors'><div class='Color' style='background-color:#ff0000;'></div><div class='Color' style='background-color:#ff6600;'></div><div class='Color' style='background-color:#ffcc33;'></div><div class='Color' style='background-color:#66cc66;'></div><div class='Color' style='background-color:#00cccc;'></div><div class='Color' style='background-color:#3366ff;'></div><div class='Color' style='background-color:#6666ff;'></div><div class='Color' style='background-color:#cc33cc;'></div><div class='Color' style='background-color:#d5d5d5;'></div><div class='Color' style='background-color:#666666;'></div></div><div class='Colors'><div class='Color' style='background-color:#cc0000;'></div><div class='Color' style='background-color:#cc6600;'></div><div class='Color' style='background-color:#cc9933;'></div><div class='Color' style='background-color:#009900;'></div><div class='Color' style='background-color:#339999;'></div><div class='Color' style='background-color:#3333ff;'></div><div class='Color' style='background-color:#6633ff;'></div><div class='Color' style='background-color:#993399;'></div><div class='Color' style='background-color:#cccccc;'></div><div class='Color' style='background-color:#4d4d4d;'></div></div><div class='Colors'><div class='Color' style='background-color:#990000;'></div><div class='Color' style='background-color:#993300;'></div><div class='Color' style='background-color:#996633;'></div><div class='Color' style='background-color:#006600;'></div><div class='Color' style='background-color:#336666;'></div><div class='Color' style='background-color:#000099;'></div><div class='Color' style='background-color:#330099;'></div><div class='Color' style='background-color:#663366;'></div><div class='Color' style='background-color:#b3b3b3;'></div><div class='Color' style='background-color:#333333;'></div></div><div class='Colors'><div class='Color' style='background-color:#330000;'></div><div class='Color' style='background-color:#663300;'></div><div class='Color' style='background-color:#333300;'></div><div class='Color' style='background-color:#003300;'></div><div class='Color' style='background-color:#003333;'></div><div class='Color' style='background-color:#000066;'></div><div class='Color' style='background-color:#330066;'></div><div class='Color' style='background-color:#330033;'></div><div class='Color' style='background-color:#aaaaaa;'></div><div class='Color' style='background-color:#1a1a1a;'></div></div></div>";
	 if (!data.hideNoFill) { 
	buffer[_i++] = "<div class='Text' style='margin-top:4px;'><div id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_default'></div></div>";
	 } 
	 if (data.allowColorInput) { 
	buffer[_i++] = "<div class='Text' style='margin-top:4px;'><table role=\"presentation\" border=\"0\" width='100%'><tr><td><div id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_input'></div></td><td><div id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_button'></div></td></tr></table><table role=\"presentation\" class='DwtColorPickerLabel' border=\"0\"><tr><td><div>";
	buffer[_i++] = AjxMsg.previewResult;
	buffer[_i++] = "</div></td><td><div id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_preview' class='Color'></div></td><td><div id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_error'></div></td></tr></table></div>";
	 } 

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#DwtColorPicker"
}, false);

AjxTemplate.register("dwt.Widgets#DwtColorPickerButton", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<table role=\"presentation\" class='ZWidgetTable ZMenuItemTable ZMenuItemBorder'><tr><td><div id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_color' class='Color'></div></td><td id='";
	buffer[_i++] = data["id"];
	buffer[_i++] = "_title' class='ZWidgetTitle'\n";
	buffer[_i++] = "\t\t\t";
	 if (AjxEnv.isIE) { 
	buffer[_i++] = "\n";
	buffer[_i++] = "\t\t\t\tstyle='width:auto;'\n";
	buffer[_i++] = "\t\t\t";
	 } 
	buffer[_i++] = "\n";
	buffer[_i++] = "\t\t\t></td></tr></table>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#DwtColorPickerButton",
	"class": "ZWidget"
}, false);

AjxTemplate.register("dwt.Widgets#SVGGradient", 
function(name, params, data, buffer) {
	var _hasBuffer = Boolean(buffer);
	data = (typeof data == "string" ? { id: data } : data) || {};
	buffer = buffer || [];
	var _i = buffer.length;

	buffer[_i++] = "<?xml version=\"1.0\" ?><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\"\n";
	buffer[_i++] = "\t     viewBox=\"0 0 1 1\" preserveAspectRatio=\"none\"><linearGradient id=\"thegradient\"\n";
	buffer[_i++] = "\t\t                gradientUnits=\"userSpaceOnUse\"\n";
	buffer[_i++] = "\t\t                x1=\"";
	buffer[_i++] = data["x1"];
	buffer[_i++] = "\" y1=\"";
	buffer[_i++] = data["y1"];
	buffer[_i++] = "\" x2=\"";
	buffer[_i++] = data["x2"];
	buffer[_i++] = "\" y2=\"";
	buffer[_i++] = data["y2"];
	buffer[_i++] = "\"><stop offset=\"0%\" stop-color=\"";
	buffer[_i++] = data["startColor"];
	buffer[_i++] = "\"\n";
	buffer[_i++] = "\t\t\t            stop-opacity=\"1\"/><stop offset=\"100%\" stop-color=\"";
	buffer[_i++] = data["endColor"];
	buffer[_i++] = "\"\n";
	buffer[_i++] = "\t\t\t            stop-opacity=\"1\"/></linearGradient><rect x=\"0\" y=\"0\" width=\"1\" height=\"1\"\n";
	buffer[_i++] = "\t\tfill=\"url(#thegradient)\" /></svg>";

	return _hasBuffer ? buffer.length : buffer.join("");
},
{
	"id": "dwt.Widgets#SVGGradient"
}, false);

}
